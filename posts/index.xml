<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - yejian's blog</title><link>https://jianye0428.github.io/posts/</link><description>所有文章 | yejian's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>18817571704@163.com (Jian YE)</managingEditor><webMaster>18817571704@163.com (Jian YE)</webMaster><lastBuildDate>Sat, 20 Jan 2024 10:04:30 +0800</lastBuildDate><atom:link href="https://jianye0428.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>RL | 强化学习 -- 简介</title><link>https://jianye0428.github.io/posts/rl_introduction/</link><pubDate>Fri, 14 Jul 2023 08:21:32 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/rl_introduction/</guid><description><![CDATA[<p>\usepackage{amssymb}</p>
<h2 id="1-强化学习">1. 强化学习</h2>
<p>Reinforcement Learning (RL): 强化学习</br>
强化学习属于机器学习的一种，不同于<code>监督学习</code>和<code>无监督学习</code>，通过智能体与环境的不断交互(即采取动作)，进而获得奖励，从而不断优化自身动作策略，以期待最大化其长期收益(奖励之和)。强化学习特别适合序贯决策问题(涉及一系列有序的决策问题)。</p>
<p>在实际应用中，针对某些任务，我们往往无法给每个数据或者状态贴上准确的标签，但是能够知道或评估当前情况或数据是好还是坏，可以采用强化学习来处理。例如，下围棋(Go)，星际争霸II(Starcraft II)等游戏。</p>
<h4 id="11-强化学习的定义">1.1 强化学习的定义</h4>
<p>Agent interacts with its surroundings known as the environment. Agent will get a reward from the environemnt once it takes an action in the current enrivonment. Meanwhile, the environment evolves to the next state. The goal of the agent is to maximize its total reward (the Return) in the long run.</p>
<p>智能体与环境的不断交互(即在给定状态采取动作)，进而获得奖励，此时环境从一个状态转移到下一个状态。智能体通过不断优化自身动作策略，以期待最大化其长期回报或收益(奖励之和)。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">强化学习流程图</div>
</center>
<br>
<h3 id="12-强化学习的相关概念">1.2 强化学习的相关概念</h3>
<p>(1) 状态 State ( $S$ ): agent’s observation of its environment;</br></p>
<p>(2) 动作 Action ($A$): the approaches that agent interacts with the environment;</br></p>
<p>(3) 奖励 Reward ($R_t$): the bonus that agent get once it takes an action in the environment at the given time step t.回报(Return)为Agent所获得的奖励之和。</br></p>
<p>(4) 转移概率 Transistion Probability ($P$): the transition possibility that environment evolves from one state to another. 环境从一个状态转移到另一个状态，可以是确定性转移过程，例如，$S_{t+1} = f(S_t, A_t)$, 也可以是随机性转移过程，例如 $S_{t+1} \sim p\left( S_{t+1}|S_t, A_t \right)$</br></p>
<p>(5) 折扣因子 Discount factor ( $\gamma$ ): to measure the importance of future reward to agent at the current state.</br></p>
<p>(6) 轨迹(Trajectory)是一系列的状态、动作、和奖励，可以表述为：</p>
<p>$$\tau = (S_0, A_0, R_0, S_1, A_1, R_1, &hellip; )$$</p>
<p>用轨迹$\tau$来记录Agent如何和环境交互。轨迹的初始状态是从起始状态分布中随机采样得到的。一条轨迹有时候也称为片段(Episode)或者回合，是一个从初始状态(Initial State，例如游戏的开局)到最终状态(Terminal State，如游戏中死亡或者胜利)的序列。</br></p>
<p>(7) 探索-利用的折中(Exploration-Exploitation Tradeoff)
这里，探索是指Agent通过与环境的交互来获取更多的信息，而利用是指使用当前已知信息来使得Agent的表现达到最佳，例如，贪心(greedy)策略。同一时间，只能二者选一。因此，如何平衡探索和利用二者，以实现长期回报(Long-term Return)最大，是强化学习中非常重要的问题。</br></p>
<p>因此，可以用$ (S，A，P，R，\gamma) $来描述强化学习过程。</p>
<h3 id="13-强化学习的数学建模">1.3 强化学习的数学建模</h3>
<p>(1) 马尔可夫过程 (Markov Process，MP) 是一个具备马尔可夫性质的离散随机过程。</p>
<p>马尔可夫性质是指下一状态 $ S_{t+1} $ 只取决于当前状态 $S_t$.</p>
<p>$$p(S_{t+1}|S_{t}) = p(S_{t+1} | S_0, S_1, S_2, &hellip;, S_t)$$</p>
<p>可以用有限状态集合 $\mathcal{S}$ 和状态转移矩阵 $\mathbf{P}$ 表示MP过程为 $&lt;\mathcal{S}, \mathbf{P}&gt;$。</p>
<p>为了能够刻画环境对Agent的反馈奖励，马尔可夫奖励过程将上述MP从 $&lt;\mathcal{S}, \mathbf{P}&gt;$ 扩展到了$ &lt;\mathcal{S}, \mathbf{P}, R, \gamma&gt;$。这里，$R$表示奖励函数，而 $\gamma$ 表示奖励折扣因子。</p>
<p>$$R_t = R(S_t)$$</p>
<p>回报(Return)是Agent在一个轨迹上的累计奖励。折扣化回报定义如下：</p>
<p>$$G_{t=0:T} = R(\tau) = \sum_{t=0}^{T}\gamma^{t}R_t$$</p>
<p>价值函数(Value Function) $V(s)$是Agent在状态$s$的期望回报(Expected Return)。</p>
<p>$$V^{\pi} (s) = \mathbb{E}[R(\tau) | S_0 = s]$$</p>
<p>(3) 马尔可夫决策过程 (Markov Decision Process，MDP)</br></p>
<p>MDP被广泛应用于经济、控制论、排队论、机器人、网络分析等诸多领域。
马尔可夫决策过程的立即奖励(Reward，$R$)与状态和动作有关。MDP可以用$&lt;\mathcal{S},\mathcal{A}, \mathbf{P}, R, \gamma&gt;$来刻画。
$\mathcal{A}$表示有限的动作集合，此时，立即奖励变为</p>
<p>$$R_t = R(S_t, A_t)$$</p>
<p>策略(Policy)用来刻画Agent根据环境观测采取动作的方式。Policy是从一个状态 $s \in \mathcal{S}$ 到动作 $a \in \mathcal{A}$的概率分布$\pi(a|s)$ 的映射，$\pi(a|s)$ 表示在状态$s$下，采取动作 $a$ 的概率。</p>
<p>$$\pi (a|s) = p (A_t = a | S_t = s), \exist{t} $$</p>
<p>期望回报(Expected Return)是指在一个给定策略下所有可能轨迹的回报的期望值，可以表示为：</p>
<p>$$J(\pi) = \int_{\tau} p(\tau | \pi) R(\tau) = \mathbb{E}_{\tau \sim \pi}[R(\tau)]$$</p>
<p>这里, $p(\tau|\pi)$表示给定初始状态分布 $\rho_0$ 和策略 $\pi$，马尔可夫决策过程中一个 $T$ 步长的轨迹 $\tau$ 的发生概率，如下：</p>
<p>$$p(\tau | \pi) = \rho_0(s_0)\prod \limits_{t=0}^{T-1} p(S_{t+1} | S_t, A_t) \pi (A_t | S_t)$$</p>
<p>强化学习优化问题通过优化方法来提升策略，以最大化期望回报。最优策略$\pi^*$ 可以表示为:</p>
<p>$$\pi ^ * = \argmax_{\pi} J(\pi)$$</p>
<p>给定一个策略 $\pi$，价值函数$V(s)$，即给定状态下的期望回报，可以表示为:</p>
<p>$$V^{\pi}(s) = \mathbb{E}<em>{\tau \sim \pi} [R(\tau) | S_0 = s] = \mathbb{E}</em>{A_t \sim \pi(\cdot | S_t)} [\sum_{t=0}^{\infin}\gamma^t R(S_t, A_t) | S_0 = s]$$</p>
<p>new</p>
<p>$$V^{\pi}(s)=\mathbb{E}<em>{\tau\sim\pi}\left[R(\tau)|S_0=s\right]=\mathbb{E}</em>{A_t}\sim\pi(\cdot|S_t)\left[\sum_{t=0}^{\infty}\gamma^tR(S_t,A_t)|S_0=s\right]$$</p>
<p>在MDP中，给定一个动作，就有动作价值函数(Action-Value Function)，是基于状态和动作的期望回报。其定义如下：</p>
<p>$$Q^{\pi}(s, a) = \mathbb{E}<em>{\tau \sim \pi}[R(\tau) | S_0 = s, A_0 = a] = \mathbb{E}</em>{A_t \sim \pi(\cdot | S_t)}[\sum_{t=0}^{\infin}\gamma^t R(S_t, A_t)|S_0 = s, A_0 = a]$$</p>
<p>new</p>
<p>$$Q^{\pi}(s,a)=\mathbb{E}<em>{\tau\sim\pi}[R(\tau)|S_0=s,A_0=a]=\mathbb{E}</em>{A_t\sim\pi(\cdot|S_t)}\left[\sum_{t=0}^{\infty}\gamma^tR(S_t,A_t)|S_0=s,A_0=a\right]$$</p>
<p>根据上述定义，可以得到：</p>
<p>$$V^{\pi}(s) = \mathbb{E}_{a \sim \pi}[Q^{\pi}(s,a)]$$</p>
<h2 id="2-深度强化学习">2. 深度强化学习</h2>
<p>Deep Learning + Reinforcement Learning = Deep Reinforcement Learning (DRL)
深度学习DL有很强的抽象和表示能力，特别适合建模RL中的值函数，例如：动作价值函数 $Q^\pi \left(s, a \right)$。
二者结合，极大地拓展了RL的应用范围。</p>
<h2 id="3-常见深度强化学习算法">3. 常见深度强化学习算法</h2>
<p>深度强化学习的算法比较多，常见的有：DQN，DDPG，PPO，TRPO，A3C，SAC 等等。</p>
<h2 id="4-深度强化学习算法分类">4. 深度强化学习算法分类</h2>
<h3 id="41-根据agent训练与测试所采用的策略是否一致">4.1 根据Agent训练与测试所采用的策略是否一致</h3>
<h4 id="411-off-policy-离轨策略离线策略">4.1.1 off-policy (离轨策略、离线策略)</h4>
<p>Agent在训练(产生数据)时所使用的策略 $\pi_1$与 agent测试(方法评估与实际使用&ndash;目标策略)时所用的策略 $\pi_2$ 不一致。</p>
<p>例如，在DQN算法中，训练时，通常采用 $\epsilon-greedy$ 策略；而在测试性能或者实际使用时，采用 $ a^* = arg \max\limits_{a} Q^{\pi}\left( s, a \right) $ 策略。</p>
<p>常见算法有：DDPG，TD3，Q-learning，DQN等。</p>
<h4 id="412-on-policy-同轨策略在线策略">4.1.2 on-policy (同轨策略、在线策略)</h4>
<p>Agent在训练时(产生数据)所使用的策略与其测试(方法评估与提升)时使用的策略为同一个策略 $\pi$。</p>
<p>常见算法有：Sarsa，Policy Gradient，TRPO，PPO，A3C等。</p>
<h3 id="42-策略优化的方式不同">4.2 策略优化的方式不同</h3>
<h4 id="421-value-based-algorithms基于价值的算法">4.2.1 Value-based algorithms(基于价值的算法)</h4>
<p>基于价值的方法通常意味着对动作价值函数 $Q^{\pi}(s,a)$的优化，最优策略通过选取该函数 $Q^{\pi}(s,a)$ 最大值所对应的动作，即 $\pi^* \approx \arg \max\limits_{\pi}Q^{\pi}(s,a)$，这里，$\approx$ 由函数近似误差导致。</p>
<p>基于价值的算法具有采样效率相对较高，值函数估计方差小，不易陷入局部最优等优点，缺点是通常不能处理连续动作空间问题，最终策略通常为确定性策略。</p>
<p>常见算法有 Q-learning，DQN，Double DQN，等，适用于 Discrete action space。其中，DQN算法是基于state-action function $Q(s,a)$ 来进行选择最优action的。</p>
<h4 id="422-policy-based-algorithms基于策略的算法">4.2.2 Policy-based algorithms(基于策略的算法)</h4>
<p>基于策略的方法直接对策略进行优化，通过对策略迭代更新，实现累计奖励(回报)最大化。其具有策略参数化简单、收敛速度快的优点，而且适用于连续或者高维动作空间。</p>
<p>策略梯度方法(Policy Gradient Method，PGM)是一类直接针对期望回报通过梯度下降(Gradient Descent，针对最小化问题)进行策略优化的强化学习方法。其不需要在动作空间中求解价值最大化的优化问题，从而比较适用于 continuous and high-Dimension action space，也可以自然地对随机策略进行建模。</p>
<p>PGM方法通过梯度上升的方法直接在神经网络的参数上优化Agent的策略。</p>
<p>根据相关理论，期望回报 $J(\pi_{\theta})$ 关于参数 $\theta$ 的梯度可以表示为：</p>
<p>$$\nabla_{\theta}J(\pi_{\theta}) = \mathbb{E}<em>{\tau \sim \pi</em>{\theta}}[\sum_{t=0}^{T}R_{t}\nabla_{\theta}\sum_{t&rsquo;=0}^{T} \log \pi_{\theta}(A_{t&rsquo;} | S_{t&rsquo;})] = \mathbb{E}<em>{\tau \sim \pi</em>{\theta}}[\sum_{t&rsquo;=0}^{T}\nabla_{\theta}\log \pi_{\theta}(A_{t&rsquo;} | S_{t&rsquo;})\sum_{t=0}^{T} R_t]$$</p>
<p>$$\nabla_\theta J(\pi_\theta)=\mathbb{E}<em>{\tau\sim\pi</em>\theta}\left[\sum_{t=0}^TR_t\nabla_\theta\sum_{t^{\prime}=0}^T\log\pi_\theta(A_{t^{\prime}}|S_{t^{\prime}})\right]=\mathbb{E}<em>{\tau\sim\pi</em>\theta}\left[\sum_{t^{\prime}=0}^T\nabla_\theta\log\pi_\theta\left(A_{t^{\prime}}|S_{t^{\prime}}\right)\sum_{t=0}^TR_t\right]$$</p>
<p>$$\nabla_{\theta} J(\pi_{\theta}) = \mathbb{E}$$</p>
<p>$$V^{\pi}(s) = \mathbb{E}_{a \sim \pi}[Q^{\pi}(s,a)]$$</p>
<p>当$T \rightarrow \infin$ 时，上式可以表示为：</p>
<p>$$\nabla_{\theta}J(\pi_{\theta}) = \mathbb{E}<em>{\tau \sim \pi</em>{\theta}}[\sum_{t&rsquo;=0}^{\infin}\nabla_{\theta} \log \pi_{\theta}(A_{t&rsquo;} | S_{t&rsquo;}) \gamma^{t&rsquo;}\sum_{t=t&rsquo;}^{\infin} \gamma^{t-t&rsquo;}R_t]$$</p>
<p>在实际中，经常去掉 $ \gamma^{t^{\prime}} $，从而避免过分强调轨迹早期状态的问题。</p>
<p>上述方法往往对梯度的估计有较大的方法(奖励 $R_t$ 的随机性可能对轨迹长度L呈指数级增长)。为此，常用的方法是引进一个基准函数 $b(S_i)$，仅是状态 $S_i$ 的函数。可将上述梯度修改为：</p>
<p>$$\nabla_{\theta}J(\pi_{\theta}) = \mathbb{E}<em>{\tau \sim \pi</em>{\theta}}[\sum_{t&rsquo;=0}^{\infin}\nabla_{\theta} \log \pi_{\theta}(A_{t&rsquo;} | S_{t&rsquo;}) (\sum_{t=t&rsquo;}^{\infin} \gamma^{t-t&rsquo;}R_t - b(S_{t&rsquo;}))]$$</p>
<p>常见的PGM算法有REINFORCE，PG，PPO，TRPO 等。</p>
<h4 id="423-actor-critic-algorithms-演员-评论家方法">4.2.3 Actor-Critic algorithms (演员-评论家方法)</h4>
<p>Actor-Critic方法结合了上述基于价值的方法和基于策略的方法，利用基于价值的方法学习Q值函数或状态价值函数V来提高采样效率(Critic)，并利用基于策略的方法学习策略函数(Actor)，从而适用于连续或高维动作空间。其缺点也继承了二者的缺点，例如，Critic存在过估计问题，而Actor存在探索不足的问题等。</p>
<p>常见算法有 DDPG, A3C，TD3，SAC，等，适用于 continuous and high-Dimension action space</p>
<h3 id="43-参数更新的方式不同">4.3 参数更新的方式不同</h3>
<p>Parameters updating methods</p>
<h4 id="431-monte-carlo-method蒙特卡罗方法">4.3.1 Monte Carlo method(蒙特卡罗方法)</h4>
<p>蒙特卡罗方法：必须等待一条轨迹 $\tau_k$ 生成(真实值)后才能更新。</p>
<p>常见算法有：Policy Gradient，TRPO，PPO等。</p>
<h4 id="432-temporal-difference-method时间差分方法">4.3.2 Temporal Difference method(时间差分方法)</h4>
<p>时间差分方法：在每一步动作执行都可以通过自举法(Bootstrapping)(估计值)及时更新。</p>
<p>常见算法有：DDPG，Q-learning，DQN等。</p>
<p>[1]. <a href="https://blog.csdn.net/b_b1949/article/details/128997146"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/b_b1949/article/details/128997146<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Google Benchmark 性能测试分析工具</title><link>https://jianye0428.github.io/posts/google_benchmark_introduction/</link><pubDate>Fri, 19 Jan 2024 19:33:03 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/google_benchmark_introduction/</guid><description><![CDATA[<h2 id="0-简介">0. 简介</h2>
<p>作为一个程序而言，benchmark是非常关键的一个衡量指标，无论是程序算法的指标还是程序运行性能的指标，这些我们都可以去完成衡量。对于性能衡量而言google benchmark无疑是一个比较好的选择。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">性能测试工具对比</div>
</center>
<br>
<h2 id="1-google-benchmark安装">1. google benchmark安装</h2>
<p><a href="https://github.com/google/benchmark"target="_blank" rel="external nofollow noopener noreferrer">google benchmark 下载地址<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><strong>编译安装:</strong></p>
<p>登录 linux环境，执行以下命令，进行编译安装：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone https://github.com/google/benchmark.git
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> benchmark
</span></span><span class="line"><span class="cl">git clone https://github.com/google/googletest.git
</span></span><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake .. -DCMAKE_BUILD_TYPE<span class="o">=</span>RELEASE
</span></span><span class="line"><span class="cl">make -j4
</span></span><span class="line"><span class="cl"><span class="c1"># 如果想全局安装就接着运行下面的命令</span>
</span></span><span class="line"><span class="cl">sudo make install</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="2--代码编写">2.  代码编写</h2>
<p>创建一个C++源文件，并编写包含基准测试函数的代码。例如，创建一个名为benchmark_example.cpp的文件，并编写如下内容：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">BM_MyFunction</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这里编写您要测试的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 执行您的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">BM_MyFunction</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_MAIN</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上述示例中，<code>BM_MyFunction</code>是您要测试的函数。</p>
<p>然后我们可以使用C++编译器编译您的代码，并链接Google Benchmark库。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">g++ benchmark_example.cpp -o benchmark_example -lbenchmark -lpthread</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是cmakelist，则可以使用</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_FLAGS</span> <span class="s2">&#34;${CMAKE_CXX_FLAGS} -pthread&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># benchmark依赖thread线程库
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">benchmark</span> <span class="s">STATIC</span> <span class="s">IMPORTED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">benchmark</span> <span class="s">PROPERTY</span> <span class="s">IMPORTED_LOCATION</span> <span class="s">/usr/local/lib/libbenchmark.a</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">demo</span> <span class="s">demo.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">demo</span>
</span></span><span class="line"><span class="cl">    <span class="s">benchmark</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span>
</span></span><span class="line"><span class="cl">    <span class="s">demo</span>
</span></span><span class="line"><span class="cl">    <span class="s">DESTINATION</span> <span class="s2">&#34;bin/&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="21-基础代码调用测试">2.1 基础代码调用测试</h3>
<p>我们可以看到每一个benchmark测试用例都是一个类型为<code>std::function</code>的函数，其中<code>benchmark::State&amp;</code>负责测试的运行及额外参数的传递。</p>
<p>测试用例编写完成后，我们需要使用<code>BENCHMARK()</code>将我们的测试用例注册进benchmark，这样程序运行时才会执行我们的测试。</p>
<p>最后是用<code>BENCHMARK_MAIN();</code>替代直接编写的main函数，它会处理命令行参数并运行所有注册过的测试用例生成测试结果。</p>
<table><tr><td bgcolor=yellow>Example 1:</td></tr></table>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// benchmark::State &amp;state用于维护测试上下文信息，以及控制迭代次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">vector_test</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">array_test</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 注册测试用例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">vector_test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">array_test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// benchmark的主函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK_MAIN</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果格式如下:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Load Average: 0.43, 0.25, 0.10
</span></span><span class="line"><span class="cl">------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark            Time             CPU   Iterations
</span></span><span class="line"><span class="cl">------------------------------------------------------
</span></span><span class="line"><span class="cl">vector_test       6.81 ns         6.81 ns    <span class="m">102373755</span>
</span></span><span class="line"><span class="cl">array_test        13.6 ns         13.6 ns     <span class="m">51227934</span></span></span></code></pre></td></tr></table>
</div>
</div><table><tr><td bgcolor=yellow>Example 2</td></tr></table>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// constexpr function具有inline属性，你应该把它放在头文件中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">my_pow</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用operator[]读取元素，依次存入1-6的平方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_operator</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_operator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用at()读取元素，依次存入1-6的平方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_at</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_at</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// std::get&lt;&gt;(array)是一个constexpr function，它会返回容器内元素的引用，并在编译期检查数组的索引是否正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_get</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_get</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_MAIN</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到每一个benchmark测试用例都是一个类型为<code>std::function&lt;void(benchmark::State&amp;)&gt;</code>的函数，其中<code>benchmark::State&amp;</code>负责测试的运行及额外参数的传递。</p>
<p>随后我们使用<code>for (auto _: state) {}</code>来运行需要测试的内容，<code>state</code>会选择合适的次数来运行循环，时间的计算从循环内的语句开始，所以我们可以选择像例子中一样在for循环之外初始化测试环境，然后在循环体内编写需要测试的代码。</p>
<p>测试用例编写完成后我们需要使用<code>BENCHMARK(&lt;function_name&gt;)</code>;将我们的测试用例注册进benchmark，这样程序运行时才会执行我们的测试。</p>
<p>最后是用BENCHMARK_MAIN();替代直接编写的main函数，它会处理命令行参数并运行所有注册过的测试用例生成测试结果。</p>
<p>示例中大量使用了<code>constexpt</code>，这是为了能在编译期计算出需要的数值避免对测试产生太多噪音。</p>
<p>然后我们编译测试程序：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">g++ -Wall -std<span class="o">=</span>c++14 benchmark_example.cpp -pthread -lbenchmark</span></span></code></pre></td></tr></table>
</div>
</div><p>benchmark需要链接<code>libbenchmark.so</code>，所以需要指定<code>-lbenchmark</code>，此外还需要<code>thread</code>的支持，因为<code>libstdc++</code>不提供<code>thread</code>的底层实现，我们需要<code>pthread</code>。另外不建议使用-lpthread，官方表示会出现兼容问题，在我这测试也会出现链接错误。注意文件名一定要在-lbenchmark前面，否则编译会失败，具体参见：https://github.com/google/benchmark/issues/619</p>
<p>如果你是在Windows平台使用google/benchmark，那么你需要额外链接shlwapi.lib才能使benchmark正常编译和运行。详细信息在这里。</p>
<p>编译好程序后就可以运行测试了：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T15:56:26+08:00
</span></span><span class="line"><span class="cl">Running ./benchmark_example_two
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 0.36, 0.64, 0.82
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">---------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                     Time             CPU   Iterations
</span></span><span class="line"><span class="cl">---------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_array_operator       30.9 ns         30.6 ns     <span class="m">22700640</span>
</span></span><span class="line"><span class="cl">bench_array_at             31.1 ns         30.9 ns     <span class="m">22376913</span>
</span></span><span class="line"><span class="cl">bench_array_get            29.4 ns         29.4 ns     <span class="m">23760270</span></span></span></code></pre></td></tr></table>
</div>
</div><p>显示的警告信息表示在当前系统环境有一些噪音(例如其他在运行的程序)可能导致结果不太准确，并不影响我们的测试。</p>
<p>在Windows上通常没有上述警告，如果你需要在Linux平台上去除相关警告的话，请参考此处。</p>
<p>测试结果与预期基本相符，<code>std::get</code>最快，<code>at()</code>最慢。</p>
<h3 id="22-传参调用测试">2.2 传参调用测试</h3>
<p>上面的测试用例都只接受一个<code>benchmark::State&amp;</code>类型的参数，所以我们可以使用<code>BENCHMARK</code>宏生成的对象的<code>Arg</code>方法来完成参数的传递。</p>
<p>传递进来的参数会被放入<code>state</code>对象内部存储，通过<code>range</code>方法获取，调用时的参数<code>0</code>是传入参数的需要，对应第一个参数。</p>
<p>举个例子，假如我们需要实现一个队列，现在有ring buffer和linked list两种实现可选，现在我们要测试两种方案在不同情况下的性能表现：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 必要的数据结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;ring.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;linked_ring.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ring buffer的测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int_10</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span> <span class="c1">// 暂停计时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span> <span class="c1">// 恢复计时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int_10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// linked list的测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_linked_queue_insert_int_10</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">LinkedRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_linked_queue_insert_int_10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 还有针对删除的测试，以及针对string的测试，都是高度重复的代码，这里不再罗列
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很显然，上面的测试除了被测试类型和插入的数据量之外没有任何区别，如果可以通过传入参数进行控制的话就可以少写大量重复的代码。</p>
<p>编写重复的代码是浪费时间，而且往往意味着你在做一件蠢事，google的工程师们当然早就注意到了这一点。虽然测试用例只能接受一个<code>benchmark::State&amp;</code>类型的参数，但我们可以将参数传递给state对象，然后在测试用例中获取：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">length</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的例子展示了如何传递和获取参数：</p>
<ul>
<li>传递参数使用<code>BENCHMARK</code>宏生成的对象的<code>Arg</code>方法</li>
<li>传递进来的参数会被放入<code>state</code>对象内部存储，通过<code>range</code>方法获取，调用时的参数<code>0</code>是传入参数的需要，对应第一个参数</li>
</ul>
<p><code>Arg</code>方法一次只能传递一个参数，那如果一次想要传递多个参数呢？也很简单：</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的例子没什么实际意义，只是为了展示如何传递多个参数，<code>Args</code>方法接受一个<code>vector</code>对象，所以我们可以使用c++11提供的大括号初始化器简化代码，获取参数依然通过<code>state.range</code>方法，<code>1</code>对应传递进来的第二个参数。</p>
<p>有一点值得注意，参数传递只能接受整数，如果你希望使用其他类型的附加参数，就需要另外想些办法了。</p>
<h3 id="23-简化多个类似测试用例的生成功">2.3 简化多个类似测试用例的生成功</h3>
<p>向测试用例传递参数的最终目的是为了在不编写重复代码的情况下生成多个测试用例，在知道了如何传递参数后你可能会这么写：</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">length</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 下面我们生成测试插入10，100，1000次的测试用例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T15:56:26+08:00
</span></span><span class="line"><span class="cl">Running ./benchmark_example_two
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 0.36, 0.64, 0.82
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">--------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                    Time              CPU      Iterations
</span></span><span class="line"><span class="cl">----------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/10              <span class="m">584</span>  ns           <span class="m">547</span> ns     <span class="m">1000000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/100             <span class="m">1357</span> ns           <span class="m">1367</span> ns     <span class="m">560000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/1000            <span class="m">9207</span> ns           <span class="m">9521</span> ns     <span class="m">64000</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上的代码虽然结果是正确的，但是仍然写了很多重复代码！</p>
<p>幸好<code>Arg</code>和<code>Args</code>会将我们的测试用例使用的参数进行注册以便产生用例名/参数的新测试用例，并且返回一个指向<code>BENCHMARK</code>宏生成对象的指针，换句话说，如果我们想要生成仅仅是参数不同的多个测试的话，只需要链式调用Arg和Args即可：</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果和上面一样。</p>
<p>但这还不是最优解，我们仍然重复调用了Arg方法，如果我们需要更多用例时就不得不又要做重复劳动了。</p>
<p>对此google benchmark也有解决办法：我们可以使用<code>Range</code>方法来自动生成一定范围内的参数。</p>
<p>先看看Range的原型：</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMAEK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">limit</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>start表示参数范围起始的值，limit表示范围结束的值，Range所作用于的是一个_闭区间_。</p>
<p>但是如果我们这样改写代码，是会得到一个错误的测试结果:</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                   Time            CPU      Iterations
</span></span><span class="line"><span class="cl">----------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/10              <span class="m">584</span>  ns         <span class="m">625</span> ns     <span class="m">1000000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/64              <span class="m">1042</span> ns         <span class="m">1029</span> ns    <span class="m">896000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/512             <span class="m">4948</span>  ns        <span class="m">5313</span> ns    <span class="m">100000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/1000            <span class="m">9221</span> ns         <span class="m">8545</span> ns     <span class="m">89600</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为什么会这样呢？那是因为Range默认除了start和limit，中间的其余参数都会是某一个基底（base）的幂，基地默认为8，所以我们会看到64和512，它们分别是8的平方和立方。</p>
<p>想要改变这一行为也很简单，只要重新设置基底即可，通过使用RangeMultiplier方法：</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在结果恢复如初了。</p>
<p>使用Ranges可以处理多个参数的情况：</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Ranges</span><span class="p">({{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">},</span> <span class="p">{</span><span class="mi">128</span><span class="err">，</span> <span class="mi">256</span><span class="p">}});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一个范围指定了测试用例的第一个传入参数的范围，而第二个范围指定了第二个传入参数可能的值（注意这里不是范围了）。</p>
<p>与下面的代码等价：</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">128</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">100</span><span class="p">,</span> <span class="mi">128</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">128</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">256</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">100</span><span class="p">,</span> <span class="mi">256</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">256</span><span class="p">})</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上就是用生成的第一个参数的范围于后面指定内容的参数做了一个笛卡尔积。</p>
<h3 id="24-使用参数生成器">2.4 使用参数生成器</h3>
<p>如果我想定制没有规律的更复杂的参数呢？这时就需要实现自定义的参数生成器了。</p>
<p>一个参数生成器的签名如下：</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CustomArguments</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Benchmark</span><span class="o">*</span> <span class="n">b</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们在生成器中计算处参数，然后调用<code>benchmark::internal::Benchmark</code>对象的<code>Arg</code>或<code>Args</code>方法像上两节那样传入参数即可。</p>
<p>随后我们使用<code>Apply</code>方法把生成器应用到测试用例上：</p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Apply</span><span class="p">(</span><span class="n">CustomArguments</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其实这一过程的原理并不复杂，我做个简单的解释：</p>
<ol>
<li><code>BENCHMARK</code>宏产生的就是一个<code>benchmark::internal::Benchmark</code>对象然后返回了它的指针</li>
<li>向<code>benchmark::internal::Benchmark</code>对象传递参数需要使用<code>Arg</code>和<code>Args</code>等方法</li>
<li><code>Apply</code>方法会将参数中的函数应用在自身</li>
<li>我们在生成器里使用<code>benchmark::internal::Benchmark</code>对象的指针<code>b</code>的<code>Args</code>等方法传递参数，这时的<code>b</code>其实指向我们的测试用例</li>
</ol>
<p>到此为止生成器是如何工作的已经一目了然了，当然从上面得出的结论，我们还可以让Apply做更多的事情。</p>
<p>下面看下Apply的具体使用：</p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 这次我们生成100，200，...，1000的测试用例，用range是无法生成这些参数的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">custom_args</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Benchmark</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Apply</span><span class="p">(</span><span class="n">custom_args</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="25-模板类的调用测试">2.5 模板类的调用测试</h3>
<p>如果针对每一种情况写测试函数，显然违反了<code>DRY原则</code>，因为除了vector的类型参数不同，其他代码几乎是完全一样的。</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_reserve</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">bench_vector_reserve</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">is_reserve</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">container</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// BENCHMARK_TEMPLATE(bench_vector_reserve, std::string, 100);
</span></span></span><span class="line"><span class="cl"><span class="c1">// // benchmark的主函数
</span></span></span><span class="line"><span class="cl"><span class="c1">// BENCHMARK_MAIN();
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>非常的简单，我们通过<code>length</code>控制插入的元素个数；<code>is_reserve</code>则负责控制是否预分配内存，通过<code>if constexpr</code>可以生成reserve和不进行任何操作的两种代码（如果不熟悉c++17的if constexpr，推荐花两分钟看看<a href="https://www.cnblogs.com/apocelipes/p/14536236.html#%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"target="_blank" rel="external nofollow noopener noreferrer">这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>）。</p>
<p>然后我们像往常一样定义一个测试用例：</p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">BENCHMARK<span class="o">(</span>bench_vector_reserve&lt;std::string,100&gt;<span class="o">)</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可是等我们编译的时候却报错了！</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ g++ test.cpp -lpthread -lbenchmark -lbenchmark_main
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">test.cpp:19:48: 错误：宏“BENCHMARK”传递了 <span class="m">2</span> 个参数，但只需要 <span class="m">1</span> 个
</span></span><span class="line"><span class="cl">   <span class="m">19</span> <span class="p">|</span> BENCHMARK<span class="o">(</span>bench_vector_reserve&lt;std::string,100&gt;<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>                                                ^
</span></span><span class="line"><span class="cl">In file included from a.cpp:1:
</span></span><span class="line"><span class="cl">/usr/local/include/benchmark/benchmark.h:1146: 附注：macro <span class="s2">&#34;BENCHMARK&#34;</span> defined here
</span></span><span class="line"><span class="cl"> <span class="m">1146</span> <span class="p">|</span> <span class="c1">#define BENCHMARK(n)                                     \</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>
</span></span><span class="line"><span class="cl">test.cpp:19:1: 错误：‘BENCHMARK’不是一个类型名
</span></span><span class="line"><span class="cl">   <span class="m">19</span> <span class="p">|</span> BENCHMARK<span class="o">(</span>bench_vector_reserve&lt;std::string,100&gt;<span class="o">)</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>原因是这样的，在编译器处理宏的时候实际上不会考虑c++语法，所以分割模板参数的逗号被识别成了分割宏参数的逗号，因此在宏处理器的眼里我们像是传了两个参数。这也说明了<code>BENCHMARK</code>是处理不了模板的。</p>
<p>不过别担心，Google早就想到这种情况了，所以提供了<code>BENCHMARK_TEMPLATE</code>宏，我们只需要把模板名字和需要的类型参数依次传给宏即可：</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T19:12:57+08:00
</span></span><span class="line"><span class="cl">Running ./benchmark_template
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 1.67, 1.82, 1.39
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                                 Time             CPU   Iterations
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100&gt;                 <span class="m">2912</span> ns         <span class="m">2910</span> ns       <span class="m">239967</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 1000&gt;               <span class="m">27585</span> ns        <span class="m">27571</span> ns        <span class="m">25299</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 10000&gt;             <span class="m">275549</span> ns       <span class="m">275527</span> ns         <span class="m">2534</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100000&gt;           <span class="m">3158585</span> ns      <span class="m">2818440</span> ns          <span class="m">253</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100, false&gt;          <span class="m">7743</span> ns         <span class="m">7635</span> ns        <span class="m">89883</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 1000, false&gt;        <span class="m">54695</span> ns        <span class="m">54663</span> ns        <span class="m">12540</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 10000, false&gt;      <span class="m">671379</span> ns       <span class="m">671340</span> ns         <span class="m">1050</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100000, false&gt;    <span class="m">8904492</span> ns      <span class="m">8903935</span> ns           <span class="m">79</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="26-定制测试参数">2.6 定制测试参数</h3>
<p>在上面的代码中，length参数其实是不必要的，所以代码可以这样改：</p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_reserve</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">bench_vector_reserve</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">is_reserve</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 通过range方法获取传入的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">container</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们测试的元素数量是[10, 100, 1000, 10^4, 10^5]。</p>
<p>除此之外还有另一种叫“密集参数”的Ranges。google benchmark提供了DenseRange方法。</p>
<p>这个方法的原型如下：</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">DenseRange</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">step</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Ranges</code>是累乘，而<code>DenseRange</code>是累加，因为累乘会导致几何级数的增长，在数轴上的分布越来越稀疏，累加则看上去像是均匀分布的，因此累加的参数生成器被叫做<code>密集参数生成器</code>。</p>
<p>如果我们把测试用例这么改：</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DenseRange</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们的length就是这样一个序列：<code>[1000，2000，3000， ...，9000，10000]</code>。</p>
<p>关于自定义参数最后一个知识点是<code>ArgsProduct</code>。看名字就知道这是一个参数工厂。</p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ArgsProduct</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">arglists</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::vector&lt;int64_t&gt;</code>实际上就是一组参数，<code>arglists</code>就是多组参数的合集，他们之间会被求笛卡尔积，举个例子：</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">BM_test</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span> <span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等价于下面的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">BM_test</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="p">...</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="err">```</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到参数工厂其实得自己手写所有参数，那如果我想配合工厂使用Ranges呢？</p>
<p>没问题，benchmark的开发者们早就想到了，所以提供了下面这些帮助函数：</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="cm">/*multi=*/</span><span class="mi">2</span><span class="p">)</span>   <span class="c1">// 生成：[8, 16, 32, 64, 128]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">benchmark</span><span class="o">::</span><span class="n">CreateDenseRange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/*step=*/</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 生成：[1, 2, 3, 4, 5, 6]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果换成我们的例子，就可以这样写：</p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>借助仅仅两行代码我们就能生成数量可观的测试用例：</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T19:26:55+08:00
</span></span><span class="line"><span class="cl">Running ./bm_template_2
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 1.91, 2.05, 1.65
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                                Time             CPU   Iterations
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10                   <span class="m">466</span> ns          <span class="m">466</span> ns      <span class="m">1505218</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100                 <span class="m">3549</span> ns         <span class="m">3548</span> ns       <span class="m">200461</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/1000               <span class="m">34067</span> ns        <span class="m">34049</span> ns        <span class="m">20858</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10000             <span class="m">324499</span> ns       <span class="m">324370</span> ns         <span class="m">2125</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100000           <span class="m">3229254</span> ns      <span class="m">3227361</span> ns          <span class="m">219</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10           <span class="m">1604</span> ns         <span class="m">1603</span> ns       <span class="m">436414</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100          <span class="m">7707</span> ns         <span class="m">7705</span> ns        <span class="m">89743</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/1000        <span class="m">57709</span> ns        <span class="m">57694</span> ns        <span class="m">12026</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10000      <span class="m">688582</span> ns       <span class="m">688283</span> ns         <span class="m">1008</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100000    <span class="m">9208480</span> ns      <span class="m">9205775</span> ns           <span class="m">75</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，这只是一个类型参数，实际上我们还有另外两个类型需要测试。另外这是1.5.5新增的功能，如果你想尝鲜得先升级google benchmark。</p>
<p>通常做到上面那一步就足够了，然而在这里我们还有优化空间，因为如果我们把其他两个测试用的类型加上，代码是这样的，MyClass的定义后面会给出：</p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">MyClass</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">MyClass</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你看见了什么？没错，重复重复重复！我们又违背了DRY原则。</p>
<p>重复说不上什么十恶不赦，但能避免还是要避免的，所以我准备用宏来简化这些代码：</p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define generate_test(type) \
</span></span></span><span class="line"><span class="cl"><span class="cp">	BENCHMARK_TEMPLATE(bench_vector_reserve, type)-&gt;ArgsProduct({benchmark::CreateRange(10, 100000, 10)}); \
</span></span></span><span class="line"><span class="cl"><span class="cp">	BENCHMARK_TEMPLATE(bench_vector_reserve, type, false)-&gt;ArgsProduct({benchmark::CreateRange(10, 100000, 10)});
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">generate_test</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">generate_test</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">generate_test</span><span class="p">(</span><span class="n">MyClass</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这下舒服多了。</p>
<p>接着来看我们的MyClass，我们的MyClass包含几个虚函数，禁止移动赋值，同时被刻意设计成了非平凡复制，这样的类型可以说是绕过了标准库容器设计的大部分优化措施，算是个妥妥的反面教材，希望你的项目里尽量不要出现这种东西：</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2L</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">long</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个类其实就是针对内存分配器实现的，vector在重新进行内存分配后很可能靠移动语义或者memmove来移动数据，这两者将导致重新分配内存导致的性能损失变小，不利于我们观察vector的行为，所以我定制了这个类。</p>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T19:39:19+08:00
</span></span><span class="line"><span class="cl">Running ./bm_template_3
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 1.94, 1.42, 1.32
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                                Time             CPU   Iterations
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10                   <span class="m">480</span> ns          <span class="m">480</span> ns      <span class="m">1399285</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100                 <span class="m">3446</span> ns         <span class="m">3445</span> ns       <span class="m">200045</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/1000               <span class="m">34552</span> ns        <span class="m">33697</span> ns        <span class="m">20974</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10000             <span class="m">329746</span> ns       <span class="m">329407</span> ns         <span class="m">2123</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100000           <span class="m">3263084</span> ns      <span class="m">3262478</span> ns          <span class="m">215</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10           <span class="m">1603</span> ns         <span class="m">1602</span> ns       <span class="m">435234</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100          <span class="m">7871</span> ns         <span class="m">7870</span> ns        <span class="m">88586</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/1000        <span class="m">58803</span> ns        <span class="m">58793</span> ns        <span class="m">11582</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10000      <span class="m">713880</span> ns       <span class="m">711949</span> ns          <span class="m">973</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100000    <span class="m">9387908</span> ns      <span class="m">9385776</span> ns           <span class="m">74</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/10                   <span class="m">388</span> ns          <span class="m">387</span> ns      <span class="m">1800299</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/100                 <span class="m">2421</span> ns         <span class="m">2421</span> ns       <span class="m">289565</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/1000               <span class="m">23424</span> ns        <span class="m">23413</span> ns        <span class="m">29931</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/10000             <span class="m">229590</span> ns       <span class="m">229543</span> ns         <span class="m">3081</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/100000           <span class="m">2258210</span> ns      <span class="m">2257467</span> ns          <span class="m">309</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/10           <span class="m">1331</span> ns         <span class="m">1329</span> ns       <span class="m">526682</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/100          <span class="m">4098</span> ns         <span class="m">4094</span> ns       <span class="m">169896</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/1000        <span class="m">26619</span> ns        <span class="m">26614</span> ns        <span class="m">26307</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/10000      <span class="m">248256</span> ns       <span class="m">248125</span> ns         <span class="m">2864</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/100000    <span class="m">2411262</span> ns      <span class="m">2410631</span> ns          <span class="m">286</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/10                       <span class="m">547</span> ns          <span class="m">547</span> ns      <span class="m">1264878</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/100                     <span class="m">4268</span> ns         <span class="m">4268</span> ns       <span class="m">163187</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/1000                   <span class="m">41305</span> ns        <span class="m">41292</span> ns        <span class="m">16957</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/10000                 <span class="m">408955</span> ns       <span class="m">408888</span> ns         <span class="m">1713</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/100000               <span class="m">4095353</span> ns      <span class="m">4093747</span> ns          <span class="m">170</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/10               <span class="m">1428</span> ns         <span class="m">1428</span> ns       <span class="m">487914</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/100              <span class="m">8052</span> ns         <span class="m">8050</span> ns        <span class="m">86405</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/1000            <span class="m">65784</span> ns        <span class="m">65772</span> ns        <span class="m">10679</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/10000          <span class="m">741154</span> ns       <span class="m">741025</span> ns          <span class="m">940</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/100000        <span class="m">6842572</span> ns      <span class="m">6839261</span> ns          <span class="m">102</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="27-使用benchmark接口">2.7. 使用Benchmark接口</h3>
<p>这里将待测试的函数注册为一个基准测试用例，并指定测试用例的名称和参数。该代码中使用了三种不同的注册方式：<code>函数指针</code>、<code>Lambda 函数</code>和<code>带参数的函数指针</code>。最后，使用 <code>benchmark::RunSpecifiedBenchmarks</code> 函数运行所有注册的基准测试用例，并使用 <code>benchmark::Shutdown</code> 函数释放资源。</p>
<div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">BM_DemoSleep</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span> <span class="c1">//待测试的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">BM_DemoSleep1</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;id:&#34;</span><span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">benchmark</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span> <span class="c1">// 初始化Benchmark
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">ReportUnrecognizedArguments</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用函数指针注册
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">benchmark</span><span class="o">::</span><span class="n">RegisterBenchmark</span><span class="p">(</span><span class="s">&#34;BM_DemoSleep&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BM_DemoSleep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用Lamba函数注册
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">benchmark</span><span class="o">::</span><span class="n">RegisterBenchmark</span><span class="p">(</span><span class="s">&#34;BM_DemoSleep1&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用带参数的函数指针注册
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">benchmark</span><span class="o">::</span><span class="n">RegisterBenchmark</span><span class="p">(</span><span class="s">&#34;BM_DemoSleep2&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BM_DemoSleep1</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">benchmark</span><span class="o">::</span><span class="n">RunSpecifiedBenchmarks</span><span class="p">();</span> <span class="c1">// 运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">benchmark</span><span class="o">::</span><span class="n">Shutdown</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="3-ref">3. Ref:</h2>
<p>[1]. <a href="https://mp.weixin.qq.com/s/hrKwlKj6i2twd_qNqaHyYg"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/hrKwlKj6i2twd_qNqaHyYg<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://github.com/google/benchmark/blob/main/docs/user_guide.md"target="_blank" rel="external nofollow noopener noreferrer">Google Benchmark 用户手册<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://www.cnblogs.com/apocelipes/p/10348925.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/apocelipes/p/10348925.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
]]></description></item><item><title>configure、make、make install 背后的原理</title><link>https://jianye0428.github.io/posts/make_install/</link><pubDate>Sat, 20 Jan 2024 10:04:30 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/make_install/</guid><description><![CDATA[<h2 id="1-简介">1、 简介</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./configure
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">make install</span></span></code></pre></td></tr></table>
</div>
</div><p>以上三个命令是源码安装软件的通用步骤。其主要完成以下工作：</p>
<ul>
<li>
<p><strong><code>./configure</code></strong>: <font color=red>配置</font>，是用来检测你的安装平台的目标特征。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。configure 脚本负责在使用的系统上准备好软件的构建环境。确保接下来的构建和安装过程所需要的依赖准备好，并且搞清楚使用这些依赖需要的东西。</p>
</li>
<li>
<p><strong><code>make</code></strong>: <font color=red>构建</font>，用来编译，它从<code>Makefile</code>中读取指令，然后编译。下载的源码包一般没有一个最终的 <code>Makefile</code> 文件，一般是一个模版文件 <a href="http://Makefile.in"target="_blank" rel="external nofollow noopener noreferrer">http://Makefile.in<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 文件，然后 <code>configure</code> 根据系统的参数生成一个定制化的 <code>Makefile</code> 文件。这个过程会执行在 Makefile 文件中定义的一系列任务将软件源代码编译成可执行文件。</p>
</li>
<li>
<p><strong><code>make install</code></strong>:<font color=red>安装</font>，它也从Makefile中读取指令，安装到指定的位置。make install 命令就是将可执行文件、第三方依赖包和文档复制到正确的路径。</p>
</li>
</ul>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>这些脚本是怎么产生的?</p>
<blockquote>
<p>安装过程简单说就是 configure 脚本根据系统信息将 Makefile.in 模版文件转换为 Makefile文件，但是 configure 和 Makefile.in 文件是怎么产生的呢？</p>
</blockquote>
<blockquote>
<p>如果你曾经试着打开 configure 或者 Makefile.in 文件，你会发现超长而且复杂的 shell 脚本语言。有时候这些脚本代码比它们要安装的程序源代码还要长。</p>
</blockquote>
<blockquote>
<p>如果想手动创建一个这样的 configure 脚本文件是非常可怕的，好消息是这些脚本是<strong>通过代码生成</strong>的。</p>
</blockquote>
<blockquote>
<p>通过这种方式构建的软件通常是通过一个叫做 autotools 的工具集打包的。这个工具集包含 autoconf 、automake 等工具，所有的这些工具使得维护软件生命周期变得很容易。最终用户不需要了解这些工具，但却可以让软件在不同的 Unix 系统上的安装步骤变得简单。</p>
</blockquote>
</div>
    </div>
  </div>
<h2 id="2-详细说明">2、 详细说明</h2>
<h3 id="21-configure命令">2.1 configure命令</h3>
<p>这一步一般用来生成 <code>Makefile</code>，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，具体参数可以通过<code>configure --help</code> 察看，下面举几个例子:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./configure --prefix<span class="o">=</span>/usr ...</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>--prefix=/usr</code>: 意思是将该软件安装在 <code>/usr</code> 下面，执行文件就会安装在 /usr/bin (而不是默认的 /usr/local/bin), 资源文件就会安装在 /usr/share(而不是默认的/usr/local/share)。选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统）</li>
<li><code>--bindir=</code>: 指定二进制文件的安装位置.这里的二进制文件定义为可以被用户直接执行的程序</li>
<li><code>--enable-static与--enable-shared:</code>
<ul>
<li><code>--enable-static</code>: 生成静态链接库</li>
<li><code>--enable-shared</code>: 生成动态链接库</li>
</ul>
</li>
<li><code>--with-</code>: 用于启用或禁用特定功能或模块。例如:
<ul>
<li><code>--with-ssl</code>表示启用SSL支持</li>
<li><code>--without-gui</code>表示禁用图形界面。</li>
</ul>
</li>
<li><code>--with-package=dir</code></li>
<li><code>--with-apxs</code> 是指定 apache 的配置程序路径，php编译程序会通过这个程序查找apache的相关路径</li>
<li><code>--with-libxml-dir</code>: 指向的是 libxml 的库路径</li>
<li><code>--with-gd</code>: 指静态编译gd库</li>
<li><code>--with-png-dir</code>: 指定 libpng 的路径</li>
<li><code>--enable-</code>: 用于启用或禁用特定功能或模块。与&ndash;with-选项类似，但更常用于启用或禁用编译选项。</li>
<li><code>--disable-</code>: 用于禁用特定功能或模块。与&ndash;enable-选项相反，用于禁用编译选项。</li>
<li><code>–sys-config=</code>: 指定软件的配置文件。有一些软件还可以加上 <code>–with</code>、<code>–enable</code>、<code>–without</code>、<code>–disable</code> 等等参数对编译加以控制</li>
</ul>
<h3 id="22-make-命令">2.2 make 命令</h3>
<p>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p>
<p>可能遇到的错误：<code>make ***</code> 没有指明目标并且找不到 makefile。 没有Makefile，先<code>./configure</code> 一下，再<code>make</code>。<code>make uninstall</code> 是卸载，不加参数就是默认的进行源代码编译。</p>
<p><code>make</code>工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，<code>make</code>依据它来批处理编译，这个文件就是<code>makefile</code>。</p>
<h3 id="23-make-install-命令">2.3 make install 命令</h3>
<p>这条命令来进行安装（当然有些软件需要先运行 <code>make check</code> 或 <code>make test</code> 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。</p>
<p><code>make install</code> 和<code>make install prefix=/usr/local/</code> 等价。</p>
<p><code>make install prefix=/usr/local/ sysconfdir=/etc DESTDIR=/tmp/build</code>支持<code>DESTDIR</code>的意义就是，保证所有要安装的文件，都会被安装在DESTDIR目录下，不会污染系统的package的目录。install也 是linux系统命令。</p>
<h3 id="24-扩展说明">2.4 扩展说明</h3>
<p>Linux的用户可能知道，在Linux下安装一个应用程序时，一般先运行脚本configure，然后用make来编译源程序，在运行make install，最后运行make clean删除一些临时文件。</p>
<p>configure是一个shell脚本，它可以自动设定源程序以符合各种不同平台上Unix系统的特性，并且根据系统叁数及环境产生合适的Makefile文件或是C的头文件(header file)，让源程序可以很方便地在这些不同的平台上被编译连接。</p>
<p>利用configure所产生的Makefile文件有几个预设的目标可供使用，其中几个重要的简述如下：</p>
<ul>
<li><code>make all</code>: 产生我们设定的目标，即此范例中的可执行文件。只打make也可以，此时会开始编译原始码，然后连结，并且产生可执行文件。只打make 默认就是<code>make all</code>，只编译其中某个目标则在后面给目标名称：make ce-common。</li>
<li><code>make clean</code>: 清除编译产生的可执行文件及目标文件(object file，*.o)。</li>
<li><code>make distclean</code>: 除了清除可执行文件和目标文件外，把configure所产生的Makefile也清除掉。</li>
<li><code>make install</code>: 将程序安装至系统中。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。</li>
<li><code>make dist</code>: 将程序和相关的档案包装成一个压缩文件以供发布。执行完在目录下会产生一个以PACKAGE-VERSION.tar.gz为名称的文件。 PACKAGE和VERSION这两个变数是根据http://configure.in文件中AM_INIT_AUTOMAKE(PACKAGE，VERSION)的定义。在此范例中会产生test-1.0.tar.gz的档案。</li>
<li><code>make distcheck</code>: 和make dist类似，但是加入检查包装后的压缩文件是否正常。这个目标除了把程序和相关文件包装成tar.gz文件外，还会自动把这个压缩文件解开，执行 configure，并且进行make all 的动作，确认编译无误后，会显示这个tar.gz文件可供发布了。这个检查非常有用，检查过关的包，基本上可以给任何一个具备GNU开发环境-的人去重新编译。</li>
</ul>
<h2 id="3-总结">3. 总结</h2>
<p>通过源码编译安装一个软件如下:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./configure --prefix<span class="o">=</span>/usr/local/<span class="si">${</span><span class="nv">program_name</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">make install
</span></span><span class="line"><span class="cl">make clean</span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意: </mark> <code>--prefix</code>可以在configure或者make install时指定安装路径。</p>
<h2 id="4-参考">4. 参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/77813702"target="_blank" rel="external nofollow noopener noreferrer">Linux命令详解：./configure、make、make install 命令<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77813702"target="_blank" rel="external nofollow noopener noreferrer">configure、 make、 make install 背后的原理(翻译)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
]]></description></item><item><title>程序安装教程</title><link>https://jianye0428.github.io/posts/softwareinstallation/</link><pubDate>Sat, 15 Jul 2023 15:52:02 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/softwareinstallation/</guid><description><![CDATA[<h2 id="一-apt-get-source-update">一、 apt-get source update</h2>
<ol>
<li>apt-get source
change the <code>/etc/apt/sources.list</code> file to <a href="https://developer.aliyun.com/mirror/ubuntu"target="_blank" rel="external nofollow noopener noreferrer">aliyun source<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li>add sudo user in root<a href="https://blog.csdn.net/acelove40/article/details/54343629"target="_blank" rel="external nofollow noopener noreferrer">link<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">adduser <span class="o">[</span>name<span class="o">]</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">apt-get install sudo</span></span></code></pre></td></tr></table>
</div>
</div>赋予用户<code>sudo</code>权限:
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo usermod -a -G adm username
</span></span><span class="line"><span class="cl">sudo usermod -a -G sudo username
</span></span><span class="line"><span class="cl">su <span class="o">[</span>name<span class="o">]</span></span></span></code></pre></td></tr></table>
</div>
</div>在文件<code>/etc/sudoers</code>中更改用户的<code>sudo</code>权限:
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"># sudoers file.
</span></span><span class="line"><span class="cl">#
</span></span><span class="line"><span class="cl"># This file MUST be edited with the &#39;vi sudo&#39; command as root.
</span></span><span class="line"><span class="cl">#
</span></span><span class="line"><span class="cl"># See the sudoers man page for the details on how to write a sudoers file.
</span></span><span class="line"><span class="cl">#
</span></span><span class="line"><span class="cl"># Host alias specification
</span></span><span class="line"><span class="cl"># User alias specification
</span></span><span class="line"><span class="cl"># Cmnd alias specification
</span></span><span class="line"><span class="cl"># Defaults specification
</span></span><span class="line"><span class="cl"># User privilege specification
</span></span><span class="line"><span class="cl">root    ALL=(ALL) ALL
</span></span><span class="line"><span class="cl">[username] ALL=(ALL) ALL
</span></span><span class="line"><span class="cl"># Uncomment to allow people in group wheel to run all commands
</span></span><span class="line"><span class="cl"># %wheel        ALL=(ALL)       ALL
</span></span><span class="line"><span class="cl"># Same thing without a password
</span></span><span class="line"><span class="cl"># %wheel        ALL=(ALL)       NOPASSWD: ALL
</span></span><span class="line"><span class="cl"># Samples
</span></span><span class="line"><span class="cl"># %users  ALL=/sbin/mount /cdrom,/sbin/umount /cdrom
</span></span><span class="line"><span class="cl"># %users  localhost=/sbin/shutdown -h now</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="二-anaconda-or-miniconda-installation">二、 Anaconda or Miniconda Installation</h2>
<ol>
<li>
<p>download anaconda or miniconda from <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/"target="_blank" rel="external nofollow noopener noreferrer">tsinghua source website<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>download command:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh</span></span></code></pre></td></tr></table>
</div>
</div><p>run the command to install:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">bash Miniconda3-latest-linux-x86_64.sh</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>change the conda channels to tsinghua source</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">nano ~/.condarc</span></span></code></pre></td></tr></table>
</div>
</div><p>paste the following channels into your <code>~/.condarc</code> file:<a href="https://blog.csdn.net/weixin_34910922/article/details/116721774"target="_blank" rel="external nofollow noopener noreferrer">ref link<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
</span></span><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
</span></span><span class="line"><span class="cl">#Conda Forge
</span></span><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
</span></span><span class="line"><span class="cl">#msys2（可略）
</span></span><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/
</span></span><span class="line"><span class="cl">#bioconda（可略）
</span></span><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/
</span></span><span class="line"><span class="cl">#menpo（可略）
</span></span><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/
</span></span><span class="line"><span class="cl">#pytorch
</span></span><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/
</span></span><span class="line"><span class="cl"># for legacy win-64（可略）
</span></span><span class="line"><span class="cl">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/
</span></span><span class="line"><span class="cl">conda config --set show_channel_urls yes</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>anaconda 环境文件<code>environment.yml</code>使用参考
创建环境:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">conda env create -f environment.yml -n myenv</span></span></code></pre></td></tr></table>
</div>
</div><p>导出当前环境配置:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">conda env <span class="nb">export</span> &gt; environment.yml</span></span></code></pre></td></tr></table>
</div>
</div><p>更新环境:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">conda env update -f environment.yml</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="三-cmake-installation">三、 Cmake Installation</h2>
<p><a href="https://blog.csdn.net/liushao1031177/article/details/119799007"target="_blank" rel="external nofollow noopener noreferrer">Ref Link<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol>
<li>Download cmake source file:
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">wget https://cmake.org/files/v3.20/cmake-3.20.0-linux-x86_64.tar.gz</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>extract the file and move the file to <code>/opt/cmake-3.20.0</code>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">tar zxvf cmake-3.20.0-linux-x86_64.tar.gz
</span></span><span class="line"><span class="cl">mv cmake-3.20.0-linux-x86_64 /opt/cmake-3.20.0</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>link the cmake as system cmake
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"> ln -sf /opt/cmake-3.20.0/bin/*  /usr/bin/</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>check if successfully installed
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --version</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="四-openmpi-installation">四、 Openmpi Installation</h2>
<p><a href="https://blog.csdn.net/songbaiyao/article/details/72858184"target="_blank" rel="external nofollow noopener noreferrer">Ref Link<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol>
<li>Install <code>openmpi</code> with command line:
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo apt-get install openmpi-bin openmpi-doc libopenmpi-dev</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>在conda下安装openmapi:
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">conda install openmpi</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="五-anaconda下安装jupyter-notebook">五、 Anaconda下安装jupyter notebook</h2>
<ol>
<li>
<p>安装jupyter notebook</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">pip install jupyter <span class="nv">notebook</span><span class="o">==</span>6.1.0</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>安装nbextensions</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">pip install jupyter_contrib_nbextensions
</span></span><span class="line"><span class="cl">jupyter contrib nbextension install --user</span></span></code></pre></td></tr></table>
</div>
</div><p>如果遇到如下报错信息:</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ModuleNotFoundError: No module named <span class="s1">&#39;notebook.base&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意: 一般由于notebook版本&gt;=7.0.0导致
原因: <a href="https://itsourcecode.com/modulenotfounderror/modulenotfounderror-no-module-named-notebook-base/"target="_blank" rel="external nofollow noopener noreferrer">Notebook的版本太高了，将notebook的版本降到<code>6.1.0</code><i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">pip install jupyter <span class="nv">notebook</span><span class="o">==</span>6.1.0
</span></span><span class="line"><span class="cl"><span class="c1"># 或者 pip install --upgrade notebook==6.1.0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后再重新安装插件。</p>
</li>
<li>
<p>安装nbextensions_configurator</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">pip install jupyter_nbextensions_configurator
</span></span><span class="line"><span class="cl">jupyter nbextensions_configurator <span class="nb">enable</span> --user</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>启动jupyter Notebook</p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">jupyter notebook</span></span></code></pre></td></tr></table>
</div>
</div><p>若如下报错:</p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ModuleNotFoundError: No module named <span class="s1">&#39;jupyter_server.contents&#39;</span>
</span></span><span class="line"><span class="cl">TypeError: warn<span class="o">()</span> missing <span class="m">1</span> required keyword-only argument: <span class="s1">&#39;stacklevel&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>则执行以下命令安装<code>traitlets</code>库:</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">pip install <span class="nv">traitlets</span><span class="o">==</span>5.9.0</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>在<code>codemirror.css</code>文件中更改字体
文件路径: <code>/home/{$USERNAME}/miniconda3/envs/pytorch/lib/python3.8/site-packages/notebook/static/components/codemirror/lib/codemirror.css</code></p>
</li>
<li>
<p>推荐安装的几个jupyter插件:</p>
<ul>
<li>zenmode</li>
<li>table of content(2)</li>
<li>Autopep8</li>
<li>variable inspector</li>
<li>ExecuteTime</li>
<li>Hide input all 隐藏代码输入</li>
</ul>
</li>
<li>
<p>jupyter notebook v7.0 extension installation support: <a href="https://github.com/jupyter/notebook/discussions/6881"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jupyter/notebook/discussions/6881<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
</ol>
]]></description></item><item><title>Effective Modern C++ 阅读笔记</title><link>https://jianye0428.github.io/posts/effective_modern_c-/</link><pubDate>Thu, 12 Oct 2023 20:01:17 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/effective_modern_c-/</guid><description><![CDATA[<h2 id="effective-modern-c-笔记">Effective Modern C++ 笔记</h2>
<h3 id="ch01-deducing-types">CH01 Deducing Types</h3>
<h4 id="item-1-understand-template-type-deductionhttpsblogcsdnnetdong_hfutarticledetails122727237"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122727237"target="_blank" rel="external nofollow noopener noreferrer">Item 1: Understand template type deduction.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>大部分简单场景下，我们根据模板调用可能一眼就能推导出来模板类型。但是，对于一些复杂场景，模板类型就没那么明显了，这就需要遵循一些基本原则。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//.....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>  <span class="c1">// call f with some expression
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>考虑以上代码片段，编译器在编译阶段根据调用点 expr 来推导出 T 和 ParamType 的类型。这其中 T 的推导不仅依赖 expr 的类型，也依赖 ParamType 的形式，有3种场景：</p>
<ul>
<li>ParamType 是引用或者指针类型，但不是万能引用。</li>
<li>ParamType 是万能引用。</li>
<li>ParamType 不是引用也不是指针。</li>
</ul>
<p><strong>Case 1: ParamType is a Reference or Pointer, but not a Universal Reference</strong></p>
<p>对于 ParamType 是引用或者指针类型，但不是万能引用的场景，类型推导方式如下：</p>
<ol>
<li>如果 expr 是一个引用，忽略其引用部分。</li>
<li>然后对 expr 的类型和 ParamType 进行模式匹配来决定 T。</li>
</ol>
<p>考虑下面的例子：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>     <span class="c1">// param is a reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们的变量申明如下：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>          <span class="c1">// x is an int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// cx is a const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// rx is a reference to x as a const int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用点和推导结果如下：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>      <span class="c1">// T is int, param&#39;s type is int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="c1">// param&#39;s type is int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>     <span class="c1">// T is const int,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="c1">// param&#39;s type is const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>     <span class="c1">// T is const int,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="c1">// param&#39;s type is const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一个调用，函数调用非常简单，我们很快能得到 T 是 int，param类型是 int&amp;。</p>
<p>第二个调用，cx 是 const int 类型，因此 T 被推导成 const int，param 的类型是 const int&amp;。当我们传一个 const 对象给函数的一个引用类型参数，我们期望这个const 对象不能被修改，因此 param 被推导成常量引用（reference-to-const）。这就是为什么传递一个 const 对象给 T&amp; 模板类型是安全的原因：对象的 constness 属性被推导成了 T 的一部分。</p>
<p>第三个调用，虽然 rx 的类型是一个引用，类型推导过程中将忽略 rx 的引用类型，T 被推导成一个非引用类型，即 const int，param 的类型是 const int&amp;。</p>
<p>如果我们将 param 类型改成 const T&amp;，情况略为有点不同，因为 param 的类型已经是常量引用（reference-to-const），不需要将 const 推导成 T 的一部分，如下：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span> <span class="c1">// param is now a ref-to-const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>        <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>              <span class="c1">// T is int, param&#39;s type is const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>             <span class="c1">// T is int, param&#39;s type is const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>             <span class="c1">// T is int, param&#39;s type is const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果 param 是一个指针（或者是指向常量的指针），推导方式其是引用是一样的，如下：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// param is now a pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>          <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>  <span class="c1">// px is a ptr to x as a const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>               <span class="c1">// T is int, param&#39;s type is int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>               <span class="c1">// T is const int,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="c1">// param&#39;s type is const int*
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Case1 场景的模板类型推导和我们设想的应该差不多，还是比较简单的。</p>
<p><strong>Case 2: ParamType is a Universal Reference</strong></p>
<p>模板类型参数是万能引用时，模板类型推导就没有那么明显了，详细介绍将会在 Item24 中展开，这里直接给出处理方式：</p>
<ul>
<li>如果 expr 是一个左值（lvalue），T 和 ParamType 都被推导成左值的引用。这是非常不寻常的。第一，这是唯一一个在模板类型推导中将 T 推导成一个引用的情况。第二，虽然 ParamType 被申明成语法上的一个右值（rvalue）引用，但它的推导类型却是一个左值引用。</li>
<li>如果 expr 是一个右值，和正常的规则一样（比如Case1的推导方式）。</li>
</ul>
<p>例如：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span> <span class="c1">// param is now a universal reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>              <span class="c1">// x is lvalue, so T is int&amp;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                   <span class="c1">// param&#39;s type is also int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>             <span class="c1">// cx is lvalue, so T is const int&amp;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                   <span class="c1">// param&#39;s type is also const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>             <span class="c1">// rx is lvalue, so T is const int&amp;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                   <span class="c1">// param&#39;s type is also const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>             <span class="c1">// 27 is rvalue, so T is int,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                   <span class="c1">// param&#39;s type is therefore int&amp;&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们将在 Item24 中解释这样推导的原因。</p>
<p><strong>Case 3: ParamType is Neither a Pointer nor a Reference</strong></p>
<p>当 ParamType 不是引用也不是指针，则是通过值传递的方式处理：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>       <span class="c1">// param is now passed by value
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这意味着不管传递进来的是啥，param 是实参的拷贝，它将是一个新的对象。推导方式如下：</p>
<ol>
<li>和之前一样，如果 expr 的类型是一个引用，忽略其引用部分。</li>
<li>在忽略 expr 的引用部分之后，如果 expr 是一个 const，也忽略它。如果 expr 是 volatile 的，也同样忽略。</li>
</ol>
<p>因此：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>       <span class="c1">// param is now passed by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                <span class="c1">// T&#39;s and param&#39;s types are both int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>               <span class="c1">// T&#39;s and param&#39;s types are again both int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>               <span class="c1">// T&#39;s and param&#39;s types are still both int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意到，虽然 cx 和 rx 是 const 类型，param 也不是 const 的。这是可以理解的，param 是一个新的对象， 独立于 cx 和 rx —— 是 cx 和 rx 的一个拷贝。param 的修改不会影响到 cx 和 rx，这就是为什么在类型推导时 expr 的 constness（以及 volatileness 等）被忽略的原因：因为 expr 不能被修改并不意味着它的拷贝不能。</p>
<p>对于值传递的参数模板，const 和 volatile 是被忽略的，但是对于引用类型或者常量引用类型参数的模板，expr 的 const 在类型推导时被保留下来了。考虑 expr 是一个指向常量的常量指针，通过值传递的参数类型：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>                                    <span class="c1">// param is still passed by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="s">&#34;Fun with pointers&#34;</span><span class="p">;</span>        <span class="c1">// ptr is const pointer to const object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>                                             <span class="c1">// pass arg of type const char * const
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，ptr 是常量，ptr 指向的字符串也是常量。当 ptr 传递给 f，组成指针的比特位被拷贝给 param，也就是说指针自己（ptr）是值传递，根据值传递参数模板类型推导规则，ptr 的 constness 将被忽略，param 的类型被推导为 const char*，是指向常量字符串的非常量指针。在类型推导过程中，ptr 指向对象的 constness 被保留下来，ptr 自身的 constness 在被拷贝用于创建一个新的对象 param 时被忽略了。</p>
<p><strong>Array Arguments</strong></p>
<p>以上3个 case 可以覆盖主流的模板类型推导场景了，但是还是有一个特别的场景值得考虑。数组类型和指针类型是有区别的，虽然它们经常是可以互换的，在多数场景下，一个数组可以转换成指向其第一元素的指针，如：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;J. P. Briggs&#34;</span><span class="p">;</span> <span class="c1">// name&#39;s type is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">// const char[13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">ptrToName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>      <span class="c1">// array decays to pointer
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，一个数组被传递给值传递参数模板时候，将会发生什么呢？</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>       <span class="c1">// template with by-value parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>               <span class="c1">// what types are deduced for T and param?
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>先考虑数组作为函数参数时的现象：</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">[]);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码将被等价视为：</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myFunc</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>  <span class="c1">// same function as above
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于数组参数被视为指针参数，因此在模板推导时候，对于值传递参数的函数模板， T 将被推导成 const char*。</p>
<p>但是，若模板函数的参数是引用：</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// template with by-reference parameter
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们传递一个数组给它：</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>        <span class="c1">// pass array to f
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这时候，T 的类型将被推导成数组类型， T 为 const char [13]，f 的参数（数组的引用）为 const char (&amp;)[13]，数组元素个数也可以被推导出来。</p>
<p>有趣的是，数组引用的这种功能可以用于在编译阶段计算数组元素个数：</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// return size of an array as a compile-time constant. (The
</span></span></span><span class="line"><span class="cl"><span class="c1">// array parameter has no name, because we care only about
</span></span></span><span class="line"><span class="cl"><span class="c1">// the number of elements it contains.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>                  <span class="c1">// see info below on constexpr and noexcept
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这可以让我们申明一个新的数组，它的元素个数和第一数组元素个数相同：</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">keyVals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">35</span> <span class="p">};</span> <span class="c1">// keyVals has 7 elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">mappedVals</span><span class="p">[</span><span class="n">arraySize</span><span class="p">(</span><span class="n">keyVals</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">keyVals</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mappedVals</span><span class="p">;</span>  <span class="c1">// 更 C++ 的方式
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Function Arguments</strong></p>
<p>在C++中，除了数组可以转为为指针外，函数类型也可以转为函数指针，并且上面讨论的对于数组的模板参数类型推导也可以应用于函数：</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>  <span class="c1">// someFunc is a function;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                             <span class="c1">// type is void(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>     <span class="c1">// in f1, param passed by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>         <span class="c1">// param deduced as ptr-to-func;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="c1">// type is void (*)(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>     <span class="c1">// in f2, param passed by ref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>          <span class="c1">// param deduced as ref-to-func;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="c1">// type is void (&amp;)(int, double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="c1">// T为 void (int, doble)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于推导结果，可以参考 Item4 中提供的方法进行验证，这里给一个例子：</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/type_index.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">typeindex</span><span class="o">::</span><span class="n">type_id_with_cvr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;T = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;param = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">typeindex</span><span class="o">::</span><span class="n">type_id_with_cvr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;T = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;param = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">f1</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">f2</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 打印结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">T</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">param</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">param</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。</li>
<li>在万能引用参数类型推导时，左值参数被特殊处理。</li>
<li>值传递形参的类型推导时，其 const 和 volatile 被忽略。</li>
<li>在模板类型推导时，数组或者函数类型被转换为指针类型，除非它们用来初始化引用。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-2-understand-auto-type-deductionhttpsblogcsdnnetdong_hfutarticledetails122740091"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122740091"target="_blank" rel="external nofollow noopener noreferrer">Item 2: Understand auto type deduction<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>这次学习 auto 类型的自动推导，在 auto 类型推导方法上，除了一种场景外，在 Item1 中学习的模板类型推导方法都可以适用。回顾下模板的类型推导：</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span> <span class="c1">// call f with some expression
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在调用点 f，编译器使用 expr 去推导出 T 和 ParamType 的类型。</p>
<p>对于使用 auto 声明的变量，auto 对应 T，变量的类型描述符对应 ParamType。如下例子，rx 的类型描述符是 const auto&amp;，把 x 理解成函数 f 调用的参数 expr。</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对应模板类型推导根据 ParamType 类型分3种场景进行推导，使用 auto 对变量进行申明的类型推导，也根据变量的类型描述符分3种场景进行推导：</p>
<ol>
<li>Case 1：类型描述符是一个指针或者引用，但不是万能引用。</li>
<li>Case 2：类型说明符是一个万能引用。</li>
<li>Case 3：类型说明符既不是指针也不是引用。</li>
</ol>
<p>Item1 的方法适用这3种场景，下面举例说明。</p>
<p><strong>Case 1：类型描述符是一个指针或者引用，但不是万能引用。</strong></p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rcx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// y 的类型为 int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>  <span class="c1">// y1 的类型为 const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">rcx</span><span class="p">;</span> <span class="c1">// y2 的类型为 const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Case 2：类型说明符是一个万能引用。</strong></p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rcx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>    <span class="c1">// y 的类型为 int&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// y1 的类型为 int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>   <span class="c1">// y2 的类型为 const int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">y3</span> <span class="o">=</span> <span class="n">rcx</span><span class="p">;</span>  <span class="c1">// y3 的类型为 const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Case 3：类型说明符既不是指针也不是引用。</strong></p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>        <span class="c1">// y 的类型为 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// y1 的类型为 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>       <span class="c1">// y2 的类型为 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">y3</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// y3 的类型为 const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">y4</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span> <span class="c1">// y4 的类型为 const int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Item1 中也讨论了数组和函数名退化成指针的情况，也同样适用与 auto 的类型推导：</p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;R. N. Briggs&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>       <span class="c1">// y1 类型为 const char*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>      <span class="c1">// y2 类型为 const char (&amp;) [13]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span>    <span class="c1">// f1 类型为 void (*)(double, int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">someFunc</span><span class="p">;</span>   <span class="c1">// f2 类型为 void (&amp;)(int, double)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>特殊场景：初始化列表 std::initial izer_list</strong></p>
<p>对于变量初始化，如下：</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>x3 和 x4 使用的是初始化列表的方式进行初始化，x1~x4 的类型都是int类型。但是，Item5 中将会解释为什么使用 auto 申明特定类型的变量会具有优势，这里将 int 换成 auto：</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>     <span class="c1">// type is int, value is 27
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">x2</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>      <span class="c1">// type is int, value is 27
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span> <span class="p">};</span> <span class="c1">// type is std::initializer_list&lt;int&gt;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// value is { 27 }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x4</span><span class="p">{</span> <span class="mi">27</span> <span class="p">};</span>    <span class="c1">// type is std::initializer_list&lt;int&gt;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// value is { 27 }
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>x1 和 x2 还是 int 类型，但是 x3 和 x4 却是 std::initial izer_list<int> 类型，并包含一个元素 27。这是变量申明 auto 类型推导的特殊之处：当使用 auto 申明一个变量 ，并且使用大括号的方式初始化变量，变量的类型推导为 std::initial izer_list 类型。</p>
<p>但是，下面的初始化方式会失败：</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x5</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">};</span>   <span class="c1">// error! can&#39;t deduce T for std::initializer_list&lt;T&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为这里实际上包含了两种类型推导，首先 x5 的类型被推导成 std::initializer_list，由于 std::initializer_list 是一个模板，然后必须为 std::initializer_list<T> 实例化一个 T，也就是说 T 也要被推导。这里里表里包含了两种数据类型，T 推导失败。</p>
<p>这是 auto 类型推导和模板类型推导的区别，传递这样的初始化列表给模板将导致推导失败：</p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">({</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span> <span class="p">});</span> <span class="c1">// error! can&#39;t deduce type for T
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，如果你指定了模板参数类型为 std::initializer_list<T> ，模板类型推导将推导出 T：</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">initList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">({</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span> <span class="p">});</span>   <span class="c1">// T deduced as int, and initList&#39;s type is std::initializer_list&lt;int&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 Item3 中你将看到 C++14 允许 auto 作为函数返回值，并且可以被推导。然后那是利用了模板推导，并不是 auto 推导，因此 auto 作为函数返回值时不允许返回一个大括号初始化列表，将会编译失败：</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">createInitList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>  <span class="c1">// error: can&#39;t deduce type for { 1, 2, 3 }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 lambda 函数也是一样：</p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">resetV</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">v</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">newValue</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span> <span class="o">=</span> <span class="n">newValue</span><span class="p">;</span> <span class="p">};</span>  <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">resetV</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">});</span>   <span class="c1">// error: can&#39;t deduce type for { 1, 2, 3 }
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>auto 类型推导除了大括号初始化列表方式外，和模板类型推导方法一致。模板类型推导不支持 std::initializer_list。</li>
<li>函数返回值为 auto 时，实际是使用模板推导，不是 auto 类型推导。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-3-understand-decltypehttpsblogcsdnnetdong_hfutarticledetails122745518"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122745518"target="_blank" rel="external nofollow noopener noreferrer">Item 3: Understand decltype.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>给定一个名字或者表达式，decltype 返回名字或者表达式的类型。大多数情况下，decltype 都能返回你所期望的结果，但也有一些特殊情况。</p>
<p>下面给出一些典型场景下，decltype 的返回结果，正如你所期望的那样：</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// decltype(i) is const int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span> <span class="c1">// decltype(w) is const Widget&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// decltype(f) is bool(const Widget&amp;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>   <span class="c1">// decltype(Point::x) is int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>          <span class="c1">// decltype(Point::y) is int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// decltype(w) is Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="p">...</span> <span class="c1">// decltype(f(w)) is bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>    <span class="c1">// simplified version of std::vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// decltype(v) is vector&lt;int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">...</span>   <span class="c1">// decltype(v[0]) is int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在C++11中，可能 decltype 基本的应用就是申明函数模板，它的返回值类型取决于其参数类型。例如，我们有这样一个函数，传入一个容器和下标，期望在函数末尾返回下标指向的值，并且保留返回值的类型。由于容器的 operatpr[] 通常返回一个 T&amp; （但是，std::vector<bool>，opertor[] 返回的不是一个 bool&amp;，这个我们在 Item6 中再讨论），我们期望在函数末尾返回的也是引用类型，以便于我们对其进一步赋值。使用 decltype 达成这样的目标：</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>  <span class="c1">// works, but requires refinement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用了拖尾返回值类型的语法，也即在箭头后声明返回值类型，这里可以返回我们期望的引用类型。</p>
<p>C++14可以省略拖尾返回值的声明，这意味着 auto 需要通过编译器根据函数的实现进行类型推导得到：</p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>   <span class="c1">// C++14; not quite correct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    <span class="c1">// return type deduced from c[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是 Item1 和 Item2 的推导规则告诉我们，在模板类型推导中，表达式初始化的引用属性将被忽略。考虑下面的代码片段：</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">authAndAccess</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>   <span class="c1">// authenticate user, return d[5], then assign 10 to it; this won&#39;t compile!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，d[5] 是一个 int&amp;，但是根据 auto的类型推导，authAndAccess 函数将会返回一个 int 类型，作为函数返回值，即一个 int 类型的值，这是一个右值，那么对其进行赋值是非法的。</p>
<p>为了得到我们期望的结果，也即返回引用类型，我们需要使用 decltype 的类型推导：decltype(auto)，auto 表示类型需要推导，decltype 表示使用 decltype 规则进行推导，我们修改函数实现如下：</p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>   <span class="c1">// C++14; works, but still requires refinement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，authAndAccess 将真正返回 c[i] 的类型，也即 T&amp;。</p>
<p>decltype(auto) 不限于用在函数返回值，也可以用在变量申明，例如：</p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">cw</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">myWidget1</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>    <span class="c1">// auto type deduction: myWidget1&#39;s type is Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">myWidget2</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>   <span class="c1">// decltype type deduction: myWidget2&#39;s type is const Widget&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>还有两点需要进一步讨论下，第一点是上面提到的 authAndAccess 还可以进一步优化的事情。让我们再看下 authAndAccess 的声明：</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，Container 传参是一个 lvalue-reference-to-non-const，返回值的类型是可以被修改的，这也就意味着我们不能传右值 containers，右值不能绑定到左值引用（除非是 lvalue-references-to-const ）。</p>
<p>一个比较好的解决方案是万能引用！如下：</p>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span>    <span class="c1">// c is now a universal reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个模板中，既可以传左值，也可以传右值。但是这里有一个不好地方上是：值传递会造成不必要的拷贝。</p>
<p>为了遵循 Item25 中的警告，我们需要修改下如下：</p>
<div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>  <span class="c1">// final C++14 version
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上需要 C++14 的编译器，C++11 版本的写法：</p>
<div class="highlight" id="id-43"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>   <span class="c1">// final C++11 version
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">authenticateUser</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>另一问题是开头说的少数场景下，decltype 可能返回不是你所预期的结果。对于一个左值表达式 expr，如果 expr 的类型是 T，decltype(expr) 返回的是 T&amp;。</p>
<div class="highlight" id="id-44"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>decltype(x) 是 int。但是对于 (x) 是一个左值表达式，则decltype((x)) 得到 int&amp;。</p>
<div class="highlight" id="id-45"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// decltype(x) is int, so f1 returns int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>    <span class="c1">// decltype((x)) is int&amp;, so f2 returns int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>f2 和 f1 的返回值不同，f2 返回了一个局部变量的引用，这是相当危险的。</p>
<p>因此，在使用 decltype 的时候，建议使用 Item4 中的方法进行检查，确保得到你期望的类型推导。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>decltype几乎总是能够得出变量或者表达式的类型。</li>
<li>对于类型为 T 的左值表达式，而不是名字，decltype 基本上总是输出 T&amp;。</li>
<li>C++14支持 delctype(auto)，像是 auto，能够自动从初始化列表中推断出类型，但它使用的是decltype 的推断规则。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-4-know-how-to-view-deduced-typeshttpsblogcsdnnetdong_hfutarticledetails122774872"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122774872"target="_blank" rel="external nofollow noopener noreferrer">Item 4: Know how to view deduced types.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>从前面的介绍我们知道，类型推导的结果有时候并不是非常明显就能得到，为了安全起见，我们最好能够自己亲自验证下类型推导是否符合我们的预期，在以下3个阶段我们能够获得一些类型推导的信息：</p>
<ul>
<li>代码编辑阶段</li>
<li>编译阶段</li>
<li>运行阶段</li>
</ul>
<p><strong>IDE Editors</strong></p>
<p>一般地，在编辑代码时候，你的IDE经常可以展示一些变量、函数、参数等类型。比如如下代码，当你使用鼠标指向 y1 和 y2 时候，会显示 y1 为 int 类型、y2 为 const int* 类型。</p>
<div class="highlight" id="id-46"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">y2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>IDE 之所以能够知道类型推导的结果，是因为 IDE 背后运行了 C++ 的编译器（至少是编译器的前端），这就要求你的代码或多或少是可编译状态。</p>
<p>对于简单的类型，IDE 的显示的信息通常是有用的，但是对于复杂类型，可能它的推导类型就不准了。</p>
<p><strong>Compiler Diagnostics</strong></p>
<p>可以通过导致编译错误的方式获取类型推导的信息，编译报错信息是很好的提示信息：</p>
<div class="highlight" id="id-47"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">y2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TD</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">y1Type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TD</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">y2Type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码片段，实例化模板将导致编译报错，报错信息如下：</p>
<div class="highlight" id="id-48"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">main.cpp:11:22: error: aggregate ‘TD&lt;int&gt; y1Type’ has incomplete <span class="nb">type</span> and cannot be defined
</span></span><span class="line"><span class="cl">     TD&lt;decltype<span class="o">(</span>y1<span class="o">)</span>&gt; y1Type<span class="p">;</span>
</span></span><span class="line"><span class="cl">                      ^~~~~~
</span></span><span class="line"><span class="cl">main.cpp:12:22: error: aggregate ‘TD&lt;const int*&gt; y2Type’ has incomplete <span class="nb">type</span> and cannot be defined
</span></span><span class="line"><span class="cl">     TD&lt;decltype<span class="o">(</span>y2<span class="o">)</span>&gt; y2Type<span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的报错信息可以获取到类型推导信息。</p>
<p><strong>Runtime Output</strong></p>
<p>通过允许下时打印类型是比较准确和靠谱的。第一种方式借助 typeid 控制输出：</p>
<div class="highlight" id="id-49"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">y2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;y1: &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">y1</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;y1: &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">y2</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>打印信息：</p>
<div class="highlight" id="id-50"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">y1: i
</span></span><span class="line"><span class="cl">y1: PKi</span></span></code></pre></td></tr></table>
</div>
</div><p>i 代表 int 类型， PKi 代码 pointor to const int。</p>
<p>这看起来还好，但是考虑下面的代码：</p>
<div class="highlight" id="id-51"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>                <span class="c1">// template function to be called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">createVec</span><span class="p">();</span>    <span class="c1">// factory function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="k">auto</span> <span class="n">vw</span> <span class="o">=</span> <span class="n">createVec</span><span class="p">();</span>        <span class="c1">// init vw w/factory return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vw</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vw</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>                        <span class="c1">// call f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 typeid 来输出 T 和 param 的类型，不论是哪个编译器，你都会得到错误的结果。例如微软的编译器会告诉你：二者的类型都是 class Widget const*。但是，param 的类型比 T 多一个 const &amp;。这是由于我们这里 typeid 是值传递的，在用模板规则推导类型时，由 Item1 可知会丢失 const T&amp; 中的 const 和引用属性。</p>
<p>幸好还有另一种方法，使用 Boost 库提供的方法，可以得到可靠的类型推导信息：</p>
<div class="highlight" id="id-52"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/type_index.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">typeindex</span><span class="o">::</span><span class="n">type_id_with_cvr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;T =     &#34;</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="err">`</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;param = &#34;</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span><span class="err">`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>模板函数 boost::typeindex::type_id_with_cvr 使用我们传递的类型实例化，而且它不会删去该类型已有的 const、volatile 和引用语义（所以后缀带有 “with_cvr”）。这个模板函数的返回结果是个boost::typeindex::type_index 对象，该对象的成员函数 pretty_name 会生成非常友好的 std::string来表示这个类型。</p>
<p>在 GNU 和 Clang 的编译器下运行结果为：</p>
<div class="highlight" id="id-53"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">T =         Widget const*
</span></span><span class="line"><span class="cl">param = Widget const* const&amp;</span></span></code></pre></td></tr></table>
</div>
</div><p>在微软的编译器下运行的结果一致：</p>
<div class="highlight" id="id-54"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">T =         class Widget const *
</span></span><span class="line"><span class="cl">param = class Widget const * const &amp;</span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>通常可以使用 IDE 编辑器、编译器报错信息和 Boost TypeIndex 库来查看已推断的类型。</li>
<li>一些工具的结果可能没有帮助或者不准确，还是要理解透彻 C++ 的类型推断规则。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="ch02-auto">CH02: auto</h3>
<h4 id="item-5-prefer-auto-to-explicit-type-declarationshttpsblogcsdnnetdong_hfutarticledetails122785263"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122785263"target="_blank" rel="external nofollow noopener noreferrer">Item 5: Prefer auto to explicit type declarations.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>C++ 显式声明可能会产生例如变量未初始化、申明类型冗长、无法形成闭包、截断等问题，通过使用 auto 可以很好解决这些问题。</p>
<p><strong>避免变量未初始化</strong></p>
<div class="highlight" id="id-55"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x1</span><span class="p">;</span> <span class="c1">// potentially uninitialized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// error! initializer required
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// fine, x&#39;s value is well-defined
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>x1 未初始化，其值可能是未定义的，这导致程序中可能隐藏着 bug。使用 auto 声明的变量未初始化将导致编译报错。</p>
<p><strong>简化变量申明</strong></p>
<p>考虑下面的代码，通过解引用迭代器初始化局部变量：</p>
<div class="highlight" id="id-56"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>       <span class="c1">// algorithm to dwim (&#34;do what I mean&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">dwim</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span>       <span class="c1">// for all elements in range from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>                           <span class="c1">// b to e
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span>
</span></span><span class="line"><span class="cl">	  <span class="n">currValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="err">…</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 auto 简化上述代码：</p>
<div class="highlight" id="id-57"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>    <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">dwim</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">currValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>申明闭包类型</strong></p>
<p>在 Item 2 中介绍过 auto 可以通过类型推到得到实际的类型，考虑下面的代码片段：</p>
<div class="highlight" id="id-58"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">derefUPLess</span> <span class="o">=</span>                             <span class="c1">// comparison func.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p1</span><span class="p">,</span>      <span class="c1">// for Widgets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p2</span><span class="p">)</span>      <span class="c1">// pointed to by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span> <span class="p">};</span>                     <span class="c1">// std::unique_ptrs
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>C++14 lambda 函数参数也可以使用 auto，代码简化如下：</p>
<div class="highlight" id="id-59"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">derefLess</span> <span class="o">=</span>            <span class="c1">// C++14 comparison
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span>      <span class="c1">// function for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	   <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>      <span class="c1">// values pointed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span> <span class="p">};</span>  <span class="c1">// to by anything
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	                        <span class="c1">// pointer-like
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 auto 的 derefLess 是一个闭包类型。也可以使用 std::function 得到闭包类型：</p>
<div class="highlight" id="id-60"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widgey</span><span class="o">&gt;&amp;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">derefLess</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">p2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>auto 申明的持有闭包的变量和闭包有相同的类型，并且仅使用闭包需要的内存大小。而 std::function 声明持有闭包的变量有一个固定大小内存，一旦内存大小不足，则需要申请堆内存来存储闭包。因此，std::function 申明的对象要比 auto 申明的对象占更多的内存，由于约束内嵌的使用和提供间接函数的调用，通过 std::function 对象来调用一个封装体比通过 auto 对象要慢。也就是说，std::function 方法通常体积比 auto 大且慢，还有可能导致内存不足的异常。</p>
<p><strong>避免类型截断</strong></p>
<p>auto 还有一个避免内存截断的优点，考虑下面的代码片段：</p>
<div class="highlight" id="id-61"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>v.size() 返回类型是 std::vector::size_type ，一个无符号整数类型，很多程序员可能会写出上面的代码。std::vector::size_type 在 32 位机器上是 4个字节，但在 64 位机器上则为 8 字节，但是 unsigned 固定为 4 字节。上面的代码在 32 位机器上运行没有什么问题，但移植到 64 位机器上则会导致类型截断的问题。</p>
<p><strong>避免类型不匹配</strong></p>
<p>auto 还具有一个非常隐蔽的效果，看下面的代码：</p>
<div class="highlight" id="id-62"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span> <span class="c1">// do something with p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>看上去没有什么问题？我们很有可能写出以上的迭代代码，但是 unordered_map 的 key 是 const的，即 hash map 中 std::pair 的类型是 std::pair&lt;const std::string, int&gt;。下面的代码将产生编译报错：</p>
<div class="highlight" id="id-63"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">m</span><span class="p">[</span><span class="s">&#34;key&#34;</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="nl">p</span> <span class="p">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="p">.</span><span class="n">second</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 编译报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">38</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">initialization</span> <span class="n">of</span> <span class="n">reference</span> <span class="n">of</span> <span class="n">type</span> <span class="err">&#39;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">__cxx11</span><span class="o">::</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span><span class="err">&#39;</span> <span class="n">from</span> <span class="n">expression</span> <span class="n">of</span> <span class="n">type</span> <span class="err">&#39;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">__cxx11</span><span class="o">::</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="mi">8</span> <span class="o">|</span>   <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="nl">p</span> <span class="p">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不知道这个隐蔽的背景知识的情况下，使用 auto 替代则会避免上述问题：</p>
<div class="highlight" id="id-64"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面介绍了几条使用 auto 的优势， 使用 auto 也有 Item 2 和 Item 6 介绍的使用陷阱，但是可以通过 Item 4 介绍的一些方法可视化其类型推导结果，auto 还是非常值得使用的。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>auto 变量必须初始化，不受类型不匹配导致移植和效率问题。</li>
<li>auto 类型也受 Item2 和 Item6 中介绍的陷阱困扰。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-6-use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-typeshttpsblogcsdnnetdong_hfutarticledetails122800470"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122800470"target="_blank" rel="external nofollow noopener noreferrer">Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>在 Item 5 中介绍了使用 auto 申明类型的优势，也在 Item 2 介绍了 auto 类型推导的方式和 auto 类型推导有时候并非如我们所愿的情况，本文继续分析使用 auto 存在的问题。</p>
<p>看下面的例子，函数 features 入参为 Widget 类型，返回一个 std::vector<bool>，每一个 bool 代表 Widget 是否提供一个特殊的特性：</p>
<div class="highlight" id="id-65"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">features</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设 bit 5 代表是否有高优先级，可能编码如下：</p>
<div class="highlight" id="id-66"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">highPriority</span> <span class="o">=</span> <span class="n">features</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>  <span class="c1">// is w high priority?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="n">processWidget</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">highPriority</span><span class="p">);</span>     <span class="c1">// process w in accord
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">// with its priority
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果修改 highPriority 显示申明为 auto ：</p>
<div class="highlight" id="id-67"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">highPriority</span> <span class="o">=</span> <span class="n">features</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>  <span class="c1">// is w high priority?
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将导致 processWidget 出现不可预测的行为，这是为什么呢？对 vector <T> 的 operator [] 操作，一般我们期望得到 T&amp; 类型。但是对于 vector <bool> 的 operator [] 操作，得到的是 std::vector<bool>::reference 类型，却不是 bool&amp; 类型。</p>
<p>为什么会有std::vector<bool>::reference 类型呢？主要是以下几个原因：</p>
<ol>
<li>为了节省空间，使用 1 个 bit 代替 1 个字节的 bool 类型。</li>
<li>std::vector<T> 的 operator [] 操作应该返回的是 T&amp;， 但标准库无法返对 bit 的引用。</li>
<li>为了得到接近 bool&amp; 的类型，std::vector<bool>::reference 对象能够使用在 bool&amp; 可以使用的场景。</li>
</ol>
<p>由于以上几点，再看下这段代码：</p>
<div class="highlight" id="id-68"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">highPriority</span> <span class="o">=</span> <span class="n">features</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>  <span class="c1">// is w high priority?
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，features 返回的是 std::vector<bool> 对象，然后施加 operator [] 操作得到 std::vector<bool>::reference 对象， 最后被隐式转化为 bool 类型来初始化 highPriority，highPriority 得到 std::vector<bool> 中 bit 5 的值。</p>
<div class="highlight" id="id-69"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">highPriority</span> <span class="o">=</span> <span class="n">features</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// deduce highPriority&#39;s type
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将 bool 换成 auto，由于 auto 的自动类型推导，最后无法得到 std::vector<bool> 中 bit 5 的值。具体是什么值取决于 std::vector<bool>::reference 的实现。std::vector<bool>::reference 的一种实现是这样的：这个对象包含一个指针，这个指针指向一个 word（word 存储了引用的 bit ，加上 word 中 bit 的 offset。在这里，features 返回的是一个 std::vector<bool> 临时对象 temp，operator [] 操作后，得到 std::vector<bool>::reference ，它包含一个指向 temp 中 word 的指针，加上 bit 5 的偏移。因此，在语句结尾，临时的 temp 被销毁，highPriority 包含了一个野指针，这将导致随后的 processWidget 函数的不可预测的行为。</p>
<p>这里可以使用显示类型初始化方式使用 auto ：</p>
<div class="highlight" id="id-70"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">highPriority</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">features</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">5</span><span class="p">]);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::vector<bool>::reference 是代理类（proxy class）的一个例子，代理类的目的是为了模拟和扩展某些其他类型行为，具有广泛的使用，比如标准库的智能指针类型。</p>
<p>在表达式模板中也使用代理类的技术，能够提高数值计算的效率。比如给定一个类 Matrix 和 Matrix 的对象 m1, m2, m3 和 m4，以下表达式：</p>
<div class="highlight" id="id-71"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Matrix</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">m3</span> <span class="o">+</span> <span class="n">m4</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>operator + 返回一个代理类对象将更加高效。operator + 两个 Matrix 对象得到代理 Sum&lt;Matrix, Matrix&gt; 对象，而不是Matrix 对象，上面的表达式将得到 Sum&lt;Sum&lt;Sum&lt;Matrix, Matrix&gt;,Matrix&gt;, Matrix&gt; 对象，最后隐式转化为为 Matrix 对象。</p>
<p>这种隐形的代理类遇到 auto 时候往往得不到预期的结果。因此，一般防止出现以下语句：</p>
<div class="highlight" id="id-72"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">someVar</span> <span class="o">=</span> <span class="n">expression</span> <span class="n">of</span> <span class="s">&#34;invisible&#34;</span> <span class="n">proxy</span> <span class="k">class</span> <span class="nc">type</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一种方式是使用显式的类型申明，一种方式是使用 static_cast 显示类型初始化：</p>
<div class="highlight" id="id-73"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">highPriority</span> <span class="o">=</span> <span class="n">features</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">highPriority</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">features</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">5</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Matrix</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">m3</span> <span class="o">+</span> <span class="n">m4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">m3</span> <span class="o">+</span> <span class="n">m4</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的习惯不仅用于<strong>代理类</strong>的情况，在<strong>定义一个变量的类型及其初始化表达式类型不同</strong>时，也最好显式申明变量类型，或者显示类型初始化。例如：</p>
<div class="highlight" id="id-74"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">calcEpsilon</span><span class="p">();</span> <span class="c1">// return tolerance value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">ep</span> <span class="o">=</span> <span class="n">calcEpsilon</span><span class="p">();</span> <span class="c1">// impliclitly convert double → float
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">ep</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">calcEpsilon</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>隐式的代理类型可能导致 auto 类型推导结果不符合预期。</li>
<li>对于这种代理类型一般使用显式类型申明或者显示类型初始化。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="ch03-moving-to-modern-c">CH03: Moving to Modern C++</h3>
<h4 id="item-7-distinguish-between--and--when-creating-objectshttpsblogcsdnnetdong_hfutarticledetails122811753"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122811753"target="_blank" rel="external nofollow noopener noreferrer">Item 7: Distinguish between () and {} when creating objects.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p><strong>初始化方式</strong>
C++11开始变量初始化方式有以下几种：</p>
<div class="highlight" id="id-75"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">x</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// initializer is in parentheses
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// initializer follows &#34;=&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">z</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>    <span class="c1">// initializer is in braces
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span> <span class="c1">// initializer uses &#34;=&#34; and braces
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中第四种使用等号和花括号方式初始化变量通常认为和第三种花括号的方式相同。使用等号进行初始化可能会被认为是赋值操作，对于内置类型（比如 int），可以忽略它们的区别，但对于用户自定义类型，则需要区别：</p>
<div class="highlight" id="id-76"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w1</span><span class="p">;</span>      <span class="c1">// call default constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">w1</span><span class="p">;</span> <span class="c1">// not an assignment; calls copy ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">w1</span> <span class="o">=</span> <span class="n">w2</span><span class="p">;</span>        <span class="c1">// an assignment; calls copy operator=
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>使用 {} 初始化被称为统一初始化（uniform initialization），期望能够统一应用在所有初始化场景</strong>（实际上也有缺陷，后文将介绍）。</p>
<p><strong>() 和 = 初始化方式的限制</strong></p>
<p>圆括号不能用于非静态成员变量的默认初始化：</p>
<div class="highlight" id="id-77"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>  <span class="c1">// fine, x&#39;s default value is 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// also fine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">z</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>    <span class="c1">// error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 编译报错信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">11</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">expected</span> <span class="n">identifier</span> <span class="n">before</span> <span class="n">numeric</span> <span class="n">constant</span>
</span></span><span class="line"><span class="cl">   <span class="mi">10</span> <span class="o">|</span>     <span class="kt">int</span> <span class="n">z</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>    <span class="c1">// error!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>成员变量 z 的初始化将会导致编译报错。</p>
<p>另外，C++中不能拷贝的对象则不能使用等号初始化：</p>
<div class="highlight" id="id-78"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ai1</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ai2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// fine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ai3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 编译报错信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">24</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">use</span> <span class="n">of</span> <span class="n">deleted</span> <span class="n">function</span> <span class="err">‘</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">atomic</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="err">’</span>
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">^</span></span></span></code></pre></td></tr></table>
</div>
</div><p>= 和 () 初始化都有使用的限制，可能就是 {} 初始化被称为统一初始化的原因吧。</p>
<p><strong>{} 初始化的优势</strong></p>
<p>统一初始化可以避免隐式窄化转换（narrowing conversions）：</p>
<div class="highlight" id="id-79"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sum1</span><span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="p">};</span>    <span class="c1">// error! sum of doubles may not be expressible as int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">sum2</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span>      <span class="c1">// okay (value of expression truncated to an int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum3</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>     <span class="c1">// ditto
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>统一初始化另外一个好处是避免了 C++ 复杂的语法分析（most vexing parse）：</p>
<div class="highlight" id="id-80"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w2</span><span class="p">();</span>    <span class="c1">// most vexing parse! declares a function named w2 that returns a Widget!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// call Widget ctor with argument 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w3</span><span class="p">{};</span>    <span class="c1">// calls Widget ctor with no args
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一个例子的问题可以戳 <a href="https://blog.csdn.net/Dong_HFUT/article/details/126435993?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">C++‘s most vexing parse<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 了解更多。</p>
<p><strong>{}初始化的不足</strong></p>
<p>除了 Item 2 介绍的 auto 变量类型声明使用统一初始化时候类型被推导成 std::initializer_list 的特点外，还存在统一初始化和其他初始化行为不一致的情况。</p>
<p>在没有 std::initializer_list 参数类型的构造函数时：</p>
<div class="highlight" id="id-81"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>    <span class="c1">// ctors not declaring
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>  <span class="c1">// std::initializer_list params
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>  <span class="c1">// calls first ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span>  <span class="c1">// also calls first ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>   <span class="c1">// calls second ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">};</span>   <span class="c1">// also calls second ctor
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在增加一个std::initializer_list 参数类型的构造函数时：</p>
<div class="highlight" id="id-82"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>                              <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>                            <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>      <span class="c1">// added
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>    <span class="c1">// uses parens and, as before,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// calls first ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span>    <span class="c1">// uses braces, but now calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">// std::initializer_list ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">// (10 and true convert to long double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>     <span class="c1">// uses parens and, as before,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// calls second ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">};</span>     <span class="c1">// uses braces, but now calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// std::initializer_list ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">// (10 and 5.0 convert to long double)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，w2 和 w4 将会使用新增的构造函数（第3个构造函数）。但是很明显， non-std::initializer_list 参数类型构造函数比std::initializer_list 参数类型构造函数更加匹配。</p>
<p>更有甚者，拷贝和移动构造函数也能被 std::initializer_list 构造函数绑架：</p>
<div class="highlight" id="id-83"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>    <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">operator</span> <span class="nf">float</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>   <span class="c1">// convert to float
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w5</span><span class="p">(</span><span class="n">w4</span><span class="p">);</span>    <span class="c1">// uses parens, calls copy ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w6</span><span class="p">{</span><span class="n">w4</span><span class="p">};</span>    <span class="c1">// uses braces, calls std::initializer_list ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// (w4 converts to float, and float converts to long double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w7</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w4</span><span class="p">));</span>  <span class="c1">// uses parens, calls move ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w8</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w4</span><span class="p">)};</span>  <span class="c1">// uses braces, calls std::initializer_list ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                           <span class="c1">// (for same reason as w6)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>编译器匹配 std::initializer_list 构造函数的决心很强，甚至导致编译报错，也没有匹配到普通的构造函数：</p>
<div class="highlight" id="id-84"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>   <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span> <span class="c1">// element type is now bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>                                     <span class="c1">// no implicit conversion funcs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">};</span>   <span class="c1">// error! requires narrowing conversions
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，编译器直接忽略前两个构造函数，试图匹配 std::initializer_list<bool> 构造函数，但是需要将 int (10) 和 double (5.0) 转换为 bool 类型，这是窄化转化，将会失败（前面有解释），这里就导致错误。</p>
<p>只有花括号中参数无法转换为 std::initializer_list 中类型时，编译器才匹配普通函数：</p>
<div class="highlight" id="id-85"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>    <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// std::initializer_list element type is now std::string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">// uses parens, still calls first ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span> <span class="c1">// uses braces, now calls first ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>  <span class="c1">// uses parens, still calls second ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">};</span>  <span class="c1">// uses braces, now calls second ctor
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>统一初始化除了存在上述问题，还有一些边界 case 需要处理下，看下面的例子：</p>
<div class="highlight" id="id-86"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>                              <span class="c1">// default ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span> <span class="c1">// std::initializer_list ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w1</span><span class="p">;</span>   <span class="c1">// calls default ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span><span class="p">{};</span> <span class="c1">// also calls default ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w3</span><span class="p">();</span> <span class="c1">// most vexing parse! declares a function!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>w2 将会调用默认构造函数，而没有调用选择调用 std::initializer_list 构造函数并将 list 设置为空，这是一个特例。如果希望调用 std::initializer_list 构造函数， 如下：</p>
<div class="highlight" id="id-87"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w4</span><span class="p">({});</span> <span class="c1">// calls std::initializer_list ctor with empty list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w5</span><span class="p">{{}};</span> <span class="c1">// ditto
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>了解了以上 {} 和 () 的初始化的一些不足之后，我们再看下标准库的情况，对于新手，很容易以为下面两种方式创建的对象是相同的。</p>
<div class="highlight" id="id-88"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// use non-std::initializer_list ctor: create 10-element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                             <span class="c1">// std::vector, all elements have value of 20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span> <span class="c1">// use std::initializer_list ctor: create 2-element std::vector,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                             <span class="c1">// element values are 10 and 20
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再看下面的例子：</p>
<div class="highlight" id="id-89"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>                <span class="c1">// type of object to create
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>            <span class="c1">// types of arguments to use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">doSomeWork</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">create</span> <span class="n">local</span> <span class="n">T</span> <span class="n">object</span> <span class="n">from</span> <span class="n">params</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将上面的伪代码替换成下面两种创建对象的方式：</p>
<div class="highlight" id="id-90"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">T</span> <span class="nf">localObject</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span> <span class="c1">// using parens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">T</span> <span class="n">localObject</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...};</span> <span class="c1">// using braces
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再考虑下面的调用代码：</p>
<div class="highlight" id="id-91"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">doSomeWork</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果 doSomeWork 采用圆括号的实现，结果将是 10 个元素的 std::vector。如果 doSomeWork 采用花括号的实现，结果将是 2 个元素的 std::vector。</p>
<p>标准库中的 std::make_shared 和 std::make_unique 使用圆括号初始化，并且在代码中做了注释。这类问题没有什么好的解决方案，只能在代码和接口中添加注释来告知调用者。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>括号初始化是最广泛使用的初始化语法，它防止窄化转换，并且对于 C++ 最令人头疼的解析有天生的免疫性。</li>
<li>在构造函数重载决议中，括号初始化尽最大可能与 std::initializer_list 参数匹配，即便其他构造函数看起来是更好的选择。</li>
<li>对于数值类型的std::vector来说使用花括号初始化和圆括号初始化会产生巨大的不同。</li>
<li>在模板类选择使用小括号初始化或使用花括号初始化创建对象是一个挑战。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-8-prefer-nullptr-to-0-and-nullhttpsblogcsdnnetdong_hfutarticledetails122891898"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122891898"target="_blank" rel="external nofollow noopener noreferrer">Item 8: Prefer nullptr to 0 and NULL.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>在 C++ 中，字面值 0 是一个 int 类型，不是一个指针类型，虽然 C++ 根据上下文可以将字面值 0 解释成一个空指针，但本质上，请注意字面值 0 是一个 int 类型。</p>
<p>实际上，NULL 的情况也一样，它也不是一个指针类型，根据实现情况来定，可以被允许实现为 long 类型，但本质上也不是一个指针类型。</p>
<p>字面值 0 和 NULL 不是指针类型这一事实会导致了一些让人困惑的场景，比如在 C++98 下：</p>
<div class="highlight" id="id-92"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>    <span class="c1">// three overloads of f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>           <span class="c1">// calls f(int), not f(void*)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>        <span class="c1">// might not compile, but typically calls f(int). Never calls f(void*)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>f(0) 会匹配到第一个，不会匹配 f(void*) 。NULL 的实现是 0L，可以转换成 int，bool 和 void* ，这会导致匹配失败，除非有一个 f(long) 的重载。对于程序员来说，f(NULL) 预想的是调用 f(void*)，但 C++ 实际上却去匹配参数为整型的 f，这是违反直觉的。因此， 对于 C++98 的程序员，最好避免使用指针类型重载整型。到了 C++11，上面的这个建议依然有效，因为开发者很有可能继续使用 0 和 NULL 作为空指针。</p>
<p>在 C++11 后，建议大家使用 nullptr 作为空指针。nullptr 不是一个整型，它也不是一个确定的指针类型，可以把它理解为任意类型的指针，它的准确类型是 std::nullptr_t，可以隐式转换为任意指针类型的类型。用 nullptr 代替 0 和 NULL，可以使得重载函数的调用非常明确。</p>
<div class="highlight" id="id-93"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>  <span class="c1">// calls f(void*) overload
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 nullptr 的另一个优势是可以提高代码的清晰度，尤其是使用 auto 变量时：</p>
<div class="highlight" id="id-94"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">findRecord</span><span class="p">(</span> <span class="cm">/* arguments */</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，如果你不清楚 findRecord 返回值的类型时，你可能就不清楚 result 是一个指针类型还是一个整型。但如果使用 nullptr 代替 0，代码将更加清晰，result 一定是一个指针类型，就不会模棱两可了：</p>
<div class="highlight" id="id-95"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">findRecord</span><span class="p">(</span> <span class="cm">/* arguments */</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在我们使用模板时候，nullptr 的优势将更加引人注目。假设你有这样的一些函数，只有当对应的互斥量被锁定的时候，这些函数才可以被调用，每个函数的参数是不同类型的指针：</p>
<div class="highlight" id="id-96"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f1</span><span class="p">(</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">);</span>    <span class="c1">// call these only when the appropriate mutex is locked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="nf">f2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">upw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">f3</span><span class="p">(</span><span class="n">Widget</span><span class="o">*</span> <span class="n">pw</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>传空指针调用这些函数可能是这样的：</p>
<div class="highlight" id="id-97"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">f1m</span><span class="p">,</span> <span class="n">f2m</span><span class="p">,</span> <span class="n">f3m</span><span class="p">;</span> <span class="c1">// mutexes for f1, f2, and f3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MuxGuard</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// C++11 typedef; see Item 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MuxGuard</span> <span class="nf">g</span><span class="p">(</span><span class="n">f1m</span><span class="p">);</span>      <span class="c1">// lock mutex for f1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// pass 0 as null ptr to f1 unlock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MuxGuard</span> <span class="nf">g</span><span class="p">(</span><span class="n">f2m</span><span class="p">);</span>         <span class="c1">// lock mutex for f2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f2</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// pass NULL as null ptr to f2 unlock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MuxGuard</span> <span class="nf">g</span><span class="p">(</span><span class="n">f3m</span><span class="p">);</span>            <span class="c1">// lock mutex for f3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>  <span class="c1">// pass nullptr as null ptr to f3 unlock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然前面两个调用没有使用 nullptr，但是还可以工作。但是上面代码最大的问题是调用代码没有复用，引入模板来解决这个问题：</p>
<div class="highlight" id="id-98"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FuncType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		 <span class="k">typename</span> <span class="n">MuxType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		 <span class="k">typename</span> <span class="n">PtrType</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">lockAndCall</span><span class="p">(</span><span class="n">FuncType</span> <span class="n">func</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				 <span class="n">MuxType</span><span class="o">&amp;</span> <span class="n">mutex</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				 <span class="n">PtrType</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MuxGuard</span> <span class="nf">g</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 C++ 14 中可以使用 decltype(auto) 代替上面的 —&gt; :</p>
<div class="highlight" id="id-99"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FuncType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		 <span class="k">typename</span> <span class="n">MuxType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		 <span class="k">typename</span> <span class="n">PtrType</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">lockAndCall</span><span class="p">(</span><span class="n">FuncType</span> <span class="n">func</span><span class="p">,</span>      <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						   <span class="n">MuxType</span><span class="o">&amp;</span> <span class="n">mutex</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						   <span class="n">PtrType</span> <span class="n">ptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MuxGuard</span> <span class="nf">g</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于上面的两个版本，调用代码可以如下：</p>
<div class="highlight" id="id-100"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">lockAndCall</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f1m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>        <span class="c1">// error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">lockAndCall</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">f2m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>     <span class="c1">// error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">lockAndCall</span><span class="p">(</span><span class="n">f3</span><span class="p">,</span> <span class="n">f3m</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>  <span class="c1">// fine
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>前面的两种调用将会失败。在第一个调用中，将 0 传入 lockAndCall，模板类型推导将得到它是一个 int，而 f1 期望接收的是 std::share_ptr<Widget> ，匹配失败。对于第二个调用也是类似的。第三个调用传入 nullptr 是没有问题的，当 nullptr 被传入时，ptr 的类型被推导为 std::nullptr_t ，std::nullptr_t 可以隐式转化为任意类型指针，因此能够和 f3 匹配成功。</p>
<p>上面的例子使用 nullptr 的优势非常明显，因此使用 nullptr 代替 0 和 NULL 吧！</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>相较于 0 和 NULL，优先使用 nullptr 。</li>
<li>避免对整数类型和指针类型的重载。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-9-prefer-alias-declarations-to-typedefshttpsblogcsdnnetdong_hfutarticledetails122847510"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122847510"target="_blank" rel="external nofollow noopener noreferrer">Item 9: Prefer alias declarations to typedefs.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>C++98 提供了给类型重新命名的功能：</p>
<div class="highlight" id="id-101"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">UPtrMapSS</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这在 C++11 依然能够工作， 但 C++11 提供了新的方式：别名申明（alias declarations）。</p>
<div class="highlight" id="id-102"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">UPtrMapSS</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>仅从以上例子，两种使用方式没有太大区别，下面将介绍别名申明(alias)的优势。</p>
<p>使用别名申明比使用 typedef 更容易理解，特别是申明函数指针的时候：</p>
<div class="highlight" id="id-103"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// FP is a synonym for a pointer to a function taking an int and
</span></span></span><span class="line"><span class="cl"><span class="c1">// a const std::string&amp; and returning nothing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FP</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// same meaning as above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">FP</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// alias declaration
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子只能说使用别名申明的代码略为清晰易懂一点，并不是一个不可抗拒的诱惑。但是，当在使用别名模板（alias templates）时，别名申明可以直接作用在模板申明的作用域。但是，typedef 却不行， 它需要嵌套在自定义结构体的作用域内。例如：</p>
<div class="highlight" id="id-104"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MyAllocList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span> <span class="c1">// MyAllocList&lt;T&gt; is synonym for std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">lw</span><span class="p">;</span>  <span class="c1">// client code
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 typedef ，你需要定义一个结构体，并将 typedef 放到结构体的作用域中，如下：</p>
<div class="highlight" id="id-105"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// MyAllocList&lt;T&gt;::type is synonym for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">MyAllocList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span> <span class="c1">// std::list&lt;T, std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">lw</span><span class="p">;</span> <span class="c1">// client code
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>显然，使用 typedef 已经非常吃力了。并且，如果你在模板中使用 typedef 的类型定义变量时，你还必须在前面加上 typename。</p>
<div class="highlight" id="id-106"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// MyAllocList&lt;T&gt;::type is synonym for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">MyAllocList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span> <span class="c1">// std::list&lt;T, std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>       <span class="c1">// Widget&lt;T&gt; contains Widget&lt;T&gt; contains as a data member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，MyAllocList<T>::type 表示的类型依赖于模板的类型 T。因此， MyAllocList<T>::type 是一个依赖类型(dependent type)。在 C++ 中，一个依赖类型的名称之前必须冠以 typename。而使用别名申明则没有这个问题：</p>
<div class="highlight" id="id-107"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MyAllocList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span> <span class="c1">// MyAllocList&lt;T&gt; is synonym for std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>看上去 MyAllocList<T> （使用模板别名） 也依赖于模板参数 T ，但当编译器在处理 Widget 时，MyAllocList<T> （使用模板别名） 使用了模板别名，它一定是一个类型，因此无需也不能冠以 typename。</p>
<p>但是，对于使用内嵌的 typename 的 MyAllocList<T> ，编译器在处理 Widget 时，并不知道 MyAllocList<T> 是一个类型，可能是一个特殊化的 MyAllocList ，在这个特殊化的 MyAllocList 中， MyAllocList<T>::type 表示的并不是一个类型。看下面的例子：</p>
<div class="highlight" id="id-108"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Wine</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyAllocList</span><span class="o">&lt;</span><span class="n">Wine</span><span class="o">&gt;</span> <span class="p">{</span>  <span class="c1">// MyAllocList specialization for when T is Wine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="k">class</span> <span class="nc">WineType</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">White</span><span class="p">,</span> <span class="n">Red</span><span class="p">,</span> <span class="n">Rose</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">WineType</span> <span class="n">type</span><span class="p">;</span>      <span class="c1">// in this class, type is a data member!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，MyAllocList<Wine>::type 并不是指一个类型，而是一个数据成员。如果 Widget 被使用 Wine 初始化，Widget 模板中的 MyAllocList<T>::type 指的是一个数据成员，而不是一个类型。</p>
<p>虽然，尽管别名申明有以上多个优点，但是 C++11中的 &lt;type_trais&gt; 却大量用了 typedef，C++ 标准委员会意识到使用别名什么更加合适，因此，对于 C++11 中的每个类型转换 std::transformation<T>::type ，有一个对应的 C++14 的模板别名 std::transformation_t ：</p>
<div class="highlight" id="id-109"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>  <span class="c1">// C++11: const T → T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>      <span class="c1">// C++14 equivalent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>  <span class="c1">// C++11: T&amp;/T&amp;&amp; → T
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>      <span class="c1">// C++14 equivalent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">add_lvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>  <span class="c1">// C++11: T → T&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">add_lvalue_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>      <span class="c1">// C++14 equivalent
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然以上两种方式在 C++14 中都存在，但我们没有理由再使用 typedef 的形式。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>typedef 不支持模板化，但是别名声明支持。</li>
<li>模板别名没有 ::type 后缀，在模板中，typedef 还经常要求使用 typename 前缀。</li>
<li>C++14 为 C++11 中的类型特征转换提供了模板别名。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-10-prefer-scoped-enums-to-unscoped-enumshttpsblogcsdnnetdong_hfutarticledetails122914289"><a href="https://blog.csdn.net/Dong_HFUT/article/details/122914289"target="_blank" rel="external nofollow noopener noreferrer">Item 10: Prefer scoped enums to unscoped enums.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>一般来说，定义在花括号中的对象，其作用域也在花括号内，但是 C++98 风格的枚举（enums）类型却不遵从这一规则：</p>
<div class="highlight" id="id-110"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span> <span class="c1">// black, white, red are in same scope as Color
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">white</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>               <span class="c1">// error! white already declared in this scope
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面这种将枚举成员暴露在其花括号作用域外面的方式，官方称为无作用域限制的枚举（unscoped enums）。C++11 提供不暴露枚举成员的枚举类型：有作用域限制的枚举（scoped enums）。</p>
<div class="highlight" id="id-111"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span> <span class="c1">// black, white, red are scoped to Color
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">white</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>                     <span class="c1">// fine, no other
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>减少名称污染</strong>
从上面的两个例子，可以看到 scoped enums 可以减少因作用域限制导致的名称污染，这是 scoped enums 的第一个优点。</p>
<p><strong>有强类型</strong>
scoped enums 的第二个优点是其成员有强类型，不会发生隐式类型转换。看个例子：</p>
<div class="highlight" id="id-112"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span> <span class="c1">// unscoped enum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span>  <span class="n">primeFactors</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mf">14.5</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// compare Color to double (!)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">factors</span> <span class="o">=</span> <span class="n">primeFactors</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// compute prime factors of a Color (!)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>scoped enums 则不会发生隐式类型转换，上面的例子的 Color 修改成 scoped enums 方式，则会产生编译报错：</p>
<div class="highlight" id="id-113"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span> <span class="c1">// enum is now scoped
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mf">14.5</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// error! can&#39;t compare Color and double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">factors</span> <span class="o">=</span> <span class="n">primeFactors</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>  <span class="c1">// error! can&#39;t pass Color to function expecting std::size_t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你一定要将 Color 转换为其他类型，可以使用显示类型转换：</p>
<div class="highlight" id="id-114"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">14.5</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// odd code, but it&#39;s valid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">factors</span> <span class="o">=</span> <span class="n">primeFactors</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">));</span> <span class="c1">// suspect, but it compiles
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>前向声明</strong></p>
<p>scoped enums 的第三个优点是其可以前向申明，也即枚举名可以在没有指定其成员前进行申明。</p>
<div class="highlight" id="id-115"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Color</span><span class="p">;</span> <span class="c1">// error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span><span class="p">;</span> <span class="c1">// fine
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其实，说 unscoped enums 不支持前向申明是不严谨的，其实在 C++11 中，它也可以前向申明，只不过不支持上面例子这样的前向申明，要想让它可以前向申明，还需要进行一点修改而已。所谓的前向申明，其本质就是告诉编译器目标是什么类型。</p>
<p>这里有一个事实，那就是unscoped enums 类型其实不是一个 enums，它的实际类型是编译器进行选择决定的。 scoped enums 之所以能够前向申明，是因为它的默认潜在类型（underlying type）是 int。</p>
<div class="highlight" id="id-116"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">,</span> <span class="n">red</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于上面代码，编译可以将 Color 类型选择成 char 就足够了。</p>
<div class="highlight" id="id-117"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Status</span> <span class="p">{</span> <span class="n">good</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="n">failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="n">incomplete</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="n">corrupt</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="n">indeterminate</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，对于上面这段代码，编译器可能需要将 Status 类型选择成 int。</p>
<p>总之，对于有作用域的枚举体的潜在类型是已知的，对于没有作用域的枚举体，你可以指定它。</p>
<p>对于 scoped enums ，默认的潜在类型为 int，当然你也可以进行更改：</p>
<div class="highlight" id="id-118"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Status</span><span class="p">;</span> <span class="c1">// underlying type is int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Status</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span> <span class="c1">// underlying type for Status is std::uint32_t (from &lt;cstdint&gt;)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 unscoped enums，指定了潜在类型，则可以前向申明：</p>
<div class="highlight" id="id-119"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Color</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">;</span> <span class="c1">// fwd decl for unscoped enum; underlying type is std::uint8_t
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>unscoped enums 的优势</strong></p>
<p>上面介绍了 scoped enums 比 unscoped enums 的几个优点。其实，unscoped enums 也有它自己的优势。看下面的例子：</p>
<div class="highlight" id="id-120"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">UserInfo</span> <span class="o">=</span> <span class="c1">// type alias; see Item 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="c1">// name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	       <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="c1">// email
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	       <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// reputation
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然注释说明了元组每个部分代表的含义，但是，当你遇到下面的代码时候，你可能还是记不清楚元组的第一个元素代表的是啥：</p>
<div class="highlight" id="id-121"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">UserInfo</span> <span class="n">uInfo</span><span class="p">;</span> <span class="c1">// object of tuple type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// get value of field 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用 unscoped enums 修改上面的代码，可以避免这个问题：</p>
<div class="highlight" id="id-122"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">UserInfoFields</span> <span class="p">{</span> <span class="n">uiName</span><span class="p">,</span> <span class="n">uiEmail</span><span class="p">,</span> <span class="n">uiReputation</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">UserInfo</span> <span class="n">uInfo</span><span class="p">;</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">uiEmail</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// ah, get value of email field
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，UserInfoFields 到 std::get() 要求的 std::size_t 的隐式类型转换。要是使用 scoped enums 则代码要冗余的多：</p>
<div class="highlight" id="id-123"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">UserInfoFields</span> <span class="p">{</span> <span class="n">uiName</span><span class="p">,</span> <span class="n">uiEmail</span><span class="p">,</span> <span class="n">uiReputation</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">UserInfo</span> <span class="n">uInfo</span><span class="p">;</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">val</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UserInfoFields</span><span class="o">::</span><span class="n">uiEmail</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>C++98 风格的 enum 是 unscoped enum 。</li>
<li>scoped enums 的枚举成员仅仅对枚举体内部可见。只能通过类型转换（ cast ）转换为其他类型。</li>
<li>scopded enums 和 unscoped enum 都支持指定潜在类型。scoped enum 默认潜在类型是 int 。unscoped enum 没有默认的潜在类型。</li>
<li>scoped enum 总是可以前置声明的。unscoped enum 只有当指定潜在类型时才可以前置声明。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-11-prefer-deleted-functions-to-private-undefined-oneshttpsblogcsdnnetdong_hfutarticledetails123005509"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123005509"target="_blank" rel="external nofollow noopener noreferrer">Item 11: Prefer deleted functions to private undefined ones.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>如果你的代码里有一些特殊的函数不想被别人调用，一般来说你不申明它即可。但是，有些特殊的成员函数，C++ 会自动申明，比如拷贝构造函数、拷贝赋值操作。</p>
<p><strong>C++98 的做法</strong>
C++98 的做法是将它们申明为私有并且不定义它们。以 IO 流为例，IO 流的基础类是 basic_ios，输入输出流都是继承与它。IO 流的拷贝是被阻止的（例如输入流 istream对象，表示输入数值，一些可能已经读入到内存中，一些可能还未读入，如果要复制一个输入流，是复制哪一部分？为了避免这样的问题，直接阻止 IO 流的拷贝）。</p>
<p>为了阻止 IO 流的复制，C++98 处理如下：</p>
<div class="highlight" id="id-124"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span> <span class="o">=</span> <span class="n">char_traits</span><span class="o">&lt;</span><span class="n">charT</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">basic_ios</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ios_base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">basic_ios</span><span class="p">(</span><span class="k">const</span> <span class="n">basic_ios</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// not defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">basic_ios</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">basic_ios</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// not defined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将这些函数申明为私有并不定义，若这些函数被调用，在链接阶段将会因为没有定义而失败。</p>
<p><strong>C++11 的做法</strong></p>
<p>C++11 中有更好的处理方法，给这些函数标记为 “= delete” ，表明它们是被删除的函数：</p>
<div class="highlight" id="id-125"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span> <span class="o">=</span> <span class="n">char_traits</span><span class="o">&lt;</span><span class="n">charT</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">basic_ios</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ios_base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">basic_ios</span><span class="p">(</span><span class="k">const</span> <span class="n">basic_ios</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">basic_ios</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">basic_ios</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>删除函数不可以任何方式使用，即使是成员函数和友元函数。使用这些函数将导致编译报错。这比 C++98 中的方法诊断出错误的时间提前到编译阶段。</p>
<p>将 delete 函数申明为 public 的原因是：C++ 先检查访问权限，再检查 delete 状态。如果申明为 private，当使用删除的私有函数时，有些编译器只会报出这些函数是私有的，但其实更明确的含义是这些是删除函数，不期望被使用。</p>
<p><strong>delete 函数优势</strong>
delete 函数的优势是它可以应用于任何函数，而不仅仅是成员函数。例如你有一个函数，只接受输入为 int 类型：</p>
<div class="highlight" id="id-126"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，C++ 中很多类型都可以隐式转换为 int 类型。如下调用都可以通过：</p>
<div class="highlight" id="id-127"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">isLucky</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">isLucky</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">isLucky</span><span class="p">(</span><span class="mf">3.5</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>C++11 的处理方法是将他们标记成 delete：</p>
<div class="highlight" id="id-128"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">);</span> <span class="c1">// original function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// reject chars
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// reject bools
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// reject doubles and floats
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面将参数为 double 的函数标记成 delete，可以阻止 float 和 double 两种参数的调用：C++总是倾向于将 float 转换为 double。</p>
<p>delete 函数的另一个优势体现在使用模板时候。如下面例子：</p>
<div class="highlight" id="id-129"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设你想阻止 void* 和 char* 类型的特例，将这些函数的实例化标记成 delete 即可：</p>
<div class="highlight" id="id-130"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你在一个类内部有一个函数模板，你想通过声明它们为私有来禁止某些实现，是行不通的：因为模板的特例化无法在类的作用域内定义：</p>
<div class="highlight" id="id-131"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">processPointer</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错信息：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">12</span><span class="o">:</span><span class="mi">12</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="k">explicit</span> <span class="n">specialization</span> <span class="n">in</span> <span class="n">non</span><span class="o">-</span><span class="k">namespace</span> <span class="n">scope</span> <span class="err">&#39;</span><span class="k">class</span> <span class="nc">A</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">   <span class="mi">12</span> <span class="o">|</span>   <span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span>            <span class="o">^</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">13</span><span class="o">:</span><span class="mi">8</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="k">template</span><span class="o">-</span><span class="n">id</span> <span class="err">&#39;</span><span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="err">&#39;</span> <span class="n">in</span> <span class="n">declaration</span> <span class="n">of</span> <span class="n">primary</span> <span class="k">template</span>
</span></span><span class="line"><span class="cl">   <span class="mi">13</span> <span class="o">|</span>   <span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 public 和 delete 方式则没有问题：</p>
<div class="highlight" id="id-132"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">processPointer</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此，选择使用 delete 函数吧。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>比起声明函数为 private 但不定义，使用 delete 函数更好。</li>
<li>任何函数都能 delete ，包括非成员函数和模板实例。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-12-declare-overriding-functions-overridehttpsblogcsdnnetdong_hfutarticledetails123008755"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123008755"target="_blank" rel="external nofollow noopener noreferrer">Item 12: Declare overriding functions override.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>面向对象的 C++ 主要特性是类、继承、虚函数，而这些特性的基础是继承类中重写基类的虚函数。重写（overriding）和重载（overloading）看着比较相似，但其实完全不同。重写的一个例子：</p>
<div class="highlight" id="id-133"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">();</span> <span class="c1">// base class virtual function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">();</span>  <span class="c1">// overrides Base::doWork (&#34;virtual&#34; is optional here)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">upb</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">upb</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span> <span class="c1">// call doWork through base class ptr; derived class function is invoked
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>重写需要满足的条件：</p>
<ul>
<li>基类的重写函数必须是虚函数。</li>
<li>基类和继承类的重写函数的函数名必须相同。</li>
<li>基类和继承类的重写函数的参数类型必须相同。</li>
<li>基类和继承类的重写函数的常量属性必须相同。</li>
<li>基类和继承类的重写的函数的返回值类型和异常规格说明要兼容。</li>
</ul>
<p>除了 C++98 的这些限制条件，C++11 还增加了一条：</p>
<ul>
<li>基类和继承类的重写函数的引用修饰符必须相同。</li>
</ul>
<p>引用修饰符包括左值和右值两种，左值引用成员函数可以被 *this 为左值调用，右值引用成员函数可以被 *this 为右值调用。看一个例子：</p>
<div class="highlight" id="id-134"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">doWork</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span>   <span class="c1">// this version of doWork applies only when *this is an lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;doWork() &amp;&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">doWork</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>  <span class="c1">// this version of doWork applies only when *this is an rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;doWork() &amp;&amp;&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span>  <span class="p">{</span> <span class="c1">// factory function (returns rvalue)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">w</span><span class="p">.</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">makeWidget</span><span class="p">().</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 打印信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">doWork</span><span class="p">()</span> <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">doWork</span><span class="p">()</span> <span class="o">&amp;&amp;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，w 是个左值，所以调用的是 doWork() &amp; 函数，而 makeWidget() 返回的是一个右值，所以调用的是 doWork() &amp;&amp; 函数。</p>
<p>重写的条件是非常严格的，细小的差错将会导致完全不同的结果。看个例子：</p>
<div class="highlight" id="id-135"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf3</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">mf4</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">();</span>  <span class="c1">// 缺少 const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 参数类型不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf3</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>  <span class="c1">// 引用修饰符不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">mf4</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// 基类没有加 virtual 修饰
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码，有的编译器会给出警告，有的编译器给的警告不全，还有的编译器不会给警告。所以保险的做法是自己将重写函数标记为 override，这样的话，不符合重写条件的话，编译器一定会报错。</p>
<p>所以，当你在继承类中要重写函数的话，加上 override 吧！</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>为重载函数加上override。</li>
<li>成员函数引用限定让我们可以区别对待左值对象和右值对象（即*this)。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item13-prefer-const_iterators-to-iteratorshttpsblogcsdnnetdong_hfutarticledetails123030976"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123030976"target="_blank" rel="external nofollow noopener noreferrer">Item13: Prefer const_iterators to iterators.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>STL 中 const_iterators 类似于 pointers-to-const，当你不修改 iterator 指向的对象时，最好使用 const_iterators，这样更加安全。</p>
<p>但是在 C++98 对 const_iterators 的支持并不完善。看下面的例子：</p>
<div class="highlight" id="id-136"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1983</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">1998</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码并不修改 iterator 指向的内容，显然 const_iterator 是更好的选择。C++98 中一种可能的修改如下，但却无法通过编译：</p>
<div class="highlight" id="id-137"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">IterT</span><span class="p">;</span> <span class="c1">// typedefs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">ConstIterT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIterT</span> <span class="n">ci</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIterT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span> <span class="c1">// cast
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIterT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span>   <span class="c1">// cast
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="mi">1983</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ci</span><span class="p">),</span> <span class="mi">1998</span><span class="p">);</span> <span class="c1">// may not compile; see below
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为 values 是非 const 的容器，为了使用 const_iterator，这里使用了 static_cast 强制转换一下。在 C++98 中，insert 和 erase 操作必须使用 iterator，但是在 C++98（包括 C++11）没办法将 iterator 转换为 const_iterator。</p>
<p>不过，这在 C++11 中可以得到解决，容器的成员函数 cbegin、cend 可以得到 const_iterator，即使是非 const 容器，并且 insert 和 erase 等操作可以使用 const_iterator，上述代码可以修改如下：</p>
<div class="highlight" id="id-138"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">values</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="mi">1983</span><span class="p">);</span> <span class="c1">// use cbegin and cend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">1998</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，对于泛型编程，上述代码还是不够，因为除了标准容器，还有一些类似容器的数据结构，比如数组，没有成员函数 begin 和 end，只有非成员的 begin 和 end。因此，使用非成员函数的 begin 和 end 的代码更加通用：</p>
<div class="highlight" id="id-139"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">findAndInsert</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span>        <span class="c1">// in container,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                   <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">targetVal</span><span class="p">,</span> <span class="c1">// find first occurrence of targetVal,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                   <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">insertVal</span><span class="p">)</span> <span class="c1">// then insert insertVal there
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">cbegin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="c1">// non-member cbegin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="n">cend</span><span class="p">(</span><span class="n">container</span><span class="p">),</span>   <span class="c1">// non-member cend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="n">targetVal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">container</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">insertVal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很遗憾，上述代码只能在 C++14 中才能用，因为 C++11 只提供了非成员的 begin 和 end，C++14 才提供非成员的 cbegin、cend、rbegin、rend、crbegin 和 crend。</p>
<p>如果你那的编译器只支持 C++11，那么你可以使用如下代码来实现 cbegin：</p>
<div class="highlight" id="id-140"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">cbegin</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里利用了 Item 1 中类型推导得到常量版本迭代器。</p>
<p>最后总结一下：在 C++98 中有场景可能无法使用 const_iterator。并且在 C++11 中没有提供非成员的 cbegin 和 cend。但是是鼓励大家尽可能使用 const_iterator，毕竟这样最安全。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>优先考虑 const_iterator 而非 iterator。</li>
<li>在最大程度通用的代码中，优先考虑非成员函数版本的 begin、end、rbegin 等，而非同名成员函数。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item14-declare-functions-noexcept-if-they-wont-emit-exceptionhttpsblogcsdnnetdong_hfutarticledetails123163671"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123163671"target="_blank" rel="external nofollow noopener noreferrer">Item14: Declare functions noexcept if they won‘t emit exception.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p><strong>背景</strong></p>
<p>在 C++98 中，异常规范（exception specifications）是一个比较鸡肋的设计。一个函数的实现一旦发生修改，其异常规范也可能发生改变，进而会影响到客户代码，因为客户代码可能依赖原先的异常规范。</p>
<p>C++11 对异常规范提出了有意义的改进：那就是指明函数是否可能抛出异常，不可能抛出异常的函数可以使用 noexcept 标识。</p>
<p><strong>影响调用代码的安全和性能</strong></p>
<p>在接口设计中，接口是否应该申明为 noexcept 是非常差重要的，也是客户非常关心的。接口是否为 noexcept 的状态会影响到调用者代码的安全和性能。因此如果你的函数确定不会抛出异常，就把它申明为 noexcept。</p>
<p><strong>影响编译器优化</strong></p>
<p>对于一个 noexcept 函数，编译器将会有更多优化的机会。我们看下 C++98 和 C++11 中，对于一个函数不会抛出异常的不同解释。考虑一个函数 f，它保证调用者永远不会收到异常：</p>
<div class="highlight" id="id-141"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">throw</span><span class="p">();</span>   <span class="c1">// no exceptions from f: C++98 style
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>  <span class="c1">// no exceptions from f: C++11 style
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设在运行阶段，函数 f 产生了异常，对于 C++98 风格：函数 f 的调用栈将被解开，然后经过一些动作后，程序停止。但是对于 C++11 风格：调用栈只在程序终止前才有可能被解开。</p>
<p>解开调用栈的时机和可能性的不同，对于代码的性能产生有很大的影响。对于一个 noexcept 函数，如果一个异常能传到函数外面去，优化器不需要保持运行期栈为解开的状态，也不需要确保noexcept 函数中的对象销毁的顺序和构造的顺序相反。</p>
<p>总的来说，noexcept 让函数有了更多被优化的机会：</p>
<div class="highlight" id="id-142"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">RetType</span> <span class="nf">function</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// most optimizable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">RetType</span> <span class="nf">function</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="k">throw</span><span class="p">();</span>  <span class="c1">// less optimizable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">RetType</span> <span class="nf">function</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>          <span class="c1">// less optimizable
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>影响移动语义的使用</strong></p>
<p>对于 std::vector，当 size 和 capacity 相等时候，再为其添加一个元素（push_back）时候，std::vector 需要需要申请一个新的更大的内存块，再把原来内存块中的元素转移新的内存块中。</p>
<p>C++98 的做法是：通过拷贝来转移数据，它先将旧内存块中数据拷贝到新内存块中，再销毁旧的内存块。这种做法确保了 push_pack 能够提供异常安全保证：即使拷贝过程发生异常，std::vector 还能保持旧的数据。</p>
<p>C++11 中很容易想到的一个优化：通过 move 语义来完成数据转移。但是这可能违反 push_pack 提供的异常安全保证，假设移动过程中发生异常，std::vector 的部分数据已经移动出去了，反向再把数据移动回去是困难的，本身也会产生异常，std::vector 的数据无法恢复。</p>
<p>因此，C++11 中 std::vector::push_back 能否使用 move 语义优化，要看 move 操作是否可能抛出异常，如果 move 操作不会抛出异常，则可以用 move 进行优化。是否抛出异常当然就是检查是否为 noexcept。除了 std::vector::push_back 外，std::vector::reserve 和 std::deque::insert 等操作也是采用相同的策略。</p>
<p><strong>条件 noexcept</strong></p>
<p>swap 函数是很多 STL 算法的关键部分，并且经常被拷贝和赋值操作调用，noexcept 的优化对它相当有价值。值得注意的是：标准库的 swap 是否为 noexcept 往往取决于用户自定义的 swap 是否为 noexcept。标准库中，array 和 std::pair 的 swap 声明如下：</p>
<div class="highlight" id="id-143"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">          <span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">pair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">pair</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                              <span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些 swap 函数是条件 noexcept（conditionally noexcept）：它们是否为 noexcept 取决于noexcept 中的表达式是否为 noexcept。举个例子，两个 Widget 的数组，只有用 Widget 调用的swap 是 noexcept 时，用数组调用的 swap才是 noexcept。因此，只有低层次数据结构的 swap 是noexcept，才能使得高层次数据结构的 swap 是noexcept。这就鼓励你尽量提供 noexcept swap 函数。</p>
<p><strong>异常中立函数</strong></p>
<p>从上面介绍，我们可以知道，对于不会抛出异常的函数，最好声明为 noexcept。</p>
<p>事实上，很多函数是异常中立的（exception-neutral），这些函数本身不抛出异常，但是他们调用的函数可能会抛出异常。这种场景下，异常中立函数允许将异常通过调用链传给处理程序。异常中立的函数永远不是 noexcept，因为他们可能抛出“我只经过一下”的异常。因此，大部分函数都不适合设计为成 noexcept。</p>
<p>然而，一些函数天生就不抛出异常，并且对这些函数（特别是 move 操作和 swap 函数）成为noexcept 能获得很大的回报，只要有任何可能，将他们申明为 noexcept 是值得的。</p>
<p><strong>默认 noexcept 函数</strong></p>
<p>在 C++11 中，默认情况下，所有的内存释放函数和析构函数（包括用户自定义的和编译器自动生成的）都隐式成为 noexcept。因此，我们不需要把它们声明成 noexcept（可以但没必要）。</p>
<p>只有一种情况的析构函数不是隐式 noexcept ，就是当类中的一个成员变量的析构函数声明了它可能会抛出异常（比如，声明这个析构函数为“noexcept(false)”）。这样的声明是不寻常的，标准库中没有这样的情况。</p>
<p><strong>wide contract and narrow contract</strong></p>
<p>一些库的接口设计区分了宽接口（wide contract）和窄接口（narrow contract）。一个带宽接口的函数是没有前提条件的。这样的函数被调用时不需要关注程序的状态，传入的参数方面没有限制，宽接口的函数永远不会出现未定义的行为。不带宽接口条件的函数就是窄接口函数。对这些函数来说，如果传入的参数违反了前提条件，结果将是未定义的。</p>
<p>写一个宽接口的函数，并且你知道不会抛出一个异常，那就遵循本 Item 的建议，把它声明为noexcept。但对于窄接口的函数，情况将变得比较棘手。举个例子，假设一个函数 f，这个函数被传入一个 std::string 参数。假设有一个前提条件：std::string 参数的数据长度不会超过32个字节。如果用一个超过32字节的 std::string 传入 f，f 的行为将是未定义的。f 没有义务去检查这个前提条件，调用者有责任确保前提条件得到满足。因此，把 f 声明为 noexcept 似乎是合理的：</p>
<div class="highlight" id="id-144"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// precondition: s.length() &lt;= 32
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，当前提条件被违反了（例如系统测试时候），调用者捕捉一个抛出的异常总是比找出未定义行为的原因要简单很多。但是函数被申明成了 noexcept，无法抛出类似“前提条件被违反”的异常。因此，通常只为宽接口函数提供 noexcept 声明。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>noexcept 是函数接口的一部分，并且调用者可能会依赖这个接口。</li>
<li>相较于 non-noexcept 函数，noexcept 函数有被更好优化的机会。</li>
<li>noexcept 对于 move 操作、swap、内存释放函数和析构函数是非常有价值的。</li>
<li>大部分函数是异常中立的而不是 noexcept。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-15-use-constexpr-whenever-possiblehttpsblogcsdnnetdong_hfutarticledetails123172189"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123172189"target="_blank" rel="external nofollow noopener noreferrer">Item 15: Use constexpr whenever possible.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>constexpr 是 C++11 中令人非常非常困惑的一个新特性。从概念上讲，它不止表明一个对象是 const 的，而且是在编译时被知道的。把它用在对象上，可以理解成 const 的加强版。把它用在函数时，将拥有完全不同的涵义。</p>
<p><strong>constexpr 对象</strong></p>
<p>先从 constexpr 对象开始，这个对象是 const 的，也是在编译时被知道（准确的说，应该是在翻译阶段被知道，翻译阶段包括编译和链接两个阶段）。</p>
<p>对象的值在编译时知道是非常有用的。它能被存储在只读内存中，尤其是对一些嵌入式系统来说，这是一个相当重要的特性。更广泛的应用包括用于指定数组的大小、整形模板参数、枚举成员值、对齐说明符等。如果你希望用变量做这些事情，那么将他们申明为 constexpr，编译器会保证它们是在编译时可以被知道的值：</p>
<div class="highlight" id="id-145"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>                             <span class="c1">// non-constexpr variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">arraySize1</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>     <span class="c1">// error! sz&#39;s value not known at compilation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">sz</span><span class="o">&gt;</span> <span class="n">data1</span><span class="p">;</span>          <span class="c1">// error! same problem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">arraySize2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>     <span class="c1">// fine, 10 is a compile-time constant
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">arraySize2</span><span class="o">&gt;</span> <span class="n">data2</span><span class="p">;</span>  <span class="c1">// fine, arraySize2 is constexpr
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是 const 无法像 constexpr 一样保证值可以在编译时被知道，因为 const 对象不需要用一个编译时知道的值去初始化：</p>
<div class="highlight" id="id-146"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>                            <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="k">auto</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>        <span class="c1">// fine, arraySize is const copy of sz
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">arraySize</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>  <span class="c1">// error! arraySize&#39;s value not known at compilation
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>简单来说，所有的 constexpr 对象都是 const 的，但并非所有的 const 对象都是 constexpr 的。如果你希望编译器保证变量的值能够用在需要在编译时常量的上下文中时，那么你应该使用 constexpr 而不是 const。</p>
<p><strong>constexpr 函数</strong></p>
<p>当涉及到 constexpr 函数时，constexpr 对象的使用场景变得更加有趣。当使用编译时常量来调用 constexpr 函数时，它们产生编译时常量。当用来调用函数的值不能在运行时前得知时，它们产生运行时的值。完整的理解如下：</p>
<ul>
<li>constexpr 函数可以被使用在要求编译时常量的上下文中。如果所有传入 constexpr 函数的参数都能在编译时知道，那么结果将在编译时计算出来。如果有任何一个参数的值不能在编译时知道，你的代码将不能在编译时执行。</li>
<li>当 constexpr 函数调用参数有一个或多个不能在编译时知道值时，它就像一个正常的函数一样，在运行时计算它的值。这意味着你不需要两个函数来完成相同的操作，一个为编译时常量服务，一个为所有的其它值服务。constexpr 函数做了所有的事情。</li>
</ul>
<p>看下面的例子：</p>
<div class="highlight" id="id-147"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exp</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// pow&#39;s a constexpr func that never throws
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span> <span class="c1">// impl is below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">numConds</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>                <span class="c1">// # of conditions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">numConds</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>  <span class="c1">// results has 3^numConds elements
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>pow 前面的 constexpr 意味着如果 base 和 exp 是编译时常量，pow 的返回结果可以用作编译时常量。如果 base 或 exp 不是编译时常量，pow 的结果将在运行时计算。这意味着 pow 不仅能在编译时计算std::array的大小，它也可以在运行时这么调用：</p>
<div class="highlight" id="id-148"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">base</span> <span class="o">=</span> <span class="n">readFromDB</span><span class="p">(</span><span class="s">&#34;base&#34;</span><span class="p">);</span>    <span class="c1">// get these values at runtime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">readFromDB</span><span class="p">(</span><span class="s">&#34;exponent&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">baseToExp</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">);</span>  <span class="c1">// call pow function at runtime
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当用编译时值调用 constexpr 函数，则要求该函数能够返回一个编译时值。一些限制会影响 constexpr 函数的实现，C++11 和 C++14 的限制是不同的。</p>
<p>C++11中，constexpr 函数只能有一条 return 语句。可以通过一些手段来扩展 constexpr 的 return 语句。一个问号表达式，一个是递归：</p>
<div class="highlight" id="id-149"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exp</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">exp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">base</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>C++14 的限制则大幅减小，可以实现如下：</p>
<div class="highlight" id="id-150"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exp</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">exp</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">result</span> <span class="o">*=</span> <span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>constexpr 函数被限制只能接受和返回 literal 类型，本质上这个类型的值可以在编译时确定。在 C++11 中，除了 void 类型外的所有内置类型都是 literal 类型，用户自定义类型也可能是 literal 类型。因为构造函数和其他函数也可能是 constexpr 的：</p>
<div class="highlight" id="id-151"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">xVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">yVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">xVal</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">yVal</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">xValue</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">yValue</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">setX</span><span class="p">(</span><span class="kt">double</span> <span class="n">newX</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">newX</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">setY</span><span class="p">(</span><span class="kt">double</span> <span class="n">newY</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里， Point 的构造函数被申明为 constexpr，如果传入的值是在编译时知道的值，则 Point 的成员变量的值也能在编译时知道。因此，Point也能被初始化为 constexpr：</p>
<div class="highlight" id="id-152"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mf">9.4</span><span class="p">,</span> <span class="mf">27.7</span><span class="p">);</span> <span class="c1">// fine, &#34;runs&#34; constexpr ctor during compilation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p2</span><span class="p">(</span><span class="mf">28.8</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">);</span> <span class="c1">// also fine
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>类似的，getX 和 getY 也是 constexpr 的，他们的返回值也可以被用来构造 constexpr 对象：</p>
<div class="highlight" id="id-153"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span> <span class="nf">midpoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="p">{</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">xValue</span><span class="p">()</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">xValue</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>    <span class="c1">// call constexpr member funcs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">yValue</span><span class="p">()</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">yValue</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span> <span class="c1">// init constexpr object w/result of constexpr function
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这意味着以前运行时能做的工作和编译时能做的工作之间的界限变得模糊了，一些以前只能在运行时执行的运算现在可以提前到编译是来执行了。提前的代码越多，软件的性能越好。当然编译时间也会相应增加。</p>
<p>C++11中，有两个限制阻止 Point 的成员函数 setX 和 setY 无法成为 constexpr。</p>
<ul>
<li>第一，它们修改了操作的对象。但是在C++11中，constexpr 成员函数被隐式声明为 const。</li>
<li>第二，它们的返回值类型是 void，void 类型在C++11中不是 literal 类型。</li>
</ul>
<p>在 C++14 中，去掉了这两个限制。因此，C++14 的 Point类中的 setX 和 setY 可以成为 constexpr：</p>
<div class="highlight" id="id-154"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="kt">double</span> <span class="n">newX</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">newX</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">setY</span><span class="p">(</span><span class="kt">double</span> <span class="n">newY</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这让下面的代码成为可能：</p>
<div class="highlight" id="id-155"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// return reflection of p with respect to the origin (C++14)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">reflection</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// create non-const Point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">result</span><span class="p">.</span><span class="n">setX</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">.</span><span class="n">xValue</span><span class="p">());</span> <span class="c1">// set its x and y values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">result</span><span class="p">.</span><span class="n">setY</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">.</span><span class="n">yValue</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// return copy of it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用代码可能是这样的：</p>
<div class="highlight" id="id-156"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mf">9.4</span><span class="p">,</span> <span class="mf">27.7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p2</span><span class="p">(</span><span class="mf">28.8</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// reflectedMid&#39;s value is (-19.1 -16.5) and known during compilation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">reflectedMid</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此，通过上面的介绍，我们了解了为什么要尽可能地使用 constexpr 了。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>onstexpr 对象是 const 的，给它初始化的值需要在编译时知道。</li>
<li>如果使用在编译时就知道的参数来调用 constexpr 函数，它就能产生编译时的结果。</li>
<li>相较于 non-constexpr 对象和函数，constexpr 对象很函数能被用在更广泛的上下文中。</li>
<li>constexpr 是对象接口或函数接口的一部分。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-16-make-const-member-functions-thread-safehttpsblogcsdnnetdong_hfutarticledetails123316263"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123316263"target="_blank" rel="external nofollow noopener noreferrer">Item 16: Make const member functions thread safe.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p><strong>const 成员的好处</strong></p>
<p>一般地，对于不修改成员变量的函数申明为 const 类型，它隐含了是被传入的 this 指针为 const 类型。const 成员函数有两个好处：</p>
<ul>
<li>不会修改成员变量（有特例，下面会介绍），比较安全。</li>
<li>可以被 const 和 非 const 对象调用。非 const 成员变量无法被 const 对象调用。</li>
</ul>
<p>由于 const 成员函数一般不会修改成员变量，因此 const 成员函数一般也是线程安全的。</p>
<p><strong>const 成员函数的线程安全问题</strong></p>
<p>凡是皆有例外。</p>
<p>考虑这样一个场景：用一个类来表示多项式，并求解其根。求根的过程不会修改多项式本身，因此我们可以设计如下：</p>
<div class="highlight" id="id-157"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Polynomial</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">RootsType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="n">RootsType</span> <span class="n">roots</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 此处省略其实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从功能角度来说，上面的设计没有问题。但是，求解根的代价一般都比较高，我们一般不希望重复计算多次。因此，我们可以将多项式的根缓存起来，只在必要的时候才计算，可以修改如下：</p>
<div class="highlight" id="id-158"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Polynomial</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">RootsType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RootsType</span> <span class="nf">roots</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rootsAreValid</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// if cache not valid compute roots, store them in rootVals
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="err">…</span>
</span></span><span class="line"><span class="cl">      <span class="n">rootsAreValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rootVals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="kt">bool</span> <span class="n">rootsAreValid</span><span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">RootsType</span> <span class="n">rootVals</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从概念上说，求解根不会修改多项式本身。但是，缓存的行为又会修改多项式类的成员变量。经典的做法就是将成员变量申明为 mutable，成员函数申明为 const。</p>
<p>如果 const 成员函数不会被多个线程调用，那上述代码没有任何问题。</p>
<p>但是，当存在两以上的对象同时调用 const 成员变量，则会发生线程安全问题：这两个线程中的一个或两个都可能尝试去修改成员变量 rootsAreValid 和 rootVals。这意味着在没有同步的情况下，两个不同的线程读写同一段内存，这段代码会会有未定义的行为。</p>
<p><strong>const 成员函数线程安全保证</strong></p>
<p>很容易想到的解决办法是加 mutex：</p>
<div class="highlight" id="id-159"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Polynomial</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">RootsType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RootsType</span> <span class="nf">roots</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c1">// lock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rootsAreValid</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// if cache not valid, compute/store roots
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="err">…</span>
</span></span><span class="line"><span class="cl">      <span class="n">rootsAreValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rootVals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="c1">// unlock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="kt">bool</span> <span class="n">rootsAreValid</span><span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">RootsType</span> <span class="n">rootVals</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是，由于 std::mutex 是 move-only 类型，所以包含了 std::mutex 变量的 Polynomial 对象也是 move-only 类型，失去了 copy 的能力。</p>
<p>在有些情况下，使用 std::mutex 的代价可能是比昂贵的。如果你只需要同步单一变量或者内存单元，使用 std::atomic 是相对比较廉价的。举个例子，你只需要统计一个成员函数被调用的次数：</p>
<div class="highlight" id="id-160"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span> <span class="c1">// 2D point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">distanceFromOrigin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="c1">// see Item 14 for noexcept
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">callCount</span><span class="p">;</span> <span class="c1">// atomic increment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">callCount</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和 std::mutex 一样， std::atomic 也是 move-only 的。</p>
<p>虽然 std::atomic 的开销一般比 std::mutex 高，但对于多于一个变量或内存块需要同步，还是应该使用 std::mutex。因此，看你的需求，选择使用 std::mutex 或者 std::atomic 。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>让 const 成员函数做到线程安全，除非你确保它们永远不会用在多线程的环境下。</li>
<li>相比于 std::mutex，使用 std::atomic 变量能提供更好的性能，但是它只适合处理单一的变量或内存单元。</li>
<li>std::mutex 和 std::atomic 都是 move-only 的。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-17-understand-special-member-function-generationhttpsblogcsdnnetdong_hfutarticledetails123433559"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123433559"target="_blank" rel="external nofollow noopener noreferrer">Item 17: Understand special member function generation.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>在 C++ 中，对于某些特殊成员函数，如果我们没有申明，编译器会自动生成它们。</p>
<p>在 C++98 中，这些特殊成员函数包括默认构造函数、析构函数、拷贝构造函数、拷贝赋值操作。编译器生成这些构造函数的原则是：当你没有申明它们，并且需要使用到它们。编译器生成的这些特殊函数，并且一般是 public 、 inline 和 nonvirtual 的。派生类中的析构函数有点特殊，当这个派生类继承自 virtual 析构函数的基类，在这种情况下，派生类中，编译器生成的析构函数也是 virtual 的。</p>
<p>两个 copy 操作是独立的：声明一个不会阻止编译器生成另外一个。所以如果你声明了一个拷贝构造函数，但是没有声明拷贝赋值操作 ，然后你需要用到拷贝赋值，编译器将帮你生成一个拷贝赋值操作。类似的，如果你声明了一个拷贝赋值操作，但没有声明拷贝构造函数，然后你的代码需要拷贝构造，编译器将帮你生成一个拷贝构造函数。</p>
<p>你也许听过三法则（The Rule of Three）：如果你声明了任何一个拷贝构造函数，拷贝赋值操作或析构函数，那么你应该声明所有的这三个函数。三法则的建议来源于这样的：当拷贝构造、拷贝赋值或者析构函数不能胜任时候，往往是类要管理某些资源（通常是内存资源），当需要在拷贝中对资源进行管理，那么也需要在析构函数中对资源也进行管理（通常是释放内存），反之亦然。</p>
<p>在 C++11 中，多了两个特殊成员函数：移动构造函数和移动赋值操作：</p>
<div class="highlight" id="id-161"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>             <span class="c1">// move constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>  <span class="c1">// move assignment operator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>新增的两个 move 函数生成的规则也是类似的：当你没有申明，并且代码需要使用，编译器就会替你生成。看个例子：</p>
<div class="highlight" id="id-162"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">strA</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;=====hello====&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="n">s1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="n">s2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;=== s1.str = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;=== s2.str = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">===</span> <span class="n">s1</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="o">===</span> <span class="n">s2</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="o">=====</span><span class="n">hello</span><span class="o">====</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子，编译器就会自动生成 move 构造函数。</p>
<p>但是，实际上当我们对一个类使用移动构造的时候，编译器并不保证一定是移动构造，因为这个类并不一定具备移动语义，这时候会用拷贝来代替。看这个例子：</p>
<div class="highlight" id="id-163"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;====construction====&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span> <span class="n">b</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== a.p = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== b.p = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== *(a.p) = &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== *(b.p) = &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">====</span><span class="n">construction</span><span class="o">====</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="n">a</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="mh">0x1742c20</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="n">b</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="mh">0x1742c20</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的 A b(std::move(a)); 实际上是调用的编译器生成的拷贝构造函数。</p>
<p>两个 move 函数不是独立的：如果你声明了任何一个，那就阻止了编译器生成另外一个。也就是说，如果你声明了一个 move 构造函数，那就表明默认的 memberwise move 对这个类来说是不胜任的，那么编译器会认为 默认的 memberwise move 赋值函数也是不能胜任的。所以声明一个 move 构造函数会阻止一个move 复制操作函数被自动生成，声明一个 move 赋值操作函数会阻止一个 move 构造函数被自动生成。</p>
<p>另外，如果任何类显式地声明了一个 copy 操作，两个move 操作就不会被自动生成。这样做的理由是：声明一个 copy 操作表明了用默认的 memberwise copy 来拷贝对象对于这个类来说是不合适的，然后编译器认为，如果对于 copy 操作来说memberwise copy 不合适，那么对于 move 操作来说 memberwise move 很有可能也是不合适的。将上面第一个例子添加一个拷贝构造函数：</p>
<div class="highlight" id="id-164"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">strA</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;=====hello====&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="p">(</span><span class="k">const</span> <span class="n">strA</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;== copy construction ==&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="n">s1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="n">s2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;=== s1.str = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;=== s2.str = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">==</span> <span class="n">copy</span> <span class="n">construction</span> <span class="o">==</span>
</span></span><span class="line"><span class="cl"><span class="o">===</span> <span class="n">s1</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="o">=====</span><span class="n">hello</span><span class="o">====</span>
</span></span><span class="line"><span class="cl"><span class="o">===</span> <span class="n">s2</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子可以看到：定义了 copy 构造函数，阻止了编译器生成 move 构造函数。</p>
<p>三法则的一个结论是：当类中出现一个用户自定义的析构函数，则表示简单的 memberwise copy 可能不太适合 copy 操作。这反过来就建议：如果一个类声明了一个析构函数，copy 操作可能不应该被自动生成，因为它们可能将作出一些不正确的事。在 C++98 被采用的时候，这个原因的重要性没有被发现，所以在C++98中，用户自定义的析构函数的存在不会影响编译器生成 copy 操作。这种情况在 C++11 中还是存在的，但是这只是因为条件的限制（如果阻止 copy 操作的生成会破坏太多的遗留代码）。</p>
<p>但是，三法则背后的考量还是有效的，并且，结合之前的观察：copy 操作的声明阻止隐式 move 操作的生成。这使得在C++11 中，一个类中有一个用户自定义的析构函数时，则编译器不会生成 move 操作。</p>
<p>因此：只在下面三个条件为真的时候，编译器才为类生成 move 操作（当需要的时候）：</p>
<ul>
<li>没有 copy 操作在类中被声明。</li>
<li>没有 move 操作在类中被声明。</li>
<li>没有析构函数在类中被声明。</li>
</ul>
<p>并且，当用户自定义了 move 操作时候，编译器也会认为默认的 memberwise copy 也是不适合的，也会阻止两个 copy 函数被自动生成。</p>
<p>如果你想突破这些限制：用户自定义的 copy 构造函数阻止了编译器生成 move 构造函数，但是如果编译器生成的函数提供的行为是正确的，也就是说如果 memberwise move 就是你想要的，C++11的 “=default” 可以帮助你：</p>
<div class="highlight" id="id-165"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">strA</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;=====hello====&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="p">(</span><span class="k">const</span> <span class="n">strA</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;== copy construction ==&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="p">(</span><span class="n">strA</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="n">s1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">strA</span> <span class="n">s2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;=== s1.str = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;=== s2.str = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结果：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">===</span> <span class="n">s1</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="o">===</span> <span class="n">s2</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="o">=====</span><span class="n">hello</span><span class="o">====</span></span></span></code></pre></td></tr></table>
</div>
</div><p>总结 C++11 特殊成员函数生成的规则：
因此C++11对特殊成员函数的控制规则是这样的：</p>
<p><strong>默认构造函数：</strong></p>
<ul>
<li>和C++98中的规则一样，只在类中没有用户自定义的构造函数时生成。</li>
</ul>
<p><strong>析构函数：</strong></p>
<ul>
<li>本质上和 C++98 的规则一样;</li>
<li>唯一的不同就是析构函数默认声明为 noexcept（看Item 14）。</li>
<li>和 C++98 一样，只有基类的析构函数是 virtual 时，析构函数才会是 virtual。</li>
</ul>
<p><strong>拷贝构造函数：</strong></p>
<ul>
<li>和 C++98 一样的运行期行为：memberwise 拷贝构造 non-static 成员变量。</li>
<li>只在类中没有用户自定义拷贝构造函数时被生成。</li>
<li>如果类中声明了一个move操作，它就会被删除（声明为 delete ）。</li>
<li>在有用户自定义拷贝 operator= 或析构函数时，这个函数能被生成，但是这种生成方法是被弃用的。</li>
</ul>
<p><strong>拷贝赋值 operator= ：</strong>
和 C++98 一样的运行期行为：memberwise 拷贝赋值 on-static 成员变量。
只在类中没有用户自定义拷贝 operator= 时被生成。
如果类中声明了一个 move 操作，它就会被删除（声明为 delete ）。
在有用户自定义拷贝构造函数或析构函数时，这个函数能被生成，但是这种生成方法是被弃用的。</p>
<p><strong>move构造函数和move operator=：</strong></p>
<ul>
<li>每个都对 non-static 成员变量执行 memberwise move。</li>
<li>只有类中没有用户自定义拷贝操作、move 操作或析构函数时被生成。</li>
</ul>
<p>需要注意的是：关于成员函数模板的存在，没有规则规定它会阻止编译器生成特殊成员函数。</p>
<div class="highlight" id="id-166"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>即使这些 template 能实例化出拷贝构造函数和拷贝 operator= 的函数签名（就是 T 是 Widget 的情况），编译器仍然会为Widget 生成 copy 和 move 操作。Item 26 会解释这个边缘情况。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>特殊成员函数是那些编译器可能自己帮我们生成的函数：默认构造函数，析构函数，copy 操作，move 操作。</li>
<li>只有在类中没有显式声明的 move 操作，copy 操作和析构函数时，move 操作才被自动生成。</li>
<li>只有在类中没有显式声明的拷贝构造函数的时候，拷贝构造函数才被自动生成。只要存在 move 操作的声明，拷贝构造函数就会被删除（delete）。拷贝 operator= 和拷贝构造函数的情况类似。在有显式声明的 copy 操作或析构函数时，另一个 copy 操作能被生成，但是这种生成方法是被弃用的。</li>
<li>成员函数模板永远不会抑制特殊成员函数的生成。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="ch04-smart-pointers">CH04: Smart Pointers</h3>
<h4 id="item-18-use-stdunique_ptr-for-exclusive-ownership-resource-managementhttpsblogcsdnnetdong_hfutarticledetails123465058"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123465058"target="_blank" rel="external nofollow noopener noreferrer">Item 18: Use std::unique_ptr for exclusive-ownership resource management.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>原始指针非常灵活，但是使用陷阱多，容易出错，智能指针则更容易使用。本文介绍的智能指针是 std::unique_ptr。</p>
<p><strong>独占所有权</strong></p>
<p>std::unique_ptr 表现出独占所有权的语义。一个非空的 std::unique_ptr 总是对它指向的资源拥有独占所有权，它不共享它指向的资源给其他指针。因此，无法通过值传递 std::unique_ptr 给函数，也不允许复制 std::unique_ptr。看下面的例子，注意 std::make_unique 在 C++14 才开始支持，从报错信息也可以看到拷贝构造函数是 delete 的。</p>
<div class="highlight" id="id-167"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;memory&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pInt</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// std::unique_ptr&lt;int&gt; pInt = std::make_unique&lt;int&gt;(5);  // C++14 才支持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pInt1</span><span class="p">(</span><span class="n">pInt</span><span class="p">);</span>    <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 报错信息：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">&#39;</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span><span class="err">&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">36</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">use</span> <span class="n">of</span> <span class="n">deleted</span> <span class="n">function</span> <span class="err">&#39;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Dp</span><span class="o">&gt;::</span><span class="n">unique_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Dp</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="p">[</span><span class="n">with</span> <span class="n">_Tp</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span> <span class="n">_Dp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">default_delete</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">]</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="mi">8</span> <span class="o">|</span>     <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pInt1</span><span class="p">(</span><span class="n">pInt</span><span class="p">);</span>    <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">|</span>                                    <span class="o">^</span>
</span></span><span class="line"><span class="cl"><span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="n">from</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">c</span><span class="o">++/</span><span class="mf">11.2.0</span><span class="o">/</span><span class="nl">memory</span><span class="p">:</span><span class="mi">76</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">from</span> <span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">2</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">c</span><span class="o">++/</span><span class="mf">11.2.0</span><span class="o">/</span><span class="n">bits</span><span class="o">/</span><span class="n">unique_ptr</span><span class="p">.</span><span class="nl">h</span><span class="p">:</span><span class="mi">468</span><span class="o">:</span><span class="mi">7</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span> <span class="n">declared</span> <span class="n">here</span>
</span></span><span class="line"><span class="cl">  <span class="mi">468</span> <span class="o">|</span>       <span class="n">unique_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::unique_ptr 是 move-only 类型，可以 move 它的控制权，原 std::unique_ptr 则变为空指针。看下面的例子：</p>
<div class="highlight" id="id-168"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;memory&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pInt</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pInt2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pInt</span><span class="p">);</span>    <span class="c1">// 转移所有权
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// std::cout &lt;&lt; *pInt &lt;&lt; std::endl; // Segmentation fault (core dumped) ./a.out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pInt2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pInt3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pInt2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::unique_ptr 虽然不支持复制，但有个例外：可以从函数返回一个 std::unique_ptr。</p>
<div class="highlight" id="id-169"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;memory&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pInt</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pInt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>占用内存的大小</strong></p>
<p>相较于其他智能指针，std::unique_ptr 有一个优势：在不自定义删除器的情况下，std::unique_ptr 的内存占用几乎和原始指针一致。</p>
<div class="highlight" id="id-170"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;memory&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pu</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 输出：8:8
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::unique_ptr 内部几乎不用维护其他信息（<code>std::shared_ptr</code> 需要维护引用计数），当它离开作用域，是通过 delete 删除指向的资源。但是，如果自定义了删除器，则会增加内存占用。</p>
<div class="highlight" id="id-171"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;memory&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 带参数捕捉的lambda表达式，会导致unique_ptr占用内存变大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">delint</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;c = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;d = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;deleter&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delint</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">delint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 输出：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">24</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">deleter</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一个典型应用</strong></p>
<p>std::unique_ptr 的一个典型应用是作为一个工厂函数的返回类型（指向类层次中的对象）。这里直接使用这里的代码作为例子：</p>
<div class="highlight" id="id-172"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;memory&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*!
</span></span></span><span class="line"><span class="cl"><span class="cm"> * \brief The Investment class 基类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Investment</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Investment</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*!
</span></span></span><span class="line"><span class="cl"><span class="cm"> * \brief The Stock class 派生类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Stock</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Investment</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Stock doWork....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*!
</span></span></span><span class="line"><span class="cl"><span class="cm"> * \brief The Stock class 派生类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bond</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Investment</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Bond doWork....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">InvestType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">INVEST_TYPE_STOCK</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">INVEST_TYPE_BOND</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">makeInvestment</span><span class="p">(</span><span class="n">InvestType</span> <span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 自定义析构器, 这里以lambda表达式的形式给出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">delInvmt</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Investment</span> <span class="o">*</span><span class="n">pInvestment</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// TODO 自定义析构时想干的事
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;delInvmt called....&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">pInvestment</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 待返回的指针, 初始化为空指针，并指定自定义析构器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// decltype(delInvmt) 用于获取自定义析构器的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delInvmt</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pInv</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">delInvmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意这里用reset来指定pInv获取从new产生的对象的所有权, 不能用=赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">InvestType</span><span class="o">::</span><span class="nl">INVEST_TYPE_STOCK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//pInv = new Stock; // error!! c++11禁止从裸指针到智能指针的隐式转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pInv</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Stock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">InvestType</span><span class="o">::</span><span class="nl">INVEST_TYPE_BOND</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">pInv</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Bond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">pInv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 测试工厂函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// pInv出作用域后会自己析构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">pInv</span> <span class="o">=</span> <span class="n">makeInvestment</span><span class="p">(</span><span class="n">InvestType</span><span class="o">::</span><span class="n">INVEST_TYPE_STOCK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pInv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">pInv</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;----------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 测试move效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">pInv</span> <span class="o">=</span> <span class="n">makeInvestment</span><span class="p">(</span><span class="n">InvestType</span><span class="o">::</span><span class="n">INVEST_TYPE_BOND</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">pInv2</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">pInv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;after move pInv to pInv2 </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pInv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pInv is empty </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pInv2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pInv2 is valid </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pInv2</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;----------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 测试unique_ptr向shared_ptr转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="o">&gt;</span> <span class="n">pInv</span> <span class="o">=</span> <span class="n">makeInvestment</span><span class="p">(</span><span class="n">InvestType</span><span class="o">::</span><span class="n">INVEST_TYPE_BOND</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pInv</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 输出：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Stock</span> <span class="n">doWork</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="n">delInvmt</span> <span class="n">called</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="o">----------------</span>
</span></span><span class="line"><span class="cl"><span class="n">after</span> <span class="n">move</span> <span class="n">pInv</span> <span class="n">to</span> <span class="n">pInv2</span>
</span></span><span class="line"><span class="cl"><span class="n">pInv</span> <span class="n">is</span> <span class="n">empty</span>
</span></span><span class="line"><span class="cl"><span class="n">pInv2</span> <span class="n">is</span> <span class="n">valid</span>
</span></span><span class="line"><span class="cl"><span class="n">Bond</span> <span class="n">doWork</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="n">delInvmt</span> <span class="n">called</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="o">----------------</span>
</span></span><span class="line"><span class="cl"><span class="n">Bond</span> <span class="n">doWork</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="n">delInvmt</span> <span class="n">called</span><span class="p">....</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>杂项</strong></p>
<p>std::unique_ptr 通过 std::unique_ptr&lt;T[]&gt; 形式支持指向数组，并通过 delete [] 释放资源。</p>
<div class="highlight" id="id-173"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;memory&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 重载了operator[]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::unique_ptr 可以直接隐式转换为 <code>std::shared_ptr</code>。</p>
<div class="highlight" id="id-174"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Investment</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span>   <span class="c1">// converts std::unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">makeInvestment</span><span class="p">(</span> <span class="n">arguments</span> <span class="p">);</span>     <span class="c1">// to `std::shared_ptr`
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>std::unique_ptr 是一个小的、快的、move-only 的智能指针，它能用来管理资源，并且独占资源的所有权。</li>
<li>默认情况下，std::unique_ptr 资源的销毁是用 delete 进行的，但也可以用户自定义 deleter。用带状态的 deleter 和函数指针作为 deleter 会增加 std::unique_ptr 对象的大小。</li>
<li>很容易将 std::unique_ptr 转换为 <code>std::shared_ptr</code>。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-19-use-stdshared_ptr-for-shared-ownership-resource-managementhttpsblogcsdnnetdong_hfutarticledetails123599599"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123599599"target="_blank" rel="external nofollow noopener noreferrer">Item 19: Use <code>std::shared_ptr</code> for shared-ownership resource management.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>上文中介绍了 std::unique_ptr ，它对指向的资源拥有独占所有权。本文介绍一种新的智能指针：<code>std::shared_ptr</code>，它和其他指向该资源的指针有共享所有权，它可以拷贝和传递，并且通过引用计数来管理资源的生命周期。</p>
<p></p>
<p><code>std::shared_ptr</code> 的模型如上图所示：它包含两个指针，一个指向对象的原始指针和一个指向控制块的原始指针。所以 <code>std::shared_ptr</code> 的内存占用总是原始指针的两倍。</p>
<p><strong>引用计数</strong></p>
<p><code>std::shared_ptr</code> 是通过共享所有权的语义来管理对象的生命周期。对于指向该对象的所有 <code>std::shared_ptr</code>，它们都不独占这个对象，它们合作来管理这个对象的生命周期：当最后一个指向对象的 <code>std::shared_ptr</code> 不再指向这个对象（比如，<code>std::shared_ptr</code> 被销毁了或者指向了别的对象），<code>std::shared_ptr</code> 会销毁它指向的对象。</p>
<p><code>std::shared_ptr</code> 实际是通控制块的引用计数（reference counter）来管理对象的生命周期。一个 <code>std::shared_ptr</code> 可以通过查看引用计数知道有多少个 <code>std::shared_ptr</code> 指向该对象。引用计数更新如下：</p>
<ul>
<li><code>std::shared_ptr</code> 的构造函数会通常增加引用计数。但是对于 move 构造函数：从一个<code>std::shared_ptr</code> 移动构造一个<code>std::shared_ptr</code> 会将源 <code>std::shared_ptr</code> 设置为 nullptr，源 <code>std::shared_ptr</code> 不再指向资源，并且新的 <code>std::shared_ptr</code> 开始指向资源。所以，它不需要维护引用计数。</li>
<li><code>std::shared_ptr</code> 的析构函数会减少引用计数。</li>
<li>拷贝 operator= 既增加也减少引用计数：如果 sp1 和 sp2 是指向不同对象的 <code>std::shared_ptr</code>，赋值操作 “sp1 = sp2” 会修改 sp1 来让它指向 sp2 指向的对象。这个赋值操作的效果就是：原本被 sp1 指向的对象的引用计数减一，同时被 sp2 指向的对象的引用计数加一。</li>
</ul>
<p>如果一个<code>std::shared_ptr</code> 查询到一个引用计数在一次自减后变成 0 了，这就意味着没有别的 <code>std::shared_ptr</code> 指向这个资源了，所以 <code>std::shared_ptr</code> 就会销毁这个资源。</p>
<div class="highlight" id="id-175"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== p1.use_count() = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== p2.use_count() = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p4</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== p3.use_count() = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== p2.use_count() = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p4</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== p3.use_count() = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;==== p2.use_count() = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">====</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="n">p2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="n">p3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="n">p2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="n">p3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">====</span> <span class="n">p2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1</span></span></span></code></pre></td></tr></table>
</div>
</div><p>另外，为了保证多线程安全，引用计数的增加和减少操作必须是原子操作。</p>
<p><strong>自定义deleter</strong></p>
<p>上一篇文章介绍过 <code>std::unique_ptr</code> 可以自定义 <code>deleter</code>，并且会增加 <code>std::unique_ptr</code> 占用内存大小。<code>std::shared_ptr</code> 默认也使用 delete 来销毁资源，也支持自定义 <code>deleter</code>，但是其实现机制和 <code>std::unique_ptr</code> 不同。<code>std::unique_ptr</code> 的 <code>deleter</code> 是智能指针的一部分，但是对于 <code>std::shared_ptr</code> 并非如此，它的 <code>deleter</code> 是属于 control block，因此 <code>std::shared_ptr</code> 占用内存大小不会因为自定义 <code>deleter</code> 而改变。</p>
<div class="highlight" id="id-176"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">loggingDel</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Widget</span> <span class="o">*</span><span class="n">pw</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				  <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">makeLogEntry</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">					<span class="k">delete</span> <span class="n">pw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">loggingDel</span><span class="p">)</span><span class="o">&gt;</span> <span class="c1">// deleter type is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">upw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>                <span class="c1">// part of ptr type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span>         <span class="c1">// deleter type is not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>  <span class="c1">// part of ptr type
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::shared_ptr</code> 这样的设计更加灵活。看下面的例子：</p>
<div class="highlight" id="id-177"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">customDeleter1</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Widget</span> <span class="o">*</span><span class="n">pw</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span> <span class="c1">// custom deleters,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">customDeleter2</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Widget</span> <span class="o">*</span><span class="n">pw</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span> <span class="c1">// each with a different type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw1</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">customDeleter1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">customDeleter2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="n">vpw</span><span class="p">{</span> <span class="n">pw1</span><span class="p">,</span> <span class="n">pw2</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>pw1 和 pw2 具有相同的类型，可以放到一个容器中。它们能互相赋值，并且它们都能被传给一个函数作为参数，只要这个函数的参数是<code>std::shared_ptr</code>类型。但是对于有自定义 <code>deleter</code> 的两个 <code>std::unique_ptr</code>，因为类型不同，无法做到这些功能。</p>
<p><strong>控制块</strong></p>
<p>上面介绍的引用计数和自定义 deleter 都是存在 <code>std::shared_ptr</code> 指向的控制块中。一个对象的控制块应该被指向这个对象的第一个 <code>std::shared_ptr</code>创建。通常，一个创建 <code>std::shared_ptr</code> 的函数不可能知道是否有其他 <code>std::shared_ptr</code> 已经指向这个对象，所以控制块的创建需要遵循以下规则：</p>
<ul>
<li>std::make_shared 总是创建一个控制块，它制造一个新对象，所以当 std::make_shared 被调用的时，这个对象没有控制块。
当一个 <code>std::shared_ptr</code> 的构造来自一个独占所有权的智能指针（<code>std::unique_ptr</code> 或 <code>std::auto_ptr</code>）时，创造一个控制块。独占所有权的指针不使用控制块，所以原来的被指向的对象没有控制块。</li>
<li>当使用一个原始指针构造 <code>std::shared_ptr</code> 时，它创造一个控制块。如果你想使用一个已有控制块的对象来创建一个<code>std::shared_ptr</code> 的话，你可以传入一个 <code>std::shared_ptr</code> 或一个 <code>std::weak_ptr</code> 作为构造函数的参数，但不能传入一个原始指针。使用 <code>std::shared_ptr</code> 或 <code>std::weak_ptr</code> 作为构造函数的参数不会创建一个新的控制块，因为它们能依赖传入的智能指针来指向必要的控制块。</li>
</ul>
<p>这些规则产生一个结果：用一个原始指针来构造超过一个的 <code>std::shared_ptr</code> 的对象时，会让这个对象拥有多个控制块。</p>
<div class="highlight" id="id-178"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">pw</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">spw1</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">spw2</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用原始指针变量作为 <code>std::shared_ptr</code> 构造函数的参数时，有一个特别让人惊奇的方式（涉及到 this 指针）会产生多个控制块。</p>
<div class="highlight" id="id-179"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">processedWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">process</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">process</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">processedWidget</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>   <span class="c1">// add it to list of processed Widgets; this is wrong!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码能编译，但是它传入一个原始指针（this）给一个 <code>std::shared_ptr</code> 的容器。因此 <code>std::shared_ptr</code> 的构造函数将为它指向的 Widget（*this）创建一个新的控制块。但是，如果在成员函数外面已经有 <code>std::shared_ptr</code> 指向这个 Widget，则会导致资源的 double free。例如如下代码：</p>
<div class="highlight" id="id-180"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">w</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你的类被 <code>std::shared_ptr</code> 管理，你可以继承 std::enable_shared_from_this，这样就能用this指针安全地创建一个<code>std::shared_ptr</code>。</p>
<div class="highlight" id="id-181"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="n">processedWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">loggingDel</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Widget</span> <span class="o">*</span><span class="n">pw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">pw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">process</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">process</span><span class="p">()</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">processedWidget</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">loggingDel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">w</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在使用 shared_from_this 返回 this 指针的 <code>std::shared_ptr</code> 的时候 shared_from_this 会先搜索当前对象的控制块，如果有就不会再创建控制块了。所以以上代码就不会产生 double free 的问题了。</p>
<p>但是，这个设计依赖于当前的对象已经有一个相关联的控制块了。也就是说，必须已经有一个 <code>std::shared_ptr</code> 指向当前的对象。如果没有，shared_from_this 也会抛出异常，它的行为还将是未定义的。</p>
<p>为了防止用户在一个 <code>std::shared_ptr</code> 指向这个对象前，调用成员函数（这个成员函数调用了 shared_from_this），继承自std::enable_shared_from_this 的类通常将它们的构造函数为申明为 private，并且让用户通过调用一个返回 <code>std::shared_ptr</code> 的工厂函数来创建对象。</p>
<div class="highlight" id="id-182"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// factory function that perfect-forwards args
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to a private ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">process</span><span class="p">();</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>     <span class="c1">// ctors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此外，<code>std::shared_ptr</code> 另外一个和 std::unique_ptr 不同的地方是：<code>std::shared_ptr</code> 的 API 被设计为只能作为单一对象的指针。没有 <code>std::shared_ptr</code>&lt;T[]&gt;，但是使用 std::array，std::vector 和 std::string 可以满足这样的需求。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li><code>std::shared_ptr</code> 为任意共享所有权的资源提供一种自动垃圾回收的便捷方式。</li>
<li>较之于 std::unique_ptr，<code>std::shared_ptr</code> 对象占用的内存通常大两倍，控制块会产生开销，需要原子引用计数修改操作。</li>
<li>默认资源销毁是通过 delete，但是也支持自定义 deleter。自定义 deleter 的类型对 <code>std::shared_ptr</code> 的类型没有影响。</li>
<li>避免从原始指针变量上创建 <code>std::shared_ptr</code>。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-20-use-stdweak_ptr-for-stdshared_ptr-like-pointers-that-can-danglehttpsblogcsdnnetdong_hfutarticledetails123612236"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123612236"target="_blank" rel="external nofollow noopener noreferrer">Item 20: Use std::weak_ptr for <code>std::shared_ptr</code> like pointers that can dangle.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p><strong>std::weak_ptr 的特点</strong></p>
<p>std::weak_ptr 通常不会单独使用，一般是与 <code>std::shared_ptr</code> 搭配使用，可以将 std::weak_ptr 类型指针视为 <code>std::shared_ptr</code> 指针的一种辅助工具，借用 std::weak_ptr 类型指针， 可以获取 <code>std::shared_ptr</code> 指针的一些状态信息，例如有多少 <code>std::shared_ptr</code> 指针指向相同的资源、<code>std::shared_ptr</code> 指针指向的内存是否已经被释放等。</p>
<p>std::weak_ptr 常常是通过 <code>std::shared_ptr</code> 构造而来，它和 std::shard_ptr 指向的相同的位置。但是，std::weak_ptr 不会影响对象的引用计数，也就是说，std::weak_ptr 被创建时，引用计数不会增加，当它被释放时，引用计数也不会减少。</p>
<div class="highlight" id="id-183"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">spw</span> <span class="o">=</span>                     <span class="c1">// after spw is constructed, the pointed-to Widget&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// ref count (RC) is 1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">wpw</span><span class="p">(</span><span class="n">spw</span><span class="p">);</span> <span class="c1">// wpw points to same Widget as spw. RC remains 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="n">spw</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// RC goes to 0, and the Widget is destroyed. wpw now dangles
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">wpw</span><span class="p">.</span><span class="n">expired</span><span class="p">())</span> <span class="err">…</span> <span class="c1">// if wpw doesn&#39;t point to an object…
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::weak_ptr 没有解引用操作，但可以将它转换为 <code>std::shared_ptr</code>，使用 lock 可以保证线程安全。</p>
<div class="highlight" id="id-184"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw1</span> <span class="o">=</span> <span class="n">wpw</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// if wpw&#39;s expired, spw1 is null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">spw2</span> <span class="o">=</span> <span class="n">wpw</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// same as above, but uses auto
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw3</span><span class="p">(</span><span class="n">wpw</span><span class="p">);</span> <span class="c1">// if wpw&#39;s expired, throw std::bad_weak_ptr
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>std::weak_ptr 的典型应用</strong></p>
<p>下面介绍 std::weak_ptr 的两个典型应用，其实本质上就是利用了 std::weak_ptr 的特点：<strong>共享资源所有权，但又不增加其引用计数。</strong></p>
<p><font color=red>循环引用</font></p>
<p>std::weak_ptr 的一个典型应用是解决 <code>std::shared_ptr</code> 的内存泄露问题&mdash;-循环引用。看下面的代码：</p>
<div class="highlight" id="id-185"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A constructor&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A destructor&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;B constructor&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;B&#39;s destructor&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">aa</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// aa 引用计数为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// bb 引用计数为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">aa</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">bb</span><span class="p">;</span><span class="c1">// bb 引用计数为 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">bb</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="n">aa</span><span class="p">;</span><span class="c1">// aa 引用计数为 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">A</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span> <span class="n">constructor</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从运行结果可以看到 A 和 B 都调用了构造函数，却没有调用析构函数，导致了资源泄露。原因是 main 函数结束后，两个对象的引用计数都为 1 ，导致 <code>std::shared_ptr</code> 没有调用析构函数。解决办法是将 A 和 B 对象中 shared_ptr 换成 weak_ptr 即可。</p>
<p><font color=red>带缓存的工厂方法</font></p>
<p>当调用工厂方法的代价比较高时，可以通过增加缓存来优化。但是把所有对象都缓存下来会造成效率问题，当对象不再使用时，可以销毁其缓存。</p>
<p>示例代码参考这里:</p>
<div class="highlight" id="id-186"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*!
</span></span></span><span class="line"><span class="cl"><span class="cm"> * \brief The Investment class 基类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Investment</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Investment</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*!
</span></span></span><span class="line"><span class="cl"><span class="cm"> * \brief The Stock class 派生类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Stock</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Investment</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Stock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;~Stock() called....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Stock doWork....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*!
</span></span></span><span class="line"><span class="cl"><span class="cm"> * \brief The Stock class 派生类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bond</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Investment</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Bond</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;~Bond() called....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doWork</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Bond doWork....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">InvestType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">INVEST_TYPE_STOCK</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">INVEST_TYPE_BOND</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 工厂函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">makeInvestment</span><span class="p">(</span><span class="n">InvestType</span> <span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 自定义析构器, 这里以lambda表达式的形式给出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">delInvmt</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Investment</span> <span class="o">*</span><span class="n">pInvestment</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;custom delInvmt called....&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pInvestment</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意：pInvestment可能为空指针，比如默认为空，然后调用reset赋值时，会先调用一遍析构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pInvestment</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// TODO 自定义析构时想干的事
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">delete</span> <span class="n">pInvestment</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 待返回的指针, 初始化为空指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="o">&gt;</span> <span class="n">pInv</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意这里用reset来指定pInv获取从new产生的对象的所有权, 不能用=赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">InvestType</span><span class="o">::</span><span class="nl">INVEST_TYPE_STOCK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意：自定义析构器是随对象一起指定的，这里区别于unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pInv</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Stock</span><span class="p">,</span> <span class="n">delInvmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">InvestType</span><span class="o">::</span><span class="nl">INVEST_TYPE_BOND</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果不指定自定义析构器的话，则不会调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pInv</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Bond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">pInv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 带缓存的工厂函数
</span></span></span><span class="line"><span class="cl"><span class="c1">// 使用场景：当调用工厂函数makeInvestment成本高昂(e.g. 会执行一些文件或数据块的I/O操作), 并且type会频繁的重复调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="o">&gt;</span> <span class="n">fastLoadInvestment</span><span class="p">(</span><span class="n">InvestType</span> <span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义一个做缓存的容器，注意这里存的内容是weak_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用weak_ptr的好处是，它不会影响所指涉对象的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果这里改为shared_ptr的话，则函数外边永远不会析构掉这个对象, 因为缓存中至少保证其引用计数为1。这就背离的我们的设计
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">InvestType</span><span class="p">,</span> <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="o">&gt;&gt;</span> <span class="n">s_cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将weak_ptr生成shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">pInv</span> <span class="o">=</span> <span class="n">s_cache</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果缓存中没有的话，则调用工厂函数创建一个新对象，并且加入到缓存中去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pInv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;create new investment..</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pInv</span> <span class="o">=</span> <span class="n">makeInvestment</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">s_cache</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">pInv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pInv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">pInv</span> <span class="o">=</span> <span class="n">fastLoadInvestment</span><span class="p">(</span><span class="n">InvestType</span><span class="o">::</span><span class="n">INVEST_TYPE_BOND</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pInv</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-------------------------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">pInv</span> <span class="o">=</span> <span class="n">fastLoadInvestment</span><span class="p">(</span><span class="n">InvestType</span><span class="o">::</span><span class="n">INVEST_TYPE_BOND</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pInv</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-------------------------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">pInv</span> <span class="o">=</span> <span class="n">fastLoadInvestment</span><span class="p">(</span><span class="n">InvestType</span><span class="o">::</span><span class="n">INVEST_TYPE_STOCK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pInv</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">pInv2</span> <span class="o">=</span> <span class="n">fastLoadInvestment</span><span class="p">(</span><span class="n">InvestType</span><span class="o">::</span><span class="n">INVEST_TYPE_STOCK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pInv2</span><span class="o">-&gt;</span><span class="n">doWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">create</span> <span class="k">new</span> <span class="n">investment</span><span class="p">..</span>
</span></span><span class="line"><span class="cl"><span class="n">Bond</span> <span class="n">doWork</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">Bond</span><span class="p">()</span> <span class="n">called</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="o">-------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="n">create</span> <span class="k">new</span> <span class="n">investment</span><span class="p">..</span>
</span></span><span class="line"><span class="cl"><span class="n">Bond</span> <span class="n">doWork</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">Bond</span><span class="p">()</span> <span class="n">called</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="o">-------------------------------</span>
</span></span><span class="line"><span class="cl"><span class="n">create</span> <span class="k">new</span> <span class="n">investment</span><span class="p">..</span>
</span></span><span class="line"><span class="cl"><span class="n">Stock</span> <span class="n">doWork</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="n">Stock</span> <span class="n">doWork</span><span class="p">....</span>
</span></span><span class="line"><span class="cl"><span class="n">custom</span> <span class="n">delInvmt</span> <span class="n">called</span><span class="p">...</span><span class="mf">.0</span><span class="n">x1258cd0</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">Stock</span><span class="p">()</span> <span class="n">called</span><span class="p">....</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对象的缓存管理器需要一个类似 <code>std::shared_ptr</code> 的指针，但又想这些对象的生存期可以由调用者来管理来管理，因而使用 std::weak_ptr 可以满足这种需求。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>对类似 <code>std::shared_ptr</code> 可能悬空的指针，使用 std::weak_ptr。</li>
<li>std::weak_ptr 的潜在使用场景包括：caching、observer lists、避免 <code>std::shared_ptr</code> 的循环引用。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-21-prefer-stdmake_unique-and-stdmake_shared-to-direct-use-of-newhttpsblogcsdnnetdong_hfutarticledetails123622543"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123622543"target="_blank" rel="external nofollow noopener noreferrer">Item 21: Prefer std::make_unique and std::make_shared to direct use of new.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>std::make_shared 是 C++11 开始支持的，但是 std::make_unique 是 C++14 才开始支持。如果你的编译器只支持 C++11，你可以实现自己的 make_unique。</p>
<div class="highlight" id="id-187"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::make_unique 和 std::make_shared 是三个 make 函数中的两个，第三个 make 函数是 std::allocate_shared。它的行为和std::make_shared 一样，唯一的不同是它的第一个参数是一个分配器（allocator）对象，这个对象是用来动态申请内存的。make 函数能传入任意集合的参数，然后完美转发给构造函数，并动态创建一个对象，然后返回指向这个对象的智能指针。</p>
<p>创建智能指针有两种方式，一种是使用 make 函数，另一种是使用 new 直接创建。下面介绍二者的优缺点，并建议尽可能使用 make 函数。</p>
<p><strong>make 函数的优点</strong></p>
<p><font color=red>支持 auto</font></p>
<div class="highlight" id="id-188"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">upw1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>       <span class="c1">// with make func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">upw2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>    <span class="c1">// without make func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">spw1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>       <span class="c1">// with make func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>    <span class="c1">// without make func
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 make 函数的第一个优点是支持 auto，避免重复代码，使得代码更加清晰好维护。</p>
<p><font color=red>避免异常</font></p>
<p>使用 make 函数的第二个优点跟异常安全有关。先看下面这个例子：</p>
<div class="highlight" id="id-189"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">processWidget</span><span class="p">(</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>  <span class="c1">// declare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">processWidget</span><span class="p">(</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span> <span class="n">computePriority</span><span class="p">());</span>  <span class="c1">// potential resource leak!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">computePriority</span><span class="p">());</span>           <span class="c1">// no potential resource leak
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用 new，processWidget 调用时，产生如下步骤：</p>
<ul>
<li>执行 new Widget</li>
<li>执行 <code>std::shared_ptr</code> 的构造</li>
<li>执行 computePriority()</li>
</ul>
<p>但是，编译器可能不一定产生上述代码顺序。new Widget 肯定时要在 <code>std::shared_ptr</code> 的构造函数之前执行，但 computePriority() 可能在这两个步骤的前、中或后产生，可能时这样：</p>
<ul>
<li>执行 new Widget</li>
<li>执行 computePriority()</li>
<li>执行 <code>std::shared_ptr</code> 的构造</li>
</ul>
<p>如果 computePriority() 产生异常，第一步 new 的 Widget 还未被 <code>std::shared_ptr</code> 接管，会产生内存泄漏。使用 make 函数则不会有这样的问题。</p>
<p><font color=red>效率更高</font></p>
<p>使用 make 函数的第三个优点是可以避免多次内存分配、效率更高。</p>
<div class="highlight" id="id-190"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">spw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 new，需要分配两次内存，一次分配 Widget 的内存，一次分配控制块的内存。若使用 make 函数，则只需要分配一次内存块，make 函数（<code>std::shared_ptr</code> 和 std::allocate_shared）会申请一块内存同时存储 Widget 和控制块。</p>
<p><strong>make函数的缺陷</strong></p>
<p>上面介绍了 make 函数的优点，下面介绍 make 函数的缺陷。</p>
<p><font color=red>无法自定义 deleter</font></p>
<p>使用 new，可以自定义 deleter，但是 make 函数无法做到。</p>
<div class="highlight" id="id-191"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">widgetDeleter</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Widget</span><span class="o">*</span> <span class="n">pw</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">widgetDeleter</span><span class="p">)</span><span class="o">&gt;</span>  <span class="n">upw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">widgetDeleter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">widgetDeleter</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red>语义歧义</font></p>
<p>对于 std::vector，支持使用圆括号和花括号两种初始化方法：</p>
<div class="highlight" id="id-192"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>   <span class="c1">// 10 elements, every element is 20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>  <span class="c1">// two elements: 10 and 20
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，make 函数不支持花括号的形式。原因是圆括号支持完美转发，花括号不支持完美转发，使用 make 函数可以完美转发圆括号。如果你想使用花括号进行初始化，只能使用 new。</p>
<div class="highlight" id="id-193"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">sp1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，Item 30 将会给出一个变通方案：使用auto类型推导来从初始化列表创建一个 std::initializer_list 对象，然后传入 auto 创建的对象给 make 函数：</p>
<div class="highlight" id="id-194"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// create std::initializer_list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">initList</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// create std::vector using std::initializer_list ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">spv</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">initList</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red>延长对象销毁时间</font></p>
<p>对于 make_shared_ptr ，它是申请一块内存块，用于储存对象和控制块。我们知道，创建 shared_ptr 时候会附属产生 weak_ptr, 它也有一个引用计数（weak 计数）存储在控制块中。</p>
<p>std::weak_ptr 是通过检查控制块中的引用计数（非 weak counter）判断自己是否失效。如果引用计数为 0，则 weak_ptr 失效，否则未失效。但是，只有 weak counter 不为 0，整个控制块就必须存在，那么 shared_ptr 指向的对象也不能释放。如果对象类型很大，并且最后一个 std::shared_pt r和最后一个 std::weak_ptr 销毁的间隔很大，那么一个对象销毁将延迟到最后才能释放。</p>
<div class="highlight" id="id-195"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ReallyBigType</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">pBigObj</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ReallyBigType</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// create very large object via std::make_shared
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>    <span class="c1">// create `std::shared_ptr`s and std::weak_ptrs to large object, use them to work with it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>    <span class="c1">// final `std::shared_ptr` to object destroyed here, but std::weak_ptrs to it remain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>    <span class="c1">// during this period, memory formerly occupied by large object remains allocated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>    <span class="c1">// final std::weak_ptr to object destroyed here;  memory for control block and object is released
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用 new，因为是两块内存块，只要最后一个指向 ReallyBigType 对象的 <code>std::shared_ptr</code> 销毁了，这个对象的内存就能被释放：</p>
<div class="highlight" id="id-196"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ReallyBigType</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span> <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">ReallyBigType</span><span class="o">&gt;</span> <span class="n">pBigObj</span><span class="p">(</span><span class="k">new</span> <span class="n">ReallyBigType</span><span class="p">);</span>  <span class="c1">// create very large object via new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">…</span> <span class="c1">// as before, create `std::shared_ptr`s and std::weak_ptrs to object, use them with it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">…</span> <span class="c1">// final `std::shared_ptr` to object destroyed here, but std::weak_ptrs to it remain; memory for object is deallocated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">…</span> <span class="c1">// during this period, only memory for the control block remains allocated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">…</span> <span class="c1">// final std::weak_ptr to object destroyed here; memory for control block is released
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一个 trick</strong>
讲完 make 的优缺点，我们回顾下上面说过的一个使用 new 可能导致内存泄漏的问题：</p>
<div class="highlight" id="id-197"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">processWidget</span><span class="p">(</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">cusDel</span><span class="p">(</span><span class="n">Widget</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// custom deleter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">processWidget</span><span class="p">(</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">cusDel</span><span class="p">),</span>    <span class="c1">// potential resource leak!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">computePriority</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果修改如下：</p>
<div class="highlight" id="id-198"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">cusDel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">processWidget</span><span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">computePriority</span><span class="p">());</span>  <span class="c1">// correct, but not optimal; see below
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样可以避免内存泄漏，但是效率不高。可能存在异常泄漏的版本，我们传递给 processWidget 的是一个右值，而上面这个安全版本传递的是左值。传递右值只需要 move，而传递左值必须要拷贝，拷贝一个 <code>std::shared_ptr</code> 要求对它的引用计数进行一个原子的自增操作，但是 move 一个 <code>std::shared_ptr</code> 不需要修改引用计数。因此，上面的安全版本可以通过 move 来优化：</p>
<div class="highlight" id="id-199"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">cusDel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span>  <span class="n">computePriority</span><span class="p">());</span> <span class="c1">// both efficient and exception safe
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样，使用 new，既安全又没有性能损失，并且还支持自定义 deleter。</p>
<p>最后，还是建议优先使用 make 函数，除非你有特殊的原因。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>和直接使用 new 相比，make 函数消除了代码重复、提高了异常安全性。对于 std::make_shared和 std::allocate_shared，生成的代码更小更快。</li>
<li>不适合使用 make 函数的情况包括需要指定自定义删除器和希望用大括号初始化。</li>
<li>对于<code>std::shared_ptr</code>s, make函数可能不被建议的其他情况包括 (1)有自定义内存管理的类和 (2)特别关注内存的系统、非常大的对象，以及 std::weak_ptrs 比对应的 <code>std::shared_ptr</code>s 存在的时间更长。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-22-when-using-the-pimpl-idiom-define-special-member-functions-in-the-implementation-filehttpsblogcsdnnetdong_hfutarticledetails123704824"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123704824"target="_blank" rel="external nofollow noopener noreferrer">Item 22: When using the Pimpl Idiom, define special member functions in the implementation file.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>这部分介绍一个智能指针的应用场景：PImpl技术，俗称编译防火墙。</p>
<p><strong>PImpl 技术（编译防火墙）</strong></p>
<p>PImpl（Pointer to implementation）是一种 C++ 惯用技术，它是通过将类的具体实现放在另一个单独的类（或结构体）中，并通过不透明的指针进行访问。该技术能够将具体的实现细节从对象中去除，能够有效地减少编译依赖。也被称为“编译防火墙（Compilation Firewalls）”。看一个例子：</p>
<div class="highlight" id="id-200"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>  <span class="c1">// in header &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>        <span class="c1">// Gadget is some user-defined type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里， Widget 中包含 std::string、std::vector 和 Gadget 类型成员变量，对于 Widget 的客户，必须包含 <string> 、<vector> 和 gadget.h 这些头文件。一旦这些头文件的内容发生改变（当然，string 和 vector 两个头文件的内容很少被修改），使用 Widget 的客户代码必须重新编译。</p>
<p>PImpl 技术可以很好的解决这个问题。将 Widget 类中的数据成员变量封装成一个类（或结构体），然后将数据成员替换成这个类（或结构体）的指针。</p>
<div class="highlight" id="id-201"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="c1">// still in header &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>  <span class="c1">// dtor is needed—see below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>  <span class="c1">// declare implementation struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Impl</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>  <span class="c1">// and pointer to it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Widget 类中不在提及 std::string、std::vector 和 Gadget 类型，因而无需包含相应的头文件。即使这些头文件的内容发生改变， Widget 客户代码也无需重新编译。</p>
<p>一个只声明不定义的类型被成为不完整类型（incomplete type），Widget::Impl 就是这样的一个类型，声明一个指向它的指针是可以编译的，PImpl 技术就是利用了这一点。PImpl 技术的典型方式如下：</p>
<ul>
<li>前向声明一个类型，然后申明一个指向这个类型的指针。</li>
<li>在原始类的实现文件中定义这个类型，并实现这个指针的动态内存分配和回收。</li>
</ul>
<div class="highlight" id="id-202"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">   </span><span class="c1">// in impl. file &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;gadget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>            <span class="c1">// definition of Widget::Impl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>    <span class="c1">// with data members formerly in Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span>    <span class="c1">// allocate data members for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="k">new</span> <span class="n">Impl</span><span class="p">)</span>   <span class="c1">// this Widget object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::~</span><span class="n">Widget</span><span class="p">()</span>   <span class="c1">// destroy data members for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span> <span class="k">delete</span> <span class="n">pImpl</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// this object
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样，就把 <string> 、<vector> 和 gadget.h 这些头文件的依赖从 widget.h （Widget 的客户可见）中转移到了 widget.cpp （Widget 的实现者可见）中。</p>
<p>以上就是 Pimpl 技术的基本原理，这里都是直接使用原始指针，完全是 C++98 风格的实现，C++11 之后，我们更倾向使用智能指针来代替原始指针。</p>
<p><strong>PImpl 技术的智能指针版本</strong></p>
<p>这里，std::unique_ptr 是比较合适用来替换原始指针的，我们修改上面的代码：</p>
<div class="highlight" id="id-203"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// in &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>  <span class="c1">// use smart pointer instead of raw pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gadget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于智能指针的自动析构指向的资源，这里无需析构函数。</p>
<div class="highlight" id="id-204"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，以上代码会编译报错，报错信息如下：</p>
<div class="highlight" id="id-205"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">In file included from /usr/include/c++/9/memory:80,
</span></span><span class="line"><span class="cl">                 from widget.h:3,
</span></span><span class="line"><span class="cl">                 from hello.cpp:1:
</span></span><span class="line"><span class="cl">/usr/include/c++/9/bits/unique_ptr.h: In instantiation of ‘void std::default_delete&lt;_Tp&gt;::operator<span class="o">()(</span>_Tp*<span class="o">)</span> const <span class="o">[</span>with <span class="nv">_Tp</span> <span class="o">=</span> Widget::Impl<span class="o">]</span>’:
</span></span><span class="line"><span class="cl">/usr/include/c++/9/bits/unique_ptr.h:292:17:   required from ‘std::unique_ptr&lt;_Tp, _Dp&gt;::~unique_ptr<span class="o">()</span> <span class="o">[</span>with <span class="nv">_Tp</span> <span class="o">=</span> Widget::Impl<span class="p">;</span> <span class="nv">_Dp</span> <span class="o">=</span> std::default_delete&lt;Widget::Impl&gt;<span class="o">]</span>’
</span></span><span class="line"><span class="cl">widget.h:5:7:   required from here
</span></span><span class="line"><span class="cl">/usr/include/c++/9/bits/unique_ptr.h:79:16: error: invalid application of ‘sizeof’ to incomplete <span class="nb">type</span> ‘Widget::Impl’
</span></span><span class="line"><span class="cl">   <span class="m">79</span> <span class="p">|</span>  static_assert<span class="o">(</span>sizeof<span class="o">(</span>_Tp<span class="o">)</span>&gt;0,
</span></span><span class="line"><span class="cl">      <span class="p">|</span></span></span></code></pre></td></tr></table>
</div>
</div><p>编译报错分析如下：</p>
<blockquote>
<p>在 main 函数结束时候，离开了 w 的作用域，w 将被销毁，也即会调用 Widget 的析构函数。我们的代码虽然没有定义 Widget 的析构函数，但是根据 Item &gt; 17 的介绍可以知道，编译器会生成默认的析构函数（inline 的）。析构函数中会释放 pImpl，pImpl 的是 std::unique_ptr<Impl> 类型。而 std::unique_ptr 默认使用 delete 析构，默认的 delete 代码中会使用 static_assert 确保指针不会指向一个不完整类型，这里用到了 sizeof，而一个不完整类型无法进行 sizeof。</p>
</blockquote>
<div class="highlight" id="id-206"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="c1">/// Primary template of default_delete, used by unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">default_delete</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">/// Default constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">constexpr</span> <span class="nf">default_delete</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/** @brief Converting constructor.
</span></span></span><span class="line"><span class="cl"><span class="cm">       *
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Allows conversion from a deleter for arrays of another type, @p _Up,
</span></span></span><span class="line"><span class="cl"><span class="cm">       * only if @p _Up* is convertible to @p _Tp*.
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Up</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span>
</span></span><span class="line"><span class="cl">         <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">*</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">*&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">default_delete</span><span class="p">(</span><span class="k">const</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">/// Calls @c delete @p __ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">_Tp</span><span class="o">*</span> <span class="n">__ptr</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">		  <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">is_void</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		          <span class="s">&#34;can&#39;t delete pointer to incomplete type&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		  <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">_Tp</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		          <span class="s">&#34;can&#39;t delete pointer to incomplete type&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		  <span class="k">delete</span> <span class="n">__ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>所以，要解决这个问题，只需要保证在销毁 <code>std::unique_ptr&lt;Impl&gt;</code> 时，Impl 是一个完整类型即可，也即有定义。Impl 的定义在 Wigdet.cpp 文件中，因此我们只需让编译器在 Wigdet.cpp 生成析构函数即可。</p>
<div class="highlight" id="id-207"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// in &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>   <span class="c1">// declaration only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>  <span class="c1">// use smart pointer instead of raw pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gadget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::~</span><span class="n">Widget</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// ~Widget definition
</span></span></span><span class="line"><span class="cl"><span class="c1">// Widget::~Widget() = default;  // same effect as above
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于智能指针的自动析构指向的资源，这里无需析构函数。</p>
<div class="highlight" id="id-208"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样就可以编译通过了。但是上面的实现还有点问题：从 Item 17 介绍我们知道，析构函数的声明会阻止编译器生成 move 操作，那么以上代码将不支持 move 操作了。解决办法也是相似的：</p>
<div class="highlight" id="id-209"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// in &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>   <span class="c1">// declaration only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>              <span class="c1">// declarations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>   <span class="c1">// only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>  <span class="c1">// use smart pointer instead of raw pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gadget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::~</span><span class="n">Widget</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// ~Widget definition
</span></span></span><span class="line"><span class="cl"><span class="c1">// Widget::~Widget() = default;  // same effect as above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样 Widget 具备了 move 操作。但是还是存在一点问题：</p>
<ul>
<li>根据 Item 17 知道，因为自定义了 move 操作，将会阻止编译器生成 copy 操作。</li>
<li>即使编译器生成了 copy 操作（使用 = default 进行声明），也是一个浅拷贝，std::uniqe_ptr 是一个所有权独享的对象，对它进行拷贝会转移所有权。</li>
</ul>
<p>因此，需要我们自定义 copy 操作：</p>
<div class="highlight" id="id-210"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// in &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>   <span class="c1">// declaration only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>              <span class="c1">// declarations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>   <span class="c1">// only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>               <span class="c1">// declarations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>    <span class="c1">// only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>  <span class="c1">// use smart pointer instead of raw pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gadget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::~</span><span class="n">Widget</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// ~Widget definition
</span></span></span><span class="line"><span class="cl"><span class="c1">// Widget::~Widget() = default;  // same effect as above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>              <span class="c1">// copy ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>  <span class="c1">// copy operator=
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">pImpl</span> <span class="o">=</span> <span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>到目前为止，以上代码的实现是比较完整的了。</p>
<p>为了实现 Pimpl 技术，std::unique_ptr 是合适的，因为 pImpl 指针对 Impl 有独有所有权。如果你使用 <code>std::shared_ptr</code> 代替 std::unique_ptr，以上出现的问题将不会出现。示例如下：</p>
<div class="highlight" id="id-211"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// in &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// in &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gadget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Gadget</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//======================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">w2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w1</span><span class="p">));</span> <span class="c1">// move-construct w2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">w1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w2</span><span class="p">);</span>     <span class="c1">// move-assign w1
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::shared_ptr</code> 的 deleter 不是其自身的一部分，属于控制块，我们的代码不会包含删除器的代码，因此不需要自定义析构函数，那么 move 和 copy 操作都会自定生成。而 <code>std::shared_ptr</code> 又是值语义的，拷贝也不会发生问题（通过引用计数进行内存管理）。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>pImpl 惯用法通过减少类实现和类使用者之间的编译依赖来减少编译时间。</li>
<li>对于std::unique_ptr 类型的 pImpl 指针，需要在头文件的类里声明特殊的成员函数，但是在实现文件里面来实现他们。即使是编译器自动生成的代码可以工作，也要这么做。</li>
<li>以上的建议只适用于 std::unique_ptr，不适用于 <code>std::shared_ptr</code>。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="ch05-rvalue-references-move-semantics-and-perfect-forwarding">CH05: Rvalue References, Move Semantics, and Perfect Forwarding</h3>
<h4 id="item-23-understand-stdmove-and-stdforwardhttpsblogcsdnnetdong_hfutarticledetails123765869"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123765869"target="_blank" rel="external nofollow noopener noreferrer">Item 23: Understand std::move and std::forward.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>std::move 和 std::forward 并不像他们名字所表达的那样，实际上 std::move 并没有移动数据，std::forward 也并没有转发数据，并且它们在运行期什么也没做。</p>
<p>先说 std::move，我们看下它在 C++11 中简易的实现如下：</p>
<div class="highlight" id="id-212"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>    <span class="c1">// in namespace std
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span>                          <span class="c1">// alias declaration;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span><span class="p">;</span>  <span class="c1">// see Item 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::move 只是返回了右值引用。这里使用了 remove_reference 是为了去除引用标识符。当 T 是一个引用类型的时候，根据引用折叠原理，T&amp;&amp; 会被折叠成一个左值引用类型。所以 remove_reference 是为了去防止 T 是一个引用类型， 它会去除引用进而保证 std::move 返回一个右值引用。因此 std::move 只是做了类型转换，并没有移动数据。由于只有右值是可以被移动的，std::move 更像是说明经过它之后对象可能会被移动（可能，而不是一定，后文会有解释）。</p>
<p>而 C++14 的 std::move 更加简洁：</p>
<div class="highlight" id="id-213"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>             <span class="c1">// C++14; still in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>   <span class="c1">// namespace std
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::move 的目的就是让编译器把修饰的变量看做是右值，进而就可以调用其移动构造函数。事实上，右值是仅可以被移动的对象，std::move 之后不一定一定调用构造函数。看下面的例子，假如你有这样的一个类：</p>
<div class="highlight" id="id-214"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Annotation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span> <span class="o">:</span> <span class="n">text_</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Annotation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span> <span class="o">:</span> <span class="n">text_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">text</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Annotation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//这里换成了带有const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="n">Annotation</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span> <span class="o">:</span> <span class="n">text_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">text</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一个实现会发生两次拷贝，第二个实现会发生一次拷贝和一次移动，那么第三个实现会发生什么呢？</p>
<p>由于 Annotation 的构造函数传入的是一个 const std::string text，std::move(text) 会返回一个常量右值引用，也就是 const 属性被保留了下来。而 std::string 的 move 构造函数的参数只能是一个非 const 的右值引用，这里不能去调用 move 构造。只能调用 copy 构造，因为 copy 构造函数的参数是一个 const 引用，它是可以指向一个 const 右值。因此，第三个实现也是发生两次拷贝。</p>
<p>也可以用下面的例子验证一下：</p>
<div class="highlight" id="id-215"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/type_index.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">typeindex</span><span class="o">::</span><span class="n">type_id_with_cvr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;constructon&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;copy constructon&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;move constructon&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">A</span> <span class="n">a1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a1</span><span class="p">))</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">a2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">constructon</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="k">const</span><span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">copy</span> <span class="n">constructon</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此，我们可以总结出两点启示：</p>
<ul>
<li>第一，假如你想对象能够真正被移动，不要声明将其申明为 const，对 const 对象的移动操作会被转换成了拷贝操作。</li>
<li>第二，std::move 不仅不移动任何东西，甚至不能保证被转换的对象可以被移动。唯一可以确认的是应用 std::move 的对象结果是个右值。</li>
</ul>
<p>再说 std::forward。std::forward 也并没有转发数据，本质上只是做类型转换，与 std::move 不同的是，std::move 是将数据无条件的转换右值，而 std::forward 的转换是有条件的：当传入的是右值的时候将其转换为右值类型。</p>
<p>看一个 std::forward 的典型应用：</p>
<div class="highlight" id="id-216"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;chrono&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lvalArg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;process(const Widget&amp; lvalArg)&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rvalArg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;process(Widget&amp;&amp; rvalArg)&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">logAndProcess</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">process</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">logAndProcess</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>              <span class="c1">// call with lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">logAndProcess</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w</span><span class="p">));</span>   <span class="c1">// call with rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lvalArg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">process</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rvalArg</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当我们通过左值去调用 logAndProcess 时，自然期望这个左值可以同样作为一个左值转移到 process 函数，当我们通过右值去调用 logAndProcess 时，我们期望这个右值可以同样作为一个右值转移到 process 函数。</p>
<p>但是，对于 logAndProcess 的参数 param，它是个左值（可以取地址）。在 logAndProcess 内部只会调用左值的 process 函数。为了避免这个问题，当且仅当传入的用来初始化 param 的实参是个右值，我们需要 std::forward 来把 param 转换成一个右值。至于 std::forward 是如何知道它的参数是通过一个右值来初始化的，将会在 Item 28 中会解释这个问题。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>std::move 无条件将输入转化为右值。它本身并不移动任何东西。</li>
<li>std::forward 把其参数转换为右值，仅仅在参数被绑定到一个右值时。</li>
<li>std::move 和 std::forward 只是做类型转换，在运行时（runtime）不做任何事。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-24-distinguish-universal-references-from-rvalue-referenceshttpsblogcsdnnetdong_hfutarticledetails123773321"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123773321"target="_blank" rel="external nofollow noopener noreferrer">Item 24: Distinguish universal references from rvalue references.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>在 C++11 移动语义出现后，遇到 T&amp;&amp; ，你可能认为就是右值引用，其实不然，这可能是一个万能引用（universal reference），右值引用和万能引用只是形式上相似而已，二者实际上是两个概念。右值引用只能绑定到一个右值上；而万能引用既可以绑定到一个右值，也可以绑定到一个左值。另外，万能引用能绑定到 const 或非 const 对象，也能绑定到 volatile 或非 volatile 对象，甚至能绑定到 const 加 volatile 的对象。</p>
<div class="highlight" id="id-217"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>           <span class="c1">// rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">();</span>         <span class="c1">// rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">var1</span><span class="p">;</span>               <span class="c1">// not rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>   <span class="c1">// rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>                <span class="c1">// not rvalue reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>万能引用主要有两种形式，一种是作为函数模版参数：</p>
<div class="highlight" id="id-218"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>  <span class="c1">// param is a universal reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一种是使用 auto 进行类型推导：</p>
<div class="highlight" id="id-219"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">var1</span><span class="p">;</span>  <span class="c1">// var2 is a universal reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>两种形式有一个共同点，那就是形式为 T&amp;&amp; 或者 auto&amp;&amp;，并且存在类型推导。像下面的代码就不是万能引用：</p>
<div class="highlight" id="id-220"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>   <span class="c1">// no type deduction; param is an rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">();</span> <span class="c1">// no type deduction; var1 is an rvalue reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>万能引用是一种引用，它必须被初始化。万能引用的初始化决定了它代表一个右值还是一个左值。如果初始化为一个右值，万能引用对应右值引用。如果初始化为一个左值，万能引用对应一个左值引用。</p>
<div class="highlight" id="id-221"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span> <span class="c1">// param is a universal reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">);</span> <span class="c1">// lvalue passed to f; param&#39;s type is Widget&amp; (i.e., an lvalue reference)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w</span><span class="p">));</span> <span class="c1">// rvalue passed to f; param&#39;s type is Widget&amp;&amp; (i.e., an rvalue reference)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要使一个引用成为万能引用，必须满足两个条件：形式为 T&amp;&amp; 或者 auto&amp;&amp; （当然 T 只是符号，也可以是 type&amp;&amp; 等等），并且存在类型推导。</p>
<div class="highlight" id="id-222"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">param</span><span class="p">);</span> <span class="c1">// param is an rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// error! can&#39;t bind lvalue to rvalue reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子中，如果调用点没有显示指明类型，也会发生类型推导。但它的形式不是 T&amp;&amp;，而是 std::vector&amp;&amp;，只是右值引用，若传递一个左值给 f ，将发生编译报错。</p>
<p>T&amp;&amp; 的形式是要求非常严格的，哪怕加一个 const 在前面，就会变成右值引用：</p>
<div class="highlight" id="id-223"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span> <span class="c1">// param is an rvalue reference
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>还需要注意，存在形式完全是 <code>T&amp;&amp;</code>，但因为不存在类型推导而不是万能引用的例子，std::vector 的 push_back 就是这样的情况：</p>
<div class="highlight" id="id-224"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="c1">// from C++ Standards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>push_back 的参数完全符合万能引用的形式，但是没有类型推导发生。因为 push_back 不能存在于vector 的特定实例之外，并且实例的类型就完全决定了 push_back 的声明类型。</p>
<div class="highlight" id="id-225"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// declare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// causes the std::vector template to be instantiated as follows:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::vector 中和 push_back 概念上相似的 emplace_back 用到了类型推导：</p>
<div class="highlight" id="id-226"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="c1">// still from C++ Standards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>类型参数 Args （Args 其实是一个参数包，不是一个类型参数，可以把它视为一个类型参数。）独立于 vector 的类型参数 T，所以每次 emplace_back 被调用的时，Args 必须被推导，因而这里是万能引用。</p>
<p>auto&amp;&amp; 形式的变量也发生类型推导，也是万能引用。auto 形式的万能引用在 C++14 的 lambda 表达式中非常常见：</p>
<div class="highlight" id="id-227"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">timeFuncInvocation</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="n">timer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span>          <span class="c1">// invoke func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...</span>  <span class="c1">// on params
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">stop</span> <span class="n">timer</span> <span class="n">and</span> <span class="n">record</span> <span class="n">elapsed</span> <span class="n">time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>func 是一个万能引用，它能被绑定到任何调用的对象上，不管是左值还是右值。params 也是一个万能引用，它能被绑定到任何数量的任意类型的对象上去。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>如果一个函数模板参数有 T&amp;&amp; 格式，并且发生类型推导，或者一个对象使用 auto&amp;&amp; 来声明，那么参数或对象就是一个万能引用。</li>
<li>如果类型推导的格式不是准确的 T&amp;&amp;（type&amp;&amp;），或者如果类型推导没有发生，T&amp;&amp;（type&amp;&amp;）就是一个右值引用。</li>
<li>如果用右值来初始化，万能引用相当于右值引用。如果用左值来初始化，则相当于左值引用。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-25-use-stdmove-on-rvalue-references-stdforward-on-universal-referenceshttpsblogcsdnnetdong_hfutarticledetails123946594"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123946594"target="_blank" rel="external nofollow noopener noreferrer">Item 25: Use std::move on rvalue references, std::forward on universal references.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>如果函数参数为右值引用，那么这个参数只能绑定到一个右值，你应该充分利用右值的特性（可以被移动），使用 std::move 无条件将参数转换为右值。</p>
<div class="highlight" id="id-228"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>        <span class="c1">// rhs is rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">p</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">SomeDataStructure</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>万能引用既可以绑定到右值，也可以绑定到左值。当万能引用的参数被初始为右值时候，应该使用 std::forward 将其转换为右值。</p>
<div class="highlight" id="id-229"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">)</span>  <span class="c1">// newName is universal reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>总的来说，在转发右值引用参数给其他函数时候，应该使用 std::move 无条件将其转为右值。当转发万能引用参数给其他函数时候，应该使用 std::forward 有条件将其转换为右值，因为万能引用有可能绑定到右值。</p>
<p>虽然参数是右值引用时候，使用 std::forward 会将其转换为右值，但还是建议你使用 std::move，因为这样代码更加简洁，也更符合习惯。</p>
<p>如果参数是万能引用，则需要避免使用 std::move 转换为右值。看下面的例子：</p>
<div class="highlight" id="id-230"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">)</span> <span class="c1">// universal reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">SomeDataStructure</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getWidgetName</span><span class="p">();</span> <span class="c1">// factory function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getWidgetName</span><span class="p">();</span> <span class="c1">// n is local variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">w</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// moves n into w!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>             <span class="c1">// n&#39;s value now unknown
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用 std::move 将会无条件将参数转为为右值，n 会被移动给 w.name，n 会变空，这显然不是好的代码设计。为了让 setName 函数不修改入参，有人可能会想通过重载 setName 改善上面代码：</p>
<div class="highlight" id="id-231"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">newName</span><span class="p">)</span>  <span class="c1">// set from const lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">newName</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">)</span>  <span class="c1">// set from rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这依然不是好的设计，还是有缺点。一方面，上面的代码可能比较低效，考虑这样的调用：</p>
<div class="highlight" id="id-232"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">w</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&#34;Adela Novak&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::string 是可以直接通过字面字符串进行构造，如果是万能引用版本，则可以直接在 setName 内部通过字面字符串直接构造 w.name。但是对于重载版本的 setName 来说，则会产生临时的 std::string 对象。</p>
<p>另一方面，最大的缺点是 setName 的参数若有 N 个的话，那需要写 2^N 个重载函数。更糟糕的是，像模板函数不限制个数的参数时候，这种重载的方式更难以为继了。</p>
<div class="highlight" id="id-233"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>            <span class="c1">// from C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_shared</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>  <span class="c1">// Standard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>            <span class="c1">// from C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>  <span class="c1">// Standard
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，当我们在一个函数中使用 std::move 转换右值引用和 std::forward 转化万能引用时候，在这个参数最后一次使用时候才应用 std::move 或 std::forward 。</p>
<div class="highlight" id="id-234"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>        <span class="c1">// text is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">setSignText</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">text</span><span class="p">)</span>  <span class="c1">// univ. reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">sign</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>  <span class="c1">// use text, but don&#39;t modify it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>  <span class="c1">// get current time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">signHistory</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>  <span class="c1">// conditionally cast text to rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果函数的入参是一个右值引用（或万能引用），函数体中返回这个入参（by value），你应该使用 std::move (std::forward) 来返回这个引用。</p>
<div class="highlight" id="id-235"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Matrix</span>   <span class="c1">// by-value return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">lhs</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>  <span class="c1">// move lhs into return value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 std::move 将 lhs 转化为右值，可以促使编译使用移动而非拷贝的方式将 lhs 移动给函数返回值。</p>
<p>对于万能引用，情况也是类似的。如果参数绑定到右值，使用 std::forward 可以促使编译器使用移动而非拷贝动作。</p>
<div class="highlight" id="id-236"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Fraction</span>   <span class="c1">// by-value return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">reduceAndCopy</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">frac</span><span class="p">)</span>   <span class="c1">// universal reference param
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">frac</span><span class="p">.</span><span class="n">reduce</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">frac</span><span class="p">);</span>  <span class="c1">// move rvalue into return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                                <span class="c1">// value, copy lvalue
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，上述的情况不能推广到函数中返回局部变量的场景。看下面的例子：</p>
<div class="highlight" id="id-237"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span>  <span class="c1">// &#34;Copying&#34; version of makeWidget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>  <span class="c1">// local variable configure w
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">w</span><span class="p">;</span>  <span class="c1">// &#34;copy&#34; w into return value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你可能做如下 “优化” ：</p>
<div class="highlight" id="id-238"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span>  <span class="c1">// Moving version of makeWidget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>  <span class="c1">// move w into return value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                       <span class="c1">// (don&#39;t do this!)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>“优化” 的版本反而会让编译器生成的代码效率更低，原因是因为编译器的返回值优化（RVO），可以查阅 C++ 返回值优化 RVO 了解更多，这里不再赘述了。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>对右值引用使用 std::move，对通用引用使用 std::forward。</li>
<li>对按值返回的函数返回值，无论返回右值引用还是通用引用，执行相同的操作。</li>
<li>当局部变量就是返回值是，不要使用s td::move 或者 std::forward。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-26-avoid-overloading-on-universal-referenceshttpsblogcsdnnetdong_hfutarticledetails123965108"><a href="https://blog.csdn.net/Dong_HFUT/article/details/123965108"target="_blank" rel="external nofollow noopener noreferrer">Item 26: Avoid overloading on universal references.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>这一节给出的建议是尽量不要对万能引用参数的函数进行重载，根因是重载函数的匹配规则。先从一个例子说起：</p>
<div class="highlight" id="id-239"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span>  <span class="c1">// global data structure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">logAndAdd</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>  <span class="c1">// get current time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">log</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s">&#34;logAndAdd&#34;</span><span class="p">);</span>  <span class="c1">// make log entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">names</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>    <span class="c1">// add name to global data structure; see Item 42 for info on emplace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码，我们看3个调用：</p>
<div class="highlight" id="id-240"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">petName</span><span class="p">(</span><span class="s">&#34;Darla&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">logAndAdd</span><span class="p">(</span><span class="n">petName</span><span class="p">);</span> <span class="c1">// pass lvalue std::string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">logAndAdd</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">));</span> <span class="c1">// pass rvalue std::string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">logAndAdd</span><span class="p">(</span><span class="s">&#34;Patty Dog&#34;</span><span class="p">);</span> <span class="c1">// pass string literal
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一个调用：logAndAdd 的参数 name 被绑定到一个左值 petName 上。由于 name 是一个左值，names.emplace(name) 将发生一次拷贝。</p>
<p>第二个调用：std::string(“Persephone”) 首先会显示构造出一个临时的 std::string，并且是一个右值。name 被绑定到一个右值，但是 name 是一个左值，names.emplace(name) 将发生一次拷贝。</p>
<p>第三个调用：“Patty Dog” 传入 logAndAdd 将隐式构造出一个临时的 std::string，并且是一个右值。name 被绑定到一个右值，但是 name 是一个左值，names.emplace(name) 将发生一次拷贝。</p>
<p>后面两个调用点， name 都是绑定到一个右值，我们可以通过移动来代替拷贝来提高性能，我们很容易使用万能引用重写 logAndAdd 如下：</p>
<div class="highlight" id="id-241"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">logAndAdd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s">&#34;logAndAdd&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">names</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">petName</span><span class="p">(</span><span class="s">&#34;Darla&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">logAndAdd</span><span class="p">(</span><span class="n">petName</span><span class="p">);</span>  <span class="c1">// as before, copy lvalue into multiset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">logAndAdd</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">));</span> <span class="c1">// move rvalue instead of copying it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">logAndAdd</span><span class="p">(</span><span class="s">&#34;Patty Dog&#34;</span><span class="p">);</span> <span class="c1">// create std::string in multiset instead of copying a temporary std::string
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在，步入本节的主题。对于上述代码，假设在 logAndAdd 内部需要根据一个索引查找 name，logAndAdd 被重载成这样：</p>
<div class="highlight" id="id-242"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nameFromIdx</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span> <span class="c1">// return name corresponding to idx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">logAndAdd</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="c1">// new overload
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s">&#34;logAndAdd&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">names</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// as berfore
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">logAndAdd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s">&#34;logAndAdd&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">names</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>新增一个 int 类型参数的调用方式：</p>
<div class="highlight" id="id-243"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">petName</span><span class="p">(</span><span class="s">&#34;Darla&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">logAndAdd</span><span class="p">(</span><span class="n">petName</span><span class="p">);</span>                     <span class="c1">// as before, these
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">logAndAdd</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">));</span>   <span class="c1">// calls all invoke
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">logAndAdd</span><span class="p">(</span><span class="s">&#34;Patty Dog&#34;</span><span class="p">);</span>                 <span class="c1">// the T&amp;&amp; overload
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">logAndAdd</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// calls int overload
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上还没什么问题，一切都还符合我们的预期。但是，考略下面的调用场景：</p>
<div class="highlight" id="id-244"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">short</span> <span class="n">nameIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>  <span class="c1">// give nameIdx a value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">logAndAdd</span><span class="p">(</span><span class="n">nameIdx</span><span class="p">);</span>  <span class="c1">// error!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 short 类型的 nameIdx，我们期望的显示是调用 int 类型的 logAndAdd 重载。但事实却是这样：万能引用版本的 T 将被推导成 short，因而产生一个确切的匹配版本，然后在 names.emplace 时候会用 short 类型去构造 std::string，显然会报错。</p>
<p>在 C++ 中，以万能引用为参数的函数是最贪婪的函数，它能实例化出多数能够胜任的精确匹配版本，而这个例子中 short 需要做类型转换成 int 类型才会匹配到 int 类型的 logAndAdd。而 C++ 重载函数的匹配原则：<strong>如果模板实例化出的函数和普通重载函数都精确匹配，则优先选择普通重载函数，其次选择模板函数实例化出来的精确版本</strong>。因此这里会匹配到万能引用实例化出的版本。</p>
<p>再看万能引用构造函数的例子：</p>
<div class="highlight" id="id-245"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">)</span>         <span class="c1">// perfect forwarding ctor;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span>  <span class="c1">// initializes data member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>       <span class="c1">// int ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里会有两个问题。首先，传一个除 int 外的整形类型（比如，std::size_t, short, long）将不会调用 int 版本的构造函数，而是调用万能l引用版本的构造函数，然后这将导致编译失败。然后还有一个更加糟糕的问题，根据 <a href="https://blog.csdn.net/Dong_HFUT/article/details/123433559?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">Item 17: Understand special member function generation<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>. 介绍我们知道编译器将在合适的条件下生成 copy 和 move 类构造函数。Person 实际可能是下面这个样子：</p>
<div class="highlight" id="id-246"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// perfect forwarding ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>   <span class="c1">// int ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>  <span class="c1">// copy ctor (compiler-generated)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Person</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>  <span class="c1">// move ctor (compiler-generated)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>考虑下面的调用：</p>
<div class="highlight" id="id-247"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Person</span> <span class="nf">p</span><span class="p">(</span><span class="s">&#34;Nancy&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">cloneOfP</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// create new Person from p; this won&#39;t compile!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 p 去创建一个新的 Person，这里不会调用 Person 的拷贝构造函数，而会调用完美转发构造函数。这是因为 Person 的拷贝构造函数的参数是一个 const 类型的 ，而 p 是一个非 const 类型，并且完美转发构造函数会实例化出一个精确的匹配版本。当我们稍微改造下 p，就可以调用编译器生成的拷贝构造函数：</p>
<div class="highlight" id="id-248"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Person</span> <span class="nf">cp</span><span class="p">(</span><span class="s">&#34;Nancy&#34;</span><span class="p">);</span>  <span class="c1">// object is now const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">cloneOfP</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>         <span class="c1">// calls copy constructor!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然完美转发构造函数也能实例化出一个精确函数签名的版本，但是 C++ 重载匹配会选择普通的重载版本。</p>
<p>当继承介入进来之后，问题将变得更加让人无法接受，我们看下这样的代码片段：</p>
<div class="highlight" id="id-249"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecialPerson</span><span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">SpecialPerson</span><span class="p">(</span><span class="k">const</span> <span class="n">SpecialPerson</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="c1">// copy ctor; calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>                           <span class="c1">// base class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>                                   <span class="c1">// forwarding ctor!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SpecialPerson</span><span class="p">(</span><span class="n">SpecialPerson</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>      <span class="c1">// move ctor; calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>                <span class="c1">// base class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>                                   <span class="c1">// forwarding ctor!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这两个构造函数都会调用基类的完美转发构造函数，因为这两个构造函数给基类传入的都是 SpecialPerson 类型的参数，完美转发构造函数会实例化出精确匹配的版本，最后代码将无法编译通过。</p>
<p>总之，对万能引用参数函数进行重载是一个糟糕的设计，我们需要尽量避免。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>对万能引用参数的函数进行重载，调用机会将比你期望的多得多。</li>
<li>完美转发构造函数是糟糕的实现，因为对于 non-const 左值不会调用拷贝构造而是完美转发构造，而且会劫持派生类对于基类的拷贝和移动构造的调用。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-27-familiarize-yourself-with-alternatives-to-overloading-on-universal-referenceshttpsblogcsdnnetdong_hfutarticledetails124227488"><a href="https://blog.csdn.net/Dong_HFUT/article/details/124227488"target="_blank" rel="external nofollow noopener noreferrer">Item 27: Familiarize yourself with alternatives to overloading on universal references.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>在 <a href="https://blog.csdn.net/Dong_HFUT/article/details/123965108?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">Item26<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中建议大家尽量不要对万能引用进行重载，但同时也确实存在需要对万能引用进行重载的场景。今天就和大家探索下如何满足这种场景的需求，这个 Item 将沿用上个 Item的例子，阅读本文前建议先看上一个 Item。</p>
<p><strong>放弃重载</strong>
对于 Item26 中 logAndAdd 函数，为了避免万能引用实例化匹配产生的问题，一种方式就是不使用重载，取而代之的是给这些重载函数起不同的名字。</p>
<div class="highlight" id="id-250"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">logAndAddName</span><span class="p">(...)</span>
</span></span><span class="line"><span class="cl"><span class="n">logAndAddNameByIdx</span><span class="p">(...)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种方法虽然在一定程度上可以解决这个问题，但是对于构造函数，就无能为力了（构造函数函数名是固定的）。</p>
<p><strong>const T&amp; 传递</strong></p>
<p>另一种选择是不采用万能引用传参（pass-by-universal-reference），使用 const T&amp; 传参。这也是 Item26 开始就介绍的方法，但是它的缺点是效率不高。</p>
<p><strong>值传递</strong></p>
<p>直接选择传值，这种方式将在 Item41 中继续讨论，这里只介绍这种方法的使用：</p>
<div class="highlight" id="id-251"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">n</span><span class="p">)</span> <span class="c1">// replaces T&amp;&amp; ctor; see
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span>        <span class="c1">// Item 41 for use of std::move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>       <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::string 的构造函数没有传 int 的版本，所有 int 类型和类似 int 类型（int，short，size_t，long）参数的传递给构造函数都将匹配到 int 类型重载构造函数。类似的，所有 std::string 类型和类似 std::string 类型（比如字面的&quot;Ruth&quot;）的参数传递给构造函数都将匹配到 std::string 类型重载构造函数。</p>
<p><strong>使用 Tag 分发</strong></p>
<p>const T&amp; 传递和值传递都不支持完美转发。如果使用万能引用的动机是为了完美转发，那还必须只能使用万能引用，并且那你也不想放弃重载，这里介绍一种使用 Tag 分发的方法。</p>
<p>基于 Tag 分发其实就是使用 Tag 对参数进行区分，进而分发到不同的函数实现。对于上个 Item 中的例子:</p>
<div class="highlight" id="id-252"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span> <span class="c1">// global data structure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>              <span class="c1">// make log entry and add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">logAndAdd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="c1">// name to data structure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s">&#34;logAndAdd&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">names</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 Tag 分发的实现如下：</p>
<div class="highlight" id="id-253"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">logAndAddImpl</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s">&#34;logAndAdd&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">names</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">logAndAddImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">logAndAdd</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">logAndAdd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">logAndAddImpl</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>C++11 引入的 std::is_integral<T> 可以判断参数类型是否为整形。在这个例子中，如果 logAndAdd 传入的是左值类型的 int，T将被推导成 int&amp;，但不是 int，为了解决这个问题，使用 std::remove_reference 去除引用。</p>
<p>从概念上讲，logAndAdd 传递了一个布尔值给 logAndAddImpl，表示传递的实参是否为整形。但是我们知道 true 和 false 都是运行时的值，而模板匹配是编译阶段的事情。C++ 标准库提供了 std::true_type 和 std::false_type 两种类型代表 true 和 false 的含义。如果 T 是整形，那么 logAndAdd 传递给 logAndAddImpl 的参数是一个继承了 std::true_type 的对象，否则是一个继承了std::false_type 的对象。</p>
<p><strong>约束接受万能引用的模板</strong></p>
<p>使用 Tag 分发的技术，是在通用引用参数函数内部根据参数类型进行分发，它解决不了 Item26 中介绍的 Person 完美转发构造函数的问题。如果你在一个构造函数内部实现 Tag 分发，但是编译器在一些情况下会自动生成构造函数，将会绕过使用 Tag 分发的构造函数。</p>
<p>问题不在于编译器生成的构造函数会绕过使用 Tag 分发的完美转发构造函数，而是从来没有绕过。例如你想用一个左值的对象去初始化一个新的对象，你想调用的是编译器生成的拷贝构造函数，但是正如 Item26 介绍的那样，实际上调用完美转发的构造函数。</p>
<p>万能引用的匹配重载函数总是贪婪的，我们需要另外一种技术控制万能引用调用的条件，那就是 std::enable_if。</p>
<p>默认条件下，所有模板都是 enable 的，当使用了 std::enable_if 后，只有满足条件的模板才是 enable 的。语法规则是这样的：</p>
<div class="highlight" id="id-254"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">.....</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>只有满足了 condition 条件才使能。我们期望不是 Person 类型的参数，模板构造函数才使能，当然我们可以使用 is_same 来判断类型是否相同，因而我们的条件可能是 !std::is_same&lt;Person, T&gt;::value。但是这里会有点小问题，比如 Person 和 Person&amp; 不是一个类型，而我们这里显然不希望 Person&amp; 类型满足条件进而使能模板。</p>
<ul>
<li>对于引用。我们期望 Person&amp; 和 Person&amp;&amp; 都像 Person 一样处理，即不使能模板。</li>
<li>对于 const 和 volatile，即 CV 描述符。我们期望 const Person、volatile Person 和 volatile const Person 也能像 Person 一样处理，即不使能模板。</li>
</ul>
<p>标准库为我们提供了 std::decay，std::decay<T>::type 的类型 和 T 的类型相同，它忽略了引用和 CV 描述符。因此我们想控制模板使能的条件是：</p>
<div class="highlight" id="id-255"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">value</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样就可以得到我们想要的实现：</p>
<div class="highlight" id="id-256"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                 <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
</span></span><span class="line"><span class="cl">                               <span class="o">&gt;::</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">               <span class="o">&gt;::</span><span class="n">type</span>
</span></span><span class="line"><span class="cl">  <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再看 Item26 中万能引用重载在遇到类继承的问题：</p>
<div class="highlight" id="id-257"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecialPerson</span><span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">SpecialPerson</span><span class="p">(</span><span class="k">const</span> <span class="n">SpecialPerson</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="c1">// copy ctor; calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>                           <span class="c1">// base class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>                                   <span class="c1">// forwarding ctor!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SpecialPerson</span><span class="p">(</span><span class="n">SpecialPerson</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>      <span class="c1">// move ctor; calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>                <span class="c1">// base class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>                                   <span class="c1">// forwarding ctor!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当我们拷贝或移动一个 SpecialPerson 对象，我们期望调用基类的拷贝或移动构造函数，但是我们传递给基类的是 SpecialPerson 类型的参数，会匹配到基类的完美转发构造函数。</p>
<p>标准库 type trait 提供了 std::is_base_of 帮我们解决这个问题。如果 T2 继承于 T1，那么 std::is_base_of&lt;T1, T2&gt;::value 为 true，并且 std::is_base_of&lt;T, T&gt;::value 也是 true。上面的代码使用 std::is_base_of 代替 is_same 得到的代码将更加合适：</p>
<div class="highlight" id="id-258"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                 <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
</span></span><span class="line"><span class="cl">                                  <span class="o">&gt;::</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">               <span class="o">&gt;::</span><span class="n">type</span>
</span></span><span class="line"><span class="cl">  <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用 C++14 实现将更加简洁：</p>
<div class="highlight" id="id-259"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                 <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
</span></span><span class="line"><span class="cl">                                  <span class="o">&gt;::</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">               <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>到目前为止，我们已经接近了完美解决了 Item26 中介绍的万能引用模板重载的问题。再加上处理整数参数类型的 Person 的重载，我们汇总代码如下：</p>
<div class="highlight" id="id-260"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">    <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">)</span>     <span class="c1">// ctor for std::strings and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="c1">// args convertible to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>                      <span class="c1">// std::strings
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>   <span class="c1">// ctor for integral args
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span> <span class="c1">// copy and move ctors, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>权衡</strong></p>
<p>本 Item 介绍的后两种技术：使用 Tag 分发和限制模板使能条件，都支持了完美转发。但使用完美转发也有缺点：</p>
<p>一个是有些类型不能完美转发，这个将在 Item30 中讨论。另外一个是当用户传递无效参数时，编译报错信息的可读性非常差。</p>
<p>例如，在创建 Person 对象的时候传递了个char16_t（C++11引进的一种以16位表示一个字符的类型）字符组成的字符串，而不是char：</p>
<div class="highlight" id="id-261"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Person</span> <span class="nf">p</span><span class="p">(</span><span class="sa">u</span><span class="s">&#34;Konrad Zuse&#34;</span><span class="p">);</span> <span class="c1">// &#34;Konrad Zuse&#34; consists of characters of type const char16_t
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当使用本 Item 的前三种技术时，编译器看到可执行的构造函数只接受 int 和 std::string，编译器会产生一些直观的错误信息表明：无法将 const char16_t[12] 转换到 int 或 std::string。</p>
<p>万能引用在接受 char16_t 类型时候没有问题，当构造函数把 char16_t 类型数组转发到 std::string 成员变量的构造中时，才发现 char16_t 数组不是 std::string 可接受的参数类型，我使用 g++ 的报错信息如下：</p>
<div class="highlight" id="id-262"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">hello.cpp: In instantiation of ‘Person::Person<span class="o">(</span>T<span class="o">&amp;&amp;)</span> <span class="o">[</span>with <span class="nv">T</span> <span class="o">=</span> const char16_t <span class="o">(</span><span class="p">&amp;</span><span class="o">)[</span>12<span class="o">]</span><span class="p">;</span> &lt;template-parameter-1-2&gt; <span class="o">=</span> void<span class="o">]</span>’:
</span></span><span class="line"><span class="cl">hello.cpp:30:26:   required from here
</span></span><span class="line"><span class="cl">hello.cpp:18:28: error: no matching <span class="k">function</span> <span class="k">for</span> call to ‘std::__cxx11::basic_string&lt;char&gt;::basic_string<span class="o">(</span>const char16_t <span class="o">[</span>12<span class="o">])</span>’
</span></span><span class="line"><span class="cl">   : name<span class="o">(</span>std::forward&lt;T&gt;<span class="o">(</span>n<span class="o">))</span> // args convertible to
</span></span><span class="line"><span class="cl">                            ^
</span></span><span class="line"><span class="cl">In file included from /usr/include/c++/7/string:52:0,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/bits/locale_classes.h:40,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/bits/ios_base.h:41,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/ios:42,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/ostream:38,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/iostream:39,
</span></span><span class="line"><span class="cl">                 from hello.cpp:1:
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:604:9: note: candidate: template&lt;class _InputIterator, class&gt; std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>_InputIterator, _InputIterator, const _Alloc<span class="p">&amp;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">         basic_string<span class="o">(</span>_InputIterator __beg, _InputIterator __end,
</span></span><span class="line"><span class="cl">         ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:604:9: note:   template argument deduction/substitution failed:
</span></span><span class="line"><span class="cl">hello.cpp:18:28: note:   candidate expects <span class="m">3</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">   : name<span class="o">(</span>std::forward&lt;T&gt;<span class="o">(</span>n<span class="o">))</span> // args convertible to
</span></span><span class="line"><span class="cl">                            ^
</span></span><span class="line"><span class="cl">In file included from /usr/include/c++/7/string:52:0,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/bits/locale_classes.h:40,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/bits/ios_base.h:41,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/ios:42,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/ostream:38,
</span></span><span class="line"><span class="cl">                 from /usr/include/c++/7/iostream:39,
</span></span><span class="line"><span class="cl">                 from hello.cpp:1:
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:566:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;<span class="o">&amp;&amp;</span>, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>basic_string<span class="o">&amp;&amp;</span> __str, const _Alloc<span class="p">&amp;</span> __a<span class="o">)</span>
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:566:7: note:   candidate expects <span class="m">2</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:562:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;<span class="p">&amp;</span>, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const basic_string<span class="p">&amp;</span> __str, const _Alloc<span class="p">&amp;</span> __a<span class="o">)</span>
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:562:7: note:   candidate expects <span class="m">2</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:558:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>std::initializer_list&lt;_Tp&gt;, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>initializer_list&lt;_CharT&gt; __l, const _Alloc<span class="p">&amp;</span> <span class="nv">__a</span> <span class="o">=</span> _Alloc<span class="o">())</span>
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:558:7: note:   no known conversion <span class="k">for</span> argument <span class="m">1</span> from ‘const char16_t <span class="o">[</span>12<span class="o">]</span>’ to
</span></span><span class="line"><span class="cl">std::initializer_list&lt;char&gt;’
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:531:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;<span class="o">&amp;&amp;)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>basic_string<span class="o">&amp;&amp;</span> __str<span class="o">)</span> noexcept
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:531:7: note:   no known conversion <span class="k">for</span> argument <span class="m">1</span> from ‘const char16_t <span class="o">[</span>12<span class="o">]</span>’ to
</span></span><span class="line"><span class="cl">std::__cxx11::basic_string&lt;char&gt;<span class="o">&amp;&amp;</span>’
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:519:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type, _CharT, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="p">;</span> std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type <span class="o">=</span> long unsigned int<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>size_type __n, _CharT __c, const _Alloc<span class="p">&amp;</span> <span class="nv">__a</span> <span class="o">=</span> _Alloc<span class="o">())</span>
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:519:7: note:   candidate expects <span class="m">3</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:509:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const _CharT*, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const _CharT* __s, const _Alloc<span class="p">&amp;</span> <span class="nv">__a</span> <span class="o">=</span> _Alloc<span class="o">())</span>
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:509:7: note:   no known conversion <span class="k">for</span> argument <span class="m">1</span> from ‘const char16_t <span class="o">[</span>12<span class="o">]</span>’ to
</span></span><span class="line"><span class="cl">const char*’
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:499:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const _CharT*, std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="p">;</span> std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type <span class="o">=</span> long unsigned int<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const _CharT* __s, size_type __n,
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:499:7: note:   candidate expects <span class="m">3</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:481:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;<span class="p">&amp;</span>, std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type, std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="p">;</span> std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type <span class="o">=</span> long unsigned int<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const basic_string<span class="p">&amp;</span> __str, size_type __pos,
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:481:7: note:   candidate expects <span class="m">4</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:465:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;<span class="p">&amp;</span>, std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type, std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type<span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="p">;</span> std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type <span class="o">=</span> long unsigned int<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const basic_string<span class="p">&amp;</span> __str, size_type __pos,
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:465:7: note:   candidate expects <span class="m">3</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:450:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;<span class="p">&amp;</span>, std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type, const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="p">;</span> std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type <span class="o">=</span> long unsigned int<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const basic_string<span class="p">&amp;</span> __str, size_type __pos,
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:450:7: note:   candidate expects <span class="m">3</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:437:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const basic_string<span class="p">&amp;</span> __str<span class="o">)</span>
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:437:7: note:   no known conversion <span class="k">for</span> argument <span class="m">1</span> from ‘const char16_t <span class="o">[</span>12<span class="o">]</span>’ to
</span></span><span class="line"><span class="cl">const std::__cxx11::basic_string&lt;char&gt;<span class="p">&amp;</span>’
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:429:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">(</span>const _Alloc<span class="p">&amp;</span><span class="o">)</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">(</span>const _Alloc<span class="p">&amp;</span> __a<span class="o">)</span> _GLIBCXX_NOEXCEPT
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:429:7: note:   no known conversion <span class="k">for</span> argument <span class="m">1</span> from ‘const char16_t <span class="o">[</span>12<span class="o">]</span>’ to
</span></span><span class="line"><span class="cl">const std::allocator&lt;char&gt;<span class="p">&amp;</span>’
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:420:7: note: candidate: std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string<span class="o">()</span> <span class="o">[</span>with <span class="nv">_CharT</span> <span class="o">=</span> char<span class="p">;</span> <span class="nv">_Traits</span> <span class="o">=</span> std::char_traits&lt;char&gt;<span class="p">;</span> <span class="nv">_Alloc</span> <span class="o">=</span> std::allocator&lt;char&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl">       basic_string<span class="o">()</span>
</span></span><span class="line"><span class="cl">       ^~~~~~~~~~~~
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:420:7: note:   candidate expects <span class="m">0</span> arguments, <span class="m">1</span> provided</span></span></code></pre></td></tr></table>
</div>
</div><p>如果完美转发多次，错误信息将更加迷惑。std::is_constructible 可以在编译期间测试一个类型的对象是否能被另一个不同类型（或一些不同类型）的对象（或者另一些对象）构造，我们可以使用 static_assert 断言来实现：</p>
<div class="highlight" id="id-263"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">    <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">)</span>     <span class="c1">// ctor for std::strings and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="c1">// args convertible to std::strings
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// assert that a std::string can be created from a T object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">static_assert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	  <span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	  <span class="s">&#34;Parameter n can&#39;t be used to construct a std::string&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>   <span class="c1">// ctor for integral args
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span> <span class="c1">// copy and move ctors, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>g++ 编译报错如下：</p>
<div class="highlight" id="id-264"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">// ...... 此处省略
</span></span><span class="line"><span class="cl">/usr/include/c++/7/bits/basic_string.h:420:7: note:   candidate expects <span class="m">0</span> arguments, <span class="m">1</span> provided
</span></span><span class="line"><span class="cl">hello.cpp:20:6: error: static assertion failed: Parameter n can<span class="err">&#39;</span>t be used to construct a std::string
</span></span><span class="line"><span class="cl">      static_assert<span class="o">(</span>
</span></span><span class="line"><span class="cl">      ^~~~~~~~~~~~~</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，我们我们已经完美解决了 Item26 中介绍的万能引用模板重载的问题。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>万能引用和重载的组合替代方案包括使用不同的函数名、通过 const 左值引用传参、按值传递参数，使用 tag 分发。</li>
<li>通过 std::enable_if 约束模板来允许万能引用和重载组合使用，std::enable_if 可以控制编译器什么条件才使用万能引用的实例。</li>
<li>万能引用参数通常具有高效率的优势，但通常可用性较差。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-28-understand-reference-collapsinghttpsblogcsdnnetdong_hfutarticledetails124517043"><a href="https://blog.csdn.net/Dong_HFUT/article/details/124517043"target="_blank" rel="external nofollow noopener noreferrer">Item 28: Understand reference collapsing.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p><strong>引用折叠规则</strong></p>
<p>所谓引用折叠（reference collapsing）就是引用指向引用（reference to reference）会折叠（或者坍塌）成一种引用。我们知道，引用分为左值引用和右值引用，因此，引用指向引用就存在 4 种情况：</p>
<ol>
<li>左值引用指向左值引用，记为 A&amp; &amp;</li>
<li>左值引用指向右值引用，记为 A&amp; &amp;&amp;</li>
<li>右值引用指向左值引用，记为 A&amp;&amp; &amp;</li>
<li>右值引用指向右值引用，记为 A&amp;&amp; &amp;&amp;</li>
</ol>
<p>引用折叠的规则为：</p>
<blockquote>
<p>只要两个引用中的一个为左值引用的话，则折叠为左值引用，否则为右值引用。</p>
</blockquote>
<p>应用上述引用折叠规则，引用指向引用的 4 种情况的结果为：</p>
<ol>
<li>A&amp; &amp; —&gt; A&amp;</li>
<li>A&amp; &amp;&amp; &mdash;-&gt; A&amp;</li>
<li>A&amp;&amp; &amp; &mdash;-&gt; A&amp;</li>
<li>A&amp;&amp; &amp;&amp; &mdash;-&gt; A&amp;&amp;</li>
</ol>
<p>根据引用折叠规则，我们看一下引用折叠应用的几种应用场景。</p>
<p><strong>万能引用的实例化</strong></p>
<p>对于万能引用：</p>
<div class="highlight" id="id-265"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们在 <a href="https://blog.csdn.net/Dong_HFUT/article/details/123773321?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">Item 24<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中介绍过，万能引用的参数（param）的初始化决定了它代表一个右值还是一个左值。如果初始化为一个右值，万能引用对应右值引用。如果初始化为一个左值，万能引用对应一个左值引用。</p>
<p>这里其实是应用了引用折叠规则。首先类型 T 根据传递给 param 的参数是左值还是右值进行推导，推导的机制为：</p>
<blockquote>
<p>如果一个左值传递给 param，T 被推导为一个左值引用；如果一个右值传递给 param，T 被推导成一个非引用类型。</p>
</blockquote>
<p>我们先看传递一个左值的情况：</p>
<div class="highlight" id="id-266"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">w</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，T 被推导成一个左值引用，这里为 Widget&amp;，我们用它实例化模板，得到：</p>
<div class="highlight" id="id-267"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后应用引用折叠规则，得到：</p>
<div class="highlight" id="id-268"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此，初始化为一个左值，万能引用对应一个左值引用。</p>
<p>再看传递一个右值的情况：</p>
<div class="highlight" id="id-269"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">widgetFactory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">widgetFactory</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，T 被推导成一个非引用类型，这里为 Widget，我们用它实例化模板，得到：</p>
<div class="highlight" id="id-270"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里没有引用指向引用的情况，因此，如果初始化为一个右值，万能引用对应右值引用。</p>
<p>以上就解释了万能引用如何根据初始化参数推导模板参数类型的。</p>
<p><strong>std::forward 机制</strong></p>
<p>引用折叠也是 std::forward 机制的关键部分。看一个 std::forward 应用于万能引用参数的例子：</p>
<div class="highlight" id="id-271"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">fParam</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span> <span class="c1">// do some work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">someFunc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fParam</span><span class="p">));</span> <span class="c1">// forward fParam to someFunc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>根据上面的介绍，我们知道， T 的推导类型取决于 fParam 被初始参数为左值还是右值：如果一个左值传递给 param，T 被推导为一个左值引用；如果一个右值传递给 param，T 被推导成一个非引用类型。</p>
<div class="highlight" id="id-272"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果 fParam 被初始化为一个左值类型 Widget，则 T 被推导为 Widget&amp;，则 std::forward 被实例化成 std::forward&lt;Widget&amp;&gt;：</p>
<div class="highlight" id="id-273"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::remove_reference&lt;Widget&amp;&gt;::type 产生 Widget，则 std::forward 变为：</p>
<div class="highlight" id="id-274"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再应用引用折叠规则，则 std::forward 变为：</p>
<div class="highlight" id="id-275"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如你所见，当一个左值传递给模板函数 f，std::forward 的入参和返回值类型都是一个左值引用，由于 param 的类型已经是一个 Widget&amp;，因此 std::forward 内部的 cast 啥也没干。这完全符合对 std::forward 的预期，传入左值 std::forward 则返回左值（左值引用本质上就是左值），实际上并没有做任何类型 cast。</p>
<p>再来看 fParam 被初始化为一个右值类型 Widget，则 T 被推导为 Widget，则 std::forward 被实例化成 std::forward<Widget>：</p>
<div class="highlight" id="id-276"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::remove_reference 产生 Widget，则 std::forward 变为：</p>
<div class="highlight" id="id-277"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里没有引用折叠的事情，结果也是符合我们对 std::forward 的预期：传入右值 std::forward 则返回右值（把左值参数 param 转化为右值）。</p>
<p><strong>生成 auto 变量</strong></p>
<p>再看 auto 变量的情况，也是类似模板类型的：</p>
<div class="highlight" id="id-278"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这其实也是一个万能引用（见 Item 24）。如果用一个左值初始化 w1，auto 类型被推导成 Widget&amp;，则上面代码则变成一个引用指向引用的表达式：</p>
<div class="highlight" id="id-279"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应用引用折叠，则变为：</p>
<div class="highlight" id="id-280"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>w1 的结果为一个左值引用。</p>
<p>另一方面，用一个右值初始化 w2：</p>
<div class="highlight" id="id-281"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">widgetFactory</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>auto 被推导成非引用类型 Widget，则上述代码变为：</p>
<div class="highlight" id="id-282"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">widgetFactory</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>w2 的结果为一个右值引用。</p>
<p><strong>typedef 类型别名</strong></p>
<p>若使用 typedef 时候发生引用指向引用的情况，则同样应用引用折叠规则：</p>
<div class="highlight" id="id-283"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">RvalueRefToT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设使用左值引用实例化：</p>
<div class="highlight" id="id-284"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="n">w</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里将产生引用指向引用的表达式：</p>
<div class="highlight" id="id-285"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">RvalueRefToT</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应用引用折叠规则，表达式变为：</p>
<div class="highlight" id="id-286"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">RvalueRefToT</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>decltype 类型推导</strong></p>
<p>当分析 decltype 产生的类型时，存在引用指向引用的表达式，也是引用折叠的应用场景。可以参阅 <a href="https://blog.csdn.net/Dong_HFUT/article/details/122745518?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">Item 3<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>引用折叠发生在四种情况：模板实例化，auto 类型的生成，创建和使用 typedef、别名声明和decltype。</li>
<li>当编译器生成了引用的引用时，通过引用折叠就是单个引用。其中之一为左值引用就是左值引用，否则就是右值引用。</li>
<li>在类型推导区分左值和右值以及引用折叠发生的上下文中，万能引用是右值引用。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-29-assume-that-move-operations-are-not-present-not-cheap-and-not-usedhttpsblogcsdnnetdong_hfutarticledetails124577258"><a href="https://blog.csdn.net/Dong_HFUT/article/details/124577258"target="_blank" rel="external nofollow noopener noreferrer">Item 29: Assume that move operations are not present, not cheap, and not used.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>在 C++11 新增特性中，移动语义无疑是最重要的一个，它允许编译器使用高效的 move 操作代替低效的 copy 操作。一般地，把你的 C++98 代码使用 C++11 编译器重新编译后，运行的会更快一些。</p>
<p>然而，凡是都不是绝对的，本 item 会介绍一些移动语义不可用、不那么高效的场景。</p>
<p>对于 C++ 标准库，针对 C++11 特性做了大量的修改，添加了对移动语义的支持，对 C++ 标准库使用移动操作基本上都会带来性能的提升。但对于我们自己存量的老代码，多数是不支持移动语义的。并且在 Item 17 中也介绍了，编译器只会在没有用户自定义拷贝操作和析构函数时才会生成移动操作。因此，这种情况下无法享受到移动语义带来的性能收益。</p>
<p>C++11 标准库已经都支持移动操作了，但不意味着一定都会带来性能的提升。例如 std::array，其实它本质上是披着标准库容器接口外衣的数组。一般的 STL 容器的对象，其数据成员是在堆上，对象中有一个指针指向这个堆。这个指针的存在，让容器内容的移动只要将目标容器的指针指向源容器的堆，然后将源容器的指针设置为空即可。</p>
<p></p>
<p>std::array 没有这样的指针，它的内容直接存储在对象的 buffer 中，它的移动没法像一般的容器那样通过直接改变容器中指针的指向来高效完成移动。std::array 的移动需要将数据一个一个移动或拷贝。</p>
<p></p>
<p>对于 std::string，提供了常量时间的移动和线性时间的拷贝，听起来移动比拷贝高效很多。然而，也有例外。std::string 有一种实现叫 SSO（small string optimization），对于小字符串（例如少于 15 个字符）其数据直接存储在对象中，而不存储在堆上。SSO 直接使用对象内部的 buffer 存放内容，而省去动态申请堆内存。移动基于 SSO 实现的小字符串并不会比拷贝高效。</p>
<p>即使对于支持移动语义的类型，看似一定使用移动的场景，却最终使用的是拷贝。Item 14 介绍了一些标准库操作提供了异常规范影响移动语义的场景。只有移动操作一定不会抛出异常的情况下，拷贝操作在内部才会被移动操作替换。如果移动操作没有被申明为 noexcept，即使是适合移动操作的场景，编译器也会依然生成拷贝操作。</p>
<p>此外，虽然左值可以使用 std::move 将其转换为右值进行移动操作，但会存在一些异常情况，参见 Item 25 。因而尽可能只对右值进行移动操作。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>假设移动操作不可用、不廉价。</li>
<li>在已知类型或支持移动语义的代码中，不需要进行此假设。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-30-familiarize-yourself-with-perfect-forwarding-failure-caseshttpsblogcsdnnetdong_hfutarticledetails124787082"><a href="https://blog.csdn.net/Dong_HFUT/article/details/124787082"target="_blank" rel="external nofollow noopener noreferrer">Item 30: Familiarize yourself with perfect forwarding failure cases.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>完美转发（perfect forwarding）是 C++11 非常重要的一个特性。转发意味着一个函数将其参数传给另一函数，第二个函数的目的是接收第一个函数接收到的参数，并且二者是同一个对象。这就排除了值传递参数形式，因为值传递需要拷贝对象，拷贝后对象就不是源对象了。指针传递也可以达到转发的效果，但要求用户必须传递指针，算不上完美转发。</p>
<p>完美转发不仅要转发对象本身，还有附带属性，比如对象是左值还是右值、是 const 还是 volatile。根据 Item 24 的介绍，只能使用万能引用的方式，因为只有万能引用能够对传递的参数的左值或右值信息进行编码。</p>
<p>典型的形式如下：</p>
<div class="highlight" id="id-287"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>           <span class="c1">// accept any argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>  <span class="c1">// forward it to f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>fwd 还可以转发可变参数：</p>
<div class="highlight" id="id-288"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>           <span class="c1">// accept any arguments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>  <span class="c1">// forward them to f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一些类型的参数会导致完美转发失败，本 Item 接下来介绍几个导致完美转发失败的场景。</p>
<p><strong>花括号初始化（统一初始化、列表初始化）</strong></p>
<p>假设函数 f 申明如下：</p>
<div class="highlight" id="id-289"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用统一初始化方式调用 f 没有问题：</p>
<div class="highlight" id="id-290"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">f</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">});</span> <span class="c1">// fine, &#34;{1, 2, 3}&#34; implicitly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// converted to std::vector&lt;int&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 f ({ 1, 2, 3 })，在函数调用点，编译器会比较入参和函数的参数申明，看它们是否兼容。如有必要，编译器会执行隐式类型转换来让调用成功。在这个例子中，编译器会将 {1, 2, 3} 转换成一个 std::vector<int> 类型（因为 std::vector 有初始化列表的构造函数版本），这样就调用成功了。</p>
<p>但是将列表初始化参数传递给 fwd，则产生编译错误：</p>
<div class="highlight" id="id-291"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">});</span> <span class="c1">// error! doesn&#39;t compile
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过转发函数模板 fwd 间接调用 f，编译器将不再比较通过 fwd 调用点传入的参数和函数 f 的参数申明。取而代之的是，编译器推导通过 fwd 传递的参数类型，并将比较推导类型和函数 f 的参数申明。下面两者之一的情况发生时，将导致完美转发失败：</p>
<ul>
<li>编译器无法推导 fwd 的参数类型。</li>
<li>编译器将 fwd 的参数类型推导“错误”。这里的错误可能是使用推导类型的 fwd 的实例无法编译通过，也可能是使用推导类型调用 f 和直接使用传递给 fwd 的参数调用 f 的行为不一样。</li>
</ul>
<p>对于 fwd({ 1, 2, 3 })，由于 fwd 没有申明为一个 std::initializer_list，编译器不会将表达式 {1, 2, 3} 推导类型，因此编译失败。</p>
<div class="highlight" id="id-292"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;vector&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>           <span class="c1">// accept any argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>  <span class="c1">// forward it to f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">fwd</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 编译报错如下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">&#39;</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span><span class="err">&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">matching</span> <span class="n">function</span> <span class="k">for</span> <span class="n">call</span> <span class="n">to</span> <span class="err">&#39;</span><span class="n">fwd</span><span class="p">(</span><span class="o">&lt;</span><span class="n">brace</span><span class="o">-</span><span class="n">enclosed</span> <span class="n">initializer</span> <span class="n">list</span><span class="o">&gt;</span><span class="p">)</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">   <span class="mi">15</span> <span class="o">|</span>   <span class="n">fwd</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span>   <span class="o">~~~^~~~~~~~~~</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">9</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span> <span class="nl">candidate</span><span class="p">:</span> <span class="err">&#39;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="mi">9</span> <span class="o">|</span> <span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>           <span class="c1">// accept any argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">|</span>      <span class="o">^~~</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">9</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span>   <span class="k">template</span> <span class="n">argument</span> <span class="n">deduction</span><span class="o">/</span><span class="n">substitution</span> <span class="nl">failed</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span>   <span class="n">couldn</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">deduce</span> <span class="k">template</span> <span class="n">parameter</span> <span class="sc">&#39;T&#39;</span>
</span></span><span class="line"><span class="cl">   <span class="mi">15</span> <span class="o">|</span>   <span class="n">fwd</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是完美转发失败的第一个例子。不过，上面的问题也可以解决：虽然模板类型推导无法推导出初始化列表的类型，但是 auto 可以:</p>
<div class="highlight" id="id-293"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">il</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// il&#39;s type deduced to be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="c1">// std::initializer_list&lt;int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="n">il</span><span class="p">);</span>               <span class="c1">// fine, perfect-forwards il to f
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>0 或 NULL 作为空指针</strong></p>
<p>在 Item8 中介绍过， 当使用 0 或者 NULL 作为一个空指针传给模板，会被推导成 int 类型，无法被当成指针类型进行完美转发。</p>
<div class="highlight" id="id-294"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>           <span class="c1">// accept any argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>  <span class="c1">// forward it to f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">fwd</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// fwd(0);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 编译报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="err">&#39;</span><span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">[</span><span class="n">with</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">]</span><span class="err">&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">14</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span>   <span class="n">required</span> <span class="n">from</span> <span class="n">here</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">conversion</span> <span class="n">from</span> <span class="err">&#39;</span><span class="kt">long</span> <span class="kt">int</span><span class="err">&#39;</span> <span class="n">to</span> <span class="err">&#39;</span><span class="kt">void</span><span class="o">*</span><span class="err">&#39;</span> <span class="p">[</span><span class="o">-</span><span class="n">fpermissive</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="mi">10</span> <span class="o">|</span>   <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>  <span class="c1">// forward it to f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">|</span>   <span class="o">~^~~~~~~~~~~~~~~~~~~~~~~~</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span>    <span class="o">|</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span>    <span class="kt">long</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">8</span><span class="o">:</span> <span class="nl">note</span><span class="p">:</span>   <span class="n">initializing</span> <span class="n">argument</span> <span class="mi">1</span> <span class="n">of</span> <span class="err">&#39;</span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="mi">3</span> <span class="o">|</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span>        <span class="o">^~~~~</span></span></span></code></pre></td></tr></table>
</div>
</div><p>解决办法也很简单，使用 nullptr 作为空指针。</p>
<p><strong>仅仅声明整型的静态常量（static const）数据成员</strong></p>
<p>一般地，没有必要在类中定义静态常量数据成员，仅仅申明它就够了，因为编译器会对执行常量传播，因此不会为静态常量数据成员分配实际的存储空间。例如下面的代码片段：</p>
<div class="highlight" id="id-295"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">MinVals</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span> <span class="c1">// MinVals&#39; declaration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span> <span class="c1">// no defn. for MinVals
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">widgetData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">widgetData</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">Widget</span><span class="o">::</span><span class="n">MinVals</span><span class="p">);</span> <span class="c1">// use of MinVals
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然 Widget::MinVals 没有存储空间，但是使用它初始化 widgetData 是没有问题的，因为编译器会直接将使用到它的地方替换成 28。但是若对 Widget::MinVals 取地址，将找不到 Widget::MinVals 的定义，链接时将会失败。</p>
<div class="highlight" id="id-296"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">Widget</span><span class="o">::</span><span class="n">MinVals</span><span class="p">);</span>   <span class="c1">// fine, treated as &#34;f(28)&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="n">Widget</span><span class="o">::</span><span class="n">MinVals</span><span class="p">);</span> <span class="c1">// error! shouldn&#39;t link
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然万能引用没有对 Widget::MinVals 取地址，但是万能引用的参数是引用类型，对于编译器而言，引用通常被对待成指针一样。因此，完美转发也就失败了。</p>
<p>上面说的是引用通常被当成指针，不排除有的编译器不是这样，也即可以对静态常量数据成员进行完美转发。但我们没必须要冒这样的险，只要增加一个定义即万事大吉。</p>
<div class="highlight" id="id-297"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">Widget</span><span class="o">::</span><span class="n">MinVals</span><span class="p">;</span> <span class="c1">// in Widget&#39;s .cpp file
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>函数重载和函数模板</strong></p>
<div class="highlight" id="id-298"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// pf = &#34;processing function&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">processVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">processVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">processVal</span><span class="p">);</span>   <span class="c1">// fine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="n">processVal</span><span class="p">);</span> <span class="c1">// error! which processVal?
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于重载函数 processVal，通过 fwd 转发 processVal 将会失败，因为模板类型推导无法推导 processVal 的类型。使用模板函数，也有同样的问题。</p>
<div class="highlight" id="id-299"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">workOnVal</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">)</span> <span class="c1">// template for processing values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="n">workOnVal</span><span class="p">);</span> <span class="c1">// error! which workOnVal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// instantiation?
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>解决的办法是：主动给出函数重载和函数模板的类型：</p>
<div class="highlight" id="id-300"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">ProcessFuncType</span> <span class="o">=</span> <span class="c1">// make typedef; see Item 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ProcessFuncType</span> <span class="n">processValPtr</span> <span class="o">=</span> <span class="n">processVal</span><span class="p">;</span>  <span class="c1">// specify needed signature for processVal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="n">processValPtr</span><span class="p">);</span> <span class="c1">// fine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ProcessFuncType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">workOnVal</span><span class="p">));</span> <span class="c1">// also fine
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然上面的行为有点奇怪，完美转发需要知道转发的是哪一个。</p>
<p><strong>位域</strong></p>
<p>完美转发失败的最后一个例子是使用位域作为函数参数。</p>
<div class="highlight" id="id-301"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">IPv4Header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="nl">version</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">IHL</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">DSCP</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">ECN</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">totalLength</span><span class="p">:</span><span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">sz</span><span class="p">);</span> <span class="c1">// function to call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">IPv4Header</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">totalLength</span><span class="p">);</span> <span class="c1">// fine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">totalLength</span><span class="p">);</span> <span class="c1">// error!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>失败的原因是因为 fwd 的参数是一个引用，C++ 标准规定一个非 const 引用无法引用一个位域字段。这样的规定也是合理的，比特位域通常只是 int 类型的一部分，没有一个确切的地址，也就没办法通过指针指向它，而通常引用本质上是指针，因此无法引用位域。</p>
<p>而指向常量的引用可以绑定到位域，本质上是因为绑定到了位域的一个拷贝对象上（比如 int）。</p>
<div class="highlight" id="id-302"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">IPv4Header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="nl">version</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">IHL</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">DSCP</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">ECN</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">totalLength</span><span class="p">:</span><span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>           <span class="c1">// accept any argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>  <span class="c1">// forward it to f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">IPv4Header</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">totalLength</span><span class="p">);</span>  <span class="c1">// fine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">fwd</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">totalLength</span><span class="p">);</span> <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 编译报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">&#39;</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span><span class="err">&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">24</span><span class="o">:</span><span class="mi">9</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">bind</span> <span class="n">bit</span><span class="o">-</span><span class="n">field</span> <span class="err">&#39;</span><span class="n">h</span><span class="p">.</span><span class="n">IPv4Header</span><span class="o">::</span><span class="n">totalLength</span><span class="err">&#39;</span> <span class="n">to</span> <span class="err">&#39;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">   <span class="mi">24</span> <span class="o">|</span>   <span class="n">fwd</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">totalLength</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">|</span>       <span class="o">~~^~~~~~~~~~~</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么完美转发位域也可以通过对位域进行拷贝，然后再转发。</p>
<div class="highlight" id="id-303"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// copy bitfield value; see Item 6 for info on init. form
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">length</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">totalLength</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="n">length</span><span class="p">);</span> <span class="c1">// forward the copy
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>当模板类型推导失败或者推导类型是错误的时候完美转发会失败。</li>
<li>导致完美转发失败的类型有花括号初始化、空指针的 0 或者 NULL、只声明的整型 static const 数据成、，模板和重载的函数名和位域。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="ch06-lambda-expressions">CH06: Lambda Expressions</h3>
<h4 id="item-31-avoid-default-capture-modeshttpsblogcsdnnetdong_hfutarticledetails125037605"><a href="https://blog.csdn.net/Dong_HFUT/article/details/125037605"target="_blank" rel="external nofollow noopener noreferrer">Item 31: Avoid default capture modes.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>C++11 lambda 表达式有两种默认捕获模式：传引用捕获和传值捕获。默认传引用捕获可能导致引用悬挂的问题。默认传值捕获其实也不能避免这个问题，并且你的 lambda 闭包也不是独立的。</p>
<p>先看默认传引用捕获导致引用悬挂的问题。看下面的代码片段：</p>
<div class="highlight" id="id-304"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">FilterContainer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">FilterContainer</span> <span class="n">filters</span><span class="p">;</span> <span class="c1">// filtering funcs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">addDivisorFilter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">calc1</span> <span class="o">=</span> <span class="n">computeSomeValue1</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">calc2</span> <span class="o">=</span> <span class="n">computeSomeValue2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">computeDivisor</span><span class="p">(</span><span class="n">calc1</span><span class="p">,</span> <span class="n">calc2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// danger! ref to divisor will dangle！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>filters</code> 存放了 <code>lamdba</code> 闭包，闭包引用了 <code>addDivisorFilter</code> 作用域内的局部变量 <code>divisor</code>，当离开 <code>addDivisorFilter</code> 作用域后，局部变量 <code>divisor</code> 将被析构，若此时使用 <code>filters</code> 则导致引用悬挂。</p>
<p>使用显示的传引用捕获也有同样的问题：</p>
<div class="highlight" id="id-305"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="o">&amp;</span><span class="n">divisor</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>             <span class="c1">// danger! ref to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// divisor will
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>                                  <span class="c1">// still dangle!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不过，显示的传引用捕获可以提醒我们 lambda 表达式的生命周期依赖于 divisor 的生命周期，也可以提醒我们需要确保 divisor 的生命周期要长于 lambda 表达式的生命周期。</p>
<p>解决上述问题，可以通过默认传值捕获的方式解决：</p>
<div class="highlight" id="id-306"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">filters</span><span class="p">.</span><span class="n">emplace</span><span class="p">.</span><span class="n">back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，默认传值捕获也不一定能够解决悬挂问题：例如你通过传值的方式捕获一个指针，也即你拷贝了一个指针给 lambda 闭包了，但是你无法阻止 lambda 闭包外指针被 delete，从而导致指针悬挂的问题。看下面的例子：</p>
<div class="highlight" id="id-307"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span> <span class="c1">// ctors, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// add an entry to filters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">divisor</span><span class="p">;</span> <span class="c1">// used in Widget&#39;s filter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码貌似是安全的。因为你通过默认传值捕获方式，应该不会有悬挂的问题。但是，lambda 表达式只能捕获作用域内的非静态局部变量，而 divisor 是一个成员变量。那么上面的代码为什么可以编译通过呢？可以先看下面这段代码：</p>
<div class="highlight" id="id-308"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">divisor</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码编译无法通过：</p>
<div class="highlight" id="id-309"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">main.cpp: In member <span class="k">function</span> <span class="s1">&#39;void Widget::addFilter() const&#39;</span>:
</span></span><span class="line"><span class="cl">main.cpp:19:6: error: capture of non-variable <span class="s1">&#39;Widget::divisor&#39;</span>
</span></span><span class="line"><span class="cl">   <span class="m">19</span> <span class="p">|</span>     <span class="o">[</span>divisor<span class="o">](</span>int value<span class="o">)</span> <span class="o">{</span> <span class="k">return</span> value % <span class="nv">divisor</span> <span class="o">==</span> 0<span class="p">;</span> <span class="o">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如我们所设想的，lambda 表达式无法捕获非静态成员变量。前面默认传值捕获之所以能够通过编译，原因其实是这里的 lambda 表达式捕获的是 this 指针，也就是将 this 指针拷贝进了闭包。编译器在内部将 divisor 替换成了 this-&gt;divisor，等价如下：</p>
<div class="highlight" id="id-310"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里实际捕获的不是 divisor，而是 this 指针。了解了上述真相后，就不难理解默认传值捕获也可能导致指针悬挂的问题了。</p>
<div class="highlight" id="id-311"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">FilterContainer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">FilterContainer</span> <span class="n">filters</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomeWork</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">pw</span><span class="o">-&gt;</span><span class="n">addFilter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>filters</code> 包含了 Widget 的 this 指针的拷贝。 doSomeWork 执行完成后，Widget 将被析构，导致 filters 包含了一个悬挂的指针。</p>
<p>上述问题可以通过使用一个局部变量拷贝成员变量来解决。如下：</p>
<div class="highlight" id="id-312"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">divisorCopy</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">;</span> <span class="c1">// copy data member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">divisorCopy</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// capture the copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisorCopy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// use the copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者默认传值捕获也是一样：</p>
<div class="highlight" id="id-313"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">divisorCopy</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">;</span> <span class="c1">// copy data member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// capture the copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisorCopy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// use the copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>c++14 的方式更加简洁：</p>
<div class="highlight" id="id-314"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>               <span class="c1">// C++14:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[</span><span class="n">divisor</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>    <span class="c1">// copy divisor to closure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// use the copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>lambda</code> 表达式只能捕获非静态局部变量，对于 <code>static</code> 或者 <code>global</code> 变量，<code>lambda</code> 表达式不会捕获。所以这些变量发生改变会影响到 <code>lambda</code> 表达的行为。使用默认传值捕获，可能会让你以为你的 <code>lambda</code> 闭包是独立的，不依赖外部变量的变化，其实不然。</p>
<div class="highlight" id="id-315"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">addDivisorFilter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">auto</span> <span class="n">calc1</span> <span class="o">=</span> <span class="n">computeSomeValue1</span><span class="p">();</span> <span class="c1">// now static
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="k">auto</span> <span class="n">calc2</span> <span class="o">=</span> <span class="n">computeSomeValue2</span><span class="p">();</span> <span class="c1">// now static
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="k">auto</span> <span class="n">divisor</span> <span class="o">=</span> <span class="c1">// now static
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">computeDivisor</span><span class="p">(</span><span class="n">calc1</span><span class="p">,</span> <span class="n">calc2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>   <span class="c1">// captures nothing!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// refers to above static
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">++</span><span class="n">divisor</span><span class="p">;</span>   <span class="c1">// modify divisor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码可能会让你产生错觉：因为是使用默认传值捕获，<code>lambda</code> 闭包是将 <code>divisor</code> 拷贝进去的。但是 <code>static</code> 变量不会被 <code>lambda</code> 闭包捕获， <code>divisor</code> 的改变会影响到 <code>lambda</code> 表达式的行为。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>默认的按引用捕获可能会导致引用悬挂。</li>
<li>默认的按值引用对于悬挂指针很敏感（尤其是this指针），并且它会误导人认为 lambda 是独立的。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-32-use-init-capture-to-move-objects-into-closureshttpsblogcsdnnetdong_hfutarticledetails125111586"><a href="https://blog.csdn.net/Dong_HFUT/article/details/125111586"target="_blank" rel="external nofollow noopener noreferrer">Item 32: Use init capture to move objects into closures.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>如果你想移动一个对象都 lambda 闭包，值捕获和引用捕获都不能实现该目的。C++ 14 提供了初始化捕获（init capture）模式支持移动捕获。C++11 并不支持，但是可以使用 std::bind 间接模拟。</p>
<p><strong>C++14 使用初始化捕获模式实现移动捕获</strong></p>
<p>C++14 提供了支持移动捕获的机制，但并没有类似值捕获 [=] 或者引用捕获 [&amp;] 的模式直接添加一个移动捕获 [&amp;&amp;] 模式。而是采取了一种更加灵活的机制 &mdash;&ndash; 初始化捕获模式。移动捕获是采用初始化捕获的机制实现，除了默认捕获模式，初始化捕获模式可以做原来 C++11 支持的所有捕获模式能做的事，甚至还更多，比如 item31 中介绍的类成员变量的捕获。初始化捕获模式语法如下：</p>
<ul>
<li>指定闭包类的成员名称。</li>
<li>指定一个表达式来初始化这个成员。</li>
</ul>
<p>看下面的例子：移动一个 std::unique_ptr 对象到 lambda 闭包。</p>
<div class="highlight" id="id-316"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="c1">// some useful type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">isValidated</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">isProcessed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">isArchived</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// create Widget;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                      <span class="c1">// see Item 21 for info on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                      <span class="c1">// std::make_unique
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                                     <span class="c1">// configure *pw
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pw</span><span class="p">)]</span>                <span class="c1">// init data mbr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span>          <span class="c1">// in closure w/
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">};</span>    <span class="c1">// std::move(pw)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在捕获列表中，<code>“=”</code> 左边的 <code>pw</code> 是指定的 <code>lambda</code> 闭包的成员名称。<code>“=”</code> 右边的 <code>std::move(pw)</code> 是指定的用于初始化闭包成员 pw 的表达式。<code>“=”</code> 两边的作用域也不一样，左边的作用域在 <code>lambda</code> 闭包中，右边的作用域是 <code>lambda</code> 表达式被定义的作用域。</p>
<p><strong>C++11 使用 std::bind 间接实现移动捕获</strong></p>
<p>C++11 使用 std::bind 间接实现移动捕获：</p>
<ul>
<li>将被捕获对象移动至 std::bind 产生的函数对象中。</li>
<li>给 lambda 表达式一个被捕获对象的引用。</li>
</ul>
<p>看下面的例子：</p>
<div class="highlight" id="id-317"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>                            <span class="c1">// C++11 emulation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="c1">// of init capture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span> <span class="cm">/* uses of data */</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和 lambda 表达式类似，std::bind 产生一个函数对象，称为绑定函数对象。std::bind 的第一个参数是可调用对象，紧接着的参数是传递给这个对象的值。</p>
<p>对于 std::bind 传递的参数，如果是左值，则拷贝到绑定函数对象中；如果是右值，则移动到绑定函数对象中。但是对于绑定函数对象而言，它的参数是一个左值引用。在这个例子中，std::bind 传递的是一个右值 std::move(data)，func 内部调用移动构造来初始化 data。</p>
<p>默认的，lambda 闭包内的 operator() 成员方法是一个 const 的，不能对参数进行修改，所以这里显示申明成 const。如果你希望可以对参数进行修改，则可以使用 mutable关键字进行修饰。</p>
<div class="highlight" id="id-318"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="c1">// C++11 emulation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="k">mutable</span> <span class="c1">// of init capture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">{</span> <span class="cm">/* uses of data */</span> <span class="p">},</span> <span class="c1">// for mutable lambda
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再给一个前面 C++14 std::unique_ptr 移动到 lambda 闭包的例子。</p>
<p>C++14 的实现如下：</p>
<div class="highlight" id="id-319"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()]</span> <span class="c1">// as before,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span>        <span class="c1">// create pw
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">};</span>  <span class="c1">// in closure
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>C++11 间接实现如下：</p>
<div class="highlight" id="id-320"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">pw</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                       <span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">              <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>C++14 使用初始化捕获模式实现移动捕获。</li>
<li>C++11 使用 std::bind 间接实现移动捕获。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-33-use-decltype-on-auto-parameters-to-stdforward-themhttpsblogcsdnnetdong_hfutarticledetails125116613"><a href="https://blog.csdn.net/Dong_HFUT/article/details/125116613"target="_blank" rel="external nofollow noopener noreferrer">Item 33: Use decltype on auto&amp;&amp; parameters to std::forward them.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>C++14 最令人激动的特性之一便是通用 lambda（generic lambda），使用 auto 指定参数类型。lambda 表达式在编译器内部可以看作一个实现 operator() 的类，使用 auto 参数的 lambda 表达式，其实就是对 operator() 模板化。</p>
<p>例如如下 lambda 表达式：</p>
<div class="highlight" id="id-321"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看作成：</p>
<div class="highlight" id="id-322"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SomeCompilerGeneratedClassName</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>        <span class="c1">// see Item 3 for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>  <span class="c1">// auto return type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">…</span>  <span class="c1">// other closure class functionality
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面这个例子中，lambda 表达式就是将它的参数 <code>x</code> 转发给 <code>normalize</code>。如果 <code>normalize</code> 处理左值和右值的方式不同，则上述代码写的并不合理，因为它总是传递左值给 <code>normalize</code>，算不上完美转发。</p>
<p>正确的做法是使用完美转发改写上面的代码。首先将参数变成万能引用，然后使用 std::forward 进行转发：</p>
<div class="highlight" id="id-323"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">{</span> <span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;???&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，<code>std::forward</code> 的参数类型怎么写呢？如果是使用参数类型 T 的模板函数，可以直接写成 <code>std::forward&lt;T&gt;</code>，但是对于通用 lambda，没有这样的 T 可以被使用。</p>
<p>在 <a href="https://blog.csdn.net/Dong_HFUT/article/details/124517043?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">item28<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中介绍过：<font color=red>如果一个左值传递给万能引用参数，则万能引用参数被推导成一个左值；若一个右值传递给万能引用参数，则万能引用参数被推导成一个右值</font>。</p>
<p>这里我们可以借助 decltype。通过 item3 的介绍我们知道：如果 x 是一个左值，则 decltype(x) 产生一个左值引用类型；如果 x 是一个右值，则 decltype(x) 产生一个右值引用类型。通用 lambda 完美转发版本可以写成：</p>
<div class="highlight" id="id-324"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">      <span class="nf">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结合 C++14 完美转发的实现进行理解：</p>
<div class="highlight" id="id-325"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设使用 Widget 类型的变量 x 初始化 param 。如果 x 是一个左值，则 decltype(x) 产生一个左值引用类型。而 remove_reference_t 去除类型。则完美转发为：</p>
<div class="highlight" id="id-326"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应用引用折叠规则，则转换为：</p>
<div class="highlight" id="id-327"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>显然，完美转发没有做类型转化。也即转发的还是一个左值的 param。</p>
<p>如果 x 是一个右值，则 decltype(x) 产生一个右值引用类型。则完美转发为：</p>
<div class="highlight" id="id-328"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应用引用折叠规则，转换为：</p>
<div class="highlight" id="id-329"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>显然，完美转发将左值 param 转换为右值。</p>
<p>综上，使用 decltype 可以实现通用引用参数的完美转发。</p>
<p>此外，C++14 的 lambda 还支持变长参数类型：</p>
<div class="highlight" id="id-330"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">      <span class="nf">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...));</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>对 auto&amp;&amp; 参数使用 decltype来转发（std::forward）。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-34-prefer-lambdas-to-stdbindhttpsblogcsdnnetdong_hfutarticledetails125130410"><a href="https://blog.csdn.net/Dong_HFUT/article/details/125130410"target="_blank" rel="external nofollow noopener noreferrer">Item 34: Prefer lambdas to std::bind.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>C++11 的 std::bind 是对 C++98 std:bind1st 和 std::bind2nd 的继承，它在 2005 年以 TR1 文档形式非正式地成为标准库的一部分。因为，许多 C++ 程序员可能有十几年的 std::bind 使用经验，现在告诉他放弃使用 std::bind，多少可能有些不情愿。但是，本 Item 会告诉你使用 lambda 替代 std::bind 将是个更好的选择。</p>
<p>对于 C++11，除了个别边缘 case，lambda 表达式要比 std::bind 更有优势。而对于 C++14，lambda 则可以完全替代 std::bind。</p>
<p>lambda 第一个优势是代码的可读性更强。例如，我们有一个设置声音报警的函数：</p>
<div class="highlight" id="id-331"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// typedef for a point in time (see Item 9 for syntax)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// see Item 10 for &#34;enum class&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Sound</span> <span class="p">{</span> <span class="n">Beep</span><span class="p">,</span> <span class="n">Siren</span><span class="p">,</span> <span class="n">Whistle</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// typedef for a length of time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Duration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">duration</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// at time t, make sound s for duration d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setAlarm</span><span class="p">(</span><span class="n">Time</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sound</span> <span class="n">s</span><span class="p">,</span> <span class="n">Duration</span> <span class="n">d</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们想在设置声音报警后 1h，关闭报警，并持续 30s。使用 lambda 表达式修正 <code>setAlarm</code>，可以实现如下：</p>
<div class="highlight" id="id-332"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// setSoundL (&#34;L&#34; for &#34;lambda&#34;) is a function object allowing a
</span></span></span><span class="line"><span class="cl"><span class="c1">// sound to be specified for a 30-sec alarm to go off an hour
</span></span></span><span class="line"><span class="cl"><span class="c1">// after it&#39;s set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">setSoundL</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">[](</span><span class="n">Sound</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// make std::chrono components available w/o qualification
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">setAlarm</span><span class="p">(</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">hours</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// alarm to go off
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>             <span class="n">s</span><span class="p">,</span> <span class="c1">// in an hour for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>             <span class="n">seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span> <span class="c1">// 30 seconds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码逻辑非常清楚。如果使用 C++14 字面值 <code>std::literals</code> 改写上面代码，可以更加简洁：</p>
<div class="highlight" id="id-333"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">setSoundL</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">[](</span><span class="n">Sound</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span> <span class="c1">// for C++14 suffixes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">setAlarm</span><span class="p">(</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="n">h</span><span class="p">,</span> <span class="c1">// C++14, but
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>             <span class="n">s</span><span class="p">,</span> <span class="c1">// same meaning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>             <span class="mi">30</span><span class="n">s</span><span class="p">);</span> <span class="c1">// as above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用 std::bind 直接替换 lambda 表达式，可以改写成如下：</p>
<div class="highlight" id="id-334"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span> <span class="c1">// as above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span> <span class="c1">// needed for use of &#34;_1&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span> <span class="c1">// &#34;B&#34; for &#34;bind&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="n">h</span><span class="p">,</span> <span class="c1">// incorrect! see below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">_1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mi">30</span><span class="n">s</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，相较于 <code>lambda</code> 版本，使用 <code>std::bind</code>，函数调用和传参不那么明显。并且这里还有一个占位符 “_1”，使用 <code>setSoundB</code> 时候，你需要查阅 <code>setAlarm</code> 的函数申明，才知道这里的占位符的传参类型。</p>
<p>最重要的是这里的代码逻辑有问题。显然，我们期望的是在调用 <code>setAlarm</code> 时候计算表达式 <code>steady_clock::now() + 1h</code> 的值。但是，使用 <code>std::bind</code> 的时候，表达式 <code>steady_clock::now() + 1h</code> 是传递给 std::bind 而不是 <code>setAlarm</code>，这意味着，在调用 <code>std::bind</code> 的时候，表达式的值就被计算出来，然后保存在绑定对象内部。这就导致和在调用 setAlarm 时候计算表达式的期望不一致。可以再使用一个 <code>std::bind</code> 封装该表达式以延迟到 <code>setAlarm</code> 调用的时候才计算：</p>
<div class="highlight" id="id-335"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">(),</span> <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="mi">1</span><span class="n">h</span><span class="p">),</span>  <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">_1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mi">30</span><span class="n">s</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意到 <code>std::plus&lt;&gt;</code> 缺省了类型参数，这是 C++14 的新特性，如果是 C++11，则需要指定类型：</p>
<div class="highlight" id="id-336"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span><span class="o">&gt;</span><span class="p">(),</span> <span class="c1">// C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                      <span class="n">hours</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">            <span class="n">_1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果 <code>setAlarm</code> 增加一个重载版本：</p>
<div class="highlight" id="id-337"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Volume</span> <span class="p">{</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">Loud</span><span class="p">,</span> <span class="n">LoudPlusPlus</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setAlarm</span><span class="p">(</span><span class="n">Time</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sound</span> <span class="n">s</span><span class="p">,</span> <span class="n">Duration</span> <span class="n">d</span><span class="p">,</span> <span class="n">Volume</span> <span class="n">v</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>先前 lambda 版本代码依然可以正常工作。但是，std::bind 将会产生编译报错。因为编译器无法确认传递哪个版本的 <code>setAlarm</code>。需要将 setAlarm 转换为合适的函数指针：</p>
<div class="highlight" id="id-338"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">SetAlarm3ParamType</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Time</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sound</span> <span class="n">s</span><span class="p">,</span> <span class="n">Duration</span> <span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span>                                        <span class="c1">// now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SetAlarm3ParamType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">),</span>  <span class="c1">// okay
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                      <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                      <span class="mi">1</span><span class="n">h</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">_1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="mi">30</span><span class="n">s</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，这又引入了 std::bind 和 lambda 二者的不同。setSoundL 使用正常的函数调用来调用 setAlarm，编译器可以选择使用内联。</p>
<div class="highlight" id="id-339"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">setSoundL</span><span class="p">(</span><span class="n">Sound</span><span class="o">::</span><span class="n">Siren</span><span class="p">);</span> <span class="c1">// body of setAlarm may
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// well be inlined here
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是 std::bind 不可以，setSoundB 使用函数指针调用调用 setAlarm，这是运行期的行为，无法被内联。</p>
<div class="highlight" id="id-340"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">setSoundB</span><span class="p">(</span><span class="n">Sound</span><span class="o">::</span><span class="n">Siren</span><span class="p">);</span> <span class="c1">// body of setAlarm is less
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                         <span class="c1">// likely to be inlined here
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这就是使用 lambda 的第二个优势：代码的性能可能会更好。</p>
<p>使用 lambda 的第三个优势是代码更容易理解。看下面的例子：</p>
<div class="highlight" id="id-341"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">CompLevel</span> <span class="p">{</span> <span class="n">Low</span><span class="p">,</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">High</span> <span class="p">};</span> <span class="c1">// compression level
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">compress</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="c1">// make compressed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">CompLevel</span> <span class="n">lev</span><span class="p">);</span>  <span class="c1">// copy of w
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设我们想创建一个函数对象，用来指定特定 <code>Widget</code> 的压缩等级。使用 std::bind 创建函数对象：</p>
<div class="highlight" id="id-342"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compressRateB</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">compress</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">_1</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>传递 <code>w</code> 给 <code>std::bind</code>，那么 w 如何存放在 <code>compressRateB</code> 内部的呢？是传值还是传引用？如果 <code>w</code> 在调用 <code>std::bind</code> 和 <code>compressRateB</code> 之间发生改变，传引用的方式将导致结果的不同。</p>
<p><code>std::bind</code> 默认是拷贝它的参数到绑定对象内，用户可以使用 <code>std::ref</code> 指定传引用：</p>
<div class="highlight" id="id-343"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compressRateB</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">compress</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">_1</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这就需要你了解 std::bind 实现机制。但对于 lambda 的实现版本，w 是值捕获还是引用捕获非常明显：</p>
<div class="highlight" id="id-344"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compressRateL</span> <span class="o">=</span>            <span class="c1">// w is captured by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">[</span><span class="n">w</span><span class="p">](</span><span class="n">CompLevel</span> <span class="n">lev</span><span class="p">)</span>            <span class="c1">// value; lev is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="k">return</span> <span class="nf">compress</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span> <span class="p">};</span> <span class="c1">// passed by value
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>同样明显的是参数如何传递给 lambda 的。这里，很明显 lev 是值传递：</p>
<div class="highlight" id="id-345"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">compressRateL</span><span class="p">(</span><span class="n">CompLevel</span><span class="o">::</span><span class="n">High</span><span class="p">);</span> <span class="c1">// arg is passed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">// by value
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，std::bind 的绑定对象的调用，参数是如何传递的？</p>
<div class="highlight" id="id-346"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">compressRateB</span><span class="p">(</span><span class="n">CompLevel</span><span class="o">::</span><span class="n">High</span><span class="p">);</span> <span class="c1">// how is arg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">// passed?
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>答案是引用传递，这就需要你了解 std::bind 的工作机制：std::bind 绑定对象的函数调用使用了完美转发机制。</p>
<p>通过上述比较我们可以看到，相较于使用 std::bind，使用 lambda 表达式的代码可读性更强、更容易理解、性能可能更好。对于 C++14，你没有理由不选择使用 lambda。对于 C++11，只有两种场景，std::bind 可以弥补 lambda 的不足：</p>
<p>第一：移动捕获。C++14 的初始化捕获模式支持移动捕获。C++11 的 lambda 不支持移动捕获，可以使用 std::bind 模拟来间接实现，参见 Item32 。</p>
<p>第二：多态函数对象。C++14 支持 auto 参数类型，也即通用 lambda，参见 Item33 。但是 C++11 不支持通用 lambda。而 std::bind 绑定对象的函数调用使用完美转发实现，可以接收任何类型的参数。如下例子：
————————————————</p>
<div class="highlight" id="id-347"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PolyWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PolyWidget</span> <span class="n">pw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">boundPW</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">pw</span><span class="p">,</span> <span class="n">_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">boundPW</span><span class="p">(</span><span class="mi">1930</span><span class="p">);</span>       <span class="c1">// pass int to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="c1">// PolyWidget::operator()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boundPW</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>    <span class="c1">// pass nullptr to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="c1">// PolyWidget::operator()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boundPW</span><span class="p">(</span><span class="s">&#34;Rosebud&#34;</span><span class="p">);</span>  <span class="c1">// pass string literal to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="c1">// PolyWidget::operator()
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>C++11 做不到，C++14 则很容易：</p>
<div class="highlight" id="id-348"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">boundPW</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="p">{</span> <span class="n">pw</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>相较于 std::bind，lambda 代码可读性更强、更容易理解、性能可能更好。</li>
<li>C++11 的 std::bind 在实现移动捕获、模板函数对象方面可以弥补 lambda 的不足。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="ch07-the-concurrency-api">CH07: The Concurrency API</h3>
<h4 id="item-35-prefer-task-based-programming-to-thread-basedhttpsblogcsdnnetdong_hfutarticledetails125702349"><a href="https://blog.csdn.net/Dong_HFUT/article/details/125702349"target="_blank" rel="external nofollow noopener noreferrer">Item 35: Prefer task-based programming to thread-based.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>如果你想异步运行一个函数 donAsyncWork，你有两个基本的选择：基于线程的方法（thread-based）和基于任务的方法（task-based）。</p>
<div class="highlight" id="id-349"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">doAsyncWork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">doAsyncWork</span><span class="p">);</span>         <span class="c1">// thread-based
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">doAsyncWork</span><span class="p">);</span> <span class="c1">// task-based
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在比较二者优劣前，我们先介绍下 C++ 软件中线程的3个层次：</p>
<ul>
<li>硬件线程。硬件实际执行计算的并行数。现代计算机架构中，一个硬件核对应一个或多个硬件线程。</li>
<li>软件线程。也被称为系统线程，指的是操作系统管理核调度的所有线程。软件线程运行在硬件线程之上，并且可以创建的软件线程要多于硬件线程。这样的好处是：当某些软件线程处于阻塞状态（等待IO、mutex、condition variable）时，可以执行其他线程以提高吞吐率。</li>
<li>std::thread。C++ 的线程对象，作为句柄对应系统的软件线程。std::thread 也可以是空句柄而不对应系统的软件线程。例如没有执行函数、执行函数被移动其他线程、已经 join 或 detached 的 std::thread 对象。</li>
</ul>
<p><mark>基于任务的方法一般要优于基于线程的方法。</mark></p>
<p>doAsyncWork 有返回值，可以代表任务的执行状态。基于线程的方法没有提供一个很好的机制获取返回值。而 std::async 返回的 std::future 对象提供了 get 方法可以获取到返回值。并且当 doAsyncWork 返回异常时，基于线程的方法直接抛出 std::terminate，而基于任务的方法可以根据返回值做异常处理。</p>
<p>系统的软件线程是有限的，当请求创建的 std::thread 多于系统提供的最大软件线程数，将抛出 std::system_error，即使 doAsyncWork 被设置成 noexcept。因而基于线程的方法需要处理这种情况，这就需要对线程进行管理。</p>
<p>即使你没有用尽软件线程，基于线程的方法还存在认购超额（oversubscription）的问题，即就绪态的软件线程高于硬件线程。操作系统会采用时间片轮询的方式执行所有的软件线程，而线程的上下文切换会增加线程管理的开销。并且硬件线程被切换到另一个软件线程时，其 cache 上的数据通常会失效，也会增加线程的开销。想要避免认购超额问题还比较困难，软件线程于硬件线程的合理比例取决于多种因素。例如硬件架构的特点、cache的使用方式、任务的特点等。</p>
<p>综上，线程的管理是比较困难的。而基于任务的方法将线程管理交给了 C++ 标准库，而 C++ 标准库可以更好地管理线程。例如，你无需担心软件线程耗尽的问题，因为默认参数的 std::async 不一定会创建线程，它可能在认购超额时将当前任务安排在当前线程上执行。另外 C++ 标准库可能比你更清楚硬件线程的资源，可以很好的避免负载不均衡的问题。</p>
<p>当然，基于线程的方法也有一定的优势：</p>
<p>需要访问实现线程的底层API。std::thread 可以获取底层线程的句柄，可以使用底层线程的API。
需要优化线程的使用。例如，如果你正在开发一个服务软件，而这个软件是这台机器上执行的唯一有意义的进程，并且你清楚这台机器的硬件配置。
需要实现一些高级的线程技术。例如线程池技术，而 C++ 标准库没有提供。
除了上述情况外，建议优先使用基于任务的编程方法。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>std::thread API 不能直接访问异步函数执行的结果，如果执行函数有异常抛出，代码终止执行。</li>
<li>基于线程的编程方式存在资源耗尽、认购超额、负载均衡的方案移植性不佳。</li>
<li>通过 std::async 的基于任务的编程方式会默认解决上面的问题。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-36-specify-stdlaunchasync-if-asynchronicity-is-essentialhttpsblogcsdnnetdong_hfutarticledetails126076160"><a href="https://blog.csdn.net/Dong_HFUT/article/details/126076160"target="_blank" rel="external nofollow noopener noreferrer">Item 36: Specify std::launch::async if asynchronicity is essential.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>当你使用 <code>std::async()</code> 执行一个函数或可调用对象时，你通常期望这个函数是异步执行。但是， <code>std::async()</code> 不一定如你所愿。其实 <code>std::async()</code> 是根据执行策略决定是否会异步执行。 <code>std::async()</code> 有两种执行策略，定义在 <code>std::launch</code> 作用域中：</p>
<p><code>std::launch::async</code> 函数或可执行对象必须异步执行，也即运行在其他线程上。
<code>std::launch::deferred</code> 函数或可执行对象延迟执行。仅在 <code>std::async()</code> 的返回对象 <code>std::future</code> 调用 <code>get</code> 或 <code>wait</code> 时，才在当前线程同步执行，并且调用者会阻塞直到函数执行完成。</p>
<p><code>std::async()</code> 的默认策略其实是二者的组合，也即以下两者涵义完全相同：</p>
<div class="highlight" id="id-350"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="c1">// run f using default launch policy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span> <span class="o">|</span>   <span class="c1">// run f either
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span> <span class="c1">// async or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                       <span class="n">f</span><span class="p">);</span>                    <span class="c1">// deferred
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认的策略下，f 可能是同步执行也可能是异步执行。正如 Item 35: Prefer task-based programming to thread-based. 中讨论的：标准库的线程管理模块承担了线程的创建和释放的职责，可以有效避免超额订阅、保证负载均衡。这极大地方便了 std::async 的使用。</p>
<p>但是，默认策略也会有如下问题：</p>
<ul>
<li>无法预测 f 是否是并发执行。</li>
<li>无法预测 f 是否运行在 get 或 wait 调用时的线程上。</li>
<li>甚至无法预测 f 是否已经执行了。因为没法保证一定会调用 get 或 wait。</li>
</ul>
<p>当 <code>f</code> 要访问本地线程存储（TLS，Thread Local Storage）时，无法预测访问的是哪个线程的本地存储。</p>
<div class="highlight" id="id-351"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="c1">// TLS for f possibly for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                          <span class="c1">// independent thread, but
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                          <span class="c1">// possibly for thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                          <span class="c1">// invoking get or wait on fut
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>std::async 的默认策略还会影响到 wait_for 超时调用写法，可能导致 bug，例如：</p>
<div class="highlight" id="id-352"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span> <span class="c1">// for C++14 duration suffixes; see Item 34
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>                       <span class="c1">// f sleeps for 1 second,  then returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mi">1</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>             <span class="c1">// run f asynchronously (conceptually)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">fut</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="mi">100</span><span class="n">ms</span><span class="p">)</span> <span class="o">!=</span>         <span class="c1">// loop until f has
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span>     <span class="c1">// finished running...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>                                     <span class="c1">// which may never happen!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果 std::async 是并发执行，也即执行策略为 std::launch::async，以上代码没有问题。但是，如果执行策略为 std::launch::deferred时，fut.wait_for 总是返回 future_status::deferred，以上代码就会有问题。解决办法也很简单，先通过 wait_for 的超时时间为 0 来检测 std::async 是异步执行还是同步执行：</p>
<div class="highlight" id="id-353"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>          <span class="c1">// as above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">fut</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="mi">0</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span>            <span class="c1">// if task is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">deferred</span><span class="p">)</span>  <span class="c1">// deferred...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="c1">// ...use wait or get on fut
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>          <span class="c1">// to call f synchronously
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>     <span class="c1">// task isn&#39;t deferred
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">fut</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="mi">100</span><span class="n">ms</span><span class="p">)</span> <span class="o">!=</span>          <span class="c1">// infinite loop not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// possible (assuming
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                         <span class="c1">// f finishes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">…</span>                <span class="c1">// task is neither deferred nor ready,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="c1">// so do concurrent work until it&#39;s ready
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>                  <span class="c1">// fut is ready
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>综上，如果你的使用场景不是以下几种，则需要考虑是否需要替换 std::async 的默认策略：</p>
<ul>
<li>当调用 <code>get</code> 或 <code>wait</code> 时，任务不需要并发执行。</li>
<li>并不关心访问的是哪个线程的本地存储。</li>
<li>可以保证 <code>get</code> 或 <code>wait</code> 一定会被调用，或者任务不被执行也能接受。</li>
<li>使用 <code>wait_for</code> 或 <code>wait_until</code> 时，需要考虑 <code>std::launch::deferred</code> 策略。</li>
</ul>
<p>如果不是以上场景，你可能需要指定使用 <code>std::launch::async</code> 策略，也即真正创建一个线程去并发执行任务：</p>
<div class="highlight" id="id-354"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>  <span class="c1">// launch f asynchronously
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里提供一个并发执行任务的封装：</p>
<div class="highlight" id="id-355"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>  <span class="c1">// C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">inline</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">Ts</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">reallyAsync</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>       <span class="c1">// return future
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>                                        <span class="c1">// for asynchronous
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>  <span class="c1">// call to f(params...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>reallyAsync</code> 接受一个可执行对象 f 和 多个参数 params，并完美转发给 std::async ，同时使用 std::launch::async 策略。C++14 版本如下：</p>
<div class="highlight" id="id-356"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span>     <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">reallyAsync</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>std::async 的默认启动策略允许是异和者同步。</li>
<li>灵活性导致访问 thread_locals 的不确定性，隐含了任务可能不会被执行的含义，会影响程序基于超时的 wait 调用。</li>
<li>只有确定是异步时才指定为 std::launch::async。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-37-make-stdthreads-unjoinable-on-all-pathshttpsblogcsdnnetdong_hfutarticledetails126195848"><a href="https://blog.csdn.net/Dong_HFUT/article/details/126195848"target="_blank" rel="external nofollow noopener noreferrer">Item 37: Make std::threads unjoinable on all paths.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>每个 <code>std::thread</code> 只会处于两种状态状态之一：其一为 <code>joinable</code>，其二为 un<code>joinable</code> 。一个 <code>joinable</code> 的 <code>std::thread</code> 对应于一个正在或可能在运行的底层线程。例如，一个对应于处于阻塞或者等待调度的底层线程的 <code>std::thread</code> 是 <code>joinable</code>。对应于底层线程的 <code>std::thread</code> 已经执行完成也可以被认为是 <code>joinable</code>。</p>
<p>而 <code>unjoinable</code> 的线程包括：</p>
<ul>
<li>默认构造的 <code>std::thread</code>。这样的 <code>std::thread</code> 没有执行函数，也就不会对应一个底层的执行线程。</li>
<li><code>std::thread</code> 对象已经被 move。其底层线程已经被绑定到其它 <code>std::thread</code>。</li>
<li><code>std::thread</code> 已经 join。已经 join 的对应 <code>std::thread</code> 的底层线程已经运行结束。</li>
<li><code>std::thread</code> 已经 detach。已经 detach 的 <code>std::thread</code> 与其对应的底层线程已经没有关系了。</li>
</ul>
<p>std::thread 的 joinabilty 状态之所以重要的原因之一是：一个 joinable 状态的 std::thread 对象的析构函数的调用会导致正在运行程序停止运行。例如，我们有一个 doWork 函数，它接收一个过滤函数 filter 和一个最大值 MaxVal 作为参数。 doWork 检查并确定所有条件满足时，对 0 到 MaxVal 执行 filter。对于这样的场景，一般会选择基于任务的方式来实现，但是由于需要使用线程的 handle 设置任务的优先级，只能使用基于线程的方法来实现（相关讨论可以参见 <a href="https://blog.csdn.net/Dong_HFUT/article/details/125702349?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">Item 35: Prefer task-based programming to thread-based.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>）。可能的实现如下：</p>
<div class="highlight" id="id-357"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">tenMillion</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span> <span class="c1">// see Item 15 for constexpr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">doWork</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">filter</span><span class="p">,</span> <span class="c1">// returns whether
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="n">tenMillion</span><span class="p">)</span>         <span class="c1">// computation was
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>                                            <span class="c1">// performed; see
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                             <span class="c1">// Item 2 for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                             <span class="c1">// std::function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">goodVals</span><span class="p">;</span>  <span class="c1">// values that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                              <span class="c1">// satisfy filter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="n">maxVal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">goodVals</span><span class="p">]</span>  <span class="c1">// populate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">{</span>                             <span class="c1">// goodVals
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxVal</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="n">goodVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">nh</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">native_handle</span><span class="p">();</span>      <span class="c1">// use t&#39;s native
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>                                 <span class="c1">// handle to set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">// t&#39;s priority
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">conditionsAreSatisfied</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>                       <span class="c1">// let t finish
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">performComputation</span><span class="p">(</span><span class="n">goodVals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>                    <span class="c1">// computation was
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>                                 <span class="c1">// performed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>                     <span class="c1">// computation was
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                                   <span class="c1">// not performed
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于上面的实现，如果 conditionsAreSatisfied() 返回 true，没有问题。如果 conditionsAreSatisfied() 返回 false 或抛出异常，<code>std::thread</code> 对象处于 <code>joinable</code> 状态，并且其析构函数将被调用，会导致执行程序停止运行。</p>
<p>你可能会疑惑为什么 <code>std::thread</code> 的析构函数会有这样的行为，那是因为其他两种选项可能更加糟糕：</p>
<p>隐式的 join。析构函数调用时，隐式去调用 join 等待线程结束。这听起来似乎很合理，但会导致性能异常，并且这有点反直觉，因为 conditionsAreSatisfied() 返回 false 时，也即条件不满足时，还在等待 filter 计算完成。
隐式 detach。析构函数调用时，隐式调用 detach 分离线程。doWork 可以快速返回，但可能导致 bug。因为 doWork 结束后，其内部的 goodVals 会被释放，但线程还在运行，并且访问 goodVals ，将导致程序崩溃。
由于 <code>joinable</code> 的线程会导致严重的后果，因此标准委员会决定禁止这样的事情发生（通过让程序停止运行的方式）。这就需要程序员确保 <code>std::thread</code> 对象在离开其定义的作用域的所有路径上都是 un<code>joinable</code> 。但是想要覆盖所有的路径并非易事，return、continue、goto、break 或者异常等都能跳出作用域。</p>
<p>无论何时，想在出作用域的路径上执行某个动作，常用的方法是将这个动作放入到一个局部对象的析构函数中。这种对象被成为 RAII（Resource Acquisition Is Initialization）对象，产生这个对象的类是 RAII 类。RAII 类在标准库中很常见，例如 STL 容器（每个容器的析构函数销毁容器中的内容并释放它的内存）中的智能指针（std::unique_ptr 析构函数调用它的 deleter 删除它指向的对象，<code>std::shared_ptr</code> 和 std::weak_ptr 的析构函数中会减少引用计数）、std::fstream 对象（析构函数关闭相应的文件）。但是 <code>std::thread</code> 对象没有标准的 RAII 类，这可能是标准委员会拒绝将 join 和 detach 作为默认选项，因为他们也不知道这个类应该有什么样的行为。</p>
<p>好在实现这样的一个类也并非难事。例如，你可以让用户指定 ThreadRAII 类在销毁时选择 join 还是 detach：</p>
<div class="highlight" id="id-358"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadRAII</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="k">class</span> <span class="nc">DtorAction</span> <span class="p">{</span> <span class="n">join</span><span class="p">,</span> <span class="n">detach</span> <span class="p">};</span>    <span class="c1">// see Item 10 for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                             <span class="c1">// enum class info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ThreadRAII</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">DtorAction</span> <span class="n">a</span><span class="p">)</span>  <span class="c1">// in dtor, take
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">action</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{}</span>            <span class="c1">// action a on t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadRAII</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>                     <span class="c1">// see below for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                            <span class="c1">// joinability test
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">DtorAction</span><span class="o">::</span><span class="n">join</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>         <span class="c1">// see below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">DtorAction</span> <span class="n">action</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关于上面代码的几点说明：</p>
<ul>
<li>构造函数只接收 <code>std::thread</code> 的右值，因为 <code>std::thread</code> 不可拷贝。</li>
<li>构造函数参数排列顺序符合调用者的直觉（std:thread 为第一个参数，DtorAction 为第二个参数），但是成员变量的初始化符合成员变量的申明顺序。在这个类中两个成员变量的前后顺序没有意义，但是通常而言，一个成员的初始化依赖另一个成员。</li>
<li><code>ThreadRAII</code> 提供了 get 函数，用于访问底层的 <code>std::thread</code> 对象。提供 get 方法访问 <code>std::thread</code>，避免了重复实现所有 <code>std::thread</code> 的接口。</li>
<li><code>ThreadRAII</code> 的析构函数首先检查 t 是否为 <code>joinable</code> 是必要的，因为对一个 un<code>joinable</code> 的线程调用 join 和 detach 将产生未定义的行为。</li>
</ul>
<p>将 <code>ThreadRAII</code> 应用于 <code>doWork</code> 的例子上：</p>
<div class="highlight" id="id-359"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">doWork</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">filter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="n">tenMillion</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">goodVals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ThreadRAII</span> <span class="n">t</span><span class="p">(</span>                           <span class="c1">// use RAII object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">,</span> <span class="n">maxVal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">goodVals</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxVal</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="n">goodVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}),</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThreadRAII</span><span class="o">::</span><span class="n">DtorAction</span><span class="o">::</span><span class="n">join</span>          <span class="c1">// RAII action
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">nh</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">native_handle</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">conditionsAreSatisfied</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">performComputation</span><span class="p">(</span><span class="n">goodVals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子中，我们选择 join 作为 ThreadRAII 析构函数的动作。正如前文所述，detach 可能导致程序崩溃，join 可能导致性能异常。两害取其轻，性能异常相对可以接受。</p>
<p>正如 <a href="https://blog.csdn.net/Dong_HFUT/article/details/123433559?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">Item 17: Understand special member function generation.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 所介绍的，由于 ThreadRAII 自定义了析构函数，编译器将不在自动生成移动操作，但没有理由让 ThreadRAII 对象不支持移动。因而，需要我们将移动操作标记为 default：</p>
<div class="highlight" id="id-360"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadRAII</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="k">class</span> <span class="nc">DtorAction</span> <span class="p">{</span> <span class="n">join</span><span class="p">,</span> <span class="n">detach</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ThreadRAII</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">DtorAction</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">action</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadRAII</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>  <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ThreadRAII</span><span class="p">(</span><span class="n">ThreadRAII</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>            <span class="c1">// support
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ThreadRAII</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ThreadRAII</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// moving
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>               <span class="c1">// as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">DtorAction</span> <span class="n">action</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>在所有路径上保证 thread 是 unjoinable 的。</li>
<li>析构时 join 会导致难以调试的性能异常问题。</li>
<li>析构时 detach 会导致难以调试的未定义行为。</li>
<li>在成员列表的最后声明 std::thread 类型成员。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-38-be-aware-of-varying-thread-handle-destructor-behaviorhttpsblogcsdnnetdong_hfutarticledetails126435546"><a href="https://blog.csdn.net/Dong_HFUT/article/details/126435546"target="_blank" rel="external nofollow noopener noreferrer">Item 38: Be aware of varying thread handle destructor behavior.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>Item 37 介绍了 std::thread 对应一个底层的系统执行线程，一个非 deferred 任务的 future（这里包括 std::future 和 std::shared_future，下同）也对应一个底层的系统执行线程。一个 joinable 的 std::thread 对象析构时会导致程序终止，因为隐式的 join() 和隐式的 detach() 可能会更加糟糕。但是，future 的析构函数可能是隐式地执行 detach()，也可能是隐式地执行 join()，或者二者皆不是。本 Item 将和大家探讨下这个问题。</p>
<p>直观地观察，被调用者（callee）和调用者（caller）之间有一个通信通道（channel），callee 异步执行完成后，将结果写入（通常通过 std::promise 对象）这个通道，caller 通过 future 读取结果。类似下面这个模型：</p>
<p></p>
<p>但是，这个模型有点问题：callee 的结果存储在哪里？首先，不能存储在 callee 的 std::promise 对象中，因为 caller 在调用 future 的 get 方法之前，callee 可能已经结束了，callee 的局部变量 std::promise 已经销毁了。再者，callee 的结果也不能存储在 caller 的 std::future 中，因为 std::future 可以用来创建 std::shared_future ，那么这个结果就需要被拷贝多次，不是所有结果的类型都是可以拷贝的。其实 callee 的结果是被存储在独立于 caller 和 callee 之外的特殊位置，被成为共享状态（shared state）的位置。模型如下：</p>
<p></p>
<p>由于这个共享状态的存在， future 的析构函数的行为则与这个共享状态关联的 future 决定：</p>
<ul>
<li>由 std::async 发起的非 deferred 的任务的返回的 future 对象，并且它是最后一个引用共享状态的，那么它的析构会一直阻塞到任务完成，也就是隐式执行 join()。</li>
<li>其他的 future 只是简单的销毁。对于异步任务，类似隐式执行 detach()，对于 deferred 策略的任务则不再运行。</li>
</ul>
<p>反过来看，future 会隐式执行 join() 需要满足下面 3 个条件：</p>
<ul>
<li>future 是由 std::async 创建产生，并且引用共享状态。</li>
<li>std::async 指定的任务策略是 std::launch::async。</li>
<li>future 是最后一个引用共享状态的对象。</li>
</ul>
<p>future 的 API 没有提供它是否由 std::async 产生并指向共享状态，因此，对于任意的 future，我们无法知道它的析构函数会不会阻塞到任务完成。</p>
<div class="highlight" id="id-361"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// this container might block in its dtor, because one or more
</span></span></span><span class="line"><span class="cl"><span class="c1">// contained futures could refer to a shared state for a non-
</span></span></span><span class="line"><span class="cl"><span class="c1">// deferred task launched via std::async
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">futs</span><span class="p">;</span>   <span class="c1">// see Item 39 for info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// on std::future&lt;void&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>                         <span class="c1">// Widget objects might
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>                                <span class="c1">// block in their dtors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">fut</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你知道给定的 future 不满足上述 3 个条件，那么其析构函数就不会阻塞住。例如，future 来自于 std::packaged_task：</p>
<div class="highlight" id="id-362"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">calcValue</span><span class="p">();</span>               <span class="c1">// func to run
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span>      <span class="c1">// wrap calcValue so it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pt</span><span class="p">(</span><span class="n">calcValue</span><span class="p">);</span>               <span class="c1">// can run asynchronously
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>    <span class="c1">// get future for pt
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一般地， std::packaged_task pt 需要运行在一个 std::thread 上， std::packaged_task 的 future 是的析构是结束程序，还是执行 join，异或执行 detach，交给了对应的 std::thread 接下来的行为了：</p>
<div class="highlight" id="id-363"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>                                  <span class="c1">// begin block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pt</span><span class="p">(</span><span class="n">calcValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pt</span><span class="p">));</span>   <span class="c1">// std::packaged_task 不可拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>                              <span class="c1">// see below
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                                  <span class="c1">// end block
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>“…”</code> 就是接下来操作 t 的代码，可能如下：</p>
<ul>
<li>t 什么也没做（没有 join 也没有 detach）。在 block 结束时， t 是 joinable 的，这会导致程序终止。</li>
<li>t 执行 join 。这个时候， fut 的析构函数没有必要再执行 join。</li>
<li>t 执行 detach 。这个时候， fut 的析构函数没有必要再执行 detach。</li>
</ul>
<p>下面给一个测例作为验证：</p>
<div class="highlight" id="id-364"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono_literals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mi">3</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">pt</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pt</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// t.join();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// t.detach();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hello!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>执行结果如下：</p>
<div class="highlight" id="id-365"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">terminate</span> <span class="n">called</span> <span class="n">without</span> <span class="n">an</span> <span class="n">active</span> <span class="n">exception</span>
</span></span><span class="line"><span class="cl"><span class="n">Aborted</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将 <code>join</code> 或者 <code>detach</code> 部分代码打开，则不会产生上述问题。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>future 的正常析构行为只是销毁 future 本身的成员数据。</li>
<li>最后一个引用通过 std::async 创建的 non-deferred 任务的共享状态的 future 会阻塞到任务结束。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-39-consider-void-futures-for-one-shot-event-communicationhttpsblogcsdnnetdong_hfutarticledetails126895081"><a href="https://blog.csdn.net/Dong_HFUT/article/details/126895081"target="_blank" rel="external nofollow noopener noreferrer">Item 39: Consider void futures for one-shot event communication.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>对于两个异步任务，经常需要一个任务（检测线程）告诉另一个任务（反应线程）特定的事件已经发生了，反应线程可以继续执行了。这个事件可能是某个数据结构被初始化了，某一阶段计算完成了，或者一个传感器数据已经采集好了。需要一种机制来完成两个任务线程间的通信，有哪些比较好的方法呢？</p>
<p><strong>使用条件变量</strong></p>
<p>一个明显的方法就是使用条件变量。检测线程在特定事件发生后，通过条件变量通知反应线程。反应线程需要借助 std::mutex 和 std::unique_lock（std::unique_lock 和 std::lock_guard 都是管理锁的工具，都是 RAII 类；它们都是在定义时获得锁，在析构时释放锁。它们的主要区别在于 std::unique_lock 管理锁机制更加灵活，可以再需要的时候进行 lock 或者 unlock ，不必须得是析构或者构造时。因而为了防止线程一直占用锁，条件变量选择和 std::unique_lock 一起工作，条件变量的 wait 系列方法会在阻塞时候自动释放锁）。代码逻辑如下：</p>
<div class="highlight" id="id-366"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>   <span class="c1">// condvar for event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>                 <span class="c1">// mutex for use with cv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 检测线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                     <span class="c1">// detect event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>      <span class="c1">// tell reacting task
</span></span></span><span class="line"><span class="cl"><span class="c1">// cv.notify_all();   // tell multiple reacting task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 反应线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                                        <span class="c1">// prepare to react
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>                                        <span class="c1">// open critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>    <span class="c1">// lock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>                           <span class="c1">// wait for notify;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                         <span class="c1">// this isn&#39;t correct!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>                                      <span class="c1">// react to event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                         <span class="c1">// (m is locked)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                                        <span class="c1">// close crit. section;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                         <span class="c1">// unlock m via lk&#39;s dtor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                                        <span class="c1">// continue reacting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                         <span class="c1">// (m now unlocked)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码除了使用锁使程序变得复杂以外，还存在以下问题：</p>
<ul>
<li>如果检测线程在反应线程 cv.wait 前发出通知，反应线程将会错过通知而永远不会被唤醒。</li>
<li>反应线程的 cv.wait 存在被虚假唤醒的可能（由于操作系统的问题，wait 在不满足条件时，也可能被唤醒，也即虚假唤醒）。虽然可以给 wait 传谓词参数，用于判断是否为真的唤醒，但是多数情况先并没有好的判断方法。</li>
</ul>
<div class="highlight" id="id-367"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">[]{</span> <span class="k">return</span> <span class="n">whether</span> <span class="n">the</span> <span class="n">event</span> <span class="n">has</span> <span class="n">occurred</span><span class="p">;</span> <span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>使用共享的flag</strong></p>
<p>大家可能会想到使用一个共享的 flag 来实现不同线程的同步。代码逻辑如下：</p>
<div class="highlight" id="id-368"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">flag</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>   <span class="c1">// shared flag; see Item 40 for std::atomic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 检测线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                    <span class="c1">// detect event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>         <span class="c1">// tell reacting task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 反应线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                   <span class="c1">// prepare to react
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">);</span>      <span class="c1">// wait for event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                   <span class="c1">// react to event
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种方法的缺点是反应线程在等待过程中不阻塞的，而是轮询机制，一直处在运行状态，也就是仍然占用硬件资源。</p>
<p><strong>使用条件变量加共享的flag</strong></p>
<p>还可以将条件变量和共享 flag 结合使用，flag 表示是否为发生了关心的事件。通过 std::mutex 同步访问 flag，就无需使用 std::atomic 类型的 flag 了，只要简单的 bool 类型即可。</p>
<div class="highlight" id="id-369"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">flag</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 检测线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                                    <span class="c1">// detect event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// lock m via g&#39;s ctor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>                       <span class="c1">// tell reacting task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                     <span class="c1">// (part 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                                    <span class="c1">// unlock m via g&#39;s dtor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>                     <span class="c1">// tell reacting task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                     <span class="c1">// (part 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 反应线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                                      <span class="c1">// prepare to react
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">flag</span><span class="p">;</span> <span class="p">});</span>    <span class="c1">// use lambda to avoid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// spurious wakeups
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>                                    <span class="c1">// react to event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// (m is locked)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">…</span>                                      <span class="c1">// continue reacting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// (m now unlocked)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种方法功能上没有什么问题，就是代码稍微复杂了些。</p>
<p><strong>使用 future</strong></p>
<p>在 <a href="https://blog.csdn.net/Dong_HFUT/article/details/126435546?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">Item38<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中介绍了 std::future 和 std::promise 的通信方式。std::future 内部存储了一个将来会被赋值的值，并可以通过 get 方法访问。而 std::promise 在将来给这个值赋值，每个 std::promise 内部都有一个 std::future 对象，std::promise 和其内部的 std::future 共享这个值。我们并不关心这个值具体是啥，因而 std::promise 和 std::future 的模板类型使用 void 即可。代码逻辑如下：</p>
<div class="highlight" id="id-370"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>      <span class="c1">// promise for communications channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 检测线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                  <span class="c1">// detect event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>     <span class="c1">// tell reacting task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 反应线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                       <span class="c1">// prepare to react
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>  <span class="c1">// wait on future corresponding to p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">…</span>                       <span class="c1">// react to event
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用这种方法的优点包括：避免了使用 mutex，wait 是真阻塞的，也没有条件变量的 notify 在 wait 之前执行的问题。</p>
<p>当然这种方法也有缺点。首先 std::future 和 std::promise 间的共享状态是动态申请的堆内存，需要堆资源的申请和释放，有一定的开销。更重要的问题是，由于 std::promise 只能设置值一次，因而这种通知机制是一次性的。</p>
<p>假设你想让反应线程创建后暂停执行，直到期望的事件发生后继续执行，使用基于 future 的方法是一个不错的选择。例如：</p>
<div class="highlight" id="id-371"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">react</span><span class="p">();</span>           <span class="c1">// func for reacting task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">detect</span><span class="p">()</span>                             <span class="c1">// func for detecting task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([]</span>                        <span class="c1">// create thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>  <span class="c1">// suspend t until
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">react</span><span class="p">();</span>                <span class="c1">// future is set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>                                       <span class="c1">// here, t is suspended
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                          <span class="c1">// prior to call to react
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>                          <span class="c1">// unsuspend t (and thus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                          <span class="c1">// call react)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>                                       <span class="c1">// do additional work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>                               <span class="c1">// make t unjoinable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>                                         <span class="c1">// (see Item 37)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了让 detect 的所有出口 t 都是 unjoinable 的，应该使用 Item37 中介绍的 ThreadRAII 类的，例如：</p>
<div class="highlight" id="id-372"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">detect</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadRAII</span> <span class="n">tr</span><span class="p">(</span> <span class="c1">// use RAII object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([]</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                  <span class="n">react</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="p">}),</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThreadRAII</span><span class="o">::</span><span class="n">DtorAction</span><span class="o">::</span><span class="n">join</span> <span class="c1">// risky! (see below)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">…</span>              <span class="c1">// thread inside tr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">// is suspended here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span> <span class="c1">// unsuspend thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">// inside tr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然而，上述代码还存在问题。如果在第一个 “…” 的地方发生异常，p 的 set_value 不会被执行，那么 lambda 函数中的 wait 永远不会返回，由于 tr 的类型是 join 的，则 tr 的析构永远不会完成，代码将会挂起（见 <a href="http://scottmeyers.blogspot.com/2013/12/threadraii-thread-suspension-trouble.html"target="_blank" rel="external nofollow noopener noreferrer">http://scottmeyers.blogspot.com/2013/12/threadraii-thread-suspension-trouble.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中的相关讨论）。</p>
<p>这里给出不使用 RAII 类 Thread 的方法使其挂起然后取消挂起，这里关键是使用 std::shared_future 代替 std::future，std::future 的 share 成员函数将共享状态所有权转移到 std::shared_future：</p>
<div class="highlight" id="id-373"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">detect</span><span class="p">()</span>                          <span class="c1">// now for multiple
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>                                      <span class="c1">// reacting tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">share</span><span class="p">();</span>    <span class="c1">// sf&#39;s type is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// std::shared_future&lt;void&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">vt</span><span class="p">;</span>         <span class="c1">// container for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// reacting threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threadsToRun</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="n">sf</span><span class="p">]{</span> <span class="n">sf</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>   <span class="c1">// wait on local
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                          <span class="n">react</span><span class="p">();</span> <span class="p">});</span> <span class="c1">// copy of sf; see
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>                                    <span class="c1">// Item 42 for info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// on emplace_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>                                    <span class="c1">// detect hangs if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                       <span class="c1">// this &#34;…&#34; code throws!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>                       <span class="c1">// unsuspend all threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">…</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span>                 <span class="c1">// make all threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>                          <span class="c1">// unjoinable; see Item 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>                                    <span class="c1">// for info on &#34;auto&amp;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样，就可以很好地使用 future 实现线程间的一次性通信。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>对于简单的事件通信，基于条件变量的方法需要一个多余的互斥锁、对检测和反应任务的相对进度有约束，并且需要反应任务来确认事件是否已发生。</li>
<li>基于 flag 的方法可以避免的上一条的问题，但是不是真正的阻塞任务。</li>
<li>组合条件变量和 flag 使用，上面的问题都解决了，但是逻辑让人多少有点感觉有点生硬。</li>
<li>使用 std::promise 和 future 的方案可以避免这些问题，但为共享状态使用了堆内存，并且仅限于一次性通信。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-40-use-stdatomic-for-concurrency-volatile-for-special-memoryhttpsblogcsdnnetdong_hfutarticledetails127013499"><a href="https://blog.csdn.net/Dong_HFUT/article/details/127013499"target="_blank" rel="external nofollow noopener noreferrer">Item 40: Use std::atomic for concurrency, volatile for special memory.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>本 Item 探讨一下 atomic 类型和 volatile 关键字在并发程序中的区别和应用。</p>
<p>C++11 提供了 std::atomic 类模版，可以保证操作的原子性，确保其他线程看到的肯定是操作后的结果。类似对操作加锁，而其内部使用特殊指令实现，因而开销较小。考虑下面的应用场景：</p>
<div class="highlight" id="id-374"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ai</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// initialize ai to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ai</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>                 <span class="c1">// atomically set ai to 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ai</span><span class="p">;</span>         <span class="c1">// atomically read ai&#39;s value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="n">ai</span><span class="p">;</span>                    <span class="c1">// atomically increment ai to 11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">--</span><span class="n">ai</span><span class="p">;</span>                    <span class="c1">// atomically decrement ai to 10
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面代码执行过程中，其他线程读取 ai 的值只能是 0、10、11，不会有其他的值。这里面有两个方面值得注意：</p>
<ul>
<li>其一，std::cout &laquo; ai 这整个操作不是原子的，只能保证 ai 的读取是原子的，不能保证整个语句是原子的，也就是说在 ai 读取后和写到标准输出之间的时刻，ai 的值可以被其他线程修改。不过，也不影响到 ai 的输出值，因为 operator&laquo; 是值拷贝的。</li>
<li>其二，对于最后两条语句（++ai、&ndash;ai），它们都是 read-modify-write（RMW）类型操作，都是原子执行的。</li>
</ul>
<p>而对于使用 volatile 关键字的对应的例子：</p>
<div class="highlight" id="id-375"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="nf">vi</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// initialize vi to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vi</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>             <span class="c1">// set vi to 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vi</span><span class="p">;</span>     <span class="c1">// read vi&#39;s value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="n">vi</span><span class="p">;</span>                <span class="c1">// increment vi to 11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">--</span><span class="n">vi</span><span class="p">;</span>                <span class="c1">// decrement vi to 10
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上述代码执行过程中，其他线程读取到 vi 值可能是任一值，例如 -12、68、4090727，这是一种位定义的行为。再考虑下面的场景：</p>
<div class="highlight" id="id-376"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ac</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// &#34;atomic counter&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">volatile</span> <span class="kt">int</span> <span class="nf">vc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// &#34;volatile counter&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Thread 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="n">ac</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">++</span><span class="n">vc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Thread 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="n">ac</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">++</span><span class="n">vc</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>两个线程完成后，ac 的值肯定是 2，因为 ac 的 RMW 过程是保证原子的。但 vc 的值却不一定是 2，因为 vc 的 RMW 过程可以是交替进行的，例如：</p>
<ol>
<li>线程1 读取 vc 的值，为 0。</li>
<li>线程2 读取 vc 的值，仍然为 0。</li>
<li>线程1 将读取的 vc 值从增加到 1，然后写进 vc 的内存。</li>
<li>线程2 将读取的 vc 值从增加到 1，然后写进 vc 的内存。</li>
</ol>
<p>这样， vc 的值最终为 1 。vc 最终的值是不可预测的，这是一种未定义的行为。</p>
<p>这种 RMW 行为的原子性并不是关键字 volatile 和 atomic 类型的唯一区别。考虑这样一个场景：当一个线程完成一个重要计算后，通知另外一个线程。Item 39: Consider void futures for one-shot event communication. 讨论这一场景的方案。这里，我们使用 atomic 变量通信。代码类似如下：</p>
<div class="highlight" id="id-377"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">valAvailable</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">imptValue</span> <span class="o">=</span> <span class="n">computeImportantValue</span><span class="p">();</span> <span class="c1">// compute value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">valAvailable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>                      <span class="c1">// tell other task it&#39;s available
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从代码顺序上看，imptValue 的赋值发生在 valAvailable 赋值之前。但事实并未一定如此，编译器可以对改变二者的执行顺序以提高性能，例如：</p>
<div class="highlight" id="id-378"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为两个赋值语句不互相依赖，编译器可以重排序如下：</p>
<div class="highlight" id="id-379"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>即使编译器不重排序，底层的硬件也可能做重排序。</p>
<p>但是 <code>std::atomic</code> 的使用禁止了编译器和底层硬件对这段代码的重排序，这种行为称为顺序一致性模型。而 <code>volatile</code> 无法阻止这种重排序。</p>
<p><code>volatile</code> 无法保证操作的原子性和无法阻止指令的重排序，这就导致了它在并发编程中很少使用，那么 <code>volatile</code> 的使用场景是什么呢？简而言之，<code>volatile</code> 用于告诉编译器它所处理的内存表现的不太“正常”。“正常”的内存有这样的特点：将一个值写入内存，这个值保持不变，直到它被改写。例如：</p>
<div class="highlight" id="id-380"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// read x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// read x again
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码中，多次读取 x 的值，编译器可以这样优化：会将 x 的值放在寄存器中，再读取 x 的值时，直接从寄存器中读取即可。</p>
<p>对于写内存，编译器也会做优化。例如：</p>
<div class="highlight" id="id-381"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// write x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// write x again
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>编译器会进行优化：只执行了 x = 12 条语句，而删除 x = 10 这条语句。</p>
<p>上述的优化对于“正常”行为的内存是适用的，但对于特殊的内存并不适用。最常见的这种特殊内存用于 memory-mapped I/O，这种内存用于和外设通信：</p>
<div class="highlight" id="id-382"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// read x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// read x again
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的两次写内存都会对外设产生影响。例如外设根据该内存的值显示波形，那么上述多条写内存的操作就不是冗余的。对于这种情况来说必需使用 volatile 来告诉编译器禁止对变量的读写进行优化。例如：</p>
<div class="highlight" id="id-383"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// read x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// read x again (can&#39;t be optimized away)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// write x (can&#39;t be optimized away)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// write x again
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>而 std::atomic 无法做到这一点。例如：</p>
<div class="highlight" id="id-384"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// write x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// write x again
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可能被编译器优化为：</p>
<div class="highlight" id="id-385"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// write x
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>而对于：</p>
<div class="highlight" id="id-386"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// error!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// error!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上无法编译的，因为 std::atomic 的拷贝操作是被 deleted 的。std::atomic 的成员函数 load 和 store 可以提供这样的功能：</p>
<div class="highlight" id="id-387"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">td</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">());</span> <span class="c1">// read x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>           <span class="c1">// read x again
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于上述代码，编译器可能优化为：</p>
<div class="highlight" id="id-388"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">register</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>           <span class="c1">// read x into register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="k">register</span><span class="p">);</span>  <span class="c1">// init y with register value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="k">register</span><span class="p">);</span>             <span class="c1">// store register value into y
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以将二者结合起来使用。例如：</p>
<div class="highlight" id="id-389"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">volatile</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vai</span><span class="p">;</span>  <span class="c1">// operations on vai are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">// atomic and can&#39;t be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">// optimized away
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以用于 memory-mapped I/O 内存，并被多线程访问。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>std::atomic 用于不使用锁的多线程数据访问，用于编写并发程序。</li>
<li>volatile 阻止内存的读写优化。用于特殊内存的场景。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="ch08-tweaks">CH08: Tweaks</h3>
<h4 id="item-41-consider-pass-by-value-for-copyable-parameters-that-are-cheap-to-move-and-always-copiedhttpsblogcsdnnetdong_hfutarticledetails127054642"><a href="https://blog.csdn.net/Dong_HFUT/article/details/127054642"target="_blank" rel="external nofollow noopener noreferrer">Item 41: Consider pass by value for copyable parameters that are cheap to move and always copied.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>C++ 函数参数传递方式有值传递、指针传递、引用传递的方式。一般地，考虑到拷贝开销，建议使用引用传递的方式。例如：</p>
<div class="highlight" id="id-390"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">addName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">newName</span><span class="p">)</span> <span class="c1">// take lvalue;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="p">}</span>            <span class="c1">// copy it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">addName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">)</span>      <span class="o">//</span> <span class="n">take</span> <span class="n">rvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">));</span> <span class="p">}</span> <span class="c1">// move it; see
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>                                      <span class="c1">// Item 25 for use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                           <span class="c1">// of std::move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于左值，拷贝进 Widget.names 中。对于右值，移动进 Widget.names。上面代码是有效的，但是实现和维护两个函数有点冗余。</p>
<p>另一种方案是使用万能引用（universal reference）传参。例如：</p>
<div class="highlight" id="id-391"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>                            <span class="c1">// take lvalues
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">addName</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">)</span>                       <span class="c1">// and rvalues;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>                                               <span class="c1">// copy lvalues,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newName</span><span class="p">));</span>    <span class="c1">// move rvalues;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>                                               <span class="c1">// see Item 25
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                                  <span class="c1">// for use of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>                                             <span class="c1">// std::forward
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>万能引用版本代码量减少了很多，看起来也清爽很多，但也会有其他问题。但模板的实现一般要放到头文件里，也会实例化出多个版本（左值版本、右值版本以及可以转换为 std::string 的类型版本）。于此同时，还存在诸如 <a href="https://blog.csdn.net/Dong_HFUT/article/details/124787082?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">Item 30<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 介绍万能引用和完美转发失效的例子、<a href="https://blog.csdn.net/Dong_HFUT/article/details/124227488?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">Item 27<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 介绍的传参错误时编译报错可读性很差的问题。</p>
<p>那么有没有什么完美的方案可以解决上述两种方案遇到的问题呢？我们来分析下值传递的方案。</p>
<div class="highlight" id="id-392"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">addName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newName</span><span class="p">)</span>         <span class="c1">// take lvalue or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">));</span> <span class="p">}</span>  <span class="c1">// rvalue; move it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 addName 内对 newName 使用 std::move 可以减少一次拷贝。这里使用 std::move 考虑到两点：首先，newName 独立于传入的参数，不会影响到调用者；再者，这里是最后使用 newName 的地方，对其移动不会影响其他代码。</p>
<p>值传递的方案可以解决引用重载版本的源码冗余问题和万能引用版本的不适用场景、传参错误报错信息可读性等问题，那剩下的问题就是值传递方案的性能了。</p>
<p>在 C++98 中，对于值传递的方案，不管传入的左值还是右值，newName 都会通过拷贝构造函数来构造。而到了 C++11，newName 在传入左值时是拷贝构造，传入右值是移动构造。考虑到下面的代码：</p>
<div class="highlight" id="id-393"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">(</span><span class="s">&#34;Bart&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">w</span><span class="p">.</span><span class="n">addName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>            <span class="c1">// call addName with lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">w</span><span class="p">.</span><span class="n">addName</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#34;Jenne&#34;</span><span class="p">);</span>  <span class="c1">// call addName with rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">// (see below)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于第一个调用，参数 <code>newName</code> 使用左值初始化，是拷贝构造。对于第二个调用，参数 <code>newName</code> 使用右值初始化，是移动构造。</p>
<p>我们把上述三种方案写到一起再对比下性能：</p>
<div class="highlight" id="id-394"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>                             <span class="c1">// Approach 1:overload for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>                                    <span class="c1">// lvalues and rvalues.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">addName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">newName</span><span class="p">)</span> <span class="c1">// take lvalue;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="p">}</span>            <span class="c1">// copy it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">addName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">)</span>      <span class="o">//</span> <span class="n">take</span> <span class="n">rvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">));</span> <span class="p">}</span> <span class="c1">// move it; see
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>                                      <span class="c1">// Item 25 for use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                           <span class="c1">// of std::move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>                             <span class="c1">// Approach 2: use universal reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">addName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">newName</span><span class="p">)</span> <span class="c1">// take lvalue;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="p">}</span>            <span class="c1">// copy it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">addName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">)</span>      <span class="o">//</span> <span class="n">take</span> <span class="n">rvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">));</span> <span class="p">}</span> <span class="c1">// move it; see
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>                                      <span class="c1">// Item 25 for use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                           <span class="c1">// of std::move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>                              <span class="c1">// Approach 3: pass by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">addName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newName</span><span class="p">)</span>         <span class="c1">// take lvalue or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">));</span> <span class="p">}</span>  <span class="c1">// rvalue; move it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>同样，考虑上面两种调用方式：</p>
<div class="highlight" id="id-395"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">(</span><span class="s">&#34;Bart&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">w</span><span class="p">.</span><span class="n">addName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>            <span class="c1">// call addName with lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">w</span><span class="p">.</span><span class="n">addName</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#34;Jenne&#34;</span><span class="p">);</span>  <span class="c1">// call addName with rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">// (see below)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，我们忽略掉编译器根据上下文信息所做的编译优化的干扰，对比下三种方案的性能开销：</p>
<ul>
<li><strong>引用重载</strong>：首先，无论是左值还是右值重载函数， 调用者的实参是被绑定到引用 newName上，没有拷贝或移动开销。再者，对于左值引用重载函数， newName 被拷贝到 Widget::names 内，而对于右值引用重载函数，newName 被移动到 Widget::names 内。总的来说，左值需要一次拷贝，右值需要一次移动。</li>
<li><strong>万能引用</strong>：首先，调用者的实参也是被绑定到引用 newName上，也没有拷贝或移动开销。再者，由于使用了 std::forward ，左值实参则被拷贝到 Widget::names 内，而右值实参则被移动到 Widget::names 内。总的来说，左值需要一次拷贝，右值需要一次移动。对于调用者传入的参数不是 std::string 类型，而是可以转换为 std::string 的类型，比如 char* 类型，对于引用重载版本，需要先将 char* 构造成 std::string，这会增加其开销，而万能引用版本则直接将 char* 转发给 std::string 构造函数直接构造 std::string 类型，详见 Item 25 。这里不考虑这种特殊情况。</li>
<li><strong>值传递</strong>：首先，对于左值，需要调用拷贝构造 newName，而对于右值，需要移动构造 newName。再者， newName 被无条件移动到 Widget::names 内。总的来说，左值需要一次拷贝加一次移动，右值需要两次移动。相较于前两种引用传参的方法，多了一次移动操作。</li>
</ul>
<p>再回头看下本 Item 的标题： Consider pass by value for copyable parameters that are cheap to move and always copied。缘于以下四个原因：</p>
<ol>
<li>只考虑值传递的话，只需要写一个函数，目标代码中也会生成一个函数，并且可以避免万能引用方法的问题。但是引入了一点性能开销。</li>
<li>只对可拷贝的参数使用值传递方法。如果参数是 move-only 的，那值传递的方法肯定会失败。对于 move-only 类型参数，也无须提供左值引用重载函数，只需要一个右值引用的重载函数即可。例如，对于传递 std::unique_ptr 类型参数：</li>
</ol>
<div class="highlight" id="id-396"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">	<span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">setPtr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;&amp;</span> <span class="n">ptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">w</span><span class="p">.</span><span class="n">setPtr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;Modern C++&#34;</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码，<code>std::make_unique&lt;std::string&gt;(&quot;Modern C++&quot;)</code> 产生一个右值，然后被移动到成员变量 p 上。因此总的开销是一次移动。如果只提供值传递的方法：
<code>c++ class Widget { public: ... void setPtr(std::unique_ptr&lt;std::string&gt; ptr) { p = std::move(ptr); } ... }; </code></p>
<p>相同的调用，会隐式移动构造 <code>ptr</code>，接着移动赋值给<code>p</code>。因而总的开销则是两次移动操作。
3. 只有当移动开销低时才考虑值传递方法。因为只有当移动开销很低时，额外的一次移动才是可接受的。否则，执行一次不必要的移动操作和执行一次不必要的拷贝操作是类似的，都一样违反了 C++98 中避免值拷贝这一规则。
4. 只有当参数总是要被拷贝的时才考虑值传递方法。假设在将参数放入 Widget::names 内之前先对参数进行合法性检查，满足条件才放入到 Widget::names 内。例如：</p>
<div class="highlight" id="id-397"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">addName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">newName</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">minLen</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">newName</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">maxLen</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newName</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果不满足条件则会浪费 newName 的构造和析构的开销，想比较而言，引用传参开销更小。</p>
<p>即使上述条件都满足（移动开销低的可拷贝参数被无条件拷贝）时，值传递也不一定适用。函数参数的拷贝有两种方式：通过构造（拷贝构造或移动构造）和通过赋值（拷贝赋值或移动赋值）。上面例子中的 addName 使用的就是构造的方式，其参数 newName 通过拷贝构造创建了一个新的元素放在 std::vector 的尾部。这种情况比引用传参多一次移动。</p>
<p>当参数通过赋值拷贝，情况要复杂的多。例如，你有一个表示密码的类，由于密码可以被改变，需要同时提供 setter 和 changeTo 两个方法，值传递方法的实现如下：</p>
<div class="highlight" id="id-398"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Password</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Password</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pwd</span><span class="p">)</span>  <span class="c1">// pass by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">:</span> <span class="n">text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pwd</span><span class="p">))</span> <span class="p">{}</span>           <span class="c1">// construct text
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">changeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newPwd</span><span class="p">)</span>   <span class="c1">// pass by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="n">text</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newPwd</span><span class="p">);</span> <span class="p">}</span>       <span class="c1">// assign text
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>                  <span class="c1">// text of password
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">initPwd</span><span class="p">(</span><span class="s">&#34;Supercalifragilisticexpialidocious&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Password</span> <span class="nf">p</span><span class="p">(</span><span class="n">initPwd</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，<code>p.text</code> 通过构造函数进行了密码的初始化。通过前面的分析可知，相比较引用传递的方法，多了一次额外的移动开销。当通过下面的方式修改密码时：</p>
<div class="highlight" id="id-399"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newPassword</span> <span class="o">=</span> <span class="s">&#34;Beware the Jabberwock&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="p">.</span><span class="n">changeTo</span><span class="p">(</span><span class="n">newPassword</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>changeTo 采用的是赋值构造，值传递的方法会产生性能问题。构造 newPwd 时， std::string 的构造函数会被调用，这个构造函数中会分类内存来保存 newPwd，然后， newPwd 移动赋值给 text，这将导致 text 原来指向的内存会释放掉。也就是说，修改密码的过程发生一次内存的申请和一次内存的释放。其实在这里，旧的密码（“Supercalifragilisticexpialidocious”）比新的密码（“Beware the Jabberwock”）长度更长，没有必要申请或者释放内存。如果采用下面引用重载的方法，很可能申请和释放内存都不会发生：</p>
<div class="highlight" id="id-400"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Password</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">changeTo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">newPwd</span><span class="p">)</span> <span class="c1">// the overload
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>                                        <span class="c1">// for lvalues
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">text</span> <span class="o">=</span> <span class="n">newPwd</span><span class="p">;</span>          <span class="c1">// can reuse text&#39;s memory if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">// text.capacity() &gt;= newPwd.size()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当 text 的字符串长度大于 newPwd 的时会复用已经分配的内存。因此，开销要比值传递的方式要小。如果旧密码的长度要比新密码短时，那么赋值过程中的申请和释放内存不可避免，则值传递和引用传递二者的开销一致。</p>
<p>上面对函数参数通过赋值来拷贝的分析要考虑多种因素，例如传递的类型、左值还是右值、类型是否使用动态内存等。例如: 对于 std::string，如果它使用了SSO 优化，那么赋值的操作会将要赋值的内容放到 SSO 的缓存中，那么情况又不一样了。SSO 优化详见 <a href="https://blog.csdn.net/Dong_HFUT/article/details/124577258?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">Item 29<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
<p>如果要追求极致的性能，值传递的方式可能不再是一个可行的方法，因为避免一次廉价的移动开销也是很重要的。并且我们并不是总是知道会有多少次这样的移动操作，例如，addName 通过值传递造成了一次额外的移动操作，但是这个函数内部又调用了 validateName，并且也是值传递的方式，这将就又造成了一次额外的移动开销，validateName 内部如果再调用其他的函数，并且这个函数同样是值传递的方式呢?这就造成了累加效应，而采用引用传递的方式就不会有这样的累加效应。</p>
<p>最后，一个与性能无关的话题，但却值得我们关注。那就是值传递的类型切割问题（slicing problem），详见 <a href="https://blog.csdn.net/Dong_HFUT/article/details/124577258?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">C++ 按值传递的切割问题（Slicing Problem）<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>对于可复制、移动开销低、且无条件复制的参数，按值传递效率基本与按引用传递效率一致，而且易于实现，生成更少的目标代码。</li>
<li>通过构造函数拷贝参数可能比通过赋值拷贝开销大的多。</li>
<li>按值传递会引起切片问题，不适合基类类型的参数。</li>
</ul>
</div>
    </div>
  </div>
<h4 id="item-42-consider-emplacement-instead-of-insertionhttpsblogcsdnnetdong_hfutarticledetails127073175"><a href="https://blog.csdn.net/Dong_HFUT/article/details/127073175"target="_blank" rel="external nofollow noopener noreferrer">Item 42: Consider emplacement instead of insertion.<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<p>如果你有一个容器用于保存 std::string，你可以使用插入函数（例如 insert、push_front、push_back 或 std::forward_list 的insert_after）添加元素。例如：</p>
<div class="highlight" id="id-401"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">;</span>  <span class="c1">// container of std::string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;xyzzy&#34;</span><span class="p">);</span>        <span class="c1">// add string literal
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，std::vector 的类型是 std::string，而插入的是字面值字符串（const char[6]）。std::vector 的 push_back 重载了左值和右值引用：</p>
<div class="highlight" id="id-402"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span>                         <span class="c1">// from the C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>  <span class="c1">// Standard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// insert lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>       <span class="c1">// insert rvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于下面的调用：</p>
<div class="highlight" id="id-403"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;xyzzy&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于实参的类型（const char[6]）和 push_back 形参类型（std::string 引用）类型不匹配，编译器会使用字符串字面值创建一个临时的 std::string 对象，再将这个临时对象传给 push_back，类似如下语义：</p>
<div class="highlight" id="id-404"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;xyzzy&#34;</span><span class="p">));</span> <span class="c1">// create temp. std::string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                    <span class="c1">// and pass it to push_back
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们再仔细分解一下编译器的行为如下：</p>
<ol>
<li>使用字面值 &ldquo;xyzzy&rdquo; 创建临时的 std::string 对象（记为 temp），这里调用一次 std::string 的构造函数。并且 temp 是一个右值。</li>
<li>temp 接着被传入右值引用重载的 push_back，也即将 temp 拷贝给 x。接着将 x 放入 vs 中，这里调用移动构造函数完成。</li>
<li>最后 temp 被销毁，调用 std::string 的析构函数。</li>
</ol>
<p>我们只是将字符串字面值传给 std::string 容器，却要调用两次构造和一次析构，对于追求代码性能的程序员而言，这个性能开销可能是无法接受的。</p>
<p>解决方案是使用 emplace_back 代替：</p>
<div class="highlight" id="id-405"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;xyzzy&#34;</span><span class="p">);</span> <span class="c1">// construct std::string inside
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                          <span class="c1">// vs directly from &#34;xyzzy&#34;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>emplace_back 使用了完美转发机制，如果传入的是右值，将直接使用这个右值在容器内部完成元素的构造。使用 emplace_back 将不会创建临时的 std::string 对象，将使用传入的字符串字面值（&ldquo;xyzzy&rdquo;）直接在容器内构造 std::string 对象。只要传入的参数合法，emplace_back 可以接收任意参数，然后完美转发到容器内部直接构造容器的元素。例如：</p>
<div class="highlight" id="id-406"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">);</span> <span class="c1">// insert std::string consisting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                          <span class="c1">// of 50 &#39;x&#39; characters
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>emplace</code> 系列接口和传统插入接口不同之处在于它可以接收可变参数，并且采用了完美转发机制，可以直接使用传入参数来构造容器元素（必须匹配到容器元素的构造函数）。而传统插入接口必须要插入和容器元素类型完全相同的对象。emplace 的优势是避免了临时对象的构造和析构。如果直接插入容器元素对象，那么二者是等价的，例如：</p>
<div class="highlight" id="id-407"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">queenOfDisco</span><span class="p">);</span>     <span class="c1">// copy-construct queenOfDisco
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="c1">// at end of vs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">queenOfDisco</span><span class="p">);</span>  <span class="c1">// ditto
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>emplace</code> 接口可以实现传统插入接口能做的所有事情，并且理论上，<code>emplace</code> 接口有时更高效。但实际却情况并非完全如此，虽然多数场景下，emplace 接口要比传统插入接口更加高效。但在少数场景下，传统插入接口要比 <code>emplace</code> 接口更加高效，这样的场景并不好归类，因为这取决于多种因素，例如传入参数的类型、使用的容器、插入容器中的位置、容器元素构造函数的异常安全机制、容器是否允许插入重复值、要插入的元素是否已经在容器中等。因而，给性能调优的建议是性能实测。</p>
<p>当然还是有一定的办法帮你来识别，如果以下条件都满足，<code>emplace</code> 接口几乎肯定要比传统插入接口更加高效：</p>
<ul>
<li><strong>要插入的值是通过构造函数插入容器，而非赋值</strong>。上面插入的字符串字面值就是这种情况，但如果插入的位置已经有元素了，情况就不同了，例如：
<div class="highlight" id="id-408"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">vs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="s">&#34;xyzzy&#34;</span><span class="p">);</span>  <span class="c1">// add &#34;xyzzy&#34; to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                              <span class="c1">// beginning of vs
</span></span></span></code></pre></td></tr></table>
</div>
</div>很少有编译器采用构造的方法将元素插入已经存在容器中存在的问题（这里是 vs[0]），而多数采用移动赋值的方法插入到已存在的位置。移动赋值需要被移动的对象，这就意味着需要构造临时的对象。那么 emplace 不会有临时对象的构造和析构的优势也就不存在了。</li>
<li><strong>传入参数的类型和容器元素的类型不同</strong>。emplace 的优势是需要构造临时的对象，如果传参的类型和容器元素的类型相同，也就不会产生临时对象了，emplace 的优势也就不存在了。</li>
<li><strong>容器不大可能因为元素值重复而拒绝其加入</strong>。这就意味着要不容器允许重复值加入，要不新加入的值大多数是唯一的。这样要求的原因是因为为了检测一个新值是否已经存在， emplace 的实现通常会创建一个新值的节点，然后和容器中已存在节点的值相比较，如果新节点的值不在容器中，则链接该节点。如果新节点的值已经在容器中，新创建的节点就要被销毁，这意味着新节点的构造和销毁就浪费了。</li>
</ul>
<p>下面的调用完全满足上面的条件，因而 <code>empalce_back</code> 比 <code>push_back</code> 要高效。</p>
<div class="highlight" id="id-409"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;xyzzy&#34;</span><span class="p">);</span>  <span class="c1">// construct new value at end of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                           <span class="c1">// container; don&#39;t pass the type in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                           <span class="c1">// container; don&#39;t use container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                           <span class="c1">// rejecting duplicates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">);</span>  <span class="c1">// ditto
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在决定是否使用 <code>emplace</code> 的时候，还有另外两个因素需要注意。第一个因素就是资源管理。例如：</p>
<div class="highlight" id="id-410"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="n">ptrs</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你要添加一个自定义 deleter 的 <code>std::shared_ptr</code> 对象，那么无法使用 std::make_shared_ptr 来创建（详见Item 21）。只能使用 <code>std::shared_ptr</code> 管理原始指针:</p>
<div class="highlight" id="id-411"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">killWidget</span><span class="p">(</span><span class="n">Widget</span><span class="o">*</span> <span class="n">pWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ptrs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">killWidget</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ptrs.push_back({ new Widget, killWidget });  // ditto
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样会先创建一个临时的 <code>std::shared_ptr</code> 对象，然后再传给 push_back。如果使用 emplace 接口，原则上临时对象的创建是可以避免的，但是这里创建临时对象却是必要的，考虑下面的过程：</p>
<ol>
<li>首先，临时的 <code>std::shared_ptr</code><Widge> 对象（temp）被创建。</li>
<li>然后， push_back 接受 temp 的引用。在 分配节点（用于接收 temp 的拷贝）的时候发生 OOM（out-of-memory）。</li>
<li>最后，异常从 push_back 传出后，temp 被销毁，它所管理的 Widget 对象也通过 killWidget 进行释放。</li>
</ol>
<p>而如果使用 empalce 接口：</p>
<div class="highlight" id="id-412"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ptrs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">killWidget</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>new Widget 创建的原始指针被完美转发到 emplace_back 内部构造器，此时发生 OOM。</li>
<li>异常从 push_back 传出后，原始指针是 Widget 唯一访问路径，它直接被销毁，但其管理的内存却没办法释放，就会发生内存泄漏。</li>
</ol>
<p>对于 std::unique_ptr 也有类似的问题。出现这样问题的根本原因是 <code>std::shared_ptr</code> 和 std::unique_ptr 对资源的管理取决于它们是否立即接管了这个资源，而 emplace 的完美转发机制延迟了资源管理对象的创建，这就给资源异常留下了可能的机会。这也是为什么建议使用 std::make_shared 和 std::make_unique 创建对象的原因。其实不应该将 “new Widget” 这样的表达式直接传给传统插入和 emplace 这样的函数，而应该直接传智能指针对象，像下面这样：</p>
<div class="highlight" id="id-413"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span>  <span class="c1">// create Widget and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="n">killWidget</span><span class="p">);</span> <span class="c1">// have spw manage it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ptrs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">spw</span><span class="p">));</span>          <span class="c1">// add spw as rvalue
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者:</p>
<div class="highlight" id="id-414"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="err">`</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">killWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ptrs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">spw</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>两种方式都可以避免内存泄漏的问题，同时 emplace 的性能和传统插入接口也是一致的。</p>
<p>使用 emplace 第二个值得注意的因素是它和显示构造函数的交互。C++11 支持了正则表达式，假设创建一个存放正则表达式的容器：</p>
<div class="highlight" id="id-415"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">regex</span><span class="o">&gt;</span> <span class="n">regexes</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果不小心写出了下面的错误代码：</p>
<div class="highlight" id="id-416"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">regexes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">// add nullptr to container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                               <span class="c1">// of regexes?
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>nullptr 不是正则表达式，为什么编译不会报错？例如：</p>
<div class="highlight" id="id-417"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">regex</span> <span class="n">r</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// error! won&#39;t compile
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>而使用 push_back 接口就是会报错：</p>
<div class="highlight" id="id-418"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">regexes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">// error! won&#39;t compile
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这背后的原因是使用字符串构造 std::regex 对象比较耗时，为此 std::regex 禁止隐式构造，采用 const char* 指针的std::regex 构造函数是显式的。这也就是下面代码无法编译通过的原因了：</p>
<div class="highlight" id="id-419"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">regex</span> <span class="n">r</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>     <span class="c1">// error! won&#39;t compile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">regexes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">// error! won&#39;t compile
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 emplace 接口，由于完美转发机制，最后在容器内部直接拿到 const char* 显示构造 std::regex ，因此。下面的代码可以编译通过：</p>
<div class="highlight" id="id-420"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">regexes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">// can compile
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>总而言之，使用 emplace 接口时一定要注意传入参数的正确性。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>总结<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>原则上，emplacement 函数会比传统插入函数更高效。</li>
<li>实际上，当执行如下操作时，emplacement 函数更快：（1）值被构造到容器中，而不是直接赋值；（2）传入参数的类型与容器类型不一致；（3）容器不拒绝已经存在的重复值。</li>
<li>emplacement 函数可能执行类型转化，而传统插入函数会拒绝。</li>
</ul>
</div>
    </div>
  </div>
<p>Reference:</br>
<a href="https://moodle.ufsc.br/pluginfile.php/2377667/mod_resource/content/0/Effective_Modern_C__.pdf"target="_blank" rel="external nofollow noopener noreferrer">ebook &ndash; Effective Modern C++<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[1]. <a href="https://zhuanlan.zhihu.com/p/592921281"target="_blank" rel="external nofollow noopener noreferrer">《Effective Modern C++》笔记与实践<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://blog.csdn.net/Dong_HFUT/article/details/127155670"target="_blank" rel="external nofollow noopener noreferrer">Effective Modern C++ 完全解读笔记汇总<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://zhuanlan.zhihu.com/p/553706181"target="_blank" rel="external nofollow noopener noreferrer">Effective modern C++ 学习笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[4]. <a href="https://blog.csdn.net/fengbingchun/article/details/104136592"target="_blank" rel="external nofollow noopener noreferrer">Effective Modern C++42招独家技巧助你改善C++11和C++14的高效用法笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
]]></description></item><item><title>C++ Concurrency in Action [2] | CH02 Managing Threads</title><link>https://jianye0428.github.io/posts/ch02_managing_threads/</link><pubDate>Wed, 01 Nov 2023 21:16:33 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ch02_managing_threads/</guid><description><![CDATA[<h2 id="stdthreadhttpsencppreferencecomwcppthreadthread"><a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h2>
<ul>
<li>每个程序有一个执行 main() 函数的主线程，将函数添加为 <a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的参数即可启动另一个线程，两个线程会同时运行</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hello world&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">f</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// 等待新起的线程退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的参数也可以是函数对象或者 lambda</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 会调用 A 的拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">A</span><span class="p">());</span>  <span class="c1">// most vexing parse，声明名为 t2 参数类型为 A 的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">{</span><span class="n">A</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t4</span><span class="p">((</span><span class="n">A</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t5</span><span class="p">{[]</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t5</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在线程销毁前要对其调用 <a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 等待线程退出或 <a href="https://en.cppreference.com/w/cpp/thread/thread/detach"target="_blank" rel="external nofollow noopener noreferrer">detach<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 将线程分离，否则 <a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的析构函数会调用 <a href="https://en.cppreference.com/w/cpp/error/terminate"target="_blank" rel="external nofollow noopener noreferrer">std::terminate<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 终止程序，注意分离线程可能出现空悬引用的隐患</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">call</span><span class="p">(</span><span class="n">x_</span><span class="p">);</span>  <span class="c1">// 存在对象析构后引用空悬的隐患
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">call</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span> <span class="n">a</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">a</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>  <span class="c1">// 不等待 t 结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>  <span class="c1">// 函数结束后 t 可能还在运行，而 x 已经销毁，a.x_ 为空悬引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">f</span><span class="p">};</span>  <span class="c1">// 导致空悬引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 会在线程结束后清理 <a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，使其与完成的线程不再关联，因此对一个线程只能进行一次 <a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([]</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果线程运行过程中发生异常，之后的 <a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 会被忽略，为此需要捕获异常，并在抛出异常前 <a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([]</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// 处理异常前先 join()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">throw</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// 再将异常抛出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// 之前抛异常，不会执行到此处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++20 提供了 <a href="https://en.cppreference.com/w/cpp/thread/jthread"target="_blank" rel="external nofollow noopener noreferrer">std::jthread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，它会在析构函数中对线程 <a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">jthread</span> <span class="n">t</span><span class="p">([]</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread/detach"target="_blank" rel="external nofollow noopener noreferrer">detach<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 分离线程会让线程在后台运行，一般将这种在后台运行的线程称为守护线程，守护线程与主线程无法直接交互，也不能被 <a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([]</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>创建守护线程一般是为了长时间运行，比如有一个文档处理应用，为了同时编辑多个文档，每次新开一个文档，就可以开一个对应的守护线程</li>
</ul>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">edit_document</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">open_document_and_display_gui</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done_editing</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">user_command</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">get_user_input</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">open_new_document</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">new_name</span> <span class="o">=</span> <span class="n">get_filename_from_user</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">edit_document</span><span class="p">,</span> <span class="n">new_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">process_user_input</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="为带参数的函数创建线程">为带参数的函数创建线程</h2>
<ul>
<li>有参数的函数也能传给 <a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，参数的默认实参会被忽略</li>
</ul>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">f</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span>  <span class="c1">// std::thread t{f} 则会出错，因为默认实参会被忽略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参数的引用类型也会被忽略，为此要使用 <a href="https://en.cppreference.com/w/cpp/utility/functional/ref"target="_blank" rel="external nofollow noopener noreferrer">std::ref<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">f</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果对一个实例的 non-static 成员函数创建线程，第一个参数类型为成员函数指针，第二个参数类型为实例指针，后续参数为函数参数</li>
</ul>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">{</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span>  <span class="c1">// 调用 a-&gt;f(42)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">{</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span>   <span class="c1">// 拷贝构造 tmp_a，再调用 tmp_a.f(42)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果要为参数是 move-only 类型的函数创建线程，则需要使用 <a href="https://en.cppreference.com/w/cpp/utility/move"target="_blank" rel="external nofollow noopener noreferrer">std::move<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 传入参数</li>
</ul>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">f</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="转移线程所有权">转移线程所有权</h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 是 move-only 类型，不能拷贝，只能通过移动转移所有权，但不能转移所有权到 joinable 的线程</li>
</ul>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">a</span><span class="p">{</span><span class="n">f</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="p">.</span><span class="n">joinable</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">joinable</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{</span><span class="n">g</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">joinable</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">joinable</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// a = std::move(b);  // 错误，不能转移所有权到 joinable 的线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">a</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">joinable</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">.</span><span class="n">joinable</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">a</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>移动操作同样适用于支持移动的容器</li>
</ul>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([]</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 可以作为函数返回值</li>
</ul>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{[]</span> <span class="p">{}};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">f</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 也可以作为函数参数</li>
</ul>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([]</span> <span class="p">{}));</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([]</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>实现一个可以直接用 <a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 构造的自动清理线程的类</li>
</ul>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">scoped_thread</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">scoped_thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">t_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t_</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&#34;no thread&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">scoped_thread</span><span class="p">()</span> <span class="p">{</span> <span class="n">t_</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">scoped_thread</span><span class="p">(</span><span class="k">const</span> <span class="n">scoped_thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">scoped_thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">scoped_thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">scoped_thread</span> <span class="n">t</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{[]</span> <span class="p">{}}};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>类似 <a href="https://en.cppreference.com/w/cpp/thread/jthread"target="_blank" rel="external nofollow noopener noreferrer">std::jthread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的类</li>
</ul>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Jthread</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Jthread</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Jthread</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">t_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">Jthread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">t_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Jthread</span><span class="p">(</span><span class="n">Jthread</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">t_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">t_</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Jthread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Jthread</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">t_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">t_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Jthread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">t_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">Jthread</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Jthread</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">t_</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">t_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">get_id</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t_</span><span class="p">.</span><span class="n">get_id</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">joinable</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t_</span><span class="p">.</span><span class="n">joinable</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">join</span><span class="p">()</span> <span class="p">{</span> <span class="n">t_</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">detach</span><span class="p">()</span> <span class="p">{</span> <span class="n">t_</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">as_thread</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">as_thread</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Jthread</span> <span class="n">t</span><span class="p">{[]</span> <span class="p">{}};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="查看硬件支持的线程数量">查看硬件支持的线程数量</h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency"target="_blank" rel="external nofollow noopener noreferrer">hardware_concurrency<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 会返回硬件支持的并发线程数</li>
</ul>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; concurrent threads are supported.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>并行版本的 <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate"target="_blank" rel="external nofollow noopener noreferrer">std::accumulate<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">accumulate_block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">num_threads</span> <span class="o">=</span>  <span class="c1">// 线程数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">hardware_threads</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>  <span class="c1">// 每个线程中的数据量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">num_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 已有主线程故少一个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>  <span class="c1">// block_end 指向当前块尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{</span><span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{},</span> <span class="n">block_start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="n">block_end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">])};</span>
</span></span><span class="line"><span class="cl">    <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">init</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="线程号">线程号</h2>
<ul>
<li>可以通过对线程实例调用成员函数 <a href="https://en.cppreference.com/w/cpp/thread/thread/get_id"target="_blank" rel="external nofollow noopener noreferrer">get_id<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 或在当前线程中调用 <a href="https://en.cppreference.com/w/cpp/thread/get_id"target="_blank" rel="external nofollow noopener noreferrer">std::this_thread::get_id<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 获取 <a href="https://en.cppreference.com/w/cpp/thread/thread/id"target="_blank" rel="external nofollow noopener noreferrer">线程号<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，其本质是一个无符号整型的封装，允许拷贝和比较，因此可以将其作为容器的键值，如果两个线程的线程号相等，则两者是同一线程或都是空线程（一般空线程的线程号为 0）</li>
</ul>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#elif defined __GNUC__
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;syscall.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_current_thread_id</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>       <span class="c1">// 19840
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">GetCurrentThreadId</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>             <span class="c1">// 19840
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">GetThreadId</span><span class="p">(</span><span class="n">GetCurrentThread</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 19840
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#elif defined __GNUC__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>              <span class="c1">// 140250646003520
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">getpid</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 1502109，ps aux 显示此 pid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_gettid</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 1502109
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">master_thread_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">==</span> <span class="n">master_thread_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do_master_thread_work();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// do_common_work();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">print_current_thread_id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">{</span><span class="n">f</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="cpu-亲和性affinity">CPU 亲和性（affinity）</h2>
<ul>
<li>将线程绑定到一个指定的 CPU core 上运行，避免多核 CPU 上下文切换和 cache miss 的开销</li>
</ul>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#elif defined __GNUC__
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">affinity_cpu</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">native_handle_type</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetThreadAffinityMask</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1ll</span> <span class="o">&lt;&lt;</span> <span class="n">cpu_id</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fail to affinity&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#elif defined __GNUC__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="n">cpu_set_t</span> <span class="n">cpu_set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">CPU_SET</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">pthread_setaffinity_np</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cpu_set</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cpu_set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">errno</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fail to affinity&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">affinity_cpu_on_current_thread</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetThreadAffinityMask</span><span class="p">(</span><span class="n">GetCurrentThread</span><span class="p">(),</span> <span class="mi">1ll</span> <span class="o">&lt;&lt;</span> <span class="n">cpu_id</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fail to affinity&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#elif defined __GNUC__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="n">cpu_set_t</span> <span class="n">cpu_set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">CPU_SET</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">pthread_setaffinity_np</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cpu_set</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cpu_set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">errno</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fail to affinity&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">affinity_cpu_on_current_thread</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">{[]</span> <span class="p">{}};</span>
</span></span><span class="line"><span class="cl">  <span class="n">affinity_cpu</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">native_handle</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">{</span><span class="n">f</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CMake 笔记 | [7] 设置语言标准（一）</title><link>https://jianye0428.github.io/posts/cmake_note_7/</link><pubDate>Wed, 17 Jan 2024 09:04:22 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_7/</guid><description><![CDATA[<h2 id="一c--标准历史">一、C ++ 标准历史</h2>
<ul>
<li>1998 年，C++ 标准委员会发布了第一版 C++ 标准，并将其命名为 C++ 98 标准</li>
<li>2011 年，新的 C++ 11 标准诞生，用于取代 C++ 98 标准。此标准还有一个别名，为C++ 0x</li>
<li>2014 年，C++ 14 标准发布，该标准库对 C++ 11 标准库做了更优的修改和更新</li>
<li>2017 年底，C++ 17 标准正式颁布</li>
</ul>
<h2 id="二c-11版本特性介绍">二、C++ 11版本特性介绍</h2>
<p>在 <code>C++ 11</code> 标准之前，<code>C++</code> 标准委员会还在 2003 年对 C++ 98 标准做了一次修改（称为 <code>C++ 03</code> 标准），但由于仅仅修复了一些 <code>C++ 98</code> 标准中存在的漏洞，并未修改核心语法，因此人们习惯将这次修订和 C++ 98 合称为 <code>C++98/03</code> 标准。</p>
<p>以上 3 个标准中，<code>C++ 11</code> 标准无疑是颠覆性的，该标准在 C++ 98 的基础上修正了约 600 个 C++ 语言中存在的缺陷，同时添加了约 140 个新特性，这些更新使得 C++ 语言焕然一新。</p>
<h3 id="21-类型推导之auto和decltype">2.1 类型推导之auto和decltype</h3>
<p>在 <code>C++11</code> 之前的版本中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等。<code>C++11</code> 使用 <code>auto</code> 关键字来支持自动类型推导。</p>
<p>在之前的 <code>C++</code> 版本中，<code>auto</code> 用来指明变量的存储类型，它和 <code>static</code> 是相对的。<code>auto</code> 表示变量是自动存储的，这也是编译器的默认规则，所以写不写都一样，这使得 <code>auto</code> 的存在变得非常鸡肋。</p>
<p><code>C++ 11</code> 赋予 <code>auto</code> 新的含义，用它来做自动类型推导。即，使用 <code>auto</code> 关键字后，编译器会在编译期间自动推导出变量的类型。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li><code>auto</code> 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</li>
<li>使用 <code>auto</code> 类型推导的变量必须马上初始化，因为 <code>auto</code> 在 <code>C++11</code> 中只是占位符，并非如 int 一样的真正的类型声明。</li>
</ul>
</div>
    </div>
  </div>
<p><strong>auto与const的结合使用</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// n 为const int,auto 被推导为int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// f为const int， auto 被推导为int（const属性被抛弃）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// r1为const int &amp;类型，auto被推导为int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// r1为const int&amp;类型，auto 被推导为const int 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>auto</code> 与 <code>const</code> 结合的用法：</p>
<ul>
<li>当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code> 属性；</li>
<li>当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</li>
<li><code>auto</code>的限制：
<ul>
<li>使用<code>auto</code>时必须对变量进行初始化</li>
<li><code>auto</code>不能作为函数的形参</li>
<li><code>auto</code> 不能作用于类的</li>
</ul>
</li>
<li>非静态成员变量中
<ul>
<li><code>auto</code> 关键字不能定义数组</li>
<li>auto 不能作用于模板参数</li>
</ul>
</li>
</ul>
<p><code>decltype</code> 是 <code>C++11</code> 新增的一个关键字，它和 <code>auto</code> 的功能一样，都用来在编译时期进行自动类型推导。<code>decltype</code> 是declare type的缩写，译为声明类型。</p>
<p><code>auto</code> 并不适用于所有的自动类型推导场景，在某些特殊情况下 <code>auto</code> 用起来非常不方便，甚至压根无法使用，所以 <code>decltype</code> 关键字也被引入到 <code>C++11</code> 中。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中，<code>var_name</code> 表示变量名，<code>value</code> 表示赋给变量的值，<code>exp</code> 表示一个表达式。</p>
<p><code>auto</code> 根据=右边的初始值 <code>value</code> 推导出变量的类型，而 <code>decltype</code> 根据 <code>exp</code> 表达式推导出变量的类型，跟=右边的 <code>value</code> 没有关系。</p>
<p><code>auto</code> 要求变量必须初始化，而 <code>decltype</code> 不要求。</p>
<p><code>exp</code> 就是一个普通的表达式，它可以是任意复杂的形式，但是必须要保证 <code>exp</code> 的结果是有类型的，不能是 <code>void</code>；例如，当 <code>exp</code> 调用一个返回值类型为 <code>void</code> 的函数时，<code>exp</code> 的结果也是 <code>void</code> 类型，此时就会导致编译错误。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// b 被推导成了 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x 被推导成了 double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="mf">10.8</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// y 被推导成了 double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span> <span class="n">y</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>decltype 推导规则</strong></p>
<ul>
<li>如果 <code>exp</code> 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 <code>decltype(exp)</code> 的类型就和 <code>exp</code> 一致。</li>
<li>如果 <code>exp</code> 是函数调用，那么 <code>decltype(exp)</code> 的类型就和函数返回值的类型一致。</li>
<li>如果 <code>exp</code> 是一个左值，或者被<code>括号( )</code>包围，那么 <code>decltype(exp)</code>的类型就是 <code>exp</code> 的引用；假设 <code>exp</code> 的类型为 T，那么 <code>decltype(exp)</code> 的类型就是 T&amp;。</li>
</ul>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；
右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。
有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。</div>
    </div>
  </div>
<p><strong>auto与decltype对 cv 限定符的处理:</strong></p>
<p>cv 限定符是 const 和 volatile 关键字的统称:</p>
<ul>
<li>const 关键字用来表示数据是只读的，也就是不能被修改</li>
<li>volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取</li>
</ul>
<p>在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。其原理见auto与const的结合使用。</p>
<p><strong>auto与decltype对引用(&amp;)的处理:</strong></p>
<p>当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。</p>
<h3 id="22-c-返回值类型后置">2.2 C++ 返回值类型后置</h3>
<p>在泛型编程中，如果需要通过参数的运算来得到返回值的类型：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="n">Add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="o">+</span><span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Add</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码是因为我们并不关心a + b的类型是什么，因此只需要通过decltype(a + b)直接得到返回值类型即可。</p>
<p>上述使用过程十分不方便，因为外部其实并不知道参数之间应该如何运算，只有Add函数知道返回值应该如何推导。</p>
<p>在函数定义上直接通过decltype获取返回值：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">T</span><span class="p">()</span> <span class="o">+</span> <span class="n">U</span><span class="p">())</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法如下：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">))</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码虽然成功地使用 <code>decltype</code> 完成了返回值的推导，但写法过于晦涩，会大大增加<code>decltype</code>在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>因此，在 C++11 中增加了<strong>返回类型后置语法</strong>，将 <code>decltype</code> 和 <code>auto</code> 结合起来完成返回值类型的推导。</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="23-对模板实例化中连续尖括号改进">2.3 对模板实例化中连续尖括号&raquo;改进</h3>
<p>在 C++98/03 的泛型编程中，模板实例化过程中，连续两个右尖括号（&raquo;）会被编译器解释成右移操作符，而不是模板参数表的结束。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//编译出错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Foo</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">type</span> <span class="n">xx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码使用 gcc 编译时，会得到如下错误提示：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">error: ‘&gt;&gt;’ should be ‘&gt;&gt;’ within a nested template argument list Foo&lt;A&gt;::type xx<span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>意思就是，Foo&lt;A<int>&gt;这种写法是不被支持的，要写成这样<code>Foo&lt;A&lt;int&gt; &gt;</code>(注意两个右尖括号之间的空格)。</p>
<p>这种限制是<strong>很没有必要</strong>的。因为在 C++ 的各种成对括号中，目前只有右尖括号连续写两个会出现这种二义性。static_cast、reinterpret_cast 等 C++ 标准转换运算符，都是使用&lt;&gt;来获得待转换类型（type-id）的。若这个 type-id 本身是一个模板，用起来会很不方便。</p>
<p>在 C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出&raquo;是一个右移操作符还是模板参数表的结束标记。</p>
<p><mark>注意：</mark>上述这种自动化的处理在某些时候会与老标准不兼容：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 解决方案：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Foo&lt;(100 &gt;&gt; 2)&gt; xx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Foo</span><span class="o">&lt;</span><span class="mi">100</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">xx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 C++98/03 的编译器中编译是没问题的，但 C++11 的编译器会显示:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">error: expected unqualif?ied-id before ‘&gt;’ token Foo&lt;<span class="m">100</span> &gt;&gt; 2&gt; xx<span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="24-使用using定义别名替代typedef">2.4 使用using定义别名（替代typedef）</h3>
<p>C++可以使用typedef重定义一个类型，被重定义的类型不一定是一个新的类型，也有可能仅仅是原有类型取了一个新的名字。使用typedef重定义类型是很方便的，但它也有一些限制，如无法重定义一个模板等。</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">str_map_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">str_map_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">map_1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，<code>using</code>的别名语法覆盖了<code>typedef</code>的全部功能。</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 重定义unsigned int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uint_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">uint_t</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 重定义std::map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map_int_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">map_int_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重定义模板
</span></span></span><span class="line"><span class="cl"><span class="c1">// C++98/03
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">func_t</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">type</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 func_t 模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">xx_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">func_t</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 func_t 模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">xx_2</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从示例中可以看出，通过 <code>using</code> 定义模板别名的语法，只是在普通类型别名语法的基础上增加 <code>template</code> 的参数列表。使用 <code>using</code> 可以轻松地创建一个新的模板别名，而不需要像 <code>C++98/03</code> 那样使用烦琐的外敷模板。</p>
<h3 id="25-支持函数模板的默认参数">2.5 支持函数模板的默认参数</h3>
<p>在 <code>C++98/03</code> 标准中，<strong>类模板</strong>可以有默认的模板参数:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="n">U</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是不支持函数的默认模板参数：</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// error in C++98/03: default template arguments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用:</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//T = int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。即当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导：</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="n">func</span><span class="p">(</span><span class="n">U</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// R=int, U=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">(</span><span class="mi">97</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// R=char, U=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">97</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// R=double, U=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">97</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数无法推导出来，又未设置其默认值，则编译器直接报错。</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">double</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">val1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">U</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// T=char, U=double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 编译报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="26-在函数模板和类模板中使用可变参数">2.6 在函数模板和类模板中使用可变参数</h3>
<p><strong><font color=red>可变参数</font></strong>，指的是参数的个数和类型都可以是任意的。</p>
<p>对于函数参数而言，C++ 一直都支持为函数设置可变参数，最典型的代表就是 printf() 函数，它的语法格式为:</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">printf</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>...</code>就表示的是可变参数，即 printf() 函数可以接收任意个参数，且各个参数的类型可以不同。</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %c&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %c %f&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通常将容纳多个参数的可变参数称为<strong>参数包</strong>。借助 <code>format</code> 字符串，<code>printf()</code> 函数可以轻松判断出参数包中的参数个数和类型。</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdarg&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//可变参数的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">vair_fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">va_list</span> <span class="n">args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//可变参数有 4 个，分别为 10、20、30、40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">vair_fun</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>想使用参数包中的参数，需要借助<code>&lt;cstdarg&gt;</code>头文件中的 <code>va_start</code>、<code>va_arg</code> 以及 <code>va_end</code> 这 3 个带参数的宏：</p>
<ul>
<li><code>va_start(args, count)</code>：args 是 va_list 类型的变量，可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；</li>
<li><code>va_arg(args, int)</code>：调用 va_start找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回;</li>
<li><code>va_end(args)</code>：不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。</li>
</ul>
<p>使用<code>…</code>可变参数的过程中，需注意以下几点：</p>
<ul>
<li><code>…</code> 可变参数必须作为函数的最后一个参数，且一个函数最多只能拥有 1 个可变参数;</li>
<li>可变参数的前面至少要有 1 个有名参数;</li>
<li>当可变参数中包含 <code>char</code> 类型的参数时，<code>va_arg</code> 宏要以 <code>int</code> 类型的方式读取；当可变参数中包含 <code>short</code> 类型的参数时，<code>va_arg</code> 宏要以 <code>double</code> 类型的方式读取。</li>
</ul>
<p><mark>需要注意的是,</mark> <code>…</code>可变参数的方法仅适用于函数参数，并不适用于模板参数。</p>
<h3 id="27-可变参数模板">2.7 可变参数模板</h3>
<p>C++ 11 标准发布之前，<strong>函数模板</strong>和<strong>类模板</strong>只能设定固定数量的模板参数。<u>C++11 标准对模板的功能进行了扩展，允许模板中包含任意数量的模板参数，这样的模板又称可变参数模板。</u></p>
<p><strong>可变参数函数模板</strong></p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vair_fun</span><span class="p">(</span><span class="n">T</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//函数体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>模板参数中， <code>typename</code>（或者 class）后跟 <code>…</code> 就表明 T 是一个 <font color=red>可变模板参数</font> ，它可以接收多种数据类型，又称 <font color=red>模板参数包</font> 。vair_fun() 函数中，args 参数的类型用 <code>T…</code> 表示，表示 <code>args</code> 参数可以接收任意个参数，又称 <font color=red>函数参数包</font> 。即此函数模板最终实例化出的 vair_fun() 函数可以指定任意类型、任意数量的参数。</p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vair_fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">vair_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vair_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在模板函数内部“解”参数包方法：</p>
<p><mark>方法一：递归方式解包</mark></p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//模板函数递归的出口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">vir_fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vir_fun</span><span class="p">(</span><span class="n">T</span> <span class="n">argc</span><span class="p">,</span> <span class="n">args</span><span class="p">...</span> <span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">argc</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//开始递归，将第一个参数外的 argv 参数包重新传递给 vir_fun
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vir_fun</span><span class="p">(</span><span class="n">argv</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vir_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果：</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="m">1</span>
</span></span><span class="line"><span class="cl">http://www.biancheng.net
</span></span><span class="line"><span class="cl">2.34</span></span></code></pre></td></tr></table>
</div>
</div><p>程序的执行流程</p>
<ul>
<li>首先，<code>main()</code> 函数调用 <code>vir_fun()</code> 模板函数时，根据所传实参的值，可以很轻易地判断出模板参数 <code>T</code> 的类型为 in<code>T</code>，函数参数 <code>argc</code> 的值为 1，剩余的模板参数和函数参数都分别位于 args 和 <code>argv</code> 中；</li>
<li><code>vir_fun()</code> 函数中，首先输出了 <code>argc</code> 的值（为 1），然后重复调用自身，同时将函数参数包 <code>argv</code> 中的数据作为实参传递给形参 <code>argc</code> 和 <code>argv</code>；</li>
<li>再次执行 <code>vir_fun()</code> 函数，此时模板参数 <code>T</code> 的类型为 char*，输出 <code>argc</code> 的值为 <code>http:www.biancheng.net</code>。再次调用自身，继续将 <code>argv</code> 包中的数据作为实参；</li>
<li>再次执行 <code>vir_fun()</code> 函数，此时模板参数 <code>T</code> 的类型为 <code>double</code>，输出 <code>argc</code> 的值为 2.34。再次调用自身，将空的 <code>argv</code> 包作为实参；</li>
<li>由于 <code>argv</code> 包没有数据，此时会调用无任何形参、函数体为空的 <code>vir_fun()</code> 函数，最终执行结束。</li>
</ul>
<p>**注意:**以递归方式解包，一定要设置递归结束的出口。例如本例中，无形参、函数体为空的 vir_fun() 函数就是递归结束的出口。</p>
<p><mark>方法二：非递归方式解包（借助逗号表达式和初始化列表，也可以解开参数包）</mark></p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">dispaly</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vir_fun</span><span class="p">(</span><span class="n">args</span><span class="p">...</span> <span class="n">argv</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 逗号表达式+初始化列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="n">argv</span><span class="p">),</span><span class="mi">0</span><span class="p">)...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vir_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以<code>{ }</code>初始化列表的方式对数组 <code>arr</code> 进行了初始化， <code>(display(argv),0)…</code> 会依次展开为 <code>(display(1),0)</code>、<code>(display(“http://www.biancheng.net”),0)</code> 和 <code>(display(2.34),0)</code>。</p>
<p>所以，下面的语句是等价的：</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="n">argv</span><span class="p">),</span><span class="mi">0</span><span class="p">)...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">),</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="mf">2.34</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，每个元素都是一个逗号表达式，以 <code>(display(1), 0)</code> 为例，它会先计算 <code>display(1)</code>，然后将 <code>0</code> 作为整个表达式的值返回给数组，因此 <code>arr</code> 数组最终存储的都是 <code>0</code>。<code>arr</code> 数组纯粹是为了将参数包展开，没有发挥其它作用。</p>
<p><strong>可变参数类模板</strong></p>
<p><code>C++11</code> 标准中，类模板中的模板参数也可以是一个可变参数。<code>C++11</code> 标准提供的 <code>tuple</code> 元组类就是一个典型的可变参数模板类。</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">tuple</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和固定模板参数的类不同，tuple 模板类实例化时，可以接收任意数量、任意类型的模板参数:</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="n">tp0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tp1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tp2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">tp3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">,</span> <span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="28-引入tuple和lambda">2.8 引入tuple和Lambda</h3>
<p>tuple 的应用场景:</p>
<ul>
<li>当需要存储多个不同类型的元素时，可以使用 tuple；</li>
<li>当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。
具体使用方式请参考《C++标准库》</li>
</ul>
<p><strong>Lambda语法格式</strong></p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">[</span><span class="err">外部变量访问方式说明符</span><span class="p">](</span><span class="err">参数</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">mutable</span> <span class="k">noexcept</span><span class="o">/</span><span class="k">throw</span><span class="p">()</span><span class="o">-&gt;</span><span class="err">返回值类型</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="err">函数体</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>[外部变量访问方式说明符]：[]方括号用于向编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量(外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量)。
<ul>
<li>
<table>
<thead>
<tr>
<th style="text-align:center">外部变量格式</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">空方括号表示当前lambda匿名函数不导入任何外部变量</td>
</tr>
<tr>
<td style="text-align:center">[=]</td>
<td style="text-align:center">只有一个=符合，表示以值传递的方式导入所有外部变量</td>
</tr>
<tr>
<td style="text-align:center">[&amp;]</td>
<td style="text-align:center">只有一个&amp;符号，表示以引用传递的方式导入所有外部变量</td>
</tr>
<tr>
<td style="text-align:center">[val1, val2,&hellip;]</td>
<td style="text-align:center">表示以值传递的方式导入val1、val2等外部变量，同时多个变量之间没有前后次序</td>
</tr>
<tr>
<td style="text-align:center">[&amp;val1, &amp;val2,&hellip;]</td>
<td style="text-align:center">表示以引用传递的方式导入val1、val2等指定的外部变量，多个变量之间没有前后次序</td>
</tr>
<tr>
<td style="text-align:center">[val, &amp;val2,&hellip;]</td>
<td style="text-align:center">以上两种方式还可以混合使用</td>
</tr>
<tr>
<td style="text-align:center">[=, &amp;val1,&hellip;]</td>
<td style="text-align:center">表示除val1以引用传递的方式导入以外，其他外部变量都以值传递的方式导入</td>
</tr>
<tr>
<td style="text-align:center">[this]</td>
<td style="text-align:center">表示以值传递的方式导入当前的this指针</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><strong>(参数)</strong>：和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同()小括号一起省略。</li>
<li><strong>mutable</strong>：此关键字可以省略，如果使用之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。（注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量）。</li>
<li><strong>noexcept/throw()</strong>：可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用throw()可以指定 lambda 函数内部可以抛出的异常类型。（注意，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败）。</li>
<li><strong><code>-&gt;</code>返回值类型</strong>：指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略-&gt; 返回值类型。</li>
<li><strong>函数体</strong>：和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</li>
</ul>
<p><mark>注意:</mark>外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<h3 id="29-列表初始化">2.9 列表初始化</h3>
<p>具体使用方式请参考《C++ Primer Plus》《C++标准库》</p>
<h3 id="210-非受限联合体">2.10 非受限联合体</h3>
<p><strong>POD (Plain Old Data) 类型介绍:</strong>
<code>POD</code>类型一般具有以下几种特征：</p>
<ul>
<li>没有用户自定义的构造函数，析构函数、拷贝构造函数和移动构造函数</li>
<li>不能包含虚函数和虚基类</li>
<li>非静态成员必须声明为public</li>
<li>类中的第一个非静态成员的类型与基类不同</li>
<li>在类或者结构体继承时，满足以下两种情况之一：</li>
<li>派生类中有非静态成员，且只有一个包含静态成员的基类</li>
<li>基类有非静态成员，而派生类没有非静态成员</li>
<li>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说<code>POD</code>类型不能包含非<code>POD</code>类型的数据。</li>
<li>所有建通C语言的数据类型都是<code>POD</code>类型(<code>struct</code>、<code>union</code>等不能违背上述规则)</li>
</ul>
<p><strong>非受限联合体</strong></p>
<p>在 <code>C/C++</code> 中，**<font color=red>联合体</font>**是一种构造数据类型。在一个联合体内，可以定义多个不同类型的成员，这些成员将<u>会共享同一块内存空间</u>。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p>
<p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为**<font color=red>非受限联合体</font>**。</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Student</span><span class="p">(</span><span class="kt">bool</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">gender</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">gender</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">T</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Student</span> <span class="n">s</span><span class="p">;</span>  <span class="c1">// 含有非POD类型的成员，gcc-5.1.0  版本报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。</p>
<table><tr><td bgcolor=yellow>C++ 11改进1:</td></tr></table>
<ul>
<li>C++11允许非POD类型</li>
<li>C++11允许联合体又静态成员(静态成员变量智能在联合体内定义，却不能在联合体外使用)</li>
</ul>
<table><tr><td bgcolor=yellow>非受限联合体的赋值注意事项：</td></tr></table>
<ul>
<li>
<p>C++11规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 构造失败，因为 U 的构造函数被删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">U</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的例子中，因为 <code>string</code> 类拥有自定义的构造函数，所以 <code>U</code> 的构造函数被删除；定义 <code>U</code> 的类型变量 <code>u</code> 需要调用默认构造函数，所以 <code>u</code> 也就无法定义成功。</p>
</li>
<li>
<p>解决上面问题的一般需要用到 <code>placement new</code>:
<code>placement new</code> 是 <code>new</code> 关键字的一种进阶用法，既可以在栈<code>（stack）</code>上生成对象，也可以在堆<code>（heap）</code>上生成对象。相对应地，把常见的<code>new</code>的用法称为 <code>operator new</code>，它只能在 <code>heap</code> 上生成对象。</p>
<p>placement new 的语法格式:</p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">new</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="n">ClassConstruct</span><span class="p">(</span><span class="err">…</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上;
ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p>
<p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span><span class="p">()</span> <span class="p">{</span> <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="n">string</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">U</span><span class="p">()</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="o">~</span><span class="n">string</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>构造时，采用 <code>placement new</code> 将 <code>s</code> 构造在其地址 <code>&amp;s</code> 上，这里 <code>placement new</code> 的唯一作用只是调用了一下 <code>string</code> 类的构造函数。注意，在析构时还需要调用 <code>string</code> 类的析构函数。</p>
</li>
</ul>
<h3 id="211-非受限联合体的匿名声明和枚举式类">2.11 非受限联合体的匿名声明和“枚举式类”</h3>
<p><mark>匿名联合体</mark>是指不具名的联合体（也即没有名字的联合体），定义如下:</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">U</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 此联合体为匿名联合体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">union</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>联合体 <code>U</code> 内定义了一个不具名的联合体，该联合体包含一个 <code>int</code> 类型的成员变量，称这个联合体为匿名联合体。</p>
<p>非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为<code>枚举式类</code>。</p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Student</span><span class="p">(</span><span class="kt">bool</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">gender</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">a</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">gender</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="nc">Type</span> <span class="p">{</span> <span class="n">STUDENT</span><span class="p">,</span> <span class="n">NATIVE</span><span class="p">,</span> <span class="n">FOREIGENR</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="kt">bool</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span> <span class="o">=</span> <span class="n">STUDENT</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">id</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span> <span class="o">=</span> <span class="n">NATIVE</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">?</span> <span class="mi">9</span> <span class="o">:</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">memcpy</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">name</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span> <span class="o">=</span> <span class="n">FOREIGENR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Singer</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Student</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="mi">310217</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="s">&#34;J Michael&#34;</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="212-for循环基于范围的循环">2.12 for循环(基于范围的循环)</h3>
<p><code>C++ 11</code>标准之前（<code>C++ 98/03</code> 标准），如果要用 <code>for</code> 循环语句遍历一个数组或者容器，只能套用如下结构:</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="err">表达式</span> <span class="mi">1</span><span class="p">;</span> <span class="err">表达式</span> <span class="mi">2</span><span class="p">;</span> <span class="err">表达式</span> <span class="mi">3</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//循环体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>举例:</p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arc</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;http://c.biancheng.net/cplus/11/&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历普通数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">arc</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="n">myvector</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span><span class="n">arc</span><span class="o">+</span><span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历 vector 容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">iter</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>C++ 11</code> 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式:</p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="nl">declaration</span> <span class="p">:</span> <span class="n">expression</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//循环体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>declaration:</mark>表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</p>
<p><mark>expression:</mark>表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arc</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;http://c.biancheng.net/cplus/11/&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历普通数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">arc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;!&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="n">myvector</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">arc</span> <span class="o">+</span> <span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历 vector 容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">myvector</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 新语法格式的 for 循环还支持遍历用{ }大括号初始化的列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><table><tr><td bgcolor=yellow>注意:</td></tr></table>
<ul>
<li>程序中在遍历 <code>myvector</code> 容器时，定义了 <code>auto</code> 类型的 <code>ch</code> 变量，当编译器编译程序时，会通过 <code>myvector</code> 容器中存储的元素类型自动推导出 <code>ch</code> 为 <code>char</code> 类型。注意，这里的 <code>ch</code> 不是迭代器类型，而表示的是 <code>myvector</code> 容器中存储的每个元素。</li>
<li>在输出结果，其中第一行输出的字符串和 <code>!</code> 之间还输出有一个空格，因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 \0（字符串的结束标志）。</li>
</ul>
<table><tr><td bgcolor=yellow>注意:</td></tr></table>
<ul>
<li>在使用新语法格式的 <code>for</code> 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 <code>declaration</code> 参数处定义引用形式的变量。</li>
<li>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arc</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;abcde&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="n">myvector</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">arc</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历并修改容器中各个字符的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">ch</span> <span class="p">:</span> <span class="n">myvector</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ch</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历输出容器中各个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">myvector</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="213-constexpr验证是否为常量表达式">2.13 constexpr：验证是否为常量表达式</h3>
<p><code>constexpr</code> 是 C++ 11 标准新引入的关键字。</p>
<p>常量表达式，指的就是由多个（≥1）常量组成的表达式。即如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<p>以定义数组为例，数组的长度就必须是一个常量表达式：</p>
<div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误，length是变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 改进： const int length = 6;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="n">length</span><span class="p">]</span></span></span></code></pre></td></tr></table>
</div>
</div><p>程序的执行过程为预处理、编译、汇编和链接四个阶段，具体请参考<a href="https://mp.weixin.qq.com/s?__biz=MzkxMzI5Mjk4Mg==&amp;mid=2247483661&amp;idx=1&amp;sn=0071d0fb2ab4123f54885101382b522a&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">计算机系统漫游(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。大致又可以说由编译、链接、运行这3 个阶段。常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>在实际开发中，判定一个表达式是否为常量表达式方式:</p>
<ul>
<li>人为判定；</li>
<li>C++11 标准还提供有 constexpr 关键字。</li>
</ul>
<p><strong>constexpr修饰普通变量</strong></p>
<p><code>C++11</code> 标准中，定义变量时可以用 <code>constexpr</code> 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>使用 <code>constexpr</code> 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。</p>
<div class="highlight" id="id-43"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">couts</span><span class="o">&lt;&lt;</span> <span class="n">url</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码中，如果尝试将 constexpr 删除，此时编译器会提示url[num] 定义中 num 不可用作常量。使用 constexpr 修饰 num 变量，同时将 1+2+3 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p><mark>注意:</mark>当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
<p><strong>constexpr修饰函数</strong></p>
<p>这样的函数又称为<code>常量表达式函数</code>。</p>
<p><code>constexpr</code> 并非可以修改任意函数的返回值。必须满足如下条件:</p>
<ul>
<li>整个函数的函数体中，除了可以包含 <code>using</code> 指令、<code>typedef</code> 语句以及<code>static_assert</code>断言外，只能包含一条 <code>return</code> 返回语句。
<div class="highlight" id="id-44"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">display</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 可以添加 using 执行、typedef 语句以及 static_assert 断言
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>该函数必须有返回值，即函数的返回值类型不能是 void</li>
<li>函数在使用之前，必须有对应的定义语句。函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</li>
<li>return 返回的表达式必须是常量表达式</li>
</ul>
<p><mark>注意:</mark>在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的。</p>
<p><strong>constexpr修饰类的构造函数</strong></p>
<p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数:</p>
<div class="highlight" id="id-45"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 自定义类型的定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">MyType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="nf">MyType</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span><span class="o">:</span><span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">){};</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//其它结构体成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="k">struct</span> <span class="nc">MyType</span> <span class="n">mt</span> <span class="p">{</span> <span class="s">&#34;zhangsan&#34;</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mt</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">mt</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark> constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
<p>constexpr 可用于修饰函数，而类中的成员方法完全可以看做是位于类这个命名空间中的函数，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到条件。</p>
<p><mark>注意:</mark> C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
<p><strong>constexpr修饰模板函数</strong></p>
<p>C++11 语法中，<code>constexpr</code> 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p>
<p>针对这种情况下，C++11 标准规定，如果 <code>constexpr</code> 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 <code>constexpr</code> 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p><strong>constexpr与const的区别</strong></p>
<p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达只读语义的场景都使用 const，表达常量语义的场景都使用 constexpr。</p>
<p><code>只读</code>和<code>不允许被修改</code>之间并没有必然的联系</p>
<div class="highlight" id="id-46"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">con_b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">con_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">con_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>程序中用 const 修饰了 con_b 变量，表示该变量只读，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p>
<table><tr><td bgcolor=yellow>在大部分实际场景中，const 和 constexpr 是可以混用的:</td></tr></table>
<div class="highlight" id="id-47"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在某些场景中，必须明确使用 constexpr</p>
<div class="highlight" id="id-48"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">sqr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="nf">sqr2</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 可以，因为sqr1时constexpr函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">sqr1</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mylist1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 不可以，因为sqr2不是constexpr函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">sqr2</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mylist1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="214-long-long超长整形">2.14 long long超长整形</h3>
<p>将 long long 整形写入 C++ 11 标准中，如同 long 类型整数需明确标注 L 或者 l 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p>
<ul>
<li>对于有符号 long long 整形，后缀用 LL 或者 ll 标识。如，10LL 就表示有符号超长整数 10。</li>
<li>对于无符号 long long 整形，后缀用 ULL、ull、Ull 或者 uLL 标识。如，10ULL 就表示无符号超长整数 10；</li>
</ul>
<p><mark>注意:</mark> 如果不添加任何标识，则所有的整数都会默认为 int 类型。</p>
<p>了解当前平台上 long long 整形的取值范围，可以使用<climits>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：</p>
<ul>
<li>LLONG_MIN：代表当前平台上最小的 long long 类型整数；</li>
<li>LLONG_MAX：代表当前平台上最大的 long long 类型整数；</li>
<li>ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）；</li>
</ul>
<div class="highlight" id="id-49"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;long long最大值：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MIN</span> <span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MIN</span> <span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span><span class="s">&#34;long long最小值：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MAX</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MAX</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;unsigned long long最大值：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ULLONG_MAX</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="215-右值引用">2.15 右值引用</h3>
<table><tr><td bgcolor=yellow>C++左值和右值</td></tr></table>
在 C++/C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。
<p><mark>注意：</mark>左值的英文简写为lvalue，右值的英文简写为rvalue。很多人认为它们分别是left value、right value 的缩写。其实不然，lvalue 是loactor value的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 read value，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
<p>通常情况下，判断某个表达式是<code>左值</code>还是<code>右值</code>，最常用的有以下 2 种方法:</p>
<ul>
<li>可位于赋值号(=)左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</li>
<li></li>
</ul>
<div class="highlight" id="id-50"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误，5 不能为左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">5</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// b 是一个左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a、b 都是左值，只不过将 b 可以当做右值使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>有名称的、可以获取到存储地址的表达式即为<code>左值</code>；反之则是<code>右值</code>。</li>
</ul>
<p>以上面定义的变量 <code>a</code>、<code>b</code> 为例，<code>a</code> 和 <code>b</code> 是变量名，且通过 &amp;<code>a</code> 和 &amp;<code>b</code> 可以获得他们的存储地址，因此 <code>a</code> 和 <code>b</code> 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。</p>
<p><strong>右值引用</strong></p>
<p><code>右值引用</code>可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。</p>
<p><code>C++98/03</code> 标准中有引用，使用 <code>&amp;</code> 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。</p>
<div class="highlight" id="id-51"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark> 虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值。</p>
<div class="highlight" id="id-52"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark> <code>C++11</code> 标准中对右值做了更细致的划分，分别称为 <font color=red>纯右值（pure value，简称 pvalue）</font>和 <font color=red>将亡值（expiring value，简称 xvalue ）</font>。其中纯右值就是 C++98/03 标准中的右值，而<u>将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）</u>。对于纯右值和将亡值，都属于右值。</p>
<h3 id="216-移动构造函数的功能和用法">2.16 移动构造函数的功能和用法</h3>
<p><code>右值引用</code>主要用于实现<code>移动（move）语义</code>和<code>完美转发</code>。</p>
<p><strong>完美转发及其实现</strong></p>
<p>C++11 标准为 C++ 引入右值引用语法的同时，还解决了一个 C++ 98/03 标准长期存在的短板，即使用简单的方式即可在函数模板中实现参数的完美转发。</p>
<ol>
<li>
<p><strong><font color=red>完美转发</font></strong>
指的是函数模板可以将自己的参数&quot;完美&quot;地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。如：</p>
<div class="highlight" id="id-53"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述示例中，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。
function() 函数模板并没有实现完美转发。</p>
<ul>
<li>参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；</li>
<li>无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</li>
</ul>
<p>如果使用 C++ 98/03 标准下的 C++ 语言，可以采用函数模板重载的方式实现完美转发，例如：</p>
<div class="highlight" id="id-54"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重载被调用函数，查看完美转发的效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;rvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重载函数模板，分别接收左值和右值
</span></span></span><span class="line"><span class="cl"><span class="c1">// 接收右值参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 接收左值参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 5 是右值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">function</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>  <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// x 是左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于右值5 来说，它实际调用的参数类型为 const T&amp; 的函数模板，由于 t 为 const 类型，所以 otherdef() 函数实际调用的也是参数用 const 修饰的函数，所以输出“rvalue”；对于左值 x 来说，2 个重载模板函数都适用，C++编译器会选择最适合的参数类型为 T&amp; 的函数模板，进而 therdef() 函数实际调用的是参数类型为非 const 的函数，输出“lvalue”。
使用重载的模板函数实现完美转发也是有弊端的，此方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。
在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：</p>
<div class="highlight" id="id-55"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：</p>
<div class="highlight" id="id-56"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// T 为 int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">function</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// T 为 int &amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">function</span><span class="p">(</span><span class="n">num2</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由 function(num) 实例化的函数底层就变成了 function(int &amp;&amp; t)，同样由 function(num2) 实例化的函数底层则变成了 function(int &amp;&amp; &amp;&amp; t)。C++98/03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：</p>
<ul>
<li>
<p>当实参为左值或者左值引用（A&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; = A&amp;）；</p>
</li>
<li>
<p>当实参为右值或者右值引用（A&amp;&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; = A&amp;&amp;）。</p>
</li>
</ul>
<p><mark>注意：</mark>在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。</p>
<p>将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数方法：<code>引入一个模板函数 forword()</code>:</p>
<div class="highlight" id="id-57"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重载被调用函数，查看完美转发的效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;rvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现完美转发的函数模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">function</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>  <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong><font>移动语义</font></strong>
指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p>
<div class="highlight" id="id-58"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">demo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">demo</span><span class="p">()</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;construct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">demo</span><span class="p">(</span><span class="k">const</span> <span class="n">demo</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">.</span><span class="n">num</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy construct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 移动构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">demo</span><span class="p">(</span><span class="n">demo</span> <span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">num</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="n">d</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;move construct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="o">~</span><span class="n">demo</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;class destruct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="o">*</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">demo</span> <span class="nf">get_demo</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">demo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">      <span class="n">demo</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_demo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>demo类的其中一个构造函数(<code>demo(demo &amp;&amp;d)</code>)使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，<code>num</code> 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 <code>d.num</code>，有效避免了“同一块对空间被释放多次”情况的发生。</p>
<p><code>非 const 右值引用</code>只能操作右值，程序执行结果中产生的<code>临时对象</code>（例如函数返回值、lambda 表达式等）既<code>无名称</code>也无法获取其<code>存储地址</code>，所以属于<code>右值</code>。当类中同时包含<code>拷贝构造函数</code>和<code>移动构造函数</code>时，<mark>如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</mark></p>
<p><mark>注意:</mark>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
<p>默认情况下，<code>左值</code>初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则<code>必须使用右值进行初始化</code>。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 <code>std::move()</code> 函数，<font color=red>它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数</font>。</p>
<h3 id="217-move函数将左值转换为右值">2.17 <code>move()</code>函数:将左值转换为右值</h3>
<p>C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>移动构造函数的调用时机是：<code>用同类的右值对象初始化新对象</code>。用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，调用移动构造函数方法：<code>调用 move() 函数</code>。</p>
<p>move 的功能很简单，就是将某个左值强制转化为右值。</p>
<p><strong>引用限定符的用法</strong></p>
<p>首先，我们定义左值的类对象称为左值对象，右值的类对象称为右值对象。</p>
<p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用:</p>
<div class="highlight" id="id-59"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<code>demo</code> 类中的 <code>get_num()</code> 成员函数既可以被 <code>a 左值对象</code>调用，也可以被 <code>move(a)</code> 生成的右值 <code>demo</code> 对象调用，运行程序会输出两个 <code>10</code>。</p>
<p>某些场景中，可能需要限制调用成员函数的对象的类型（<code>左值</code>还是<code>右值</code>），为此 C++11 新添加了<code>引用限定符</code>。所谓引用限定符，就是在成员函数的后面添加 &amp; 或者 &amp;&amp;，从而限制调用者的类型（<code>左值</code>还是<code>右值</code>）。</p>
<div class="highlight" id="id-60"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">()</span><span class="o">&amp;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-61"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">()</span><span class="o">&amp;&amp;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark>引用限定符不适用于静态成员函数和友元函数。</p>
<p><strong>const和引用限定</strong></p>
<p>const 也可以用于修饰类的成员函数，习惯称为<code>常成员函数</code>。</p>
<div class="highlight" id="id-62"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">get_num</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>const</code> 和<code>引用限定符</code>修饰类的成员函数时，都位于函数的末尾。</p>
<p><mark>注意:</mark> <code>C++11</code> 标准规定，当<code>引用限定符</code>和 <code>const</code> 修饰同一个类的成员函数时，const 必须位于引用限定符前面。</p>
<p>当 <code>const &amp;&amp;</code> 修饰类的成员函数时，调用它的对象只能是<code>右值对象</code>；当 <code>const &amp;</code> 修饰类的成员函数时，调用它的对象既可以是<code>左值对象</code>，也可以是<code>右值对象</code>。无论是 <code>const &amp;&amp;</code> 还是 <code>const &amp;</code> 限定的成员函数，内部都不允许对当前对象做修改操作。</p>
<div class="highlight" id="id-63"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span><span class="kt">int</span> <span class="n">num2</span><span class="p">)</span> <span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">),</span><span class="n">num2</span><span class="p">(</span><span class="n">num2</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//左值和右值对象都可以调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//仅供右值对象调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">get_num2</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="217-nullptr初始化空指针">2.17 nullptr：初始化空指针</h3>
<p>实际开发中，避免产生<code>野指针</code>最有效的方法，就是在<u>定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针</u>。</p>
<p><code>野指针</code>，又称<code>悬挂指针</code>，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 <code>&amp;p</code>），极可能导致程序发生异常。</p>
<p>C++98/03 标准中，将一个指针初始化为空指针的方式：</p>
<div class="highlight" id="id-64"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，可以将指针明确指向 <code>0（0x0000 0000）</code>这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。</p>
<p>相比第一种方式，推荐将指针初始化为 NULL。NULL 并不是 C++ 的关键字，它是 C++ 事先定义好的一个<strong>宏</strong>，并且它的值往往就是字面量 <code>0（#define NULL 0）</code>。</p>
<p><code>C++</code> 中将 <code>NULL</code> 定义为字面常量 <code>0</code>，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和预期不符。</p>
<div class="highlight" id="id-65"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;void*c&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;int n&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码都将输出<code>int n</code>。对于 <code>isnull(0)</code> 来说，显然它真正调用的是参数为整形的 <code>isnull()</code> 函数；而对于 <code>isnull(NULL)</code>，我们期望它实际调用的是参数为 <code>void*c</code> 的 <code>isnull()</code> 函数，但程序的执行结果并不符合预期。</p>
<p><code>C++ 98/03</code> 标准中，如果想令 <code>isnull(NULL)</code> 实际调用的是 <code>isnull(void* c)</code>，就需要对 <code>NULL</code>（或者 0）进行强制类型转换：</p>
<div class="highlight" id="id-66"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">isnull</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">NULL</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">isnull</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于 <code>C++ 98</code> 标准使用期间，<code>NULL</code> 已经得到了广泛的应用，出于兼容性的考虑，<code>C++11</code> 标准并没有对 <code>NULL</code> 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，在 <code>C++11</code> 标准中引入一个新关键字，即 <code>nullptr</code>。</p>
<p><code>nullptr</code> 是 <code>nullptr_t</code> <code>类型的右值常量，专用于初始化空类型指针。nullptr_t</code> 是 <code>C++11</code> 新增加的数据类型，可称为<font color=red>指针空值类型</font>。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要完全定义出多个同 nullptr 完全一样的实例对象。<font color=red>nullptr 可以被隐式转换成任意的指针类型</font>。</p>
<p>通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题:</p>
<div class="highlight" id="id-67"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;void*c&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;int n&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="218-智能指针">2.18 智能指针</h3>
<p><code>智能指针</code>，可以从字面上理解为“智能”的指针。具体来讲，<code>智能指针</code>和<code>普通指针</code>的用法是相似的，不同之处在于，<code>智能指针</code><font color=red>可以在适当时机自动释放分配的内存</font>。也就是说，<u>使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现</u>。</p>
<p><code>C++ 智能指针</code>底层是采用<strong>引用计数</strong>的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p>
<p>关于智能指针的具体使用方法，请参考《C++标准库》</p>
<table><tr><td bgcolor=yellow>shared_ptr</td></tr></table>
<p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr（其中 T 表示指针指向的具体数据类型）的定义位于<memory>头文件，并位于 std 命名空间中。</p>
<p><font color=red>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存</font>。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的使用权（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<table><tr><td bgcolor=yellow>unique_ptr</td></tr></table>
<p>unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。</p>
<p>注意：每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
<p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr（T 为指针所指数据的类型）定义在<memory>头文件，并位于 std 命名空间中。</p>
<table><tr><td bgcolor=yellow>weak_ptr</td></tr></table>
<p>和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr（ T 为指针所指数据的类型）定义在<memory>头文件，并位于 std 命名空间中。</p>
<p>C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。</p>
<p>当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。</p>
]]></description></item><item><title>CMake 笔记 | [6] 设置编译选项</title><link>https://jianye0428.github.io/posts/cmake_note_6/</link><pubDate>Tue, 16 Jan 2024 08:11:33 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_6/</guid><description><![CDATA[<h2 id="一编译器选项相关概念">一、编译器选项相关概念</h2>
<p><code>编译器选项</code>是指在编译程序时，可以通过设置不同的选项来控制编译器的行为和生成的代码的特性。常见的编译器选项包括<code>优化选项</code>、<code>调试选项</code>、<code>警告选项</code>、<code>链接选项</code>等。</p>
<ul>
<li><code>优化选项</code>可以控制编译器对代码进行优化的程度，以提高程序的性能。</li>
<li><code>调试选项</code>可以生成调试信息，以便在程序出现问题时进行调试。</li>
<li><code>警告选项</code>可以控制编译器是否生成警告信息，以帮助开发者发现潜在的问题。</li>
<li><code>链接选项</code>可以控制编译器如何将多个目标文件链接在一起，以生成最终的可执行文件。</li>
</ul>
<p>不同的编译器可能支持不同的选项，具体的选项和使用方法可以参考编译器的文档或者官方网站。</p>
<p>本篇内容涉及到的编译器选项有:</p>
<ul>
<li>优化选项: <code>-fPIC</code>、<code>-fno-rtti</code>、<code>-fno exception</code>
<ul>
<li><code>-fPIC</code>:表示生成位置无关代码。具体来说，位置无关代码可以在不同的进程空间中加载和执行，而不需要进行重定位操作。fPIC选项通常用于生成动态库，因为动态库需要在不同的进程空间中加载和执行。使用-fPIC选项可以确保动态库中的代码可以在不同的进程空间中正确地执行。需要注意的是，使用<code>-fPIC</code>选项会增加代码的大小和运行时开销，因此需要根据具体情况来决定是否使用该选项。</li>
<li><code>-fno-rtti</code>: 选项可以控制编译器是否生成与C++运行时类型信息（RTTI）相关的代码，以减小程序的大小和运行时开销。需要注意的是，禁用RTTI可能会影响程序的可靠性和可维护性，因为RTTI可以帮助开发者在运行时获取对象的类型信息。因此，需要根据具体情况来决定是否使用该选项。</li>
<li><code>-fno exception</code>: 表示禁用C++异常处理机制。具体来说，使用该选项可以使编译器不生成与异常处理相关的代码，从而减小程序的大小和运行时开销。需要注意的是，禁用异常处理机制可能会影响程序的可靠性和可维护性，因为异常处理机制可以帮助开发者处理程序中的异常情况。因此，需要根据具体情况来决定是否使用该选项。</li>
</ul>
</li>
<li>警告选项:<code>-Wall</code>、<code>-Wextra</code>和<code>-Wpedantic</code>
<ul>
<li><code>-Wall</code>: 表示开启所有警告信息。具体来说，编译器会生成所有可能的警告信息，包括一些可能会被忽略的警告信息。开启<code>-Wall</code>选项可以帮助开发者发现潜在的问题，提高代码的质量和可靠性。但是，由于<code>-Wall</code>会生成大量的警告信息，有时候会影响开发效率，因此需要根据具体情况来决定是否开启该选项。</li>
<li><code>-Wextra</code>: 表示开启额外的警告信息。具体来说，编译器会生成一些不属于<code>-Wall</code>选项的警告信息，例如一些不符合标准的代码风格、一些未使用的变量等。同理，开启<code>-Wextra</code>选项可以帮助开发者发现更多的潜在问题，提高代码的质量和可靠性。但是，由于<code>-Wextra</code>会生成更多的警告信息，有时候会影响开发效率，因此需要根据具体情况来决定是否开启该选项。</li>
<li><code>-Wpedantic</code>: 表示开启严格的警告信息。具体来说，编译器会生成一些不符合C或C++标准的代码警告信息，例如使用了不推荐的语法、未定义的行为等。开启<code>-Wpedantic</code>选项可以帮助开发者编写符合标准的代码，提高代码的可移植性和可靠性。同理，由于<code>-Wpedantic</code>会生成更多的警告信息，有时候会影响开发效率，因此需要根据具体情况来决定是否开启该选项</li>
</ul>
</li>
</ul>
<h2 id="二编译器选项设置">二、编译器选项设置</h2>
<p>为目标准备了标志列表，其中一些将无法在Windows上使用：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">compile_flags</span> <span class="s2">&#34;-fPIC&#34;</span> <span class="s2">&#34;-Wall&#34;</span> <span class="s2">&#34;-fPIC&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="s">WIN32</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">compile_flags</span> <span class="s2">&#34;-Wextra&#34;</span> <span class="s2">&#34;-Wpedantic&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为库设置编译选项：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">target_compile_options</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PRIVATE</span> <span class="o">${</span><span class="nv">compile_flags</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>编译选项可以添加三个级别的可见性：<code>INTERFACE</code>、<code>PUBLIC</code>和<code>PRIVATE</code>。</p>
<ul>
<li><code>PRIVATE</code>:编译选项会应用于给定的目标，不会传递给与目标相关的目标。</li>
<li><code>INTERFACE</code>:给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。</li>
<li><code>PUBLIC</code>:编译选项将应用于指定目标和使用它的目标。</li>
</ul>
<p><font color=red>如何确定</font>项目在<code>CMake</code>构建时，实际使用了哪些编译标志？</p>
<p>一种方法是，使用CMake将额外的参数传递给本地构建工具。本例中会设置环境变量VERBOSE=1：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir -p build
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">$ cmake ..
</span></span><span class="line"><span class="cl">$ cmake --build . -- <span class="nv">VERBOSE</span><span class="o">=</span><span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">... lots of output ...
</span></span><span class="line"><span class="cl">Scanning dependencies of target test_message
</span></span><span class="line"><span class="cl">make<span class="o">[</span>2<span class="o">]</span>: 离开目录“/home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/build”
</span></span><span class="line"><span class="cl">/usr/bin/make -f message-module/CMakeFiles/test_message.dir/build.make message-module/CMakeFiles/test_message.dir/build
</span></span><span class="line"><span class="cl">make<span class="o">[</span>2<span class="o">]</span>: 进入目录“/home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/build”
</span></span><span class="line"><span class="cl"><span class="o">[</span> 25%<span class="o">]</span> Building CXX object message-module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/build/message-module <span class="o">&amp;&amp;</span> /usr/bin/c++   -I/home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/message-module/include  -O3 -DNDEBUG   -fPIC -Wall -Wextra -Wpedantic -std<span class="o">=</span>gnu++11 -o CMakeFiles/test_message.dir/src/message.cpp.o -c /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/message-module/src/message.cpp
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Linking CXX static library ../lib/libtest_message_release.a
</span></span><span class="line"><span class="cl">... lots of output ...</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种，使用CMake参数进行配置：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cmake -D <span class="nv">CMAKE_CXX_FLAGS</span><span class="o">=</span><span class="s2">&#34;-fno-exceptions -fno-rtti&#34;</span> ..</span></span></code></pre></td></tr></table>
</div>
</div><p>这个命令将编译项目，禁用异常和运行时类型标识(RTTI)。</p>
<h2 id="三补充">三、补充</h2>
<p>大多数时候，编译器有特性标示。当前的例子只适用于GCC和Clang；其他编译器不确定是否会理解这些标志。如果项目是真正跨平台，那么这个问题就必须得到解决，以下为两种解决方案：</p>
<p>第一种，所需编译器标志列表附加到每个配置类型CMake变量<code>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</code>。标志确定设置为给定编译器有效的标志，因此将包含在if-endif子句中，用于检查<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>变量：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">GNU</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wsuggest-final-types&#34;</span> <span class="s2">&#34;-Wsuggest-final-methods&#34;</span> <span class="s2">&#34;-Wsuggest-override&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">Clang</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span> <span class="s2">&#34;-Qunused-arguments&#34;</span> <span class="s2">&#34;-fcolor-diagnostics&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wdocumentation&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第二种，定义特定的标志列表：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">COMPILER_FLAGS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">COMPILER_FLAGS_DEBUG</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">COMPILER_FLAGS_RELEASE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">GNU</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wsuggest-final-types&#34;</span> <span class="s2">&#34;-Wsuggest-final-methods&#34;</span> <span class="s2">&#34;-Wsuggest-override&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">Clang</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span> <span class="s2">&#34;-Qunused-arguments&#34;</span> <span class="s2">&#34;-fcolor-diagnostics&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wdocumentation&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>稍后，使用生成器表达式来设置编译器标志的基础上，为每个配置和每个目标生成构建系统:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">target_compile_option</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">  <span class="s">PRIVATE</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CXX_FLAGS</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${CXX_FLAGS_DEBUG}&gt;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${CXX_FLAGS_RELEASE}&gt;&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们推荐使用第二种方法。</p>
<p>两种方法都有效，并在许多项目中得到广泛应用。不过，每种方式都有缺点。<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>不能保证为所有编译器都定义。此外，一些标志可能会被弃用，或者在编译器的较晚版本中引入。</p>
<p>与<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>类似，<code>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</code>变量不能保证为所有语言和供应商都提供定义。尽管检查这些变量的方式非常流行，但我们认为更健壮的替代方法是检查所需的标志集是否与给定的编译器一起工作，这样项目中实际上只使用有效的标志。</p>
]]></description></item><item><title>CMake 笔记 | [4] 条件语句、选项命令以及指定编译器</title><link>https://jianye0428.github.io/posts/cmake_note_4/</link><pubDate>Mon, 15 Jan 2024 09:07:13 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_4/</guid><description><![CDATA[<h2 id="一条件语句">一、条件语句</h2>
<p>首先，我们还是拿我们上一篇根目录下的CMakeLists.txt文件进行讲解。</p>
<p>源码地址为：https://gitee.com/jiangli01/tutorials/tree/master/cmake-tutorial/chapter1/11</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Set install direcotory
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，我们使用了一个条件语句<code>if()...endif()</code>和一个选项命令<code>option</code>。这一节我们先对条件语句<code>if()...endif()</code>进行讲解，关于选项<code>option</code>命令，将在下一节进行讲解。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>判断CMake自带的宏<code>CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</code>有没有处于开启状态，如果是默认状态的话，则<code>CMAKE_INSTALL_PREFIX</code>将被设置为<code>${CMAKE_SOURCE_DIR}/output/</code>。</p></div>
    </div>
  </div>
<p>这里，我们只写一个<code>CMakeLists.txt</code>对条件语句<code>if()...else()</code>和宏<code>CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</code>、<code>CMAKE_INSTALL_PREFIX</code>进行探索。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">condition</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;CMAKE_INSTALL_PREFIX is &#34;</span> <span class="o">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们对<code>CMAKE_INSTALL_PREFIX</code>提前进行了定义</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">condition</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span> <span class="s">off</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/test</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;CMAKE_INSTALL_PREFIX is &#34;</span> <span class="o">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二命令选项">二、命令选项</h2>
<p>当然，上述内容我们也可以在编译时，使用如下命令，而不用显式地在<code>CMakeLists.txt</code>中对<code>CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</code>进行设置，但我们需要在<code>CMakeLists.txt</code>中添加<code>option</code>命令。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">condition</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span> <span class="s2">&#34;Set default install path&#34;</span> <span class="s">off</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/test</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;CMAKE_INSTALL_PREFIX is &#34;</span> <span class="o">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake .. -DCMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT<span class="o">=</span>OFF</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，-D开关用于为CMake设置任何类型的变量：逻辑变量、路径等等。</p>
<p>源码地址: <a href="https://gitee.com/jiangli01/tutorials/tree/master/cmake-tutorial/chapter1/11"target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/jiangli01/tutorials/tree/master/cmake-tutorial/chapter1/11<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="三指定编译器">三、指定编译器</h2>
<p>到目前为止，我们还没有考虑过使用CMake如何选择编译器。<code>CMake</code>可以根据平台和生成器选择编译器，还能将编译器标志设置为默认值。</p>
<p>在实际工作中，指定编译器十分重要，比如我们要交叉编译嵌入式的项目，亦或是我们可以将<code>Qt</code>、<code>OpenCV</code>等三方库交叉编译到我们的嵌入式项目中。具体关于如何编译其他三方库生成指定的形式，我们将在之后讲到交叉编译时会详细讲解。</p>
<h3 id="31-通过命令行的形式指定">3.1 通过命令行的形式指定</h3>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake -D <span class="nv">CMAKE_CXX_COMPILER</span><span class="o">=</span>clang++ ..</span></span></code></pre></td></tr></table>
</div>
</div><p>指定<code>c++</code>的编译器为<code>clang++</code></p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CMAKE_CXX_COMPILER 指定C++编译器
</span></span><span class="line"><span class="cl">CMAKE_C_COMPILER 指定C编译器
</span></span><span class="line"><span class="cl">CMAKE_Fortran_COMPILER 指定Fortran编译器</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="32-通过导出环境变量指定">3.2 通过导出环境变量指定</h3>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">env <span class="nv">CXX</span><span class="o">=</span>clang++ cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>导出环境变量，指定C++的编译器为Clang++</p>
<p><code>CXX</code>(<code>C++</code>编译器)、<code>CC</code>(C编译器)和<code>FC</code>(Fortran编译器)</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>引用<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>注意: CMake了解运行环境，可以通过-D开关或者环境变量设置许多选项。第一种方法覆盖第二种方法，但是建议使用-D的显式设置选项。显式由于隐式，因为环境变量可能被设置为不合适的值（当前项目）。
注意: 这里，我们假设，其他的编译器，如clang++在标准的路径中可以用，CMake可以在标准路径中执行查找编译器。如果在标准路径中不可以用使用，则用户需要将完整的编译器可执行文件或者包装器路径传递给CMake。如：</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake -D <span class="nv">CMAKE_CXX_COMPILER</span><span class="o">=</span>/mnt/usr/bin/clang++ ..</span></span></code></pre></td></tr></table>
</div>
</div><p>注意: 这里，建议使用<code>-DCMAKE_&lt;LANG&gt;_COMPILER</code>选项设置编译器，而不是导出CXX、CC和FC。这是确保跨平台并与非POSIX兼容的唯一方法。为了避免变量污染环境，这些变量会影响与项目一起构建的外部库环境。</p>
</div>
    </div>
  </div>
<h3 id="33-在cmake中指定">3.3 在CMake中指定</h3>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER</span> <span class="s">/mnt/usr/bin/clang++</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在使用CMake进行构建时，CMake会进行一系列的平台测试，以确定哪些编译器可以使用以及它们是否适合当前的项目。</p>
<p>一个合适的编译器不仅取决于我们使用的平台，还取决于我们想要的生成器。CMake执行的第一个测试基于项目语言的编译器名称。如，CC是一个工作i的C编译器，那么它将用作C项目的默认编译器。</p>
<p>GNU/Linux上，使用Unix Makefile或Ninja时，GCC家族中的编译器很可能是C++、C和Fortran的默认选择。Windows上，将选择Visual Studio中C++和C编译器。如果选择MinGW或MSYS Makefile作为生成器，则默认使用MinGW编译器。</p>
<h3 id="34-编译器的补充">3.4 编译器的补充</h3>
<p>我们平台上的CMake可以找到可用的编译器和编译器标志的方法是：<code>CMake</code>提供<code>--system-information</code>标志，他将把关于系统的所有信息转储到屏幕或者文件中。</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --system-information information.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中可以看到<code>CMAKE_CXX_COMPILER</code>、<code>CMAKE_C_COMPILER</code>和<code>CMAKE_Fortran_COMPILER</code>的默认值，以及默认标志。</p>
<p>CMake提供了额外的变量来与编译器交互：</p>
<ul>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_LOADED</code>:如果为项目启用了语言<LANG>，则将设置为TRUE。</li>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>:编译器标识字符串，编译器供应商所特有。例如，GCC用于GNU编译器集合，AppleClang用于macOS上的Clang, MSVC用于Microsoft Visual Studio编译器。注意，不能保证为所有编译器或语言定义此变量。</li>
<li><code>CMAKE_COMPILER_IS_GNU&lt;LANG&gt;</code>:如果语言<LANG>是GNU编译器集合的一部分，则将此逻辑变量设置为TRUE。注意变量名的<LANG>部分遵循GNU约定：C语言为CC, C++语言为CXX, Fortran语言为G77。</li>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</code>:此变量包含一个字符串，该字符串给定语言的编译器版本。版本信息在major[.minor[.patch[.tweak]]]中给出。但是，对于CMAKE_<LANG>_COMPILER_ID，不能保证所有编译器或语言都定义了此变量。</li>
</ul>
<p>我们可以使用不同的编译器，构建下面的CMakeLists.txt。</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">recipe-06</span> <span class="s">LANGUAGES</span> <span class="s">C</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C++ compiler loaded? ${CMAKE_CXX_COMPILER_LOADED}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_LOADED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C++ compiler ID is: ${CMAKE_CXX_COMPILER_ID}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C++ from GNU? ${CMAKE_COMPILER_IS_GNUCXX}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C++ compiler version is: ${CMAKE_CXX_COMPILER_VERSION}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C compiler loaded? ${CMAKE_C_COMPILER_LOADED}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_C_COMPILER_LOADED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C compiler ID is: ${CMAKE_C_COMPILER_ID}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C from GNU? ${CMAKE_COMPILER_IS_GNUCC}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C compiler version is: ${CMAKE_C_COMPILER_VERSION}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CMake 笔记 | [5] 构建类型(Debug、Release以及其他)</title><link>https://jianye0428.github.io/posts/cmake_note_5/</link><pubDate>Mon, 15 Jan 2024 12:54:34 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_5/</guid><description><![CDATA[<h2 id="一基本概念构建类型">一、基本概念构建类型</h2>
<p><code>CMake</code>可以识别的构建类型是：</p>
<ul>
<li>Debug：用于在没有优化的情况下，使用带有调试符号构建库或者可执行文件</li>
<li>Release: 用于构建的优化的库或者可执行文件，不包含调试符号</li>
<li>RelWithDebInfo：用于构建较少的优化库或者可执行文件，包含调试符号</li>
<li>MinSizeRel：用于不增加目标代码大小的优化方式，来构建库或者可执行文件</li>
</ul>
<p>控制生成构建系统使用的配置变量是<code>CMAKE_BUILD_TYPE</code>，该变量默认为空。</p>
<p>这里我们仍然选择<a href="https://jianye0428.github.io/posts/cmake_note_3/"target="_blank" rel="external nofollow noopener noreferrer">CMake第三篇—动态库和静态库的补充中的代码<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，但是这里我们对CMakeLists.txt稍作修改。</p>
<h2 id="二项目结构">二、项目结构</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── cmake
</span></span><span class="line"><span class="cl">│   └── message_config.cmake.in
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   ├── message_export_lib.h
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   └── src
</span></span><span class="line"><span class="cl">│       └── message.cpp
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">└── hello_world.cpp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">4</span> directories, <span class="m">9</span> files</span></span></code></pre></td></tr></table>
</div>
</div><p>项目源码: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_5/message_module_lib_standard"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_5/message_module_lib_standard<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="21-message-module模块下的cmakeliststxt">2.1 message-module模块下的CMakeLists.txt</h3>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PUBLIC</span> <span class="s">-DMESSAGE_LIB_SHARED_BUILD</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PRIVATE</span> <span class="s">-DMESSAGE_LIB_EXPORTS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">STATIC</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加别名，以便库可以在构建树中使用，例如在测试时
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">DEBUG_POSTFIX</span> <span class="s2">&#34;_debug&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">RELEASE_POSTFIX</span> <span class="s2">&#34;_release&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.h&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.hpp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILE</span> <span class="s">message_lib.cmake</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">CMakePackageConfigHelpers</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the config file that is includes the exports
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">configure_package_config_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake.in</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">INSTALL_DESTINATION</span> <span class="s2">&#34;lib/cmake/test_message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the version file for the config file
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">write_basic_package_version_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config_version.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">VERSION</span> <span class="s2">&#34;${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">COMPATIBILITY</span> <span class="s">AnyNewerVersion</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">FILES</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">export</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span> <span class="s">FILE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:
这里，我们基本上没有做修改，只添加了以下内容：
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>引用<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">DEBUG_POSTFIX</span> <span class="s2">&#34;_debug&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">RELEASE_POSTFIX</span> <span class="s2">&#34;_release&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这将在 <code>debug</code> 构建模式下将库名后缀设置为 <code>_debug</code>，在 <code>release</code> 构建模式下将库名后缀设置为 <code>_release</code>。
然后，可以使用 <code>test_message_debug</code> 或 <code>test_message_release</code> 来引用库。当然，我们其实可以使用<code>find_package</code>，然后直接使用库的别名<code>test_message</code>即可。</p></div>
    </div>
  </div></p>
<h3 id="22-根目录下的cmakeliststxt">2.2 根目录下的CMakeLists.txt</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Set install direcotory
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="s">CMAKE_BUILD_TYPE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_BUILD_TYPE</span> <span class="s">Release</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;Build type&#34;</span> <span class="s">FORCE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Build type:                                       ${CMAKE_BUILD_TYPE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Debug configuration:                     ${CMAKE_C_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration:                   ${CMAKE_C_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration with Debug info:   ${CMAKE_C_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, minimal Release configuration:           ${CMAKE_C_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Debug configuration:                   ${CMAKE_CXX_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration:                 ${CMAKE_CXX_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration with Debug info: ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, minimal Release configuration:         ${CMAKE_CXX_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，我们添加了以下内容：</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>引用<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="s">CMAKE_BUILD_TYPE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_BUILD_TYPE</span> <span class="s">Release</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;Build type&#34;</span> <span class="s">FORCE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Build type:                                       ${CMAKE_BUILD_TYPE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Debug configuration:                     ${CMAKE_C_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration:                   ${CMAKE_C_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration with Debug info:   ${CMAKE_C_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, minimal Release configuration:           ${CMAKE_C_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Debug configuration:                   ${CMAKE_CXX_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration:                 ${CMAKE_CXX_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration with Debug info: ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, minimal Release configuration:         ${CMAKE_CXX_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，检查是否设置了<strong>构建类型</strong>。如果没有，则将构建类型设置为 <code>Release</code>。然后，它使用 <code>message</code> 命令输出各种编译标志，包括 <code>C</code> 和 <code>C++</code> 的 <code>Debug</code> 和 <code>Release</code> 配置，以及最小 <code>Release</code> 配置和<font color=red>带有调试信息的 <code>Release</code></font>配置。这些信息对于调试和优化构建非常有用。</p></div>
    </div>
  </div>
<h3 id="23-验证输出">2.3 验证输出</h3>
<p>我们执行以下命令，这里没有指定构建类型，即默认构建类型为<code>Release</code>。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 7.5.0
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ - skipped
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build type:                                       Release
</span></span><span class="line"><span class="cl">-- C flags, Debug configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration with Debug info:
</span></span><span class="line"><span class="cl">-- C flags, minimal Release configuration:
</span></span><span class="line"><span class="cl">-- C++ flags, Debug configuration:                   -g
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration:                 -O3 -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, minimal Release configuration:         -Os -DNDEBUG
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/build</span></span></code></pre></td></tr></table>
</div>
</div><p>执行<code>make</code>:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span> 25%<span class="o">]</span> Building CXX object message_module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Linking CXX static library ../lib/libtest_message_release.a
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span> 75%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们执行<code>make</code>命令后，生成的库命名为<code>libtest_message_release.a</code>,并将其存入lib目录中。</p>
<p>执行:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make install</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果如下:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world
</span></span><span class="line"><span class="cl">Install the project...
</span></span><span class="line"><span class="cl">-- Install configuration: <span class="s2">&#34;Release&#34;</span>
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/libtest_message_release.a
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include/message_export_lib.h
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include/message.h
</span></span><span class="line"><span class="cl">-- Up-to-date: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_lib.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_lib-release.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_config.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_config_version.cmake</span></span></code></pre></td></tr></table>
</div>
</div><p>设置构建类型为debug:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake .. -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug</span></span></code></pre></td></tr></table>
</div>
</div><p>则输出:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 7.5.0
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ - skipped
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build type:                                       Debug
</span></span><span class="line"><span class="cl">-- C flags, Debug configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration with Debug info:
</span></span><span class="line"><span class="cl">-- C flags, minimal Release configuration:
</span></span><span class="line"><span class="cl">-- C++ flags, Debug configuration:                   -g
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration:                 -O3 -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, minimal Release configuration:         -Os -DNDEBUG
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/build</span></span></code></pre></td></tr></table>
</div>
</div><p>执行<code>make</code>:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><p>输出如下:</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span> 25%<span class="o">]</span> Building CXX object message_module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Linking CXX static library ../lib/libtest_message_debug.a
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span> 75%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们执行<code>make</code>命令后，生成的库命名为<code>libtest_message_debug.a</code>,并将其存入lib目录中。</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make install</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Consolidate compiler generated dependencies of target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl">Consolidate compiler generated dependencies of target hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world
</span></span><span class="line"><span class="cl">Install the project...
</span></span><span class="line"><span class="cl">-- Install configuration: <span class="s2">&#34;Debug&#34;</span>
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/libtest_message_debug.a
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include/message_export_lib.h
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include/message.h
</span></span><span class="line"><span class="cl">-- Up-to-date: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_lib.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_lib-debug.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_config.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_config_version.cmake</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="三补充">三、补充</h2>
<p><code>Release</code>和<code>Debug</code>在构建项目通常很有用，如评估编译器优化级别的效果。对于单配置生成器，如Unix Makefile、MSYS Makefile或者Ninja，因为要对项目重新配置，这里需要运行CMake两次。</p>
<p>不过，CMake也支持<strong>符合配置生成器</strong>。这些通常是集成开发环境提供的项目文件，最显著的是Visual Studio和XCode，它们可以同时处理多个配置。可以使用CMAKE_CONFIGURATION_TYPES变量对这些生成器的可用配置进行调整。</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir -p build
</span></span><span class="line"><span class="cl"> <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl"> cmake .. -G<span class="s2">&#34;Visual Studio 14 2019 Win64&#34;</span> -D <span class="nv">CMAKE_CONFIGURATION_TYPES</span><span class="o">=</span><span class="s2">&#34;Release;Debug&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将为Release和Debug配置生成一个构建树。然后，您可以使–config标志来决定构建这两个中的哪一个:</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --build . --config Release</span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CMake 简介</title><link>https://jianye0428.github.io/posts/cmake_introduction/</link><pubDate>Wed, 01 Nov 2023 10:31:09 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_introduction/</guid><description><![CDATA[<h2 id="1-总览">1. 总览</h2>
<p><strong>什么是CMake？</strong></p>
<blockquote>
<p>CMake是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不相依于某特定编译器。并可支持多层目录、多个应用程序与多个库。 它用配置文件控制建构过程（build process）的方式和Unix的make相似，只是CMake的配置文件取名为CMakeLists.txt。
CMake并不直接建构出最终的软件，而是产生标准的建构档（如Unix的Makefile或Windows Visual C++的projects/workspaces），然后再依一般的建构方式使用。
这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是CMake和SCons等其他类似系统的区别之处。
它首先允许开发者编写一种平台无关的CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。
显然，CMake 是一个比上述几种 make 更高级的编译配置工具。“CMake”这个名字是&quot;Cross platform MAke&quot;的缩写。虽然名字中含有&quot;make&quot;，但是CMake和Unix上常见的“make”系统是分开的，而且更为高端。 它可与原生建置环境结合使用，例如：make、苹果的Xcode与微软的Visual Studio。</p>
</blockquote>
<p>CMake is not a build system like Unix Make but a build system generator. Its purpose is to take your description of a project and generate a set of configuration files to build that project.</p>
<p>CMake 是构建系统的生成器。它的目标是：根据你对项目的描述信息，去生成一系列的配置文件，来编译构建项目。</p>
<p>As part of the generation of build configuration files, CMake also analyses source code to create a dependency graph of components so that when building the project unnecessary recompilation steps can be omitted to reduce build times. For larger projects this can reduce build times down from tens of minutes or hours, to a few minutes, perhaps even less than one minute.</p>
<p>作为构建配置文件生成的一部分，CMake 还会去分析源码，来创建各个部分之间的依赖图，所以在构建项目时，不必要的重编步骤就会被省略掉。这样节省了大量构建的时间。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">CMake Build Process</div>
</center>
<br>
<p>In addition to a build system, over the years CMake has evolved into a family of development tools: <strong>CMake</strong>, <strong>CTest</strong>, <strong>CPack</strong>, and <strong>CDash</strong>. CMake is the build tool responsible for building software. CTest is a test driver tool, used to run regression tests. CPack is a packaging tool used to create platform-specific installers for software built with CMake. CDash is a web application for displaying testing results and performing continuous integration testing.</p>
<p>除了构建系统，CMake 还发展出一系列工具：CMake 是构建工具，CTest 是用于回归测试的测试工具，CPack 是用于为用 CMake 构建的软件创建指定平台安装器的打包工具，CDash 是展示测试结构和执行持续集成测试的 web 端应用。</p>
<h2 id="2-notion">2. Notion</h2>
<p>The build tree is the directory hierarchy in which all generated files are placed. Generated files consist of the makefile, the compiled object files, and a dependency file (with a . d extension) for each source file.</p>
<p>构建树是放置所有生成文件的目录层级结构。生成文件包括 makefile、编译出来的目标文件、每个源文件的依赖文件。</p>
<h2 id="3-requirements">3. Requirements</h2>
<p>When CMake was being developed, the normal practice for a project was to have a configure script and Makefiles for Unix platforms, and Visual Studio project files for Windows. This duality of build systems made cross-platform development very tedious for many projects: the simple act of adding a new source file to a project was painful. The obvious goal for developers was to have a single unified build system. The developers of CMake had experience with two approaches of solving the unified build system problem.</p>
<p>在 CMake 被开发之时，常规的项目操作是：一个配置脚本，以及 Makefiles (Unix 平台) 或 Visual Studio 项目文件(Windows 平台)。这样的构建系统导致跨平台开发非常地难受：简单地添加一个文件到项目的操作都很痛苦。对于开发者而言，一个显然的目标就是一个统一的构建系统。</p>
<p>The basic constraints of the new build system would be as follows: 对于新的构建系统的限制如下:</p>
<ul>
<li>Depend only on a C++ compiler being installed on the system. 只依赖系统安装的 c++ 编译器</li>
<li>It must be able to generate Visual Studio IDE input files. 可以生成 VS IDE 的输入文件</li>
<li>It must be easy to create the basic build system targets, including static libraries, shared libraries, executables, and plugins. 很容易创建目标文件</li>
<li>It must be able to run build time code generators. 可以运行编译时代码生成器</li>
<li>It must support separate build trees from the source tree. 可以支持独立于源树的构建树</li>
<li>It must be able to perform system introspection, i.e., be able to determine automatically what the target system could and could not do. 反映系统问题</li>
<li>It must do dependency scanning of C/C++ header files automatically. 自动地进行 C/C++ 头文件的依赖扫描</li>
<li>All features would need to work consistently and equally well on all supported platforms. 所有特性需要协调工作，且良好运行在所有支持的平台</li>
</ul>
<p>In order to avoid depending on any additional libraries and parsers, CMake was designed with only one major dependency, the C++ compiler (which we can safely assume we have if we’re building C++ code). This did limit CMake to creating its own simple language, which is a choice that still causes some people to dislike CMake. However, at the time the most popular embedded language was Tcl. If CMake had been a Tcl-based build system, it is unlikely that it would have gained the popularity that it enjoys today.</p>
<p>为了避免依赖额外的库或解析器，CMake 只存在一种主要的依赖：C++ 编译器。这限制了 CMake 创建属于自己的语言，引起大家的不满。</p>
<p>The ability to generate IDE project files is a strong selling point for CMake, but it also limits CMake to providing only the features that the IDE can support natively. However, the benefits of providing native IDE build files outweigh the limitations. Although this decision made the development of CMake more difficult, it made the development of ITK and other projects using CMake much easier. Developers are happier and more productive when using the tools they are most familiar with. By allowing developers to use their preferred tools, projects can take best advantage of their most important resource: the developer.</p>
<p>可以生成 IDE 项目文件的能力是 CMake 的一大卖点，但同样也限制了 CMake 只去提供 IDE 本地支持的一些特性。但是，利大于弊。</p>
<p>Another early CMake requirement also came from autotools: the ability to create build trees that are separate from the source tree. This allows for multiple build types to be performed on the same source tree. It also prevents the source tree from being cluttered with build files, which often confuses version control systems.</p>
<p>支持创建独立于源树的构建树。这个可以使相同的源树拥有众多的构建类型，同时也防止源树被构建文件污染，导致版本控制系统的混乱。
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">CMake Build System</div>
</center>
<br>
<h2 id="4-implementation">4. Implementation</h2>
<p><strong>Environment Variables (or Not)</strong>
The trouble with this approach is that for the build to work, all of these external variables need to be set each time a build is performed. To solve this problem CMake has a cache file that stores all of the variables required for a build in one place. These are not shell or environment variables, but CMake variables. The first time CMake is run for a particular build tree, it creates a CMakeCache.txt file which stores all the persistent variables for that build. Since the file is part of the build tree, the variables will always be available to CMake during each run.</p>
<p>难点在于在每次编译时，所有的外部变量都需要设置一遍。为了解决这个问题，CMake 用一个 cache 文件保存所有编译所需的变量。这些不是 shell 或环境变量，只是 CMake 的变量。第一次 CMake 运行时，它会创建 CMakeCache.txt 文件来保存这些变量。这个文件就是构建树的一部分，所以对于 CMake 的每次运行都是有效的。</p>
<p><strong>The Configure Step</strong>
During the configure step, CMake first reads the <code>CMakeCache.txt</code> if it exists from a prior run. It then reads CMakeLists.txt, found in the root of the source tree given to CMake. During the configure step, the <code>CMakeLists.txt</code> files are parsed by the CMake language parser. Each of the CMake commands found in the file is executed by a command pattern object. Additional <code>CMakeLists.txt</code> files can be parsed during this step by the <code>include</code> and <code>add_subdirectory</code> CMake commands. CMake has a C++ object for each of the commands that can be used in the CMake language. Some examples of commands are <code>add_library</code>, <code>if</code>, <code>add_executable</code>, <code>add_subdirectory</code>, and include. In effect, the entire language of CMake is implemented as calls to commands. The parser simply converts the CMake input files into command calls and lists of strings that are arguments to commands.</p>
<p>在配置阶段，CMake 首先读取 CMakeCache.txt 文件(如果存在的话)，然后读取 CMakeLists.txt 来查找源树的根。在配置阶段，CMakeLists.txt 文件会被 CMake 语言解析器解析。每当有 CMake 命令在这个文件中被找到就会被参数模版对象执行。额外的 CMakeLists.txt 文件会在处理 include 和 add_subdirectory 命令之时解析。</p>
<p>The configure step essentially “runs” the user-provided CMake code. After all of the code is executed, and all cache variable values have been computed, CMake has an in-memory representation of the project to be built. This will include all of the libraries, executables, custom commands, and all other information required to create the final build files for the selected generator. At this point, the <code>CMakeCache.txt</code> file is saved to disk for use in future runs of CMake.</p>
<p>配置阶段本质上会运行用户提供的 CMake 的代码。在所有代码执行完成，以及所有变量值计算完成之后，CMake 会有一个项目的内存表示需要构建，它会包含所有的库、可执行文件、指定的命令和所有其他需要去创建最终的构建文件的信息。在此，CMakeCache.txt 文件会被保存到磁盘中，作为 CMake 之后的使用。</p>
<p><strong>The Generate Step</strong></p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">CMake Generator Expression</div>
</center>
<br>
<p>Once the configure step has been completed, the generate step can take place. The generate step is when CMake creates the build files for the target build tool selected by the user. At this point the internal representation of targets (libraries, executables, custom targets) is converted to either an input to an IDE build tool like Visual Studio, or a set of Makefiles to be executed by <code>make</code>. CMake’s internal representation after the configure step is as generic as possible so that as much code and data structures as possible can be shared between different built tools.</p>
<p>一旦配置完成，就到生成阶段了。这个阶段 CMake 会创建用户选择的目标构建工具的构建文件。在此，目标的内部表示会被转成 IDE 的构建工具，或者 make 用到的一系列 Makefiles。CMake 的内部表示需要尽可能通用，这样代码和数据结构可以被不同的构建工具所共享。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Generation</div>
</center>
<br>
<h2 id="5-the-code">5. The code</h2>
<p>CMake is an object-oriented system using inheritance, design patterns and encapsulation</p>
<p>CMake 是使用了继承的面向对象的系统</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Cmake Inheritage System</div>
</center>
<br>
<p>The results of parsing each <code>CMakeLists.txt</code> file are stored in the <code>cmMakefile</code> object. In addition to storing the information about a directory, the <code>cmMakefile</code> object controls the parsing of the <code>CMakeLists.txt</code> file. The parsing function calls an object that uses a lex/yacc-based parser for the CMake language. Since the CMake language syntax changes very infrequently, and lex and yacc are not always available on systems where CMake is being built, the lex and yacc output files are processed and stored in the <code>Source</code> directory under version control with all of the other handwritten files.</p>
<p>解析 CMakeLists.txt 文件的结果被保存到 cmMakefile 对象当中。除了保存目录信息，它还控制文件的解析。解析函数可以使用 CMake 语言的解析器。CMake 语法不怎么变化，解析器在 CMake 构建时并非总是活跃的，解析的结果会被保存在 Source 目录下。</p>
<p>Another important class in CMake is cmCommand. This is the base class for the implementation of all commands in the CMake language. Each subclass not only provides the implementation for the command, but also its documentation.</p>
<p>另一个重要的类是 cmCommand。这是 CMake 命令的基类。每个子类不仅提供命令的实现，还有它们的文档说明。</p>
<h2 id="6-dependency-analysis">6. Dependency Analysis</h2>
<p>Since Integrated Development Environments (IDEs) support and maintain file dependency information, CMake skips this step for those build systems. For IDE builds, CMake creates a native IDE input file, and lets the IDE handle the file level dependency information. The target level dependency information is translated to the IDE’s format for specifying dependency information.</p>
<p>由于 IDE 本身支持和持有文件依赖信息，CMake 就可以跳过这个步骤。IDE 构建时，CMake 创建一个本地的 IDE 输入文件，然后让 IDE 去处理文件级别的依赖信息。目标级别的依赖信息会被转成 IDE 的格式来指明依赖信息。</p>
<p>With Makefile-based builds, native make programs do not know how to automatically compute and keep dependency information up-to-date. For these builds, CMake automatically computes dependency information for C, C++ and Fortran files. Both the generation and maintenance of these dependencies are automatically done by CMake. Once a project is initially configured by CMake, users only need to run make and CMake does the rest of the work.</p>
<p>在使用 Makefile 构建，本地 make 程序不需要知道怎么自动计算和保存依赖信息为最新。构建时，CMake 自动的计算这些依赖信息，包括生成和保存。一旦 CMake 初始配置好了项目，用户只需要去运行 make，然后 CMake 会把剩下的工作完成。</p>
<p>CMake does more than just generate the build files used to create object files and executable programs. It will generate a dependency file for each source file in the project. For example a main.cpp file will have a generated main.cpp.d file saved in the build folder hierarchy honouring the directory structure of the source files.</p>
<p>CMake 不只是生成构建文件，它会为项目里的每个源文件生成依赖文件。比如 main.cpp 会促使生成 main.cpp.d 文件。</p>
<p>Although users do not need to know how CMake does this work, it may be useful to look at the dependency information files for a project. This information for each target is stored in four files called depend.make, flags.make, build.make, and DependInfo.cmake. depend.make stores the dependency information for all the object files in the directory. flags.make contains the compile flags used for the source files of this target. If they change then the files will be recompiled. DependInfo.cmake is used to keep the dependency information up-to-date and contains information about what files are part of the project and what languages they are in. Finally, the rules for building the dependencies are stored in build.make. If a dependency for a target is out of date then the depend information for that target will be recomputed, keeping the dependency information current. This is done because a change to a .h file could add a new dependency.</p>
<p>依赖信息会被保存在 4 个文件当中，depend.make, flags.make, build.make, DependInfo.cmake 文件。depend.make 保存所有目录下的目标文件的依赖信息。flags.make 含有从源文件到目标的编译参数，如果参数被更改，这个文件也会被重新编译。DependInfo.cmake 是用来保证依赖信息是最新的，保存有哪些文件是项目的一部分以及它们是什么语言的信息。最后，构建这些依赖的规则会被保存在 build.make 文件中。如果目标的依赖过期了，那么依赖信息会被重新计算，保证依赖信息最新。这样做是因为头文件可能会添加新的依赖。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Cmake Dependency Graph</div>
</center>
<br>
<h2 id="7-ctest-and-cpack">7. CTest and CPack</h2>
<p>The <code>ctest</code> executable is used to run regression tests. A project can easily create tests for CTest to run with the <code>add_test</code> command. The tests can be run with CTest, which can also be used to send testing results to the CDash application for viewing on the web. CTest and CDash together are similar to the Hudson testing tool. They do differ in one major area: CTest is designed to allow a much more distributed testing environment. Clients can be setup to pull source from version control system, run tests, and send the results to CDash. With Hudson, client machines must give Hudson ssh access to the machine so tests can be run.</p>
<p>ctest 可执行文件用于跑回归测试。一个项目可以通过 <code>add_test</code> 命令很方便地创建测试。由 CTest 来执行，所以也可以把测试结果发给 CDash 来做 web 端展示。</p>
<p>The <code>cpack</code> executable is used to create installers for projects. CPack works much like the build part of CMake: it interfaces with other packaging tools. For example, on Windows the NSIS packaging tool is used to create executable installers from a project. CPack runs the install rules of a project to create the install tree, which is then given to a an installer program like NSIS. CPack also supports creating RPM, Debian <code>.deb</code> files, <code>.tar</code>, <code>.tar.gz</code> and self-extracting tar files.</p>
<p>cpack 可执行文件用来创建项目的安装器。</p>
<h2 id="8-reference">8. Reference</h2>
<p>[1]. <a href="https://mp.weixin.qq.com/s/d3wFZoyDwah5qO4UWvvXtg"target="_blank" rel="external nofollow noopener noreferrer">CMake 构建工具<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
[2]. <a href="https://aosabook.org/en/cmake.html"target="_blank" rel="external nofollow noopener noreferrer">https://aosabook.org/en/cmake.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
[3]. <a href="https://blog.feabhas.com/2021/07/cmake-part-1-the-dark-arts/"target="_blank" rel="external nofollow noopener noreferrer">https://blog.feabhas.com/2021/07/cmake-part-1-the-dark-arts/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
[4]. <a href="https://blog.feabhas.com/2021/07/cmake-part-2-release-and-debug-builds/"target="_blank" rel="external nofollow noopener noreferrer">https://blog.feabhas.com/2021/07/cmake-part-2-release-and-debug-builds/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
[5]. <a href="https://mp.weixin.qq.com/s/chn-sEBob9Dxo10cJoaUgg"target="_blank" rel="external nofollow noopener noreferrer">深入理解CMake：优化构建过程，提升开发效率<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>CMake 笔记 | [2] 多目录多文件的CMake构建方式</title><link>https://jianye0428.github.io/posts/cmake_note_2/</link><pubDate>Fri, 12 Jan 2024 15:16:22 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_2/</guid><description><![CDATA[<h3 id="一项目结构">一、项目结构</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── include
</span></span><span class="line"><span class="cl">│   └── message.h
</span></span><span class="line"><span class="cl">├── src
</span></span><span class="line"><span class="cl">│   └── message.cpp
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>项目结构是为了让我们开发人员对项目更加清晰，使代码结构更加清晰（模块化）。一般我们的项目比较简单时，可以构建为如上的项目结构。但是在构建大型项目时，项目结构会更加复杂，具体请参考下节内容。</p>
<p>这里我们构建了include目录和src目录，include目录主要存放的是CPP文件的头文件，即函数的声明，为使用它的文件提供API。src目录主要是存放的函数的具体实现。</p>
<blockquote>
<p>源码地址:</p>
</blockquote>
<h3 id="二messageh">二、message.h</h3>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="三messagecpp">三、message.cpp</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="四hello_worldcpp">四、hello_world.cpp</h3>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span> <span class="n">message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="s">&#34;Hello, CMake World!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="s">&#34;Goodbye, CMake World!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="五cmake文件">五、CMake文件</h3>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong></p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将<code>include</code>目录下的所有文件包含进来，这样include目录下的message.h将会被包含到整个项目中。如果我们在细分目录中使用包含某一模块的头文件，我们可以在具体模块的CMakeLists.txt中使用该命令，且要包含的头文件的可见性只有该模块，其他模块不可见，具体使用方法，请参考下节内容。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-43"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果<code>include</code>目录和<code>src</code>目录中有多个头文件和源文件，使用如上命令可以将所有头文件集合到HEADER和SOURCE自定义宏定义中，使用时的命令为<code>${HEADER}</code>和<code>${SOURCE}</code>。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-44"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这将结合<code>include</code>目录下的文件和src目录下的文件以及<code>hello_world.cpp</code>生成名为<code>hello-world</code>的可执行文件。</p></div>
    </div>
  </div>
<h3 id="六构建及编译">六、构建及编译</h3>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>构建过程:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/02/build</span></span></code></pre></td></tr></table>
</div>
</div><p>构建可执行文件并输出:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Scanning dependencies of target hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span> 33%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 66%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>上一篇我们没有讲将执行cmake命令后生成的MakeFile文件，其如何构建出可执行文件的具体操作，只是简单的说MakeFile需要make命令执行。</p>
<p>在我们执行完cmake ..后，将生成MakeFile文件，然后执行make后便可以生成可执行文件。</p>
<p>这里我们进行补充说明：如果我们在GNU/Linux上，执行CMake ..后会生成MakeFile文件，然后执行make命令即可生成可执行文件；在Windows上，执行cmake ..后会生成sln文件，需要使用VS进行打开，然后对其进行生成操作。Windows生成sln文件后的具体操作过程请参考最后一些补充内容。除此之外，我们可以执行以下命令，不分平台直接构建出可执行文件:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --build .</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="七静态库和动态库简介">七、静态库和动态库简介</h3>
<p>首先，如果对程序的生命周期的不清楚，请先移步<a href="https://mp.weixin.qq.com/s?__biz=MzkxMzI5Mjk4Mg==&amp;mid=2247483658&amp;idx=1&amp;sn=70144d3480b23fe13f447e3ef715a6a9&amp;chksm=c17eaad3f60923c50560d65017f44bff5e95b79765d4fce5e3f0f2f586c95799d1d671c4d945&amp;token=1465071518&amp;lang=zh_CN&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>进行学习。</p>
<h4 id="71-静态库">7.1 静态库</h4>
<p>在链接阶段，会将汇编生成的目标文件<code>.o</code>与引用到的库<strong>一起链接打包到可执行文件中</strong>。这个链接方式为<strong>静态链接</strong>，所需要的.o（unix系统）称为静态库。</p>
<ul>
<li>静态库对函数库的链接是放在编译时期完成的。</li>
<li>程序在运行时与函数库再无瓜葛，移植方便。</li>
<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接成一个可执行文件。</li>
<li>静态库对程序的更新、部署和发布会带来麻烦。如果静态库libxxx.o更新了，所有使用它的应用程序都需要重新编译、发布给用户。</li>
</ul>
<h4 id="72-动态库">7.2 动态库</h4>
<p>动态库在程序编译时并不会链接到目标代码中，而是<strong>在程序运行时才被载入</strong>。不同的应用程序如果调用相同的库，那么在内存只需要有一份该共享库的实例，规避了空间浪费。</p>
<p>动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的问题，用户只需要更新动态库即可，增量更新。</p>
<p>Windows与Linux执行文件格式不同，在创建动态库的时候有一些差异：</p>
<ul>
<li>在Windows系统下的执行文件格式是PE格式，动态库需要一个DllMain函数做初始化的入口，通常在导出函数的声明时需要有_declspec(dllexport)关键字。</li>
<li>Linux下gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便</li>
</ul>
<h3 id="八构建和链接静态库">八、构建和链接静态库</h3>
<h4 id="81-项目结构">8.1 项目结构</h4>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>在实际的项目开发过程中，我们的项目结构往往会由很多个模块组成，每个模块通过一个单独的CMakeLists.txt去控制，最后在根目录下的CMakeLists.txt中将各个模块组合使用。</p>
<p>本项目中为了简化学习，只构建了一个message-module模块，构建多个模块的方式同理。其中项目中的所有CPP源文件与第一节内容相同，这里就不展开描述了。</p>
<p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_static_lib</p>
<h4 id="82-message-module目录下的cmakelists">8.2 message-module目录下的CMakeLists</h4>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-45"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_library</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>add_library</code>生成必要的构建指令，将指定的源码编译到库中。第一个参数是目标名。整个项目中，可使用相同的名称来引用库。生成的库的实际名称将由CMake通过在前面添加前缀lib和适当的扩展名作为后缀来形成。生成库是根据第二个参数(STATIC或SHARED)和操作系统确定的，本项目是将目标文件生成静态库。</p></div>
    </div>
  </div></p>
<h4 id="83-根目录下的cmakelists">8.3 根目录下的CMakeLists</h4>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置静态库到lib文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIB_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span>  <span class="o">${</span><span class="nv">LIB_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong></p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-46"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置静态库到lib文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIB_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span>  <span class="o">${</span><span class="nv">LIB_FILE</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在构建项目时，我们为了使得项目结构更加清晰，使得生成的可执行文件、静态库以及动态库等文件能够存放在合适的位置。这样的构建方式有助于我们在项目重构、项目优化、debug的时候逻辑更加清晰。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-47"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个命令同第一节内容，因为hello_world.cpp要使用message-module模块的API，且与该CMakeLists.txt在相同层级的目录，所以需要将message-module模块的API包含进去。</p></div>
    </div>
  </div>
<p>如果hello_world.cpp中使用到了多个模块，则此处可以包含多个模块的API：</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/xxx-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-48"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_subdirectory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将我们的message-module添加进来进行编译，这个函数命令将寻找message-module目录下的CMakeLists.txt，如果该目录下没有CMakeLists.txt将报错。</p></div>
    </div>
  </div>
<p>由于在本项目中，hello_world.cpp要使用message-module模块中编译生成的静态库，所以add_subdirectory命令将message-module添加到项目中, add_subdirectory的顺序必须要先于add_executable命令。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-49"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>add_executable</code>命令将<code>hello_world.cpp</code>编译成可执行文件，其名字为项目名称<code>hello-world</code>，该可执行文件使用<code>target_link_libraries</code>命令将<code>message-module</code>模块下编译生成的静态库<code>test_message</code>链接到可执行文件中。</p>
<p>注意：在子模块message-module中编译生成的test_message是全局可见的，即任何模块或者根目录下的CMakeLists.txt都可以直接使用test_message进行调用。</p>
</div>
    </div>
  </div>
<h4 id="84-构建以及编译">8.4 构建以及编译</h4>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>构建及编译过程:</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/03/build</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># cmake --build .</span>
</span></span><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Scanning dependencies of target test_message
</span></span><span class="line"><span class="cl">[ 25%] Building CXX object message-module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl">[ 50%] Linking CXX static library ../lib/libtest_message.a
</span></span><span class="line"><span class="cl">[ 50%] Built target test_message
</span></span><span class="line"><span class="cl">Scanning dependencies of target hello-world
</span></span><span class="line"><span class="cl">[ 75%] Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl">[100%] Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl">[100%] Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过编译日志看到，首先编译了<code>message-module</code>模块，并将编译生成的<code>libtest_message.a</code>存档到了<code>../lib/</code>，即build文件夹中的lib目录中。然后链接<code>hello-world</code>所需要的依赖项，此时便将<code>test-message</code>链接到了<code>hello-world</code>中，最终生成可执行文件<code>hello-world</code>，并将其存放到<code>bin</code>目录中，即build文件夹下的bin目录。</p>
<h3 id="九只链接链接三方库静态">九、只链接链接三方库（静态）</h3>
<p>我们在构建实际项目过程中，一个项目往往需要链接许多的三方库，抑或是我们将自己的算法以静态库的形式发布，通常需要为我们的项目链接三方库。本节讲其中的一种，后续涉及到三方库的链接将讲述所有链接的方式。关于<code>third-party</code>模块下<code>include</code>文件夹下的<code>message.h</code>头文件与前面相同，lib文件夹下的<code>libtest_message.a</code>是第三节编译生成的静态库。</p>
<h4 id="91-项目结构">9.1 项目结构</h4>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── third-party
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   └── lib
</span></span><span class="line"><span class="cl">│       └── libtest_message.a
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>一般，我们将三方库放到项目中一个<code>third-party</code>的文件夹下，当然你也可以随意命名。三方库<code>third-party</code>中包含<code>include</code>和<code>lib</code>分别存放三方库的API和静态库。</p>
<p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_static_lib_third_party</p>
<h4 id="92-cmakeliststxt">9.2 CMakeLists.txt</h4>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/libtest_message.a</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">TEST_MESSAGE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-50"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/libtest_message.a</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将三方库中的静态库定义为TEST_MESSAGE，方便后续使用${TEST_MESSAGE}进行调用。当然你也可以直接在target_link_libraries命令中使用${CMAKE_SOURCE_DIR}/third-party/lib/libtest_message.a进行链接，但是这么做是不推荐的。如果多个模块都使用到了该库，那么定义为宏的方式更加方便和清晰。</p>
<p>今后，我们都将定义出来的宏统一采用了大写，意和CMake自身变量命名对其。</p>
</div>
    </div>
  </div>
<h4 id="93-构建及编译">9.3 构建及编译</h4>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>构建及编译过程:</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/04/build</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --build .</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Scanning dependencies of target hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="十编译和连接动态库">十、编译和连接动态库</h3>
<p>动态库的编写需要区分平台，在GNU/Linux平台上，动态库的编写和调用与静态库没有差别，但是在Windows平台上动态库的编写和调用需要做一定的修改。</p>
<h4 id="101-gnulinux平台上动态库的编译和链接">10.1 GNU/Linux平台上动态库的编译和链接</h4>
<p>在GNU/Linux上生成动态库的方法和静态库生成的方法类似，其目录结构等都与静态库相同，只有在使用<code>add_library</code>命令时，参数<code>STATIC</code>改为<code>SHARE</code>即可,相关项目结构和<code>CMakeLists.txt</code>如下。</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>源码地址: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>配置动态库的<code>CMakeLists.txt</code>:</p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake_minimum_required<span class="o">(</span>VERSION 3.10 FATAL_ERROR<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">project<span class="o">(</span>hello-world LANGUAGES CXX<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 设置可执行文件到bin文件夹下</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>EXECUTE_FILE <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/bin<span class="o">)</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="si">${</span><span class="nv">EXECUTE_FILE</span><span class="si">}</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 设置动态库到lib文件夹下</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>LIB_FILE <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/lib<span class="o">)</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>CMAKE_LIBRARY_OUTPUT_DIRECTORY  <span class="si">${</span><span class="nv">LIB_FILE</span><span class="si">}</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">include_directories<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/message-module/include
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_subdirectory<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/message-module
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_executable<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/hello_world.cpp
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target_link_libraries<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    test_message
</span></span><span class="line"><span class="cl"><span class="o">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们设置动态库存放的路径的宏为CMAKE_LIBRARY_OUTPUT_DIRECTORY。</p>
<p>源码地址：</p>
<h4 id="102-gnulinux只链接三方库动态库">10.2 GNU/Linux只链接三方库（动态库）</h4>
<p>在<code>GNU/Linux</code>上链接动态库的方法和静态库生成的方法类似，其目录结构等都与静态库相同，只有在使用add_library命令时，参数STATIC改为SHARE即可,相关项目结构和<code>CMakeLists.txt</code>如下。</p>
<p>目录结构:</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── third-party
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   └── lib
</span></span><span class="line"><span class="cl">│       └── libtest_message.so
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>源码地址: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib_third_party"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib_third_party<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><code>CMakeLists.txt</code>文件:</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/libtest_message.so</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">TEST_MESSAGE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="103-windows平台上动态库的编译和链接">10.3 Windows平台上动态库的编译和链接</h4>
<p>注意：通过实践发现，Windows中<code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>没有作用。在Windows中生成的动态库将会自动生成到可执行文件所在的目录。</p>
<p>前面我们说Windows平台中生成动态库的源码和静态库是不同的，在Windows平台中，在导出动态库时除了会生成<code>.dll</code>动态库之外，还会生成一个<code>.lib</code>文件。注意，这个<code>.lib</code>文件和静态库的<code>.lib</code>文件是不同的，它里面并不保存代码生成的二进制文件，而是所有需要导出符号的符号表。因此这个<code>.lib</code>文件和编译生成的静态库<code>.lib</code>相比较而言会小的多。</p>
<p>符号表是需要我们在编写源码时进行指定的，如果我们将一个符号导出（符号可以指类、函数等各种类型）,需要在其前面加上<code>__declspec(dllexport)</code>标志，这样这个符号的相关信息就会在导出的<code>.lib</code>中的符号表中了。</p>
<p>如果在源码中没有任何的<code>__declspec(dllexport)</code>,依然可以成功的编译出动态库，但是并不会生成保存符号表的<code>.lib</code>文件。</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>除了导出符号标识符<code>__declspec(dllexport)</code>以外，作为用户使用动态库的时候，对应的头文件的符号还需要<code>__declspec(dllimport)</code>标识符来表示这个符号是从动态库导入的。</p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一般，一个库文件我们并不想对导入和导出分别写两个几乎同样的头文件，因此可以使用宏定义来代替直接使用<code>__declspec(dllexport)</code>和<code>__declspec(dllimport)</code>关键字。</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED_LIB_EXPORT
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_EXPORT __declspec(dllexport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_EXPORT __declspec(dllimport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SHARED_LIB_EXPORT</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样我们只需要在编译（导出）这个库的时候，给编译器添加<code>SHARED_LIB_EXPORT</code>宏。而在使用该库的时候什么都不定义即可。</p>
<p><font color=red>我们通常编写一个头文件来专门管理<code>SHARED_LIB_EXPORT</code>宏定义。</font>为了使得我们的代码在Linux中平台以及静态库的情况，我们的头文件编写如下：</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef EXPORT_LIB_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define EXPORT_LIB_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED_LIB_BUILD
</span></span></span><span class="line"><span class="cl"><span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED_LIB_EXPORT
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API __declspec(dllexport)
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API __declspec(dllimport)
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// SHARED_LIB_EXPORT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// _WIN32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// SHARED_LIB_BUILD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! EXPORT_LIB_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们除了使用<code>SHARED_LIB_API</code>宏定义来判断是否导出为动态库以外，还使用了编译器自带的<code>_WIN32</code>宏来判断是实在windows平台上以及使用。<code>SHARED_LIB_BUILD</code>来判断是否正在编译动态库。</p>
<p>有了这个头文件之后，我们只需要在导出符号表的头文件中包含该头文件，就可以使用<code>SHARED_LIB_API</code>宏定义了。</p>
<p>除此之外，上述的头文件可以通过CMake提供的<code>GenerateExportHeader</code>命令自动生成。关于该命令的使用在后续介绍中会详细的进行探索。</p>
<p><strong>项目结构:</strong></p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │  └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_shared_lib_in_windows</p>
<p><strong>message.h</strong></p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>message.cpp</strong></p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>message-module下的CMakeLists.txt</strong></p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.h&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.hpp&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-51"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>添加别名，以便库可以在构建树中使用，例如在测试时。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-52"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">  <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>设置 test_message 的包含路径。其中，<code>PUBLIC</code> 表示这些头文件路径将会被暴露给该目标的依赖项，即其他目标可以通过依赖该目标来访问这些头文件路径。
<code>BUILD_INTERFACE</code>表示在构建时使用的头文件路径;INSTALL_INTERFACE表示在安装时使用的头文件路径，即将该目标安装到其他地方时，头文件将会被安装到 include 目录下。
综上，这段代码的作用是将当前项目的根目录添加到 “test_message” 目标的头文件包含路径中，以便在编译和安装时能够正确地访问这些头文件。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-53"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>设置 <code>test_message</code> 的相关属性，关于<code>target_include_directories</code>和<code>set_target_properties</code>的具体使用情况，我们将在以后做详细讲解。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-54"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>安装一个名为 “test_message” 的目标（在Windows上需要将编译出来的sln文件使用vs打开，然后再属性栏中的INSTALL右键生成，即可执行install命令）。其中，TARGETS 表示要安装的目标名称，即 test_message。
<code>EXPORT message_export_target</code> 表示将该目标导出到一个名为 “message_export_target” 的 CMake 配置文件中，以便其他项目可以使用该目标。
<strong>注意:</strong> 我们在根目录下已经指定了’install’安装目录的根目录。
<code>RUNTIME DESTINATION ${CMAKE_SOURCE_DIR}/output/bin</code>表示将该目标的可执行文件安装到当前项目的 bin 目录下。
<code>LIBRARY DESTINATION ${CMAKE_SOURCE_DIR}/output/lib</code>表示将该目标的共享库文件安装到 当前项目的 lib 目录下。
<code>ARCHIVE DESTINATION ${CMAKE_SOURCE_DIR}/output/lib</code>)表示将该目标的静态库文件安装到 当前项目的 lib 目录下。
<strong>注意:</strong> 在Windows构建动态库时，动态库dll会被安装到当前项目的bin目录下，目标文件.lib文件会被安装到项目的lib目录下。
综上，这段代码的作用是将 “test_message” 目标的可执行文件、共享库文件和静态库文件安装到指定的目录下，并将该目标导出到一个 CMake 配置文件中，以便其他项目可以使用该目标。关于生成cmake相关配置文件详见下一篇内容。本项目仅用此命令做输出库的相关文件的功能。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-55"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">install</span><span class="p">(</span><span class="n">DIRECTORY</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">include</span><span class="o">/</span>
</span></span><span class="line"><span class="cl">        <span class="n">DESTINATION</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">output</span><span class="o">/</span><span class="n">include</span>
</span></span><span class="line"><span class="cl">        <span class="n">FILES_MATCHING</span> <span class="n">PATTERN</span> <span class="s">&#34;*.h&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">install</span><span class="p">(</span><span class="n">DIRECTORY</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">include</span><span class="o">/</span>
</span></span><span class="line"><span class="cl">        <span class="n">DESTINATION</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">output</span><span class="o">/</span><span class="n">include</span>
</span></span><span class="line"><span class="cl">        <span class="n">FILES_MATCHING</span> <span class="n">PATTERN</span> <span class="s">&#34;*.hpp&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将当前目录下的<code>include</code>目录中的<code>.hpp</code>和<code>.h</code>安装到当前项目下的<code>output</code>目录下的<code>include</code>文件中。关于install命令的具体使用方法，我们将以后做详细解释。</p></div>
    </div>
  </div>
<p><strong>根目录下的CMakeLists.txt</strong></p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置动态库到lib文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIB_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span>  <span class="o">${</span><span class="nv">LIB_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong></p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-56"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果没有指定<code>install</code>的目录，则设置install的目录为<code>${CMAKE_SOURCE_DIR}/output/</code>。</p></div>
    </div>
  </div>
<h4 id="104-windows上只链接第三方库动态库">10.4 Windows上只链接第三方库（动态库）</h4>
<p>Windows平台上链接动态库的使用方法和GNU/Linux平台上有所不同，我们在链接时需要将符号表文件lib进行连接，然后将对应的动态库文件dll文件拷贝到环境变量或者可执行文件所在的目录下，可知行文件才可以正常过执行。</p>
<p><strong>项目结构</strong></p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── third-party
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   ├── lib
</span></span><span class="line"><span class="cl">│   │   └── test_message.lib
</span></span><span class="line"><span class="cl">│  └── bin
</span></span><span class="line"><span class="cl">│    └── test_message.dll
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>项目中使用的<code>third-party</code>使用的是上一节内容中在Windows上生成的动态库。文件hello_world.cpp与上一节内容相同，我们不再对其进行描述。</p>
<p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_shared_lib_third_party_in_windows</p>
<p><strong>CMakeLists.txt</strong></p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/test_message.lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">TEST_MESSAGE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">MSVC</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">MODEL</span> <span class="s2">&#34;${CMAKE_SOURCE_DIR}/third-party/bin/*.dll&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">add_custom_command</span><span class="p">(</span><span class="s">TARGET</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">POST_BUILD</span>
</span></span><span class="line"><span class="cl">                     <span class="s">COMMAND</span> <span class="o">${</span><span class="nv">CMAKE_COMMAND</span><span class="o">}</span> <span class="s">-E</span> <span class="s">copy_if_different</span>
</span></span><span class="line"><span class="cl">                     <span class="o">${</span><span class="nv">MODEL</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">                     <span class="o">$&lt;</span><span class="nv">TARGET_FILE_DIR:${PROJECT_NAME}</span><span class="o">&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-57"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/test_message.lib</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>链接三方库的符号表</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-58"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span> <span class="p">(</span><span class="s">MSVC</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">MODEL</span> <span class="s2">&#34;${CMAKE_SOURCE_DIR}/third-party/bin/*.dll&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">add_custom_command</span><span class="p">(</span><span class="s">TARGET</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">POST_BUILD</span>
</span></span><span class="line"><span class="cl">                     <span class="s">COMMAND</span> <span class="o">${</span><span class="nv">CMAKE_COMMAND</span><span class="o">}</span> <span class="s">-E</span> <span class="s">copy_if_different</span>
</span></span><span class="line"><span class="cl">                     <span class="o">${</span><span class="nv">MODEL</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">                     <span class="o">$&lt;</span><span class="nv">TARGET_FILE_DIR:${PROJECT_NAME}</span><span class="o">&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将我们之前生成的动态库文件dll文件手动复制到可执行文件所在的目录中。关于add_custom_command用法我们之后章节将作详细详解。</p></div>
    </div>
  </div>
<h3 id="十一补充">十一、补充</h3>
<p>在window上使用vs生成可执行文件和执行install命令。
首先，我们首先新建一个build目录，并进入该目录。</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build</span></span></code></pre></td></tr></table>
</div>
</div><p>然后使用<code>cmake</code>进行构建项目。</p>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在<code>build</code>目录下可以看到<code>sln</code>文件，使用<code>vs</code>打开。</p>
<p><strong>构建所有</strong>: 在vs中的解决方案资源管理器中右键ALL_BUILD，然后点击生成</p>
<p>编译生成hello-world进程，右键hello-world,然后点击生成。如果我们使用CMake在一个项目中生成了多个进程，我们在测试某一个进程时，在对应的进程上右键设为启动项目即可。</p>
<p><strong>执行install安装命令</strong>: 在INSTALL上右键，然后点击生成即可。注意：只有当我们的CMake中有install命令时，VS中才会出现INTALL选项。</p>
]]></description></item><item><title>CMake 笔记 | [3] 静态库和动态的补充</title><link>https://jianye0428.github.io/posts/cmake_note_3/</link><pubDate>Sun, 14 Jan 2024 09:46:26 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_3/</guid><description><![CDATA[<h2 id="一导言">一、导言</h2>
<p>对CMake在不同平台上构建动态库和静态库做进一步的探索，即如何利用一个比较统一的模板在不同的平台构建静态库和动态库，以及对add_library命令的其他参数做进一步的探索。</p>
<h2 id="二库模板">二、库模板</h2>
<h3 id="21-项目结构">2.1 项目结构</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── cmake
</span></span><span class="line"><span class="cl">│  └── message_config.cmake.in
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │  ├── message_export_lib.h
</span></span><span class="line"><span class="cl">│   │  └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>本项目的结构相对比较复杂，为了能够生成一套比较标准的库（静态库/动态库），所以项目中会包含很多配置项，接下来我们会对项目中的所有内容进行一一讲解。</p>
<h3 id="22">2.2</h3>
<p>根目录下的CMakeLists.txt</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Set install direcotory
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，我们提供了在执行<code>cmake</code>命令时的参数选项，默认默认情况下<code>BUILD_SHARED_LIBS</code>的状态是关闭的(OFF)，即默认情况下我们默认构建的是静态库。</p>
<p>当我们要构建动态库时，我们需执行以下命令（假设你已经在项目中构建了build文件夹,并且你现在在build目录中）</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake .. -DBUILD_SHARED_LIBS<span class="o">=</span>ON</span></span></code></pre></td></tr></table>
</div>
</div></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们没有指定在<code>make install</code>后的输出路径，则<code>CMAKE_INSTALL_PREFIX</code> 将设置为<code>${CMAKE_SOURCE_DIR}/output/</code>，即当前项目下的<code>output</code>目录。</p></div>
    </div>
  </div>
<h3 id="23-cmake目录下的message_configcmakein">2.3 cmake目录下的message_config.cmake.in</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">@PACKAGE_INIT@
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span> <span class="p">(</span> <span class="s2">&#34;${CMAKE_CURRENT_LIST_DIR}/message_config.cmake&#34;</span> <span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了能够生成一个标准的库，我们写了一个<code>message_config.cmake.in</code>文件，该文件执行<code>make install</code>时将被调用，调用时我们再进行讲解。</p>
<h3 id="24-message-module下message_export_libh">2.4 message-module下message_export_lib.h</h3>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_EXPORT_LIB_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_EXPORT_LIB_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef MESSAGE_LIB_SHARED_BUILD
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#ifdef MESSAGE_LIB_EXPORTS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="cp">#define MESSAGE_LIB_API __declspec(dllexport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="cp">#define MESSAGE_LIB_API __declspec(dllimport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#endif  </span><span class="c1">// MESSAGE_LIB_EXPORTS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#define MESSAGE_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#endif  </span><span class="c1">// _WIN32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#define MESSAGE_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// MESSAGE_LIB_SHARED_BUILD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_EXPORT_LIB_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，如果我们定义了宏定义<font color=red><code>MESSAGE_LIB_SHARED_BUILD</code></font>(即我们要构建动态库时)，我们将执行以下命令：如果是<code>Windows</code>平台，并且是在生成动态库时，即定义了(MESSAGE_LIB_EXPORTS)，将<code>__declspec(dllexport)</code>定义为<code>MESSAGE_LIB_API</code>；如果是使用动态库时，即未定义(MESSAGE_LIB_EXPORTS)，则将<code>__declspec(dllimport)</code>定义为<code>MESSAGE_LIB_API</code>。如果是非Windows平台，则对宏MESSAGE_LIB_API不做任何操作(因为在非Windows平台上可以动态库的生成和使用与静态库是一样的)。</p>
<p>然后，如果我们未定义宏定义MESSAGE_LIB_SHARED_BUILD(即我们要构建静态库时)，我们对宏MESSAGE_LIB_API不做任何操作。</p>
<p>注意：关于宏定义MESSAGE_LIB_SHARED_BUILD和MESSAGE_LIB_EXPORTS是否要添加利用message-module下的CMakeLists.txt进行配置。</p>
<h3 id="25-message-module下messageh">2.5 message-module下message.h</h3>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message_export_lib.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">MESSAGE_LIB_API</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们将头文件<code>message_export_lib.h</code>包含进来，来控制在不同平台生成不同的库时的选项。</p>
<h3 id="26-message-module下的cmakeliststxt">2.6 message-module下的CMakeLists.txt</h3>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PUBLIC</span> <span class="s">-DMESSAGE_LIB_SHARED_BUILD</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PRIVATE</span> <span class="s">-DMESSAGE_LIB_EXPORTS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">STATIC</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加别名，以便库可以在构建树中使用，例如在测试时
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.h&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.hpp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILE</span> <span class="s">message_lib.cmake</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">CMakePackageConfigHelpers</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the config file that is includes the exports
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">configure_package_config_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake.in</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">INSTALL_DESTINATION</span> <span class="s2">&#34;lib/cmake/test_message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the version file for the config file
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">write_basic_package_version_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config_version.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">VERSION</span> <span class="s2">&#34;${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">COMPATIBILITY</span> <span class="s">AnyNewerVersion</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">FILES</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">export</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span> <span class="s">FILE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们让宏<code>BUILD_SHARED_LIBS</code>为开启状态(即我们要构建动态库)，我们要将宏定义<code>MESSAGE_LIB_SHARED_BUILD</code>和<code>MESSAGE_LIB_EXPORTS</code>添加到编译器中，这样我们的头文件<code>message_export_lib.h</code>中便知道我们要构建<strong>动态库</strong>。</p>
<p>否则(即我们没有让BUILD_SHARED_LIBS开启)，我们将构建<strong>静态库</strong>。</p>
<p>利用<code>CMakePackageConfigHelpers</code>模块生成关于<code>test_message</code>库的cmake的配置文件，且可以使用命令<code>find_package</code>命令找到库<code>test_message</code>库。关于以上命令的具体参数使用，我们将在具体的命令学习章节进行具体的讲解和学习。</p>
<h2 id="三add_library其他参数的一些探索">三、add_library其他参数的一些探索</h2>
<h3 id="31-生成对象库">3.1 生成对象库</h3>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.5</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">recipe-03</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-objs</span>
</span></span><span class="line"><span class="cl">    <span class="s">OBJECT</span>
</span></span><span class="line"><span class="cl">        <span class="s">Message.hpp</span>
</span></span><span class="line"><span class="cl">        <span class="s">Message.cpp</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># this is only needed for older compilers
</span></span></span><span class="line"><span class="cl"><span class="c"># but doesn&#39;t hurt either to have it
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">message-objs</span>
</span></span><span class="line"><span class="cl">    <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">        <span class="s">POSITION_INDEPENDENT_CODE</span> <span class="s">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-shared</span>
</span></span><span class="line"><span class="cl">    <span class="s">SHARED</span>
</span></span><span class="line"><span class="cl">        <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-static</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">        <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">hello-world.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">message-static</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了保证编译的目标文件与生成位置无关，可以通过使用set_target_properties命令，设置message-objs目标的相应属性来实现。</p>
<p>**注意:**可能在某些平台和/或使用较老的编译器上，需要显式地为目标设置<code>POSITION_INDEPENDENT_CODE</code>属性。</p>
<p>现在，可以使用这个对象库来获取静态库(message-static)和动态库(message-shared)。要注意引用对象库的生成器表达式语法:$&lt;TARGET_OBJECTS:message-objs&gt;。生成器表达式是CMake在生成时(即配置之后)构造，用于生成特定于配置的构建输出。</p>
<h3 id="32-将静态库和动态库同时命名为同名的两个库">3.2 将静态库和动态库同时命名为同名的两个库</h3>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-shared</span>
</span></span><span class="line"><span class="cl">  <span class="s">SHARED</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">message-shared</span>
</span></span><span class="line"><span class="cl">    <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">        <span class="s">OUTPUT_NAME</span> <span class="s2">&#34;message&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-static</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">        <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">message-static</span>
</span></span><span class="line"><span class="cl">    <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">        <span class="s">OUTPUT_NAME</span> <span class="s2">&#34;message&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CMake 笔记 | [1] 单个源文件编译为可执行文件</title><link>https://jianye0428.github.io/posts/cmake_note_1/</link><pubDate>Fri, 12 Jan 2024 14:19:06 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_1/</guid><description><![CDATA[<h3 id="一项目结构">一、项目结构</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">└── hello_world.cpp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0 directories, 2 files</span></span></code></pre></td></tr></table>
</div>
</div><p>本项目只包含了一个源文件hello_world.cpp和一个CMake文件。</p>
<blockquote>
<p>源码地址: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_1/hello-world"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_1/hello-world<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</blockquote>
<div class="details admonition quote open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">注意: CMake文件的名字只能是CMakeLists.txt，当然如果使用include命令（后续会讲到），可以以任何名字进行命名，只要以.cmake结尾即可。</div>
    </div>
  </div>
<h3 id="二cpp源文件">二、CPP源文件</h3>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">SayHello</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">SayHello</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">SayHello</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Hello, CMake World!&#34;</span><span class="p">);</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="三cmake文件">三、CMake文件</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="s">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong><code>cmake_minimum_required(VERSION 3.10 FATAL_ERROR)</code></strong></p>
<p>设置CMake所需的最低版本的最低版本，如果使用的CMake版本低于该版本，则会发出致命错误。
今后，笔记中CMake的版本要求都为3.10。vscode中CMake Tool插件使用debug功能要求CMake版本不低于3.10。如果使用的系统ubuntu 16.04的话，需要升级CMake版本，windows请自行安装高于3.10版本的CMake。</p>
</li>
<li>
<p><strong><code>project(hello-world LANGUAGES CXX)</code></strong></p>
<p>声明了项目的名称和支持的编程语言，且该命令必须生命在cmake_minimum_required之后。一旦声明了项目的名称后，可以使用宏定义${PROJECT_NAME}进行调用。
在CMake中，C++是默认的编程语言。不过在实际编写代码过程中，仍建议使用LANGUAGES选项在project命令中显示地声明项目的语言。</p>
</li>
<li>
<p><strong><code>add_executable(${PROJECT_NAME} hello_world.cpp}</code></strong></p>
<p>CMake创建一个新可执行文件，其名字为${PROJECT_NAME}（也可以使用其他任意的名字）。这个可执行文件是通过编译和链接源文件hello_world.cpp生成的。</p>
<p>CMake将为编译器使用默认设置，并自动生成工具。</p>
</li>
</ul>
<h3 id="四操作">四、操作</h3>
<p>在工程文件夹下，执行如下操作:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/01/build</span></span></code></pre></td></tr></table>
</div>
</div><p>CMake的构建方式有两种: <strong>源内构建</strong>和<strong>源外构建</strong>。源内构建即在CMakeLists.txt同级目录中进行构建，构建出来的CMake文件将在该目录中，<font color=red><u>这通常是不推荐的，因为这会混合源代码和项目的目录树</u></font>。源外构建的构建方式，就是笔记的构建方式，往后我们都采用源外构建的方式。</p>
<p>CMake是一个构建系统生成器。将描述构建系统，如Unix Makefile、Ninja、sln等应当如何操作才能编译代码。然后，CMake为所选的构建系统生成相应的指令。默认情况下，在GNU/Linux和macOS系统上，CMake使用Unix Makefile生成器。Windows上，sln是默认的生成器。</p>
<p>GNU/Linux上，CMake默认生成 Makefile来构建项目:</p>
<ol>
<li><strong>Makefile</strong>: make将运行指令来构建项目。</li>
<li><strong>CMakefile</strong>: 包含临时文件的目录，CMake用于检测操作系统、编译器等。此外，根据所选的生成器，它还包含特定的文件。</li>
<li><strong>cmake_install.cmake</strong>: 处理安装规则的CMake脚本，在项目安装时使用（命令为执行为make后执行make install）。</li>
<li><strong>CMakeCache.txt</strong>: 如文件名所示，CMake缓存。CMake在重新运行配置时使用这个文件。</li>
</ol>
]]></description></item><item><title>Argoverse 2 数据集</title><link>https://jianye0428.github.io/posts/argoverse2/</link><pubDate>Fri, 05 Jan 2024 17:34:44 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/argoverse2/</guid><description><![CDATA[<h2 id="一简介">一、简介</h2>
<p>Argoverse数据集是由Argo AI、卡内基梅隆大学、佐治亚理工学院发布的用于支持自动驾驶汽车3D Tracking和Motion Forecasting研究的数据集。
数据集包括:</p>
<ul>
<li><strong>带标注的传感器数据集:</strong> 含1000个多模态数据序列，包括来自七个环视摄像机和两个双目摄像机的高分辨率图像，以及激光雷达点云和6自由度地图配准位姿。序列包含26个目标类别的三维长方体标注，所有这些标注都是充分采样的，以支持训练和三维感知模型的评估。</li>
<li><strong>激光雷达数据集:</strong> 包含20,000个未标记的激光雷达点云序列和地图配准位姿。该数据集是有史以来最大的激光雷达传感器数据集合，支持自监督学习和新兴的点云预测任务。</li>
<li><strong>运动预测数据集:</strong> 包含250,000个场景，挖掘每个场景中自车与其他参与者之间有趣和具有挑战性的交互。模型的任务是预测每个场景中scored actors的未来运动，并提供跟踪历史，捕捉目标的位置、航向、速度和类别。</li>
</ul>
<p>在所有三个数据集中，每个场景都包含自己的高精地图，带有3D车道和人行横道几何形状&ndash;来自六个不同城市的数据。所有数据集都是在CC BY-NC-SA 4.0许可下发布的。</p>
<h2 id="二argoverse-2-datasets">二、Argoverse 2 Datasets</h2>
<h3 id="21-sensor-dataset-传感器数据集">2.1 Sensor Dataset 传感器数据集</h3>
<p>Argoverse 2传感器数据集是Argoverse 1 3D跟踪数据集的后续。AV2更大，有1000个场景，高于Argoverse 1中的113个，但每个AV2场景也更丰富&ndash;AV2中有23倍的非车辆、非行人长方体。作者手工选择Argoverse 2传感器数据集中的30s组成场景，以包含拥挤的场景，其中包含未被表示的对象、值得注意的天气和有趣的行为，如插队和乱穿马路。每个场景的持续时间为15秒。表1将AV2传感器数据集与自动驾驶数据集进行了比较。图1、2和3显示了AV2的场景在标注范围、目标多样性、目标密度和场景动态性方面如何优于其他数据集。</p>
<p>与本文最相似的传感器数据集是非常有影响力的nuScenes[4]&ndash;这两个数据集都有1000个场景和高清地图，尽管Argoverse在拥有地面高度地图方面是独一无二的。nuScenes包含毫米波雷达数据，而AV2包含双目图像。nuScenes有一个很大的分类学&ndash;23个目标类别，其中10个有适合训练和评估（evaluation）的数据。本文的数据集包含30个目标类别，其中26个被很好地采样，足以用于训练和评估。nuScenes横跨两个城市，而本文的提出的数据集横跨六个城市。</p>
<p><strong>传感器套件。</strong> 激光雷达扫描收集在10赫兹，以及20 fps图像从7个摄像头定位，以提供一个完整的全景视野。此外，还提供了全局坐标系下的摄像机内参、外参和6自由度 ego-vehicle 姿态。激光雷达回波由两个32波束激光雷达捕获，激光雷达在同一方向以10赫兹旋转，但在方向上相隔180°。摄像机触发与两个激光雷达同步，导致20赫兹的帧率。七个全局快门摄像机与激光雷达同步，使它们的曝光集中在激光雷达上，扫描它们的视野。在附录中，本文提供了一个示意图，说明了汽车传感器套件及其坐标框架。</p>
<p><strong>激光雷达同步精度。</strong> 在AV2中，本文改进了摄像机和激光雷达的同步比Argoverse 1明显。本文的同步精度在[-1.39,1.39]ms，与Waymo开放数据集[-6,7]ms[45]相比较。</p>
<p><strong>标注。</strong> AV2传感器数据集包含本文30个类分类法中的对象的10 Hz 3D长方体标注（图1）。长方体的轨道标识符随着时间的推移对于相同的目标实例是一致的。如果对象在“感兴趣区域”(ROI)内&ndash;在映射的“可驾驶”区域的五米内，则对其进行标注。</p>
<p><strong>隐私。</strong> 为了保护隐私，所有的脸和车牌，无论是在车辆内还是在可驾驶区域外，都被广泛模糊。</p>
<p>传感器数据集分割。 本文随机地将数据集划分为700、150和150个场景的训练、验证和测试拆分。</p>
<h3 id="22-lidar-dataset-激光雷达数据集">2.2 Lidar Dataset 激光雷达数据集</h3>
<p>Argoverse 2 激光雷达数据集旨在支持激光雷达域中的自监督学习研究以及点云预测[48,49]。由于激光雷达数据比完整的传感器套件更紧凑，本文可以包括两倍长度的场景（30秒而不是15秒），和更多 （20,000 而不是 1,000），相当于大约40倍的驾驶小时，空间预算是5倍。AV2激光雷达数据集的挖掘标准与预测数据集（第3.3.2节）相同，以确保每个场景都是有趣的。虽然激光雷达数据集没有3D目标标注，但每个场景都带有一张高清地图，其中包含关于场景的丰富的3D信息。</p>
<p>本文的数据集是迄今为止最大的此类集合，有20,000个30秒序列。唯一一个类似的数据集，是同时发布的ONCE[36]，包含1M激光雷达帧，而本文的是6M激光雷达帧。本文的数据集以10 Hz采样，而不是像ONCE[36]中那样以2 Hz采样，使本文的数据集更适合于点云预测或自监督任务，这些任务点云随时间的演变是重要的。</p>
<p><strong>激光雷达数据集分割。</strong> 本文用分别为16,000个、2000个和2000个场景的train、validation和test拆分 随机划分数据集。</p>
<h3 id="23-motion-forecasting-dataset-运动预测数据集">2.3 Motion Forecasting Dataset 运动预测数据集</h3>
<p>运动预测解决了预测局部环境中动态行为者的未来状态（或占用图）的问题。自动驾驶相关行为者的一些例子包括：车辆（停车和移动）、行人、骑自行车的人、滑板车和宠物。由预测系统生成的预测未来被用作运动规划的主要输入，运动规划根据这种预测条件进行轨迹选择。生成这些预测提出了一个复杂的、多模态的问题，涉及许多不同的、部分观察的和社会交互的主体。然而，通过利用观察到的ground truth futures 来“自我标记”数据的能力，运动预测成为机器学习应用的理想领域（ideal domain）。</p>
<p>在Argoverse 1成功的基础上，Argoverse 2运动预测数据集提供了从自动驾驶车队收集的一组更新的预测场景。下面列举的设计决策总结了本文从内部研究/开发中吸取的集体经验教训，以及来自3个竞赛中近260个独特团队提交的2700多份submissions的反馈意见[43]:</p>
<ol>
<li>
<p>运动预测是长尾域中的一个安全关键系统。 因此，本文的数据集偏向于包含不同类型focal agent的不同和有趣的场景（见第3.3.2节）。本文的目标是鼓励开发确保尾部事件（tail events）期间安全的方法，而不是优化“轻松里程”上的预期性能。</p>
</li>
<li>
<p>There is a “Goldilocks zone” of task difficulty. Argoverse1测试集的性能已经开始稳定下来，如附录的图10所示。Argoverse 2的设计是为了增加预测的难度，在未来几年刺激富有成效的重点研究。这些变化旨在激励在扩展预测范围(3s→6s)上表现良好的方法，处理多种类型的动态对象(1→5)，并确保长尾场景的安全性。未来的Argoverse releases可能会通过减少观测窗口和增加预测层位来继续增加问题的难度。</p>
</li>
<li>
<p>可用性很重要。 Argoverse 1受益于一个庞大而活跃的研究社区&ndash;在很大程度上是由于设置和使用的简单性。因此，本文注意确保现有的Argoverse模型可以很容易地移植到Argoverse 2上运行。特别是，本文优先考虑对地图元素的直观访问，鼓励使用车道图作为强优先级的方法。为了提高训练和泛化，所有姿态也被插值和重新采样在精确的10赫兹（Argoverse 1是近似的）。新的数据集包括更少，但更长和更复杂的场景；这确保总的数据集大小保持足够大，可以训练复杂的模型，但足够小，可以方便地访问。</p>
</li>
</ol>
<h3 id="24-hd-maps-高精地图">2.4 HD Maps 高精地图</h3>
<p>上述三个数据集中的每个场景共享相同的HD地图表示。每个场景都带有自己的本地地图区域，类似于Waymo Open Motion[12]数据集。这与最初的Argoverse数据集不同，在最初的数据集中，所有场景都被本地化到两张城市地图上&ndash;一张是匹兹堡的，一张是迈阿密的。在附录中，本文提供了例子。每个场景映射的优点包括更高效的查询和处理映射更改的能力。在本文的数据集中，一个特定的十字路口可能会被观察多次，在此期间车道、人行横道甚至地面高度都可能发生变化。</p>
<p><strong>车道图。</strong> HD地图的核心特征是车道图，由图组成，其中是单个车道段。在附录中，本文列举并定义了本文为每个车道段提供的属性。与Argoverse 1不同，本文提供了实际的3D车道边界，而不仅仅是中心线。但是，本文的API提供了代码，可以在任何期望的采样分辨率下快速推断中心线。折线被量化到1cm分辨率。本文的表示比nuScenes更丰富，它只在2D中提供车道几何，而不是3D。</p>
<p><strong>可驾驶区域。</strong> 而不是像在Argoverse 1中所做的那样，以光栅化格式提供可驾驶区域分割，本文以矢量格式释放它，即作为3D多边形。这提供了多种优势，主要是在压缩方面，允许本文为成千上万的场景存储单独的地图，然而光栅格式仍然很容易衍生。将多边形顶点量化到1cm分辨率。</p>
<p>**地表高度。**只有传感器数据集包括密集的地表高度图（尽管其他数据集仍然有关于折线的稀疏的三维高度信息）。地地面高度为可行驶区域边界5m等值线内的区域提供，本文将其定义为感兴趣区域(ROI)[6]。本文这样做是因为对于建筑物内部和建筑密集的城市街区内部，地面车辆由于遮挡而无法观察的区域，地表高度的概念定义不清(ill-defined)。光栅栅格被量化到30cm分辨率，比Argoverse 1中的1m分辨率更高。</p>
<p>**本地地图的面积。**每个场景的局部地图都包括在ego-vehicle轨迹的l2范数中100米膨胀范围内找到的所有实体。</p>
<h2 id="三argoverse-2-api-简介">三、Argoverse 2 API 简介</h2>
<p>轨迹预测常用的有场景数据<code>ArgoverseScenario</code>和地图<code>ArgoverseStaticMap</code></p>
<p>轨迹序列读取的API为<code>scenario_serialization</code></p>
<p>可视化的API为<code>visualize_scenario</code></p>
<p>argoverse2和argoverse1不一样的地方是，每一段轨迹序列（Scenario）内有自己的json地图文件（虽然说都是同一幅HD map，但是对应HD map中的不同的位置），而argoverse1是所有轨迹序列共享一个地图文件</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 存放轨迹序列的类</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.data_schema</span> <span class="kn">import</span> <span class="n">ArgoverseScenario</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 用于读取轨迹序列的API</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting</span> <span class="kn">import</span> <span class="n">scenario_serialization</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 用于可视化的API</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.viz.scenario_visualization</span> <span class="kn">import</span> <span class="n">visualize_scenario</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 用于读取地图的API</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_api</span> <span class="kn">import</span> <span class="n">ArgoverseStaticMap</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>ArgoverseScenario</strong>
每个scenario有11s长的序列，包含actor的历史轨迹集合，就是这里面的tracks，对于每一个scenario，提供了以下的顶层属性:</p>
<ul>
<li><code>scenario_id</code>: 该scenario的特有ID</li>
<li><code>timestamps_ns</code>: 该scenario的所有时间戳</li>
<li><code>tracks</code>: 该scenario的所有轨迹序列</li>
<li><code>focal_track_id</code>: 该scenario的焦点agent(focal agent)的track ID</li>
<li><code>city_name</code>: 该scenario对应的城市名</li>
</ul>
<p>每个<code>track</code>包含以下属性:</p>
<ul>
<li><code>track_id</code>: 该track的特有ID</li>
<li><code>object_states</code>: 该轨迹序列对应的object在这11s内的有效观测的状态，以timestep表示时间步，一般来说最多有110步，因为采样频率为10Hz，一步对应0.1s</li>
<li><code>object_type</code>: 该轨迹序列对应的object的类型，如vehicle等</li>
<li><code>category</code>: 给轨迹序列分配种类，用于给轨迹预测的数据质量提供参考，一般来说，有四种：SCORED_TRACK，UNSCORED_TRACK，FOCAL_TRACK，TRACK_FRAGMENT。其中FOCAL_TRACK和SCORED_TRACK数据质量较好，UNSCORED_TRACK用于当作上下文输入，数据质量一般，而TRACK_FRAGMENT的时间长度不定，数据质量较差
<ul>
<li><code>TRACK_FRAGMENT</code>: Lower quality track that may only contain a few timestamps of observations. 在数据中以整数0表示</li>
<li><code>UNSCORED_TRACK</code>: Unscored track used for contextual input. 在数据中以整数1表示</li>
<li><code>SCORED_TRACK</code>: High-quality tracks relevant to the AV - scored in the multi-agent prediction challenge. 在数据中以整数2表示</li>
<li><code>FOCAL_TRACK</code>: The primary track of interest in a given scenario - scored in the single-agent prediction challenge. 在数据中以整数3表示</li>
</ul>
</li>
</ul>
<p>每个<code>object_states</code>包含以下属性，对应某一actor在某一时间点的所有信息：</p>
<ul>
<li><code>observed</code>: Boolean 指示这个object state是否在该scenario的观测区间内(observed segment)</li>
<li><code>timestep</code>: 时间步，范围是[0, num_scenario_timesteps) Time step corresponding to this object state [0, num_scenario_timesteps).</li>
<li><code>position</code>: (x, y) Coordinates of center of object bounding box. object bounding box的xy坐标</li>
<li><code>heading</code>: Heading associated with object bounding box (in radians, defined w.r.t the map coordinate frame). object bounding box的航向角，单位是弧度，是在地图坐标系下的</li>
<li><code>velocity</code>: (x, y) Instantaneous velocity associated with the object (in m/s). object的xy方向的速度</li>
</ul>
<p>每个track有以下10种label:</p>
<ul>
<li><code>Dynamic</code>
<ul>
<li><code>VEHICLE</code></li>
<li><code>PEDESTRIAN</code></li>
<li><code>MOTORCYCLIST</code></li>
<li><code>CYCLIST</code></li>
<li><code>BUS</code></li>
</ul>
</li>
<li><code>Static</code>
<ul>
<li><code>STATIC</code></li>
<li><code>BACKGROUND</code></li>
<li><code>CONSTRUCTION</code></li>
<li><code>RIDERLESS_BICYCLE</code></li>
</ul>
</li>
<li><code>UNKNOWN</code></li>
</ul>
<p><strong>ArgoverseStaticMap</strong></p>
<ul>
<li>
<p>Vector Map: Lane Graph and Lane Segments</p>
<blockquote>
<p>The core feature of the HD map is the lane graph, consisting of a graph G = (V, E), where V are individual lane segments.</p>
</blockquote>
<p>Argoverse2 提供了3D的道路边界线，而不是仅仅有centerlines，也提供了快速获取特定采样分辨率的centerlines的API，在release中多边形的分辨率被设置为1cm</p>
<p>地图以json文件的形式提供, 可以通过以下方式读取：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_api</span> <span class="kn">import</span> <span class="n">ArgoverseStaticMap</span>
</span></span><span class="line"><span class="cl"><span class="n">log_map_dirpath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&#34;av2&#34;</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&#34;00a6ffc1-6ce9-3bc3-a060-6006e9893a1a&#34;</span> <span class="o">/</span> <span class="s2">&#34;map&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">avm</span> <span class="o">=</span> <span class="n">ArgoverseStaticMap</span><span class="o">.</span><span class="n">from_map_dir</span><span class="p">(</span><span class="n">log_map_dirpath</span><span class="o">=</span><span class="n">log_map_dirpath</span><span class="p">,</span> <span class="n">build_raster</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>LaneSegment
LaneSegment中包含以下属性：</p>
<ul>
<li><code>id:</code> unique identifier for this lane segment (guaranteed to be unique only within this local map). 该lane segment的特有ID（仅在局部地图中保证是特有的ID）</li>
<li><code>is_intersection:</code> boolean value representing whether or not this lane segment lies within an intersection. boolean value，用来表示该lane segment是否位于一个路口内</li>
<li><code>lane_type:</code> designation of which vehicle types may legally utilize this lane for travel. 表示车道线类型</li>
<li><code>right_lane_boundary:</code> 3d polyline representing the right lane boundary. 3D线条，表示右车道边界线</li>
<li><code>left_lane_boundary:</code> 3d polyline representing the left lane boundary. 3D线条，表示左车道边界线</li>
<li><code>right_mark_type:</code> type of painted marking found along the right lane boundary . 右车道边界线的线型</li>
<li><code>left_mark_type:</code> type of painted marking found along the left lane boundary. 左车道边界线的线型</li>
<li><code>predecessors:</code> unique identifiers of lane segments that are predecessors of this object. 该lane segment的前继lane segment的unique ID</li>
<li><code>successors:</code> unique identifiers of lane segments that represent successor of this object. Note: this list will be empty if no successors exist. 该lane segment的后继lane segment的unique ID</li>
<li><code>right_neighbor_id:</code> unique identifier of the lane segment representing this object’s right neighbor. 该lane segment的右邻lane segment的unique ID</li>
<li><code>left_neighbor_id:</code> unique identifier of the lane segment representing this object’s left neighbor. 该lane segment的左邻lane segment的unique ID</li>
</ul>
</li>
<li>
<p>Vector Map: Drivable Area
多边形向量的分辨率也是1cm, 包含以下属性：</p>
<ul>
<li><code>id:</code> unique identifier. 特有ID</li>
<li><code>area_boundary:</code> 3d vertices of polygon, representing the drivable area’s boundary. 3D多边形，用来表示可行驶区域的边</li>
</ul>
</li>
<li>
<p>Vector Map: Pedestrian Crossings
代表人行道，由两条沿同一主轴的edge构成</p>
<ul>
<li><code>id:</code> unique identifier of pedestrian crossing. 人行道的特有ID</li>
<li><code>edge1:</code> 3d polyline representing one edge of the crosswalk, with 2 waypoints. 3D多边形，代表人行道的其中一边，由2个waypoints组成</li>
<li><code>edge2:</code> 3d polyline representing the other edge of the crosswalk, with 2 - waypoints. 3D多边形，代表人行道的其中一边，由2个waypoints组成</li>
</ul>
</li>
<li>
<p>Area of Local Maps
Each scenario’s local map includes all entities found within a 100 m dilation in l2-norm from the ego-vehicle trajectory.
每个scenario的局部地图包含距离ego-vehicle的轨迹100m l2距离内的所有实体</p>
</li>
</ul>
<p>常用API汇总:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.data_schema</span> <span class="kn">import</span> <span class="n">ArgoverseScenario</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting</span> <span class="kn">import</span> <span class="n">scenario_serialization</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.viz.scenario_visualization</span> <span class="kn">import</span> <span class="n">visualize_scenario</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_api</span> <span class="kn">import</span> <span class="n">ArgoverseStaticMap</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_primitives</span> <span class="kn">import</span> <span class="n">Polyline</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.utils.io</span> <span class="kn">import</span> <span class="n">read_json_file</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 利用pandas读取轨迹序列parquet文件</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet文件</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_dir</span><span class="p">,</span> <span class="n">raw_file_name</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;scenario_</span><span class="si">{</span><span class="n">raw_file_name</span><span class="si">}</span><span class="s1">.parquet&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 加载地图json文件</span>
</span></span><span class="line"><span class="cl"><span class="n">map_data</span> <span class="o">=</span> <span class="n">read_json_file</span><span class="p">(</span><span class="n">map_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 从地图的json文件读取车道中心线</span>
</span></span><span class="line"><span class="cl"><span class="n">centerlines</span> <span class="o">=</span> <span class="p">{</span><span class="n">lane_segment</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]:</span> <span class="n">Polyline</span><span class="o">.</span><span class="n">from_json_data</span><span class="p">(</span><span class="n">lane_segment</span><span class="p">[</span><span class="s1">&#39;centerline&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                           <span class="k">for</span> <span class="n">lane_segment</span> <span class="ow">in</span> <span class="n">map_data</span><span class="p">[</span><span class="s1">&#39;lane_segments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 加载地图API</span>
</span></span><span class="line"><span class="cl"><span class="n">map_api</span> <span class="o">=</span> <span class="n">ArgoverseStaticMap</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">map_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 以某个query中心搜索附近一定半径的的lane_segments</span>
</span></span><span class="line"><span class="cl"><span class="n">query_center</span> <span class="o">=</span> <span class="n">scenario_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;position_x&#39;</span><span class="p">,</span> <span class="s1">&#39;position_y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
</span></span><span class="line"><span class="cl"><span class="n">search_radius_m</span> <span class="o">=</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl"><span class="n">nearby_lane_segments</span> <span class="o">=</span> <span class="n">map_api</span><span class="o">.</span><span class="n">get_nearby_lane_segments</span><span class="p">(</span><span class="n">query_center</span><span class="p">,</span> <span class="n">search_radius_m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 通过map_api获取lane_segments的车道中心线</span>
</span></span><span class="line"><span class="cl"><span class="n">nearby_lane_centerlines</span> <span class="o">=</span> <span class="n">get_lane_centerlines</span><span class="p">(</span><span class="n">map_api</span><span class="p">,</span> <span class="n">nearby_lane_segments</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 获取地图内的所有pedestrian crossings（目前av2 API没有提供获取附近pedestrian crossings的API）</span>
</span></span><span class="line"><span class="cl"><span class="n">crosswalks</span> <span class="o">=</span> <span class="n">map_api</span><span class="o">.</span><span class="n">get_scenario_ped_crossings</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="四argoverse-2-数据提取">四、Argoverse 2 数据提取</h2>
<p>raw_dir 文件夹内包含<code>.parquet</code>和<code>.json</code>文件，其中文件组织形式为<code>log_map_archive_{$scenario_name}.parquet</code>和<code>scenario_{$scenario_name}.json</code>，分别代表<strong>障碍物时序信息</strong>和<strong>地图信息</strong>。</p>
<ul>
<li>设置原始数据路径:
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">raw_dir</span> <span class="o">=</span> <span class="s2">&#34;/home/yejian/yejian_personal/QCNet/train/&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">raw_file_name</span> <span class="o">=</span> <span class="s2">&#34;ffffe3df-8d26-42c3-9e7a-59de044736a0&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>读取障碍物信息和地图信息
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">parquet_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">raw_dir</span><span class="p">,</span> <span class="n">raw_file_name</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;scenario_</span><span class="si">{</span><span class="n">raw_file_name</span><span class="si">}</span><span class="s1">.parquet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;parquet_file: </span><span class="si">{</span><span class="n">parquet_file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1"># 障碍物信息</span>
</span></span><span class="line"><span class="cl"><span class="n">map_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">raw_dir</span><span class="p">,</span> <span class="n">raw_file_name</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;log_map_archive_</span><span class="si">{</span><span class="n">raw_file_name</span><span class="si">}</span><span class="s1">.json&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;map_file: </span><span class="si">{</span><span class="n">map_file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span><span class="c1"># 地图信息</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_from_parquet</span><span class="p">(</span><span class="n">parquet_file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">map_file</span> <span class="o">=</span> <span class="n">read_json_file</span><span class="p">(</span><span class="n">map_file</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>查看障碍物信息文件内容
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><code>['observed', 'track_id', 'object_type', 'object_category', 'timestep', 'position_x', 'position_y', 'heading', 'velocity_x', 'velocity_y', 'scenario_id', 'start_timestamp', 'end_timestamp', 'num_timestamps', 'focal_track_id', 'city']</code></li>
</ul>
<h2 id="reference">Reference</h2>
<p>[1]. <a href="https://blog.csdn.net/Yong_Qi2015/article/details/128731798"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Yong_Qi2015/article/details/128731798<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
[2]. <a href="https://blog.csdn.net/m0_56423263/article/details/134593815"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/m0_56423263/article/details/134593815<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br></p>
]]></description></item><item><title>长短期记忆网络 -- LSTM</title><link>https://jianye0428.github.io/posts/lstm/</link><pubDate>Thu, 28 Dec 2023 21:50:25 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/lstm/</guid><description><![CDATA[<h2 id="一传统的bp网络和cnn网络">一、传统的BP网络和CNN网络</h2>
<p>BP网络和CNN网络没有时间维，和传统的机器学习算法理解起来相差无几，CNN在处理彩色图像的3通道时，也可以理解为叠加多层，图形的三维矩阵当做空间的切片即可理解，写代码的时候照着图形一层层叠加即可。如下图是一个普通的BP网络和CNN网络。
<br></p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9;
  display:  inline-block;
  color:  #999;
  padding:  2px;">BP Network</div>
</center>
<br>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9;
  display:  inline-block;
  color:  #999;
  padding:  2px;">CNN Network</div>
</center>
<br>
<p>图中的隐含层、卷积层、池化层、全连接层等，都是实际存在的，一层层前后叠加，在空间上很好理解，因此在写代码的时候，基本就是看图写代码，比如用keras就是:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 示例代码，没有实际意义</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>  <span class="c1"># 添加卷积层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>         <span class="c1"># 添加池化层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.25</span><span class="p">))</span>                          <span class="c1"># 添加dropout层</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>  <span class="c1"># 添加卷积层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>         <span class="c1"># 添加池化层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.25</span><span class="p">))</span>                          <span class="c1"># 添加dropout层</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">....</span>   <span class="c1"># 添加其他卷积操作</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>                            <span class="c1"># 拉平三维数组为2维数组</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>        <span class="n">添加普通的全连接层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">....</span>  <span class="c1"># 训练网络</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二lstm网络">二、LSTM网络</h2>
<p>当我们在网络上搜索看LSTM结构的时候，看最多的是下面这张图:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">RNN Architecture Overview</div>
</center>
<br>
<p>这是RNN循环神经网络经典的结构图，LSTM只是对隐含层节点A做了改进，整体结构不变，因此本文讨论的也是这个结构的可视化问题。</p>
<p>中间的A节点隐含层，左边是表示只有一层隐含层的LSTM网络，所谓LSTM循环神经网络就是在时间轴上的循环利用，在时间轴上展开后得到右图。</p>
<p>看左图，很多同学以为LSTM是单输入、单输出，只有一个隐含神经元的网络结构，看右图，以为LSTM是多输入、多输出，有多个隐含神经元的网络结构，A的数量就是隐含层节点数量。</p>
<p>WTH？思维转不过来啊。这就是传统网络和空间结构的思维。</p>
<p><strong>实际上，右图中，我们看Xt表示序列，下标t是时间轴，所以，A的数量表示的是时间轴的长度，是同一个神经元在不同时刻的状态(Ht)，不是隐含层神经元个数。</strong></p>
<p>我们知道，LSTM网络在训练时会使用上一时刻的信息，加上本次时刻的输入信息来共同训练。</p>
<p>举个简单的例子: 在第一天我生病了(初始状态H0)，然后吃药(利用输入信息X1训练网络)，第二天好转但是没有完全好(H1)，再吃药(X2),病情得到好转(H2),如此循环往复知道病情好转。因此，输入Xt是吃药，时间轴T是吃多天的药，隐含层状态是病情状况。因此我还是我，只是不同状态的我。</p>
<p>实际上，LSTM的网络是这样的:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">LSTM Network</div>
</center>
<p>上面的图表示包含2个隐含层的LSTM网络，在T=1时刻看，它是一个普通的BP网络，在T=2时刻看也是一个普通的BP网络，只是沿时间轴展开后，T=1训练的隐含层信息H,C会被传递到下一个时刻T=2，如下图所示。上图中向右的五个常常的箭头，所指的也是隐含层状态在时间轴上的传递。</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">LSTM Architecture Overview</div>
</center>
<p>注意，图中H表示隐藏层状态，C是遗忘门，后面会讲解它们的维度。</p>
<h2 id="三lstm的输入结构">三、LSTM的输入结构</h2>
<p>为了更好理解LSTM结构，还必须理解LSTM的数据输入情况。仿照3通道图像的样子，再加上时间轴后的多样本的多特征的不同时刻的数据立方体如下图所示:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">Input Structure of LSTM Network</div>
</center>
<p>右边的图是我们常见模型的输入，比如XGBOOST，lightGBM，决策树等模型，输入的数据格式都是这种(N<em>F)的矩阵，而左边是加上时间轴后的数据立方体，也就是时间轴上的切片，它的维度是(N</em>T*F),第一维度是样本数，第二维度是时间，第三维度是特征数，如下图所示:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">天气数据立方体</div>
</center>
<p>这样的数据立方体很多，比如天气预报数据，把样本理解成城市，时间轴是日期，特征是天气相关的降雨风速PM2.5等，这个数据立方体就很好理解了。在NLP里面，一句话会被embedding成一个矩阵，词与词的顺序是时间轴T，索引多个句子的embedding三维矩阵如下图所示:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">NLP Embedding Matrix</div>
</center>
<h2 id="四pytorch中的lstm">四、pytorch中的LSTM</h2>
<h3 id="41-pytorch中定义的lstm模型">4.1 pytorch中定义的LSTM模型</h3>
<p>pytorch中定义的LSTM模型的参数如下</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">参数有</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">input_size</span><span class="p">:</span> <span class="n">x的特征维度</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">hidden_size</span><span class="p">:</span> <span class="n">隐藏层的特征维度</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">num_layers</span><span class="p">:</span> <span class="n">lstm隐层的层数</span><span class="err">，</span><span class="n">默认为1</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">bias</span><span class="p">:</span> <span class="n">False则bihbih</span><span class="o">=</span><span class="mi">0</span><span class="n">和bhhbhh</span><span class="o">=</span><span class="mf">0.</span> <span class="n">默认为True</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">batch_first</span><span class="p">:</span> <span class="n">True则输入输出的数据格式为</span> <span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">feature</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">dropout</span><span class="p">:</span> <span class="n">除最后一层</span><span class="err">，</span><span class="n">每一层的输出都进行dropout</span><span class="err">，</span><span class="n">默认为</span><span class="p">:</span>  <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">bidirectional</span><span class="p">:</span> <span class="n">True则为双向lstm默认为False</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结合前面的图形，我们一个个看。</p>
<p>(1)input_size: x的特征维度，就是数据立方体中的F，在NLP中就是一个词被embedding后的向量长度，如下图所示:</p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">LSTM Feature Matrix</div>
</center>
<p>(2)hidden_size: 隐藏层的特征维度(隐藏层神经元个数)，如下图所示，我们有两个隐含层，每个隐藏层的特征维度都是5。注意，<strong>非双向LSTM的输出维度等于隐藏层的特征维度</strong>。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">隐藏层特征维度</div>
</center>
<br>
<p>(3)num_layers: lstm隐层的层数，上面的图我们定义了2个隐藏层。
(4)batch_first: 用于定义输入输出维度，后面再讲。
(5)bidirectional: 是否是双向循环神经网络，如下图是一个双向循环神经网络，因此在使用双向LSTM的时候我需要特别注意，正向传播的时候有(Ht, Ct),反向传播也有(Ht&rsquo;, Ct&rsquo;),前面我们说了非双向LSTM的输出维度等于隐藏层的特征维度，而<strong>双向LSTM的输出维度是隐含层特征数<em>2，而且H,C的维度是时间轴长度</em>2</strong>。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Bidirectional RNN</div>
</center>
<br>
<h3 id="42-喂给lstm的数据格式">4.2 喂给LSTM的数据格式</h3>
<p>pytorch中LSTM的输入数据格式默认如下:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">参数有</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">seq_len</span><span class="p">:</span> <span class="n">序列长度</span><span class="err">，</span><span class="n">在NLP中就是句子长度</span><span class="err">，</span><span class="n">一般都会用pad_sequence补齐长度</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">batch</span><span class="p">:</span> <span class="n">每次喂给网络的数据条数</span><span class="err">，</span><span class="n">在NLP中就是一次喂给网络多少个句子</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">input_size</span><span class="p">:</span> <span class="n">特征维度</span><span class="err">，</span><span class="n">和前面定义网络结构的input_size一致</span><span class="err">。</span></span></span></code></pre></td></tr></table>
</div>
</div><p>前面也说到，如果LSTM的参数 batch_first=True，则要求输入的格式是:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>刚好调换前面两个参数的位置。其实这是比较好理解的数据形式，下面以NLP中的embedding向量说明如何构造LSTM的输入。</p>
<p>之前我们的embedding矩阵如下图:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Embedding Matrix</div>
</center>
<br>
<p>如果把batch放在第一位，则三维矩阵的形式如下:</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Batch First</div>
</center>
<br>
<p>其转换过程如下图所示:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">将三维矩阵转换成二维形式</div>
</center>
<br>
<p>看懂了吗，这就是输入数据的格式，是不是很简单。
LSTM的另外两个输入是 h0 和 c0，可以理解成网络的初始化参数，用随机数生成即可。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">h0</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c0</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">参数</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">num_layers</span><span class="p">:</span> <span class="n">隐藏层数</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">num_directions</span><span class="p">:</span> <span class="n">如果是单向循环网络</span><span class="err">，</span><span class="n">则num_directions</span><span class="o">=</span><span class="mi">1</span><span class="err">，</span><span class="n">双向则num_directions</span><span class="o">=</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">batch</span><span class="p">:</span> <span class="n">输入数据的batch</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">hidden_size</span><span class="p">:</span> <span class="n">隐藏层神经元个数</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，如果我们定义的input格式是:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>则H和C的格式也是要变的:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">h0</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c0</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="43-lstm的output格式">4.3 LSTM的output格式</h3>
<p>LSTM的输出是一个tuple，如下:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">output</span><span class="p">,(</span><span class="n">ht</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">output</span><span class="p">:</span>  <span class="n">最后一个状态的隐藏层的神经元输出</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">ht</span><span class="p">:</span> <span class="n">最后一个状态的隐含层的状态值</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">ct</span><span class="p">:</span> <span class="n">最后一个状态的隐含层的遗忘门值</span></span></span></code></pre></td></tr></table>
</div>
</div><p>output的默认维度是:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">output</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ht</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ct</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和input的情况类似，如果我们前面定义的input格式是:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>则ht和ct的格式也是要变的:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">ht</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ct</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>说了这么多，我们回过头来看看ht和ct在哪里，请看下图:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">LSTM Network</div>
</center>
<br>
<p>output在哪里？请看下图:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">输出层</div>
</center>
<br>
<h2 id="五lstm和其他网络组合">五、LSTM和其他网络组合</h2>
<p>还记得吗，output的维度等于隐藏层神经元的个数，即hidden_size，在一些时间序列的预测中，会在output后，接上一个全连接层，全连接层的输入维度等于LSTM的hidden_size，之后的网络处理就和BP网络相同了，如下图:</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">在LSTM网络后接上全连接层</div>
</center>
<br>
<p>用pytorch实现上面的结构:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">torch</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RegLSTM</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">super</span><span class="p">(</span><span class="n">RegLSTM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 定义LSTM</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">hidden_num_layers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 定义回归层网络，输入的特征维度等于LSTM的输出，输出维度为1</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">reg</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">ht</span><span class="p">,</span><span class="n">ct</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，有些模型则是将输出当做另一个LSTM的输入，或者使用隐藏层ht,ct的信息进行建模，不一而足。
好了，以上就是我对LSTM的一些学习心得，看完记得关注点赞。</p>
<p>REF:
[[1]. 漂亮，LSTM模型结构的可视化](https: //mp.weixin.qq.com/s?__biz=MzU1OTYzNjg5OQ==&amp;mid=2247545117&amp;idx=1&amp;sn=670ba155d94b229d39c5bf0bf20239d5&amp;chksm=fc1639d1cb61b0c72434a00454b2af8f9022e7ac3030a4186cda22ef5594ef5994620dc5fd52&amp;mpshare=1&amp;scene=1&amp;srcid=0617kfSozC3sKY1lRjYg1f0u&amp;sharer_shareinfo=6833fdea9df7fee2c423a9474c0928be&amp;sharer_shareinfo_first=6833fdea9df7fee2c423a9474c0928be#rd)
[2].https: //zhuanlan.zhihu.com/p/94757947
[3].https: //zhuanlan.zhihu.com/p/59862381
[4].https: //zhuanlan.zhihu.com/p/36455374
[5].https: //www.zhihu.com/question/41949741/answer/318771336
[6].https: //blog.csdn.net/android_ruben/article/details/80206792
to be added: <br>
[7].https: //www.analyticsvidhya.com/blog/2021/01/understanding-architecture-of-lstm/</p>
]]></description></item><item><title>TensorRT Introduction</title><link>https://jianye0428.github.io/posts/tensorrt_introduction/</link><pubDate>Fri, 14 Jul 2023 09:23:07 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/tensorrt_introduction/</guid><description><![CDATA[<h3 id="tensorrt-介绍">TensorRT 介绍</h3>
<p>TensorRT是一个高性能的深度学习推理（Inference）优化器，可以为深度学习应用提供低延迟、高吞吐率的部署推理。TensorRT可用于对超大规模数据中心、嵌入式平台或自动驾驶平台进行推理加速。TensorRT现已能支持TensorFlow、Caffe、Mxnet、Pytorch等几乎所有的深度学习框架，将TensorRT和NVIDIA的GPU结合起来，能在几乎所有的框架中进行快速和高效的部署推理。</p>
<p>TensorRT 是一个C++库，从 TensorRT 3 开始提供C++ API和Python API，主要用来针对 NVIDIA GPU进行 高性能推理（Inference）加速。</p>
<p></p>
<p>由以上图可以很清楚的看出，训练(training)和 推理(inference)的区别：</p>
<ul>
<li>**训练(training)**包含了前向传播和后向传播两个阶段，针对的是训练集。训练时通过误差反向传播来不断修改网络权值(weights)。</li>
<li>**推理(inference)**只包含前向传播一个阶段，针对的是除了训练集之外的新数据。可以是测试集，但不完全是，更多的是整个数据集之外的数据。其实就是针对新数据进行预测，预测时，速度是一个很重要的因素。</li>
</ul>
<p>一般的深度学习项目，训练时为了加快速度，会使用多GPU分布式训练。但在部署推理时，为了降低成本，往往使用单个GPU机器甚至嵌入式平台（比如 NVIDIA Jetson）进行部署，部署端也要有与训练时相同的深度学习环境，如caffe，TensorFlow等。</p>
<p>由于训练的网络模型可能会很大（比如，inception，resnet等），参数很多，而且部署端的机器性能存在差异，就会导致推理速度慢，延迟高。这对于那些高实时性的应用场合是致命的，比如自动驾驶要求实时目标检测，目标追踪等。所以为了提高部署推理的速度，出现了很多轻量级神经网络，比如squeezenet，mobilenet，shufflenet等。基本做法都是基于现有的经典模型提出一种新的模型结构，然后用这些改造过的模型重新训练，再重新部署。</p>
<p>而tensorRT 则是对训练好的模型进行优化。 tensorRT就只是 推理优化器。当你的网络训练完之后，可以将训练模型文件直接丢进tensorRT中，而不再需要依赖深度学习框架（Caffe，TensorFlow等），如下:</p>
<p></p>
<p>可以认为tensorRT是一个只有前向传播的深度学习框架，这个框架可以将 Caffe，TensorFlow的网络模型解析，然后与tensorRT中对应的层进行一一映射，把其他框架的模型统一全部 转换到tensorRT中，然后在tensorRT中可以针对NVIDIA自家GPU实施优化策略，并进行部署加速。</p>
<p>目前TensorRT8.0 几乎可以支持所有常用的深度学习框架，对于caffe和TensorFlow来说，tensorRT可以直接解析他们的网络模型；对于caffe2，pytorch，mxnet，chainer，CNTK等框架则是首先要将模型转为 ONNX 的通用深度学习模型，然后对ONNX模型做解析。而tensorflow和MATLAB已经将TensorRT集成到框架中去了。</p>
<p>**ONNX(Open Neural Network Exchange)**是微软和Facebook携手开发的开放式神经网络交换工具，也就是说不管用什么框架训练，只要转换为ONNX模型，就可以放在其他框架上面去inference。这是一种统一的神经网络模型定义和保存方式，上面提到的除了tensorflow之外的其他框架官方应该都对onnx做了支持，而ONNX自己开发了对tensorflow的支持。从深度学习框架方面来说，这是各大厂商对抗谷歌tensorflow垄断地位的一种有效方式；从研究人员和开发者方面来说，这可以使开发者轻易地在不同机器学习工具之间进行转换，并为项目选择最好的组合方式，加快从研究到生产的速度。</p>
<p>ONNX / TensorFlow / Custom deep-learning frame模型的工作方式：
</p>
<p>tensorRT中有一个 Plugin 层，这个层提供了 API 可以由用户自己定义tensorRT不支持的层。
TensorRT-plugin
</p>
<p>目前TensorRT支持的层有:https://github.com/onnx/onnx-tensorrt/blob/main/docs/operators.md
目前ONNX支持的算子:https://github.com/onnx/onnx/blob/main/docs/Operators.md</p>
<h3 id="tensorrt-优化方式">TensorRT 优化方式</h3>
<p></p>
<p>TensorRT优化方法主要有以下几种方式，最主要的是前面两种。</p>
<ul>
<li>
<p><strong>层间融合或张量融合(Layer &amp; Tensor Fusion)</strong></p>
<p>如下图左侧是GoogLeNetInception模块的计算图。这个结构中有很多层，在部署模型推理时，这每一层的运算操作都是由GPU完成的，但实际上是GPU通过启动不同的CUDA（Compute unified device architecture）核心来完成计算的，CUDA核心计算张量的速度是很快的，但是往往大量的时间是浪费在CUDA核心的启动和对每一层输入/输出张量的读写操作上面，这造成了内存带宽的瓶颈和GPU资源的浪费。TensorRT通过对层间的横向或纵向合并（合并后的结构称为CBR，意指 convolution, bias, and ReLU layers are fused to form a single layer），使得层的数量大大减少。横向合并可以把卷积、偏置和激活层合并成一个CBR结构，只占用一个CUDA核心。纵向合并可以把结构相同，但是权值不同的层合并成一个更宽的层，也只占用一个CUDA核心。合并之后的计算图（图4右侧）的层次更少了，占用的CUDA核心数也少了，因此整个模型结构会更小，更快，更高效。</p>
<p></p>
</li>
<li>
<p><strong>数据精度校准(Weight &amp;Activation Precision Calibration)</strong></p>
<p>大部分深度学习框架在训练神经网络时网络中的张量（Tensor）都是32位浮点数的精度（Full 32-bit precision，FP32），一旦网络训练完成，在部署推理的过程中由于不需要反向传播，完全可以适当降低数据精度，比如降为FP16或INT8的精度。更低的数据精度将会使得内存占用和延迟更低，模型体积更小。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Precision</th>
<th style="text-align:center">Dynamic Range</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FP32</td>
<td style="text-align:center">−3.4×1038 ~ 3.4×1038</td>
</tr>
<tr>
<td style="text-align:center">FP16</td>
<td style="text-align:center">−65504 ~ 65504</td>
</tr>
<tr>
<td style="text-align:center">INT8</td>
<td style="text-align:center">−128 ~ 127</td>
</tr>
<tr>
<td style="text-align:center">UINT8</td>
<td style="text-align:center">0 ~ 256</td>
</tr>
</tbody>
</table>
<p>INT8只有256个不同的数值，使用INT8来表示 FP32精度的数值，肯定会丢失信息，造成性能下降。不过TensorRT会提供完全自动化的校准（Calibration ）过程，会以最好的匹配性能将FP32精度的数据降低为INT8精度，最小化性能损失。</p>
</li>
<li>
<p><strong>Kernel Auto-Tuning</strong>
网络模型在推理计算时，是调用GPU的CUDA核进行计算的。TensorRT可以针对不同的算法，不同的网络模型，不同的GPU平台，进行 CUDA核的调整（怎么调整的还不清楚），以保证当前模型在特定平台上以最优性能计算。</p>
<p>TensorRT will pick the implementation from a library of kernels that delivers the best performance for the target GPU, input data size, filter size, tensor layout, batch size and other parameters.</p>
</li>
<li>
<p><strong>Dynamic Tensor Memory</strong>
在每个tensor的使用期间，TensorRT会为其指定显存，避免显存重复申请，减少内存占用和提高重复使用效率。</p>
</li>
<li>
<p><strong>Multi-Stream Execution</strong>
Scalable design to process multiple input streams in parallel，这个应该就是GPU底层的优化了。</p>
</li>
</ul>
<h3 id="tensorrt-安装">TensorRT 安装</h3>
<p><strong><a href="https://zhuanlan.zhihu.com/p/72298520"target="_blank" rel="external nofollow noopener noreferrer">CUDA的安装<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></strong></p>
<ol>
<li>
<p>安装显卡驱动</p>
</li>
<li>
<p>安装cuda
2.1 进入<a href="https://developer.nvidia.com/cuda-toolkit-archive"target="_blank" rel="external nofollow noopener noreferrer">nvidia开发者网站的CUDA下载页面<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>选择runfile格式的文件下载。</p>
<p>2.2 下载完成后，解压，并运行上图中的命令，会有条款，接受即可，注意安装CUDA的时候不要安装驱动

2.3 路径设置</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>/usr/local/cuda-10.2/bin:/usr/local/cuda-10.2/nsight-compute-2019.5.0<span class="si">${</span><span class="nv">PATH</span><span class="p">:+:</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}}</span>
</span></span><span class="line"><span class="cl">$ <span class="nb">export</span> <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>/usr/local/cuda-10.2/lib64/<span class="si">${</span><span class="nv">LD_LIBRARY_PATH</span><span class="p">:+:</span><span class="si">${</span><span class="nv">LD_LIBRARY_PATH</span><span class="si">}}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>并使设置生效:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">source</span> ~/.bashrc</span></span></code></pre></td></tr></table>
</div>
</div><p>2.4 验证安装是否成功
进入/usr/local/cuda-10.1/samples/1_Utilities/目录，</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> deviceQuery
</span></span><span class="line"><span class="cl">sudo make
</span></span><span class="line"><span class="cl">./deviceQuery</span></span></code></pre></td></tr></table>
</div>
</div><p>出现如下输出，则CUDA安装成功。
</p>
</li>
<li>
<p>安装cuDNN
3.1进入<a href="https://developer.nvidia.com/cudnn"target="_blank" rel="external nofollow noopener noreferrer">cudnn下载<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>页面，下载版本合适的版
3.2 解压，并进入到相应目录，运行以下命令：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo cp cuda/include/cudnn*.h /usr/local/cuda-10.2/include
</span></span><span class="line"><span class="cl">sudo cp cuda/lib64/libcudnn* /usr/local/cuda-10.2/lib64
</span></span><span class="line"><span class="cl">sudo chmod a+r /usr/local/cuda-10.2/include/cudnn*.h
</span></span><span class="line"><span class="cl">sudo chmod a+r /usr/local/cuda-10.2/lib64/libcudnn*</span></span></code></pre></td></tr></table>
</div>
</div><p>3.3 查看cudnn版本</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cat /usr/local/cuda-10.2/include/cudnn.h <span class="p">|</span> grep CUDNN_MAJOR -A <span class="m">2</span></span></span></code></pre></td></tr></table>
</div>
</div><p>新版本:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cat /usr/local/cuda-10.2/include/cudnn_version.h <span class="p">|</span> grep CUDNN_MAJOR -A <span class="m">2</span></span></span></code></pre></td></tr></table>
</div>
</div><p>ref: <a href="https://blog.csdn.net/weixin_43592742/article/details/115689886?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/weixin_43592742/article/details/115689886?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
</ol>
<p><strong><a href="https://github.com/nvidia/TensorRT"target="_blank" rel="external nofollow noopener noreferrer">TensorRT的安装<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></strong></p>
<p><a href="https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html"target="_blank" rel="external nofollow noopener noreferrer">英伟达提供的安装指导<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<blockquote>
<p>tensorRT 要匹配cuda和cudnn版本。在安装之前请匹配。</p>
</blockquote>
<p>OSS 和 GA 两个版本:</p>
<ol>
<li>
<p>TensorRT OSS:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone -b master https://github.com/nvidia/TensorRT TensorRT
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> TensorRT
</span></span><span class="line"><span class="cl">git submodule update --init --recursive</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>GA 版本(<a href="https://developer.nvidia.com/nvidia-tensorrt-download"target="_blank" rel="external nofollow noopener noreferrer">下载地址<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>)</p>
</li>
<li>
<p>对GA版本和OSS版本在<code>~/.bashrc</code>文件中声明路径:
(GA: General Availability Stable Version)
(OSS: OPEN SOURCE)</p>
<ol>
<li>[oss版本路径]export TRT_SOURCE=/home/yejian/TensorRT/TensorRT_7.2.1</li>
<li>[GA Release 版本路径]export TRT_RELEASE=/home/yejian/TensorRT/TensorRT_7.2.1/TensorRT-7.2.1.6/TensorRT-7.2.1.6</li>
</ol>
</li>
<li>
<p>测试确保安装成功</p>
</li>
</ol>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cd /home/yejian/TensorRT/TensorRT-8.6.1.6/samples/sampleOnnxMNIST
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">../../bin
</span></span><span class="line"><span class="cl">./sample_onnx_mnist</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>Build TensorRT RSS (这一步需要在编写自定义算子的时候编译通过，才能调用自定义算子)
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="n">cd</span><span class="w"> </span><span class="err">$</span><span class="n">TRT_OSSPATH</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">mkdir</span><span class="w"> </span><span class="o">-</span><span class="n">p</span><span class="w"> </span><span class="n">build</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">cd</span><span class="w"> </span><span class="n">build</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">cmake</span><span class="w"> </span><span class="p">..</span><span class="w"> </span><span class="o">-</span><span class="n">DTRT_LIB_DIR</span><span class="o">=</span><span class="err">$</span><span class="n">TRT_LIBPATH</span><span class="w"> </span><span class="o">-</span><span class="n">DTRT_OUT_DIR</span><span class="o">=`</span><span class="n">pwd</span><span class="o">`/</span><span class="k">out</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">make</span><span class="w"> </span><span class="o">-</span><span class="n">j</span><span class="err">$</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>ref: <a href="https://blog.csdn.net/Msjiangmei/article/details/132585145"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Msjiangmei/article/details/132585145<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="自定义算子开发----scatterelements">自定义算子开发 &ndash; ScatterElements</h2>
<p>在自定义算子开发过程中，需要撰写一下4个文件，并且把文件放在scatterElementsPlugin文件夹中:</p>
<ul>
<li><code>CmakeLists.txt</code></li>
<li><code>scatterElements.cu</code></li>
<li><code>scatterElementsPlugin.cpp</code></li>
<li><code>scatterElementsPlugin.h</code></li>
</ul>
<p>如图所示:</p>
<p></p>
<p><strong>自定义算子的生成与注册</strong></p>
<ul>
<li>将以上四个文件报括文件夹复制到TensorRT(OOS)下的plugin文件夹下;</li>
<li>然后修改注册信息文件:(这些文件也在plugin文件夹下)
<ul>
<li><code>${TRT_SOURCE}/plugin: CMakeLists.txt</code></li>
<li><code>${TRT_SOURCE}/InferPlugin.cpp</code></li>
<li><code>${TRT_SOURCE}/common/kernels/kernel.h</code></li>
<li><code>${TRT_SOURCE}/parsers/onnx/builtin_op_importers.cpp</code></li>
</ul>
</li>
</ul>
<p>执行完以上步骤以后，重新编译OOS版本，然后就可以调用自定义算子:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> <span class="nv">$TRT_OSSPATH</span>
</span></span><span class="line"><span class="cl">mkdir -p build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake .. -DTRT_LIB_DIR<span class="o">=</span><span class="nv">$TRT_LIBPATH</span> -DTRT_OUT_DIR<span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/out
</span></span><span class="line"><span class="cl">make -j<span class="k">$(</span>nproc<span class="k">)</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Maching Learning Notes 1</title><link>https://jianye0428.github.io/posts/notes_1/</link><pubDate>Sat, 15 Jul 2023 16:27:34 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/notes_1/</guid><description><![CDATA[<h2 id="用pickle保存和加载模型">用pickle保存和加载模型</h2>
<ul>
<li>保存模型
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pickle</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</span></span><span class="line"><span class="cl"><span class="n">model_dir</span> <span class="o">=</span> <span class="s1">&#39;./model.pkl&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_dir</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> <span class="c1"># 注意:保存完模型之后要关闭文件</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>加载模型
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pickle</span>
</span></span><span class="line"><span class="cl"><span class="n">model_dir</span> <span class="o">=</span> <span class="s1">&#39;./model.pkl&#39;</span>
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_dir</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">pickel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="逻辑回归-logistic-regression">逻辑回归 Logistic Regression</h2>
<ul>
<li>LR Implementation code snippets
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
</span></span><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">pickle</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">data_path</span> <span class="o">=</span> <span class="s1">&#39;./data/merged_data/data.npy&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">model_l1_path</span><span class="o">=</span><span class="s1">&#39;./model/logistic_reg_l1.pickle&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="n">model_l2_path</span><span class="o">=</span><span class="s1">&#39;./model/logictic_reg_l2.pickle&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">35</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">X_train</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># lr_l1 = LogisticRegression(penalty=&#34;l1&#34;, C=0.5, solver=&#39;sag&#39;, multi_class=&#34;auto&#34;)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># lr_l2 = LogisticRegression(penalty=&#34;l2&#34;, C=0.5, solver=&#39;sag&#39;, multi_class=&#34;auto&#34;)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># # train model</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># lr_l1.fit(X_train, Y_train)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># lr_l2.fit(X_train, Y_train)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># model performence on train set</span>
</span></span><span class="line"><span class="cl">  <span class="n">l1_train_predict</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">  <span class="n">l2_train_predict</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># model performence on test set</span>
</span></span><span class="line"><span class="cl">  <span class="n">l1_test_predict</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">  <span class="n">l2_test_predict</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">50</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># lr_l1 = LogisticRegression(penalty=&#34;l1&#34;, C=c, solver=&#39;liblinear&#39;, max_iter=1000)</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># lr_l2 = LogisticRegression(penalty=&#39;l2&#39;, C=c, solver=&#39;liblinear&#39;, max_iter=1000)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">lr_l1</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s2">&#34;l1&#34;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;liblinear&#39;</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">lr_l2</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;liblinear&#39;</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1"># 训练模型，记录L1正则化模型在训练集测试集上的表现</span>
</span></span><span class="line"><span class="cl">      <span class="n">lr_l1</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">l1_train_predict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">lr_l1</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_train</span><span class="p">),</span> <span class="n">Y_train</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">l1_test_predict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">lr_l1</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">),</span> <span class="n">y_test</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1"># 记录L2正则化模型的表现</span>
</span></span><span class="line"><span class="cl">      <span class="n">lr_l2</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">l2_train_predict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">lr_l2</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_train</span><span class="p">),</span> <span class="n">Y_train</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">l2_test_predict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">lr_l2</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">),</span> <span class="n">y_test</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">pred_y_test</span> <span class="o">=</span> <span class="n">lr_l2</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="n">mask</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pred_y_test</span><span class="o">-</span><span class="n">y_test</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">          <span class="n">neg_test</span> <span class="o">=</span> <span class="n">pred_y_test</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">          <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neg_test</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_y_test</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">          <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_l1_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">lr_l1</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_l2_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">lr_l2</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">l1_train_predict</span><span class="p">,</span> <span class="n">l2_train_predict</span><span class="p">,</span> <span class="n">l1_test_predict</span><span class="p">,</span> <span class="n">l2_test_predict</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;l1_train&#39;</span><span class="p">,</span> <span class="s1">&#39;l2_train&#39;</span><span class="p">,</span> <span class="s1">&#39;l1_test&#39;</span><span class="p">,</span> <span class="s2">&#34;l2_test&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&#34;best&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="支持向量机-support-vector-machine">支持向量机 Support Vector Machine</h2>
<ul>
<li>Using GridSearch to find the best parameters [code snippets]
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Perceptron</span><span class="p">,</span> <span class="n">LogisticRegression</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
</span></span><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">pickle</span>
</span></span><span class="line"><span class="cl">  <span class="n">merged_data_dir</span> <span class="o">=</span> <span class="s1">&#39;../data/merged_data/merged_data.npy&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="n">model_dir</span><span class="o">=</span><span class="s1">&#39;./svm.pkl&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">merged_data_dir</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">#labeling</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">ele</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">ele</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">      <span class="k">elif</span> <span class="n">ele</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">20</span> <span class="ow">and</span> <span class="n">ele</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">ele</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">ele</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># Create training and test split</span>
</span></span><span class="line"><span class="cl">  <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># feature scaling</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># sc = StandardScaler()</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># sc.fit(X_train)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># X_train_std = sc.transform(X_train)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># X_test_std = sc.transform(X_test)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">##################################</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># # Instantiate the Support Vector Classifier (SVC)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># svc = SVC(C=10, random_state=1, kernel=&#39;rbf&#39;, gamma=0.3)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># # Fit the model</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># svc.fit(X_train, y_train)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># # Make the predictions</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># y_predict = svc.predict(X_test)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># # Measure the performance</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># print(&#34;Accuracy score %.3f&#34; %metrics.accuracy_score(y_test, y_predict))</span>
</span></span><span class="line"><span class="cl">  <span class="c1">#############################################</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">svm_cross_validation</span><span class="p">(</span><span class="n">train_x</span><span class="p">,</span> <span class="n">train_y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
</span></span><span class="line"><span class="cl">      <span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</span></span><span class="line"><span class="cl">      <span class="n">model</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">],</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">]}</span>
</span></span><span class="line"><span class="cl">      <span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;accuracy&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_x</span><span class="p">,</span> <span class="n">train_y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">best_parameters</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="n">para</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">best_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
</span></span><span class="line"><span class="cl">          <span class="nb">print</span><span class="p">(</span><span class="n">para</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">model</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">best_parameters</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span> <span class="n">gamma</span><span class="o">=</span><span class="n">best_parameters</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_x</span><span class="p">,</span> <span class="n">train_y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">model</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">svm_model</span> <span class="o">=</span> <span class="n">svm_cross_validation</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_dir</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">svm_model</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">f1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span><span class="n">svm_model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="n">y_predict</span> <span class="o">=</span> <span class="n">svm_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span><span class="n">y_predict</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></description></item><item><title>configure、make、make install 背后的原理</title><link>https://jianye0428.github.io/posts/make_install/</link><pubDate>Sat, 20 Jan 2024 10:04:30 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/make_install/</guid><description><![CDATA[<h2 id="1-简介">1、 简介</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./configure
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">make install</span></span></code></pre></td></tr></table>
</div>
</div><p>以上三个命令是源码安装软件的通用步骤。其主要完成以下工作：</p>
<ul>
<li>
<p><strong><code>./configure</code></strong>: <font color=red>配置</font>，是用来检测你的安装平台的目标特征。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。configure 脚本负责在使用的系统上准备好软件的构建环境。确保接下来的构建和安装过程所需要的依赖准备好，并且搞清楚使用这些依赖需要的东西。</p>
</li>
<li>
<p><strong><code>make</code></strong>: <font color=red>构建</font>，用来编译，它从<code>Makefile</code>中读取指令，然后编译。下载的源码包一般没有一个最终的 <code>Makefile</code> 文件，一般是一个模版文件 <a href="http://Makefile.in"target="_blank" rel="external nofollow noopener noreferrer">http://Makefile.in<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 文件，然后 <code>configure</code> 根据系统的参数生成一个定制化的 <code>Makefile</code> 文件。这个过程会执行在 Makefile 文件中定义的一系列任务将软件源代码编译成可执行文件。</p>
</li>
<li>
<p><strong><code>make install</code></strong>:<font color=red>安装</font>，它也从Makefile中读取指令，安装到指定的位置。make install 命令就是将可执行文件、第三方依赖包和文档复制到正确的路径。</p>
</li>
</ul>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>这些脚本是怎么产生的?</p>
<blockquote>
<p>安装过程简单说就是 configure 脚本根据系统信息将 Makefile.in 模版文件转换为 Makefile文件，但是 configure 和 Makefile.in 文件是怎么产生的呢？</p>
</blockquote>
<blockquote>
<p>如果你曾经试着打开 configure 或者 Makefile.in 文件，你会发现超长而且复杂的 shell 脚本语言。有时候这些脚本代码比它们要安装的程序源代码还要长。</p>
</blockquote>
<blockquote>
<p>如果想手动创建一个这样的 configure 脚本文件是非常可怕的，好消息是这些脚本是<strong>通过代码生成</strong>的。</p>
</blockquote>
<blockquote>
<p>通过这种方式构建的软件通常是通过一个叫做 autotools 的工具集打包的。这个工具集包含 autoconf 、automake 等工具，所有的这些工具使得维护软件生命周期变得很容易。最终用户不需要了解这些工具，但却可以让软件在不同的 Unix 系统上的安装步骤变得简单。</p>
</blockquote>
</div>
    </div>
  </div>
<h2 id="2-详细说明">2、 详细说明</h2>
<h3 id="21-configure命令">2.1 configure命令</h3>
<p>这一步一般用来生成 <code>Makefile</code>，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，具体参数可以通过<code>configure --help</code> 察看，下面举几个例子:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./configure --prefix<span class="o">=</span>/usr ...</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>--prefix=/usr</code>: 意思是将该软件安装在 <code>/usr</code> 下面，执行文件就会安装在 /usr/bin (而不是默认的 /usr/local/bin), 资源文件就会安装在 /usr/share(而不是默认的/usr/local/share)。选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统）</li>
<li><code>--bindir=</code>: 指定二进制文件的安装位置.这里的二进制文件定义为可以被用户直接执行的程序</li>
<li><code>--enable-static与--enable-shared:</code>
<ul>
<li><code>--enable-static</code>: 生成静态链接库</li>
<li><code>--enable-shared</code>: 生成动态链接库</li>
</ul>
</li>
<li><code>--with-</code>: 用于启用或禁用特定功能或模块。例如:
<ul>
<li><code>--with-ssl</code>表示启用SSL支持</li>
<li><code>--without-gui</code>表示禁用图形界面。</li>
</ul>
</li>
<li><code>--with-package=dir</code></li>
<li><code>--with-apxs</code> 是指定 apache 的配置程序路径，php编译程序会通过这个程序查找apache的相关路径</li>
<li><code>--with-libxml-dir</code>: 指向的是 libxml 的库路径</li>
<li><code>--with-gd</code>: 指静态编译gd库</li>
<li><code>--with-png-dir</code>: 指定 libpng 的路径</li>
<li><code>--enable-</code>: 用于启用或禁用特定功能或模块。与&ndash;with-选项类似，但更常用于启用或禁用编译选项。</li>
<li><code>--disable-</code>: 用于禁用特定功能或模块。与&ndash;enable-选项相反，用于禁用编译选项。</li>
<li><code>–sys-config=</code>: 指定软件的配置文件。有一些软件还可以加上 <code>–with</code>、<code>–enable</code>、<code>–without</code>、<code>–disable</code> 等等参数对编译加以控制</li>
</ul>
<h3 id="22-make-命令">2.2 make 命令</h3>
<p>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p>
<p>可能遇到的错误：<code>make ***</code> 没有指明目标并且找不到 makefile。 没有Makefile，先<code>./configure</code> 一下，再<code>make</code>。<code>make uninstall</code> 是卸载，不加参数就是默认的进行源代码编译。</p>
<p><code>make</code>工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，<code>make</code>依据它来批处理编译，这个文件就是<code>makefile</code>。</p>
<h3 id="23-make-install-命令">2.3 make install 命令</h3>
<p>这条命令来进行安装（当然有些软件需要先运行 <code>make check</code> 或 <code>make test</code> 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。</p>
<p><code>make install</code> 和<code>make install prefix=/usr/local/</code> 等价。</p>
<p><code>make install prefix=/usr/local/ sysconfdir=/etc DESTDIR=/tmp/build</code>支持<code>DESTDIR</code>的意义就是，保证所有要安装的文件，都会被安装在DESTDIR目录下，不会污染系统的package的目录。install也 是linux系统命令。</p>
<h3 id="24-扩展说明">2.4 扩展说明</h3>
<p>Linux的用户可能知道，在Linux下安装一个应用程序时，一般先运行脚本configure，然后用make来编译源程序，在运行make install，最后运行make clean删除一些临时文件。</p>
<p>configure是一个shell脚本，它可以自动设定源程序以符合各种不同平台上Unix系统的特性，并且根据系统叁数及环境产生合适的Makefile文件或是C的头文件(header file)，让源程序可以很方便地在这些不同的平台上被编译连接。</p>
<p>利用configure所产生的Makefile文件有几个预设的目标可供使用，其中几个重要的简述如下：</p>
<ul>
<li><code>make all</code>: 产生我们设定的目标，即此范例中的可执行文件。只打make也可以，此时会开始编译原始码，然后连结，并且产生可执行文件。只打make 默认就是<code>make all</code>，只编译其中某个目标则在后面给目标名称：make ce-common。</li>
<li><code>make clean</code>: 清除编译产生的可执行文件及目标文件(object file，*.o)。</li>
<li><code>make distclean</code>: 除了清除可执行文件和目标文件外，把configure所产生的Makefile也清除掉。</li>
<li><code>make install</code>: 将程序安装至系统中。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。</li>
<li><code>make dist</code>: 将程序和相关的档案包装成一个压缩文件以供发布。执行完在目录下会产生一个以PACKAGE-VERSION.tar.gz为名称的文件。 PACKAGE和VERSION这两个变数是根据http://configure.in文件中AM_INIT_AUTOMAKE(PACKAGE，VERSION)的定义。在此范例中会产生test-1.0.tar.gz的档案。</li>
<li><code>make distcheck</code>: 和make dist类似，但是加入检查包装后的压缩文件是否正常。这个目标除了把程序和相关文件包装成tar.gz文件外，还会自动把这个压缩文件解开，执行 configure，并且进行make all 的动作，确认编译无误后，会显示这个tar.gz文件可供发布了。这个检查非常有用，检查过关的包，基本上可以给任何一个具备GNU开发环境-的人去重新编译。</li>
</ul>
<h2 id="3-总结">3. 总结</h2>
<p>通过源码编译安装一个软件如下:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./configure --prefix<span class="o">=</span>/usr/local/<span class="si">${</span><span class="nv">program_name</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">make install
</span></span><span class="line"><span class="cl">make clean</span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意: </mark> <code>--prefix</code>可以在configure或者make install时指定安装路径。</p>
<h2 id="4-参考">4. 参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/77813702"target="_blank" rel="external nofollow noopener noreferrer">Linux命令详解：./configure、make、make install 命令<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77813702"target="_blank" rel="external nofollow noopener noreferrer">configure、 make、 make install 背后的原理(翻译)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
]]></description></item><item><title>Google Benchmark 性能测试分析工具</title><link>https://jianye0428.github.io/posts/google_benchmark_introduction/</link><pubDate>Fri, 19 Jan 2024 19:33:03 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/google_benchmark_introduction/</guid><description><![CDATA[<h2 id="0-简介">0. 简介</h2>
<p>作为一个程序而言，benchmark是非常关键的一个衡量指标，无论是程序算法的指标还是程序运行性能的指标，这些我们都可以去完成衡量。对于性能衡量而言google benchmark无疑是一个比较好的选择。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">性能测试工具对比</div>
</center>
<br>
<h2 id="1-google-benchmark安装">1. google benchmark安装</h2>
<p><a href="https://github.com/google/benchmark"target="_blank" rel="external nofollow noopener noreferrer">google benchmark 下载地址<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><strong>编译安装:</strong></p>
<p>登录 linux环境，执行以下命令，进行编译安装：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone https://github.com/google/benchmark.git
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> benchmark
</span></span><span class="line"><span class="cl">git clone https://github.com/google/googletest.git
</span></span><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake .. -DCMAKE_BUILD_TYPE<span class="o">=</span>RELEASE
</span></span><span class="line"><span class="cl">make -j4
</span></span><span class="line"><span class="cl"><span class="c1"># 如果想全局安装就接着运行下面的命令</span>
</span></span><span class="line"><span class="cl">sudo make install</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="2--代码编写">2.  代码编写</h2>
<p>创建一个C++源文件，并编写包含基准测试函数的代码。例如，创建一个名为benchmark_example.cpp的文件，并编写如下内容：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">BM_MyFunction</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这里编写您要测试的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 执行您的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">BM_MyFunction</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_MAIN</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上述示例中，<code>BM_MyFunction</code>是您要测试的函数。</p>
<p>然后我们可以使用C++编译器编译您的代码，并链接Google Benchmark库。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">g++ benchmark_example.cpp -o benchmark_example -lbenchmark -lpthread</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是cmakelist，则可以使用</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_FLAGS</span> <span class="s2">&#34;${CMAKE_CXX_FLAGS} -pthread&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># benchmark依赖thread线程库
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">benchmark</span> <span class="s">STATIC</span> <span class="s">IMPORTED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">benchmark</span> <span class="s">PROPERTY</span> <span class="s">IMPORTED_LOCATION</span> <span class="s">/usr/local/lib/libbenchmark.a</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">demo</span> <span class="s">demo.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">demo</span>
</span></span><span class="line"><span class="cl">    <span class="s">benchmark</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span>
</span></span><span class="line"><span class="cl">    <span class="s">demo</span>
</span></span><span class="line"><span class="cl">    <span class="s">DESTINATION</span> <span class="s2">&#34;bin/&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="21-基础代码调用测试">2.1 基础代码调用测试</h3>
<p>我们可以看到每一个benchmark测试用例都是一个类型为<code>std::function</code>的函数，其中<code>benchmark::State&amp;</code>负责测试的运行及额外参数的传递。</p>
<p>测试用例编写完成后，我们需要使用<code>BENCHMARK()</code>将我们的测试用例注册进benchmark，这样程序运行时才会执行我们的测试。</p>
<p>最后是用<code>BENCHMARK_MAIN();</code>替代直接编写的main函数，它会处理命令行参数并运行所有注册过的测试用例生成测试结果。</p>
<table><tr><td bgcolor=yellow>Example 1:</td></tr></table>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// benchmark::State &amp;state用于维护测试上下文信息，以及控制迭代次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">vector_test</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">vec</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">array_test</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 注册测试用例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">vector_test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">array_test</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// benchmark的主函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK_MAIN</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果格式如下:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Load Average: 0.43, 0.25, 0.10
</span></span><span class="line"><span class="cl">------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark            Time             CPU   Iterations
</span></span><span class="line"><span class="cl">------------------------------------------------------
</span></span><span class="line"><span class="cl">vector_test       6.81 ns         6.81 ns    <span class="m">102373755</span>
</span></span><span class="line"><span class="cl">array_test        13.6 ns         13.6 ns     <span class="m">51227934</span></span></span></code></pre></td></tr></table>
</div>
</div><table><tr><td bgcolor=yellow>Example 2</td></tr></table>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// constexpr function具有inline属性，你应该把它放在头文件中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">my_pow</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用operator[]读取元素，依次存入1-6的平方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_operator</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_operator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用at()读取元素，依次存入1-6的平方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_at</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_at</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// std::get&lt;&gt;(array)是一个constexpr function，它会返回容器内元素的引用，并在编译期检查数组的索引是否正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_get</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">my_pow</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_get</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_MAIN</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到每一个benchmark测试用例都是一个类型为<code>std::function&lt;void(benchmark::State&amp;)&gt;</code>的函数，其中<code>benchmark::State&amp;</code>负责测试的运行及额外参数的传递。</p>
<p>随后我们使用<code>for (auto _: state) {}</code>来运行需要测试的内容，<code>state</code>会选择合适的次数来运行循环，时间的计算从循环内的语句开始，所以我们可以选择像例子中一样在for循环之外初始化测试环境，然后在循环体内编写需要测试的代码。</p>
<p>测试用例编写完成后我们需要使用<code>BENCHMARK(&lt;function_name&gt;)</code>;将我们的测试用例注册进benchmark，这样程序运行时才会执行我们的测试。</p>
<p>最后是用BENCHMARK_MAIN();替代直接编写的main函数，它会处理命令行参数并运行所有注册过的测试用例生成测试结果。</p>
<p>示例中大量使用了<code>constexpt</code>，这是为了能在编译期计算出需要的数值避免对测试产生太多噪音。</p>
<p>然后我们编译测试程序：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">g++ -Wall -std<span class="o">=</span>c++14 benchmark_example.cpp -pthread -lbenchmark</span></span></code></pre></td></tr></table>
</div>
</div><p>benchmark需要链接<code>libbenchmark.so</code>，所以需要指定<code>-lbenchmark</code>，此外还需要<code>thread</code>的支持，因为<code>libstdc++</code>不提供<code>thread</code>的底层实现，我们需要<code>pthread</code>。另外不建议使用-lpthread，官方表示会出现兼容问题，在我这测试也会出现链接错误。注意文件名一定要在-lbenchmark前面，否则编译会失败，具体参见：https://github.com/google/benchmark/issues/619</p>
<p>如果你是在Windows平台使用google/benchmark，那么你需要额外链接shlwapi.lib才能使benchmark正常编译和运行。详细信息在这里。</p>
<p>编译好程序后就可以运行测试了：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T15:56:26+08:00
</span></span><span class="line"><span class="cl">Running ./benchmark_example_two
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 0.36, 0.64, 0.82
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">---------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                     Time             CPU   Iterations
</span></span><span class="line"><span class="cl">---------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_array_operator       30.9 ns         30.6 ns     <span class="m">22700640</span>
</span></span><span class="line"><span class="cl">bench_array_at             31.1 ns         30.9 ns     <span class="m">22376913</span>
</span></span><span class="line"><span class="cl">bench_array_get            29.4 ns         29.4 ns     <span class="m">23760270</span></span></span></code></pre></td></tr></table>
</div>
</div><p>显示的警告信息表示在当前系统环境有一些噪音(例如其他在运行的程序)可能导致结果不太准确，并不影响我们的测试。</p>
<p>在Windows上通常没有上述警告，如果你需要在Linux平台上去除相关警告的话，请参考此处。</p>
<p>测试结果与预期基本相符，<code>std::get</code>最快，<code>at()</code>最慢。</p>
<h3 id="22-传参调用测试">2.2 传参调用测试</h3>
<p>上面的测试用例都只接受一个<code>benchmark::State&amp;</code>类型的参数，所以我们可以使用<code>BENCHMARK</code>宏生成的对象的<code>Arg</code>方法来完成参数的传递。</p>
<p>传递进来的参数会被放入<code>state</code>对象内部存储，通过<code>range</code>方法获取，调用时的参数<code>0</code>是传入参数的需要，对应第一个参数。</p>
<p>举个例子，假如我们需要实现一个队列，现在有ring buffer和linked list两种实现可选，现在我们要测试两种方案在不同情况下的性能表现：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 必要的数据结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;ring.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;linked_ring.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ring buffer的测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int_10</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span> <span class="c1">// 暂停计时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span> <span class="c1">// 恢复计时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int_10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// linked list的测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_linked_queue_insert_int_10</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">LinkedRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_linked_queue_insert_int_10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 还有针对删除的测试，以及针对string的测试，都是高度重复的代码，这里不再罗列
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很显然，上面的测试除了被测试类型和插入的数据量之外没有任何区别，如果可以通过传入参数进行控制的话就可以少写大量重复的代码。</p>
<p>编写重复的代码是浪费时间，而且往往意味着你在做一件蠢事，google的工程师们当然早就注意到了这一点。虽然测试用例只能接受一个<code>benchmark::State&amp;</code>类型的参数，但我们可以将参数传递给state对象，然后在测试用例中获取：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">length</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的例子展示了如何传递和获取参数：</p>
<ul>
<li>传递参数使用<code>BENCHMARK</code>宏生成的对象的<code>Arg</code>方法</li>
<li>传递进来的参数会被放入<code>state</code>对象内部存储，通过<code>range</code>方法获取，调用时的参数<code>0</code>是传入参数的需要，对应第一个参数</li>
</ul>
<p><code>Arg</code>方法一次只能传递一个参数，那如果一次想要传递多个参数呢？也很简单：</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的例子没什么实际意义，只是为了展示如何传递多个参数，<code>Args</code>方法接受一个<code>vector</code>对象，所以我们可以使用c++11提供的大括号初始化器简化代码，获取参数依然通过<code>state.range</code>方法，<code>1</code>对应传递进来的第二个参数。</p>
<p>有一点值得注意，参数传递只能接受整数，如果你希望使用其他类型的附加参数，就需要另外想些办法了。</p>
<h3 id="23-简化多个类似测试用例的生成功">2.3 简化多个类似测试用例的生成功</h3>
<p>向测试用例传递参数的最终目的是为了在不编写重复代码的情况下生成多个测试用例，在知道了如何传递参数后你可能会这么写：</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">bench_array_ring_insert_int</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">length</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ring</span> <span class="o">=</span> <span class="n">ArrayRing</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ring</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">PauseTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="p">.</span><span class="n">ResumeTiming</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 下面我们生成测试插入10，100，1000次的测试用例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T15:56:26+08:00
</span></span><span class="line"><span class="cl">Running ./benchmark_example_two
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 0.36, 0.64, 0.82
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">--------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                    Time              CPU      Iterations
</span></span><span class="line"><span class="cl">----------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/10              <span class="m">584</span>  ns           <span class="m">547</span> ns     <span class="m">1000000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/100             <span class="m">1357</span> ns           <span class="m">1367</span> ns     <span class="m">560000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/1000            <span class="m">9207</span> ns           <span class="m">9521</span> ns     <span class="m">64000</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上的代码虽然结果是正确的，但是仍然写了很多重复代码！</p>
<p>幸好<code>Arg</code>和<code>Args</code>会将我们的测试用例使用的参数进行注册以便产生用例名/参数的新测试用例，并且返回一个指向<code>BENCHMARK</code>宏生成对象的指针，换句话说，如果我们想要生成仅仅是参数不同的多个测试的话，只需要链式调用Arg和Args即可：</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果和上面一样。</p>
<p>但这还不是最优解，我们仍然重复调用了Arg方法，如果我们需要更多用例时就不得不又要做重复劳动了。</p>
<p>对此google benchmark也有解决办法：我们可以使用<code>Range</code>方法来自动生成一定范围内的参数。</p>
<p>先看看Range的原型：</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMAEK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">limit</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>start表示参数范围起始的值，limit表示范围结束的值，Range所作用于的是一个_闭区间_。</p>
<p>但是如果我们这样改写代码，是会得到一个错误的测试结果:</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                   Time            CPU      Iterations
</span></span><span class="line"><span class="cl">----------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/10              <span class="m">584</span>  ns         <span class="m">625</span> ns     <span class="m">1000000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/64              <span class="m">1042</span> ns         <span class="m">1029</span> ns    <span class="m">896000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/512             <span class="m">4948</span>  ns        <span class="m">5313</span> ns    <span class="m">100000</span>
</span></span><span class="line"><span class="cl">bench_array_ring_insert_int/1000            <span class="m">9221</span> ns         <span class="m">8545</span> ns     <span class="m">89600</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为什么会这样呢？那是因为Range默认除了start和limit，中间的其余参数都会是某一个基底（base）的幂，基地默认为8，所以我们会看到64和512，它们分别是8的平方和立方。</p>
<p>想要改变这一行为也很简单，只要重新设置基底即可，通过使用RangeMultiplier方法：</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在结果恢复如初了。</p>
<p>使用Ranges可以处理多个参数的情况：</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Ranges</span><span class="p">({{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">},</span> <span class="p">{</span><span class="mi">128</span><span class="err">，</span> <span class="mi">256</span><span class="p">}});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一个范围指定了测试用例的第一个传入参数的范围，而第二个范围指定了第二个传入参数可能的值（注意这里不是范围了）。</p>
<p>与下面的代码等价：</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">128</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">100</span><span class="p">,</span> <span class="mi">128</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">128</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">256</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">100</span><span class="p">,</span> <span class="mi">256</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">               <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">256</span><span class="p">})</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上就是用生成的第一个参数的范围于后面指定内容的参数做了一个笛卡尔积。</p>
<h3 id="24-使用参数生成器">2.4 使用参数生成器</h3>
<p>如果我想定制没有规律的更复杂的参数呢？这时就需要实现自定义的参数生成器了。</p>
<p>一个参数生成器的签名如下：</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CustomArguments</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Benchmark</span><span class="o">*</span> <span class="n">b</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们在生成器中计算处参数，然后调用<code>benchmark::internal::Benchmark</code>对象的<code>Arg</code>或<code>Args</code>方法像上两节那样传入参数即可。</p>
<p>随后我们使用<code>Apply</code>方法把生成器应用到测试用例上：</p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Apply</span><span class="p">(</span><span class="n">CustomArguments</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其实这一过程的原理并不复杂，我做个简单的解释：</p>
<ol>
<li><code>BENCHMARK</code>宏产生的就是一个<code>benchmark::internal::Benchmark</code>对象然后返回了它的指针</li>
<li>向<code>benchmark::internal::Benchmark</code>对象传递参数需要使用<code>Arg</code>和<code>Args</code>等方法</li>
<li><code>Apply</code>方法会将参数中的函数应用在自身</li>
<li>我们在生成器里使用<code>benchmark::internal::Benchmark</code>对象的指针<code>b</code>的<code>Args</code>等方法传递参数，这时的<code>b</code>其实指向我们的测试用例</li>
</ol>
<p>到此为止生成器是如何工作的已经一目了然了，当然从上面得出的结论，我们还可以让Apply做更多的事情。</p>
<p>下面看下Apply的具体使用：</p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 这次我们生成100，200，...，1000的测试用例，用range是无法生成这些参数的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">custom_args</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Benchmark</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="o">-&gt;</span><span class="n">Arg</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">bench_array_ring_insert_int</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Apply</span><span class="p">(</span><span class="n">custom_args</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="25-模板类的调用测试">2.5 模板类的调用测试</h3>
<p>如果针对每一种情况写测试函数，显然违反了<code>DRY原则</code>，因为除了vector的类型参数不同，其他代码几乎是完全一样的。</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_reserve</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">bench_vector_reserve</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">is_reserve</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">container</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// BENCHMARK_TEMPLATE(bench_vector_reserve, std::string, 100);
</span></span></span><span class="line"><span class="cl"><span class="c1">// // benchmark的主函数
</span></span></span><span class="line"><span class="cl"><span class="c1">// BENCHMARK_MAIN();
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>非常的简单，我们通过<code>length</code>控制插入的元素个数；<code>is_reserve</code>则负责控制是否预分配内存，通过<code>if constexpr</code>可以生成reserve和不进行任何操作的两种代码（如果不熟悉c++17的if constexpr，推荐花两分钟看看<a href="https://www.cnblogs.com/apocelipes/p/14536236.html#%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"target="_blank" rel="external nofollow noopener noreferrer">这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>）。</p>
<p>然后我们像往常一样定义一个测试用例：</p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">BENCHMARK<span class="o">(</span>bench_vector_reserve&lt;std::string,100&gt;<span class="o">)</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可是等我们编译的时候却报错了！</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ g++ test.cpp -lpthread -lbenchmark -lbenchmark_main
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">test.cpp:19:48: 错误：宏“BENCHMARK”传递了 <span class="m">2</span> 个参数，但只需要 <span class="m">1</span> 个
</span></span><span class="line"><span class="cl">   <span class="m">19</span> <span class="p">|</span> BENCHMARK<span class="o">(</span>bench_vector_reserve&lt;std::string,100&gt;<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>                                                ^
</span></span><span class="line"><span class="cl">In file included from a.cpp:1:
</span></span><span class="line"><span class="cl">/usr/local/include/benchmark/benchmark.h:1146: 附注：macro <span class="s2">&#34;BENCHMARK&#34;</span> defined here
</span></span><span class="line"><span class="cl"> <span class="m">1146</span> <span class="p">|</span> <span class="c1">#define BENCHMARK(n)                                     \</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>
</span></span><span class="line"><span class="cl">test.cpp:19:1: 错误：‘BENCHMARK’不是一个类型名
</span></span><span class="line"><span class="cl">   <span class="m">19</span> <span class="p">|</span> BENCHMARK<span class="o">(</span>bench_vector_reserve&lt;std::string,100&gt;<span class="o">)</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>原因是这样的，在编译器处理宏的时候实际上不会考虑c++语法，所以分割模板参数的逗号被识别成了分割宏参数的逗号，因此在宏处理器的眼里我们像是传了两个参数。这也说明了<code>BENCHMARK</code>是处理不了模板的。</p>
<p>不过别担心，Google早就想到这种情况了，所以提供了<code>BENCHMARK_TEMPLATE</code>宏，我们只需要把模板名字和需要的类型参数依次传给宏即可：</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T19:12:57+08:00
</span></span><span class="line"><span class="cl">Running ./benchmark_template
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 1.67, 1.82, 1.39
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                                 Time             CPU   Iterations
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100&gt;                 <span class="m">2912</span> ns         <span class="m">2910</span> ns       <span class="m">239967</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 1000&gt;               <span class="m">27585</span> ns        <span class="m">27571</span> ns        <span class="m">25299</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 10000&gt;             <span class="m">275549</span> ns       <span class="m">275527</span> ns         <span class="m">2534</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100000&gt;           <span class="m">3158585</span> ns      <span class="m">2818440</span> ns          <span class="m">253</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100, false&gt;          <span class="m">7743</span> ns         <span class="m">7635</span> ns        <span class="m">89883</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 1000, false&gt;        <span class="m">54695</span> ns        <span class="m">54663</span> ns        <span class="m">12540</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 10000, false&gt;      <span class="m">671379</span> ns       <span class="m">671340</span> ns         <span class="m">1050</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, 100000, false&gt;    <span class="m">8904492</span> ns      <span class="m">8903935</span> ns           <span class="m">79</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="26-定制测试参数">2.6 定制测试参数</h3>
<p>在上面的代码中，length参数其实是不必要的，所以代码可以这样改：</p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_reserve</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">bench_vector_reserve</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">is_reserve</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 通过range方法获取传入的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">container</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RangeMultiplier</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们测试的元素数量是[10, 100, 1000, 10^4, 10^5]。</p>
<p>除此之外还有另一种叫“密集参数”的Ranges。google benchmark提供了DenseRange方法。</p>
<p>这个方法的原型如下：</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">DenseRange</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">step</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Ranges</code>是累乘，而<code>DenseRange</code>是累加，因为累乘会导致几何级数的增长，在数轴上的分布越来越稀疏，累加则看上去像是均匀分布的，因此累加的参数生成器被叫做<code>密集参数生成器</code>。</p>
<p>如果我们把测试用例这么改：</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DenseRange</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们的length就是这样一个序列：<code>[1000，2000，3000， ...，9000，10000]</code>。</p>
<p>关于自定义参数最后一个知识点是<code>ArgsProduct</code>。看名字就知道这是一个参数工厂。</p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ArgsProduct</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">arglists</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::vector&lt;int64_t&gt;</code>实际上就是一组参数，<code>arglists</code>就是多组参数的合集，他们之间会被求笛卡尔积，举个例子：</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">BM_test</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span> <span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等价于下面的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BENCHMARK</span><span class="p">(</span><span class="n">BM_test</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="p">...</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="o">-&gt;</span><span class="n">Args</span><span class="p">({</span><span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">                  <span class="err">```</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到参数工厂其实得自己手写所有参数，那如果我想配合工厂使用Ranges呢？</p>
<p>没问题，benchmark的开发者们早就想到了，所以提供了下面这些帮助函数：</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="cm">/*multi=*/</span><span class="mi">2</span><span class="p">)</span>   <span class="c1">// 生成：[8, 16, 32, 64, 128]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">benchmark</span><span class="o">::</span><span class="n">CreateDenseRange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/*step=*/</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 生成：[1, 2, 3, 4, 5, 6]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果换成我们的例子，就可以这样写：</p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>借助仅仅两行代码我们就能生成数量可观的测试用例：</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T19:26:55+08:00
</span></span><span class="line"><span class="cl">Running ./bm_template_2
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 1.91, 2.05, 1.65
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                                Time             CPU   Iterations
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10                   <span class="m">466</span> ns          <span class="m">466</span> ns      <span class="m">1505218</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100                 <span class="m">3549</span> ns         <span class="m">3548</span> ns       <span class="m">200461</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/1000               <span class="m">34067</span> ns        <span class="m">34049</span> ns        <span class="m">20858</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10000             <span class="m">324499</span> ns       <span class="m">324370</span> ns         <span class="m">2125</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100000           <span class="m">3229254</span> ns      <span class="m">3227361</span> ns          <span class="m">219</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10           <span class="m">1604</span> ns         <span class="m">1603</span> ns       <span class="m">436414</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100          <span class="m">7707</span> ns         <span class="m">7705</span> ns        <span class="m">89743</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/1000        <span class="m">57709</span> ns        <span class="m">57694</span> ns        <span class="m">12026</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10000      <span class="m">688582</span> ns       <span class="m">688283</span> ns         <span class="m">1008</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100000    <span class="m">9208480</span> ns      <span class="m">9205775</span> ns           <span class="m">75</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，这只是一个类型参数，实际上我们还有另外两个类型需要测试。另外这是1.5.5新增的功能，如果你想尝鲜得先升级google benchmark。</p>
<p>通常做到上面那一步就足够了，然而在这里我们还有优化空间，因为如果我们把其他两个测试用的类型加上，代码是这样的，MyClass的定义后面会给出：</p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">MyClass</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">BENCHMARK_TEMPLATE</span><span class="p">(</span><span class="n">bench_vector_reserve</span><span class="p">,</span> <span class="n">MyClass</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ArgsProduct</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="n">benchmark</span><span class="o">::</span><span class="n">CreateRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你看见了什么？没错，重复重复重复！我们又违背了DRY原则。</p>
<p>重复说不上什么十恶不赦，但能避免还是要避免的，所以我准备用宏来简化这些代码：</p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define generate_test(type) \
</span></span></span><span class="line"><span class="cl"><span class="cp">	BENCHMARK_TEMPLATE(bench_vector_reserve, type)-&gt;ArgsProduct({benchmark::CreateRange(10, 100000, 10)}); \
</span></span></span><span class="line"><span class="cl"><span class="cp">	BENCHMARK_TEMPLATE(bench_vector_reserve, type, false)-&gt;ArgsProduct({benchmark::CreateRange(10, 100000, 10)});
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">generate_test</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">generate_test</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">generate_test</span><span class="p">(</span><span class="n">MyClass</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这下舒服多了。</p>
<p>接着来看我们的MyClass，我们的MyClass包含几个虚函数，禁止移动赋值，同时被刻意设计成了非平凡复制，这样的类型可以说是绕过了标准库容器设计的大部分优化措施，算是个妥妥的反面教材，希望你的项目里尽量不要出现这种东西：</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2L</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">long</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个类其实就是针对内存分配器实现的，vector在重新进行内存分配后很可能靠移动语义或者memmove来移动数据，这两者将导致重新分配内存导致的性能损失变小，不利于我们观察vector的行为，所以我定制了这个类。</p>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">2024-01-20T19:39:19+08:00
</span></span><span class="line"><span class="cl">Running ./bm_template_3
</span></span><span class="line"><span class="cl">Run on <span class="o">(</span><span class="m">4</span> X <span class="m">3700</span> MHz CPU s<span class="o">)</span>
</span></span><span class="line"><span class="cl">CPU Caches:
</span></span><span class="line"><span class="cl">  L1 Data <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L1 Instruction <span class="m">32</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L2 Unified <span class="m">256</span> KiB <span class="o">(</span>x4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  L3 Unified <span class="m">8192</span> KiB <span class="o">(</span>x1<span class="o">)</span>
</span></span><span class="line"><span class="cl">Load Average: 1.94, 1.42, 1.32
</span></span><span class="line"><span class="cl">***WARNING*** CPU scaling is enabled, the benchmark real <span class="nb">time</span> measurements may be noisy and will incur extra overhead.
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">Benchmark                                                Time             CPU   Iterations
</span></span><span class="line"><span class="cl">------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10                   <span class="m">480</span> ns          <span class="m">480</span> ns      <span class="m">1399285</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100                 <span class="m">3446</span> ns         <span class="m">3445</span> ns       <span class="m">200045</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/1000               <span class="m">34552</span> ns        <span class="m">33697</span> ns        <span class="m">20974</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/10000             <span class="m">329746</span> ns       <span class="m">329407</span> ns         <span class="m">2123</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string&gt;/100000           <span class="m">3263084</span> ns      <span class="m">3262478</span> ns          <span class="m">215</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10           <span class="m">1603</span> ns         <span class="m">1602</span> ns       <span class="m">435234</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100          <span class="m">7871</span> ns         <span class="m">7870</span> ns        <span class="m">88586</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/1000        <span class="m">58803</span> ns        <span class="m">58793</span> ns        <span class="m">11582</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/10000      <span class="m">713880</span> ns       <span class="m">711949</span> ns          <span class="m">973</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::string, false&gt;/100000    <span class="m">9387908</span> ns      <span class="m">9385776</span> ns           <span class="m">74</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/10                   <span class="m">388</span> ns          <span class="m">387</span> ns      <span class="m">1800299</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/100                 <span class="m">2421</span> ns         <span class="m">2421</span> ns       <span class="m">289565</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/1000               <span class="m">23424</span> ns        <span class="m">23413</span> ns        <span class="m">29931</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/10000             <span class="m">229590</span> ns       <span class="m">229543</span> ns         <span class="m">3081</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t&gt;/100000           <span class="m">2258210</span> ns      <span class="m">2257467</span> ns          <span class="m">309</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/10           <span class="m">1331</span> ns         <span class="m">1329</span> ns       <span class="m">526682</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/100          <span class="m">4098</span> ns         <span class="m">4094</span> ns       <span class="m">169896</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/1000        <span class="m">26619</span> ns        <span class="m">26614</span> ns        <span class="m">26307</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/10000      <span class="m">248256</span> ns       <span class="m">248125</span> ns         <span class="m">2864</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;std::size_t, false&gt;/100000    <span class="m">2411262</span> ns      <span class="m">2410631</span> ns          <span class="m">286</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/10                       <span class="m">547</span> ns          <span class="m">547</span> ns      <span class="m">1264878</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/100                     <span class="m">4268</span> ns         <span class="m">4268</span> ns       <span class="m">163187</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/1000                   <span class="m">41305</span> ns        <span class="m">41292</span> ns        <span class="m">16957</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/10000                 <span class="m">408955</span> ns       <span class="m">408888</span> ns         <span class="m">1713</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass&gt;/100000               <span class="m">4095353</span> ns      <span class="m">4093747</span> ns          <span class="m">170</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/10               <span class="m">1428</span> ns         <span class="m">1428</span> ns       <span class="m">487914</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/100              <span class="m">8052</span> ns         <span class="m">8050</span> ns        <span class="m">86405</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/1000            <span class="m">65784</span> ns        <span class="m">65772</span> ns        <span class="m">10679</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/10000          <span class="m">741154</span> ns       <span class="m">741025</span> ns          <span class="m">940</span>
</span></span><span class="line"><span class="cl">bench_vector_reserve&lt;MyClass, false&gt;/100000        <span class="m">6842572</span> ns      <span class="m">6839261</span> ns          <span class="m">102</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="27-使用benchmark接口">2.7. 使用Benchmark接口</h3>
<p>这里将待测试的函数注册为一个基准测试用例，并指定测试用例的名称和参数。该代码中使用了三种不同的注册方式：<code>函数指针</code>、<code>Lambda 函数</code>和<code>带参数的函数指针</code>。最后，使用 <code>benchmark::RunSpecifiedBenchmarks</code> 函数运行所有注册的基准测试用例，并使用 <code>benchmark::Shutdown</code> 函数释放资源。</p>
<div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;benchmark/benchmark.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">BM_DemoSleep</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span> <span class="c1">//待测试的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">BM_DemoSleep1</span><span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;id:&#34;</span><span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">benchmark</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span> <span class="c1">// 初始化Benchmark
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">benchmark</span><span class="o">::</span><span class="n">ReportUnrecognizedArguments</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用函数指针注册
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">benchmark</span><span class="o">::</span><span class="n">RegisterBenchmark</span><span class="p">(</span><span class="s">&#34;BM_DemoSleep&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BM_DemoSleep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用Lamba函数注册
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">benchmark</span><span class="o">::</span><span class="n">RegisterBenchmark</span><span class="p">(</span><span class="s">&#34;BM_DemoSleep1&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="n">benchmark</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">_</span> <span class="p">:</span> <span class="n">state</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用带参数的函数指针注册
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">benchmark</span><span class="o">::</span><span class="n">RegisterBenchmark</span><span class="p">(</span><span class="s">&#34;BM_DemoSleep2&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BM_DemoSleep1</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">benchmark</span><span class="o">::</span><span class="n">RunSpecifiedBenchmarks</span><span class="p">();</span> <span class="c1">// 运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">benchmark</span><span class="o">::</span><span class="n">Shutdown</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="3-ref">3. Ref:</h2>
<p>[1]. <a href="https://mp.weixin.qq.com/s/hrKwlKj6i2twd_qNqaHyYg"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/hrKwlKj6i2twd_qNqaHyYg<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://github.com/google/benchmark/blob/main/docs/user_guide.md"target="_blank" rel="external nofollow noopener noreferrer">Google Benchmark 用户手册<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://www.cnblogs.com/apocelipes/p/10348925.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/apocelipes/p/10348925.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
]]></description></item><item><title>CMake 笔记 | [7] 设置语言标准（一）</title><link>https://jianye0428.github.io/posts/cmake_note_7/</link><pubDate>Wed, 17 Jan 2024 09:04:22 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_7/</guid><description><![CDATA[<h2 id="一c--标准历史">一、C ++ 标准历史</h2>
<ul>
<li>1998 年，C++ 标准委员会发布了第一版 C++ 标准，并将其命名为 C++ 98 标准</li>
<li>2011 年，新的 C++ 11 标准诞生，用于取代 C++ 98 标准。此标准还有一个别名，为C++ 0x</li>
<li>2014 年，C++ 14 标准发布，该标准库对 C++ 11 标准库做了更优的修改和更新</li>
<li>2017 年底，C++ 17 标准正式颁布</li>
</ul>
<h2 id="二c-11版本特性介绍">二、C++ 11版本特性介绍</h2>
<p>在 <code>C++ 11</code> 标准之前，<code>C++</code> 标准委员会还在 2003 年对 C++ 98 标准做了一次修改（称为 <code>C++ 03</code> 标准），但由于仅仅修复了一些 <code>C++ 98</code> 标准中存在的漏洞，并未修改核心语法，因此人们习惯将这次修订和 C++ 98 合称为 <code>C++98/03</code> 标准。</p>
<p>以上 3 个标准中，<code>C++ 11</code> 标准无疑是颠覆性的，该标准在 C++ 98 的基础上修正了约 600 个 C++ 语言中存在的缺陷，同时添加了约 140 个新特性，这些更新使得 C++ 语言焕然一新。</p>
<h3 id="21-类型推导之auto和decltype">2.1 类型推导之auto和decltype</h3>
<p>在 <code>C++11</code> 之前的版本中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等。<code>C++11</code> 使用 <code>auto</code> 关键字来支持自动类型推导。</p>
<p>在之前的 <code>C++</code> 版本中，<code>auto</code> 用来指明变量的存储类型，它和 <code>static</code> 是相对的。<code>auto</code> 表示变量是自动存储的，这也是编译器的默认规则，所以写不写都一样，这使得 <code>auto</code> 的存在变得非常鸡肋。</p>
<p><code>C++ 11</code> 赋予 <code>auto</code> 新的含义，用它来做自动类型推导。即，使用 <code>auto</code> 关键字后，编译器会在编译期间自动推导出变量的类型。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li><code>auto</code> 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</li>
<li>使用 <code>auto</code> 类型推导的变量必须马上初始化，因为 <code>auto</code> 在 <code>C++11</code> 中只是占位符，并非如 int 一样的真正的类型声明。</li>
</ul>
</div>
    </div>
  </div>
<p><strong>auto与const的结合使用</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// n 为const int,auto 被推导为int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// f为const int， auto 被推导为int（const属性被抛弃）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// r1为const int &amp;类型，auto被推导为int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// r1为const int&amp;类型，auto 被推导为const int 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>auto</code> 与 <code>const</code> 结合的用法：</p>
<ul>
<li>当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code> 属性；</li>
<li>当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</li>
<li><code>auto</code>的限制：
<ul>
<li>使用<code>auto</code>时必须对变量进行初始化</li>
<li><code>auto</code>不能作为函数的形参</li>
<li><code>auto</code> 不能作用于类的</li>
</ul>
</li>
<li>非静态成员变量中
<ul>
<li><code>auto</code> 关键字不能定义数组</li>
<li>auto 不能作用于模板参数</li>
</ul>
</li>
</ul>
<p><code>decltype</code> 是 <code>C++11</code> 新增的一个关键字，它和 <code>auto</code> 的功能一样，都用来在编译时期进行自动类型推导。<code>decltype</code> 是declare type的缩写，译为声明类型。</p>
<p><code>auto</code> 并不适用于所有的自动类型推导场景，在某些特殊情况下 <code>auto</code> 用起来非常不方便，甚至压根无法使用，所以 <code>decltype</code> 关键字也被引入到 <code>C++11</code> 中。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中，<code>var_name</code> 表示变量名，<code>value</code> 表示赋给变量的值，<code>exp</code> 表示一个表达式。</p>
<p><code>auto</code> 根据=右边的初始值 <code>value</code> 推导出变量的类型，而 <code>decltype</code> 根据 <code>exp</code> 表达式推导出变量的类型，跟=右边的 <code>value</code> 没有关系。</p>
<p><code>auto</code> 要求变量必须初始化，而 <code>decltype</code> 不要求。</p>
<p><code>exp</code> 就是一个普通的表达式，它可以是任意复杂的形式，但是必须要保证 <code>exp</code> 的结果是有类型的，不能是 <code>void</code>；例如，当 <code>exp</code> 调用一个返回值类型为 <code>void</code> 的函数时，<code>exp</code> 的结果也是 <code>void</code> 类型，此时就会导致编译错误。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// b 被推导成了 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// x 被推导成了 double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="mf">10.8</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// y 被推导成了 double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span> <span class="n">y</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>decltype 推导规则</strong></p>
<ul>
<li>如果 <code>exp</code> 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 <code>decltype(exp)</code> 的类型就和 <code>exp</code> 一致。</li>
<li>如果 <code>exp</code> 是函数调用，那么 <code>decltype(exp)</code> 的类型就和函数返回值的类型一致。</li>
<li>如果 <code>exp</code> 是一个左值，或者被<code>括号( )</code>包围，那么 <code>decltype(exp)</code>的类型就是 <code>exp</code> 的引用；假设 <code>exp</code> 的类型为 T，那么 <code>decltype(exp)</code> 的类型就是 T&amp;。</li>
</ul>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；
右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。
有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。</div>
    </div>
  </div>
<p><strong>auto与decltype对 cv 限定符的处理:</strong></p>
<p>cv 限定符是 const 和 volatile 关键字的统称:</p>
<ul>
<li>const 关键字用来表示数据是只读的，也就是不能被修改</li>
<li>volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取</li>
</ul>
<p>在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。其原理见auto与const的结合使用。</p>
<p><strong>auto与decltype对引用(&amp;)的处理:</strong></p>
<p>当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。</p>
<h3 id="22-c-返回值类型后置">2.2 C++ 返回值类型后置</h3>
<p>在泛型编程中，如果需要通过参数的运算来得到返回值的类型：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="n">Add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="o">+</span><span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Add</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码是因为我们并不关心a + b的类型是什么，因此只需要通过decltype(a + b)直接得到返回值类型即可。</p>
<p>上述使用过程十分不方便，因为外部其实并不知道参数之间应该如何运算，只有Add函数知道返回值应该如何推导。</p>
<p>在函数定义上直接通过decltype获取返回值：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">T</span><span class="p">()</span> <span class="o">+</span> <span class="n">U</span><span class="p">())</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法如下：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">))</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码虽然成功地使用 <code>decltype</code> 完成了返回值的推导，但写法过于晦涩，会大大增加<code>decltype</code>在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>因此，在 C++11 中增加了<strong>返回类型后置语法</strong>，将 <code>decltype</code> 和 <code>auto</code> 结合起来完成返回值类型的推导。</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="23-对模板实例化中连续尖括号改进">2.3 对模板实例化中连续尖括号&raquo;改进</h3>
<p>在 C++98/03 的泛型编程中，模板实例化过程中，连续两个右尖括号（&raquo;）会被编译器解释成右移操作符，而不是模板参数表的结束。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//编译出错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Foo</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">type</span> <span class="n">xx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码使用 gcc 编译时，会得到如下错误提示：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">error: ‘&gt;&gt;’ should be ‘&gt;&gt;’ within a nested template argument list Foo&lt;A&gt;::type xx<span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>意思就是，Foo&lt;A<int>&gt;这种写法是不被支持的，要写成这样<code>Foo&lt;A&lt;int&gt; &gt;</code>(注意两个右尖括号之间的空格)。</p>
<p>这种限制是<strong>很没有必要</strong>的。因为在 C++ 的各种成对括号中，目前只有右尖括号连续写两个会出现这种二义性。static_cast、reinterpret_cast 等 C++ 标准转换运算符，都是使用&lt;&gt;来获得待转换类型（type-id）的。若这个 type-id 本身是一个模板，用起来会很不方便。</p>
<p>在 C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出&raquo;是一个右移操作符还是模板参数表的结束标记。</p>
<p><mark>注意：</mark>上述这种自动化的处理在某些时候会与老标准不兼容：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 解决方案：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Foo&lt;(100 &gt;&gt; 2)&gt; xx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Foo</span><span class="o">&lt;</span><span class="mi">100</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">xx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 C++98/03 的编译器中编译是没问题的，但 C++11 的编译器会显示:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">error: expected unqualif?ied-id before ‘&gt;’ token Foo&lt;<span class="m">100</span> &gt;&gt; 2&gt; xx<span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="24-使用using定义别名替代typedef">2.4 使用using定义别名（替代typedef）</h3>
<p>C++可以使用typedef重定义一个类型，被重定义的类型不一定是一个新的类型，也有可能仅仅是原有类型取了一个新的名字。使用typedef重定义类型是很方便的，但它也有一些限制，如无法重定义一个模板等。</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">str_map_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">str_map_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">map_1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，<code>using</code>的别名语法覆盖了<code>typedef</code>的全部功能。</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 重定义unsigned int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uint_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">uint_t</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 重定义std::map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map_int_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">map_int_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重定义模板
</span></span></span><span class="line"><span class="cl"><span class="c1">// C++98/03
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">func_t</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">type</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 func_t 模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">xx_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">func_t</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 func_t 模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">xx_2</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从示例中可以看出，通过 <code>using</code> 定义模板别名的语法，只是在普通类型别名语法的基础上增加 <code>template</code> 的参数列表。使用 <code>using</code> 可以轻松地创建一个新的模板别名，而不需要像 <code>C++98/03</code> 那样使用烦琐的外敷模板。</p>
<h3 id="25-支持函数模板的默认参数">2.5 支持函数模板的默认参数</h3>
<p>在 <code>C++98/03</code> 标准中，<strong>类模板</strong>可以有默认的模板参数:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="n">U</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是不支持函数的默认模板参数：</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// error in C++98/03: default template arguments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用:</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//T = int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。即当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导：</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="n">func</span><span class="p">(</span><span class="n">U</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// R=int, U=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">(</span><span class="mi">97</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// R=char, U=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">97</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// R=double, U=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">97</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数无法推导出来，又未设置其默认值，则编译器直接报错。</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">double</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">val1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">U</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// T=char, U=double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 编译报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="26-在函数模板和类模板中使用可变参数">2.6 在函数模板和类模板中使用可变参数</h3>
<p><strong><font color=red>可变参数</font></strong>，指的是参数的个数和类型都可以是任意的。</p>
<p>对于函数参数而言，C++ 一直都支持为函数设置可变参数，最典型的代表就是 printf() 函数，它的语法格式为:</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">printf</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>...</code>就表示的是可变参数，即 printf() 函数可以接收任意个参数，且各个参数的类型可以不同。</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %c&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %c %f&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通常将容纳多个参数的可变参数称为<strong>参数包</strong>。借助 <code>format</code> 字符串，<code>printf()</code> 函数可以轻松判断出参数包中的参数个数和类型。</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdarg&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//可变参数的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">vair_fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">va_list</span> <span class="n">args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//可变参数有 4 个，分别为 10、20、30、40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">vair_fun</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>想使用参数包中的参数，需要借助<code>&lt;cstdarg&gt;</code>头文件中的 <code>va_start</code>、<code>va_arg</code> 以及 <code>va_end</code> 这 3 个带参数的宏：</p>
<ul>
<li><code>va_start(args, count)</code>：args 是 va_list 类型的变量，可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；</li>
<li><code>va_arg(args, int)</code>：调用 va_start找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回;</li>
<li><code>va_end(args)</code>：不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。</li>
</ul>
<p>使用<code>…</code>可变参数的过程中，需注意以下几点：</p>
<ul>
<li><code>…</code> 可变参数必须作为函数的最后一个参数，且一个函数最多只能拥有 1 个可变参数;</li>
<li>可变参数的前面至少要有 1 个有名参数;</li>
<li>当可变参数中包含 <code>char</code> 类型的参数时，<code>va_arg</code> 宏要以 <code>int</code> 类型的方式读取；当可变参数中包含 <code>short</code> 类型的参数时，<code>va_arg</code> 宏要以 <code>double</code> 类型的方式读取。</li>
</ul>
<p><mark>需要注意的是,</mark> <code>…</code>可变参数的方法仅适用于函数参数，并不适用于模板参数。</p>
<h3 id="27-可变参数模板">2.7 可变参数模板</h3>
<p>C++ 11 标准发布之前，<strong>函数模板</strong>和<strong>类模板</strong>只能设定固定数量的模板参数。<u>C++11 标准对模板的功能进行了扩展，允许模板中包含任意数量的模板参数，这样的模板又称可变参数模板。</u></p>
<p><strong>可变参数函数模板</strong></p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vair_fun</span><span class="p">(</span><span class="n">T</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//函数体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>模板参数中， <code>typename</code>（或者 class）后跟 <code>…</code> 就表明 T 是一个 <font color=red>可变模板参数</font> ，它可以接收多种数据类型，又称 <font color=red>模板参数包</font> 。vair_fun() 函数中，args 参数的类型用 <code>T…</code> 表示，表示 <code>args</code> 参数可以接收任意个参数，又称 <font color=red>函数参数包</font> 。即此函数模板最终实例化出的 vair_fun() 函数可以指定任意类型、任意数量的参数。</p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vair_fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">vair_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vair_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在模板函数内部“解”参数包方法：</p>
<p><mark>方法一：递归方式解包</mark></p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//模板函数递归的出口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">vir_fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vir_fun</span><span class="p">(</span><span class="n">T</span> <span class="n">argc</span><span class="p">,</span> <span class="n">args</span><span class="p">...</span> <span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">argc</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//开始递归，将第一个参数外的 argv 参数包重新传递给 vir_fun
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vir_fun</span><span class="p">(</span><span class="n">argv</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vir_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果：</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="m">1</span>
</span></span><span class="line"><span class="cl">http://www.biancheng.net
</span></span><span class="line"><span class="cl">2.34</span></span></code></pre></td></tr></table>
</div>
</div><p>程序的执行流程</p>
<ul>
<li>首先，<code>main()</code> 函数调用 <code>vir_fun()</code> 模板函数时，根据所传实参的值，可以很轻易地判断出模板参数 <code>T</code> 的类型为 in<code>T</code>，函数参数 <code>argc</code> 的值为 1，剩余的模板参数和函数参数都分别位于 args 和 <code>argv</code> 中；</li>
<li><code>vir_fun()</code> 函数中，首先输出了 <code>argc</code> 的值（为 1），然后重复调用自身，同时将函数参数包 <code>argv</code> 中的数据作为实参传递给形参 <code>argc</code> 和 <code>argv</code>；</li>
<li>再次执行 <code>vir_fun()</code> 函数，此时模板参数 <code>T</code> 的类型为 char*，输出 <code>argc</code> 的值为 <code>http:www.biancheng.net</code>。再次调用自身，继续将 <code>argv</code> 包中的数据作为实参；</li>
<li>再次执行 <code>vir_fun()</code> 函数，此时模板参数 <code>T</code> 的类型为 <code>double</code>，输出 <code>argc</code> 的值为 2.34。再次调用自身，将空的 <code>argv</code> 包作为实参；</li>
<li>由于 <code>argv</code> 包没有数据，此时会调用无任何形参、函数体为空的 <code>vir_fun()</code> 函数，最终执行结束。</li>
</ul>
<p>**注意:**以递归方式解包，一定要设置递归结束的出口。例如本例中，无形参、函数体为空的 vir_fun() 函数就是递归结束的出口。</p>
<p><mark>方法二：非递归方式解包（借助逗号表达式和初始化列表，也可以解开参数包）</mark></p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">dispaly</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vir_fun</span><span class="p">(</span><span class="n">args</span><span class="p">...</span> <span class="n">argv</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 逗号表达式+初始化列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="n">argv</span><span class="p">),</span><span class="mi">0</span><span class="p">)...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vir_fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以<code>{ }</code>初始化列表的方式对数组 <code>arr</code> 进行了初始化， <code>(display(argv),0)…</code> 会依次展开为 <code>(display(1),0)</code>、<code>(display(“http://www.biancheng.net”),0)</code> 和 <code>(display(2.34),0)</code>。</p>
<p>所以，下面的语句是等价的：</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="n">argv</span><span class="p">),</span><span class="mi">0</span><span class="p">)...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">),</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">dispaly</span><span class="p">(</span><span class="mf">2.34</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，每个元素都是一个逗号表达式，以 <code>(display(1), 0)</code> 为例，它会先计算 <code>display(1)</code>，然后将 <code>0</code> 作为整个表达式的值返回给数组，因此 <code>arr</code> 数组最终存储的都是 <code>0</code>。<code>arr</code> 数组纯粹是为了将参数包展开，没有发挥其它作用。</p>
<p><strong>可变参数类模板</strong></p>
<p><code>C++11</code> 标准中，类模板中的模板参数也可以是一个可变参数。<code>C++11</code> 标准提供的 <code>tuple</code> 元组类就是一个典型的可变参数模板类。</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">tuple</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和固定模板参数的类不同，tuple 模板类实例化时，可以接收任意数量、任意类型的模板参数:</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="n">tp0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tp1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tp2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">tp3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">,</span> <span class="s">&#34;http://www.biancheng.net&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="28-引入tuple和lambda">2.8 引入tuple和Lambda</h3>
<p>tuple 的应用场景:</p>
<ul>
<li>当需要存储多个不同类型的元素时，可以使用 tuple；</li>
<li>当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。
具体使用方式请参考《C++标准库》</li>
</ul>
<p><strong>Lambda语法格式</strong></p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">[</span><span class="err">外部变量访问方式说明符</span><span class="p">](</span><span class="err">参数</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">mutable</span> <span class="k">noexcept</span><span class="o">/</span><span class="k">throw</span><span class="p">()</span><span class="o">-&gt;</span><span class="err">返回值类型</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="err">函数体</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>[外部变量访问方式说明符]：[]方括号用于向编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量(外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量)。
<ul>
<li>
<table>
<thead>
<tr>
<th style="text-align:center">外部变量格式</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">空方括号表示当前lambda匿名函数不导入任何外部变量</td>
</tr>
<tr>
<td style="text-align:center">[=]</td>
<td style="text-align:center">只有一个=符合，表示以值传递的方式导入所有外部变量</td>
</tr>
<tr>
<td style="text-align:center">[&amp;]</td>
<td style="text-align:center">只有一个&amp;符号，表示以引用传递的方式导入所有外部变量</td>
</tr>
<tr>
<td style="text-align:center">[val1, val2,&hellip;]</td>
<td style="text-align:center">表示以值传递的方式导入val1、val2等外部变量，同时多个变量之间没有前后次序</td>
</tr>
<tr>
<td style="text-align:center">[&amp;val1, &amp;val2,&hellip;]</td>
<td style="text-align:center">表示以引用传递的方式导入val1、val2等指定的外部变量，多个变量之间没有前后次序</td>
</tr>
<tr>
<td style="text-align:center">[val, &amp;val2,&hellip;]</td>
<td style="text-align:center">以上两种方式还可以混合使用</td>
</tr>
<tr>
<td style="text-align:center">[=, &amp;val1,&hellip;]</td>
<td style="text-align:center">表示除val1以引用传递的方式导入以外，其他外部变量都以值传递的方式导入</td>
</tr>
<tr>
<td style="text-align:center">[this]</td>
<td style="text-align:center">表示以值传递的方式导入当前的this指针</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><strong>(参数)</strong>：和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同()小括号一起省略。</li>
<li><strong>mutable</strong>：此关键字可以省略，如果使用之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。（注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量）。</li>
<li><strong>noexcept/throw()</strong>：可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用throw()可以指定 lambda 函数内部可以抛出的异常类型。（注意，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败）。</li>
<li><strong><code>-&gt;</code>返回值类型</strong>：指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略-&gt; 返回值类型。</li>
<li><strong>函数体</strong>：和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</li>
</ul>
<p><mark>注意:</mark>外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<h3 id="29-列表初始化">2.9 列表初始化</h3>
<p>具体使用方式请参考《C++ Primer Plus》《C++标准库》</p>
<h3 id="210-非受限联合体">2.10 非受限联合体</h3>
<p><strong>POD (Plain Old Data) 类型介绍:</strong>
<code>POD</code>类型一般具有以下几种特征：</p>
<ul>
<li>没有用户自定义的构造函数，析构函数、拷贝构造函数和移动构造函数</li>
<li>不能包含虚函数和虚基类</li>
<li>非静态成员必须声明为public</li>
<li>类中的第一个非静态成员的类型与基类不同</li>
<li>在类或者结构体继承时，满足以下两种情况之一：</li>
<li>派生类中有非静态成员，且只有一个包含静态成员的基类</li>
<li>基类有非静态成员，而派生类没有非静态成员</li>
<li>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说<code>POD</code>类型不能包含非<code>POD</code>类型的数据。</li>
<li>所有建通C语言的数据类型都是<code>POD</code>类型(<code>struct</code>、<code>union</code>等不能违背上述规则)</li>
</ul>
<p><strong>非受限联合体</strong></p>
<p>在 <code>C/C++</code> 中，**<font color=red>联合体</font>**是一种构造数据类型。在一个联合体内，可以定义多个不同类型的成员，这些成员将<u>会共享同一块内存空间</u>。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p>
<p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为**<font color=red>非受限联合体</font>**。</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Student</span><span class="p">(</span><span class="kt">bool</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">gender</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">gender</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">T</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Student</span> <span class="n">s</span><span class="p">;</span>  <span class="c1">// 含有非POD类型的成员，gcc-5.1.0  版本报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。</p>
<table><tr><td bgcolor=yellow>C++ 11改进1:</td></tr></table>
<ul>
<li>C++11允许非POD类型</li>
<li>C++11允许联合体又静态成员(静态成员变量智能在联合体内定义，却不能在联合体外使用)</li>
</ul>
<table><tr><td bgcolor=yellow>非受限联合体的赋值注意事项：</td></tr></table>
<ul>
<li>
<p>C++11规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 构造失败，因为 U 的构造函数被删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">U</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的例子中，因为 <code>string</code> 类拥有自定义的构造函数，所以 <code>U</code> 的构造函数被删除；定义 <code>U</code> 的类型变量 <code>u</code> 需要调用默认构造函数，所以 <code>u</code> 也就无法定义成功。</p>
</li>
<li>
<p>解决上面问题的一般需要用到 <code>placement new</code>:
<code>placement new</code> 是 <code>new</code> 关键字的一种进阶用法，既可以在栈<code>（stack）</code>上生成对象，也可以在堆<code>（heap）</code>上生成对象。相对应地，把常见的<code>new</code>的用法称为 <code>operator new</code>，它只能在 <code>heap</code> 上生成对象。</p>
<p>placement new 的语法格式:</p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">new</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="n">ClassConstruct</span><span class="p">(</span><span class="err">…</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上;
ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p>
<p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span><span class="p">()</span> <span class="p">{</span> <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="n">string</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">U</span><span class="p">()</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="o">~</span><span class="n">string</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>构造时，采用 <code>placement new</code> 将 <code>s</code> 构造在其地址 <code>&amp;s</code> 上，这里 <code>placement new</code> 的唯一作用只是调用了一下 <code>string</code> 类的构造函数。注意，在析构时还需要调用 <code>string</code> 类的析构函数。</p>
</li>
</ul>
<h3 id="211-非受限联合体的匿名声明和枚举式类">2.11 非受限联合体的匿名声明和“枚举式类”</h3>
<p><mark>匿名联合体</mark>是指不具名的联合体（也即没有名字的联合体），定义如下:</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">U</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 此联合体为匿名联合体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">union</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>联合体 <code>U</code> 内定义了一个不具名的联合体，该联合体包含一个 <code>int</code> 类型的成员变量，称这个联合体为匿名联合体。</p>
<p>非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为<code>枚举式类</code>。</p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Student</span><span class="p">(</span><span class="kt">bool</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">gender</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">a</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">gender</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="nc">Type</span> <span class="p">{</span> <span class="n">STUDENT</span><span class="p">,</span> <span class="n">NATIVE</span><span class="p">,</span> <span class="n">FOREIGENR</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="kt">bool</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span> <span class="o">=</span> <span class="n">STUDENT</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">id</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span> <span class="o">=</span> <span class="n">NATIVE</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">?</span> <span class="mi">9</span> <span class="o">:</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">memcpy</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">name</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span> <span class="o">=</span> <span class="n">FOREIGENR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Singer</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Student</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="mi">310217</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singer</span><span class="p">(</span><span class="s">&#34;J Michael&#34;</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="212-for循环基于范围的循环">2.12 for循环(基于范围的循环)</h3>
<p><code>C++ 11</code>标准之前（<code>C++ 98/03</code> 标准），如果要用 <code>for</code> 循环语句遍历一个数组或者容器，只能套用如下结构:</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="err">表达式</span> <span class="mi">1</span><span class="p">;</span> <span class="err">表达式</span> <span class="mi">2</span><span class="p">;</span> <span class="err">表达式</span> <span class="mi">3</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//循环体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>举例:</p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arc</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;http://c.biancheng.net/cplus/11/&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历普通数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">arc</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="n">myvector</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span><span class="n">arc</span><span class="o">+</span><span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历 vector 容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">iter</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>C++ 11</code> 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式:</p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="nl">declaration</span> <span class="p">:</span> <span class="n">expression</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//循环体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>declaration:</mark>表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</p>
<p><mark>expression:</mark>表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arc</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;http://c.biancheng.net/cplus/11/&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历普通数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">arc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;!&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="n">myvector</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">arc</span> <span class="o">+</span> <span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历 vector 容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">myvector</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 新语法格式的 for 循环还支持遍历用{ }大括号初始化的列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><table><tr><td bgcolor=yellow>注意:</td></tr></table>
<ul>
<li>程序中在遍历 <code>myvector</code> 容器时，定义了 <code>auto</code> 类型的 <code>ch</code> 变量，当编译器编译程序时，会通过 <code>myvector</code> 容器中存储的元素类型自动推导出 <code>ch</code> 为 <code>char</code> 类型。注意，这里的 <code>ch</code> 不是迭代器类型，而表示的是 <code>myvector</code> 容器中存储的每个元素。</li>
<li>在输出结果，其中第一行输出的字符串和 <code>!</code> 之间还输出有一个空格，因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 \0（字符串的结束标志）。</li>
</ul>
<table><tr><td bgcolor=yellow>注意:</td></tr></table>
<ul>
<li>在使用新语法格式的 <code>for</code> 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 <code>declaration</code> 参数处定义引用形式的变量。</li>
<li>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">arc</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;abcde&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="n">myvector</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">arc</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历并修改容器中各个字符的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">ch</span> <span class="p">:</span> <span class="n">myvector</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ch</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环遍历输出容器中各个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">myvector</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="213-constexpr验证是否为常量表达式">2.13 constexpr：验证是否为常量表达式</h3>
<p><code>constexpr</code> 是 C++ 11 标准新引入的关键字。</p>
<p>常量表达式，指的就是由多个（≥1）常量组成的表达式。即如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<p>以定义数组为例，数组的长度就必须是一个常量表达式：</p>
<div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误，length是变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 改进： const int length = 6;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="n">length</span><span class="p">]</span></span></span></code></pre></td></tr></table>
</div>
</div><p>程序的执行过程为预处理、编译、汇编和链接四个阶段，具体请参考<a href="https://mp.weixin.qq.com/s?__biz=MzkxMzI5Mjk4Mg==&amp;mid=2247483661&amp;idx=1&amp;sn=0071d0fb2ab4123f54885101382b522a&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">计算机系统漫游(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。大致又可以说由编译、链接、运行这3 个阶段。常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>在实际开发中，判定一个表达式是否为常量表达式方式:</p>
<ul>
<li>人为判定；</li>
<li>C++11 标准还提供有 constexpr 关键字。</li>
</ul>
<p><strong>constexpr修饰普通变量</strong></p>
<p><code>C++11</code> 标准中，定义变量时可以用 <code>constexpr</code> 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>使用 <code>constexpr</code> 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。</p>
<div class="highlight" id="id-43"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">url</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">couts</span><span class="o">&lt;&lt;</span> <span class="n">url</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码中，如果尝试将 constexpr 删除，此时编译器会提示url[num] 定义中 num 不可用作常量。使用 constexpr 修饰 num 变量，同时将 1+2+3 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p><mark>注意:</mark>当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
<p><strong>constexpr修饰函数</strong></p>
<p>这样的函数又称为<code>常量表达式函数</code>。</p>
<p><code>constexpr</code> 并非可以修改任意函数的返回值。必须满足如下条件:</p>
<ul>
<li>整个函数的函数体中，除了可以包含 <code>using</code> 指令、<code>typedef</code> 语句以及<code>static_assert</code>断言外，只能包含一条 <code>return</code> 返回语句。
<div class="highlight" id="id-44"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">display</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 可以添加 using 执行、typedef 语句以及 static_assert 断言
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>该函数必须有返回值，即函数的返回值类型不能是 void</li>
<li>函数在使用之前，必须有对应的定义语句。函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</li>
<li>return 返回的表达式必须是常量表达式</li>
</ul>
<p><mark>注意:</mark>在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的。</p>
<p><strong>constexpr修饰类的构造函数</strong></p>
<p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数:</p>
<div class="highlight" id="id-45"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 自定义类型的定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">MyType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="nf">MyType</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span><span class="o">:</span><span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">){};</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//其它结构体成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="k">struct</span> <span class="nc">MyType</span> <span class="n">mt</span> <span class="p">{</span> <span class="s">&#34;zhangsan&#34;</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mt</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">mt</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark> constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
<p>constexpr 可用于修饰函数，而类中的成员方法完全可以看做是位于类这个命名空间中的函数，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到条件。</p>
<p><mark>注意:</mark> C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
<p><strong>constexpr修饰模板函数</strong></p>
<p>C++11 语法中，<code>constexpr</code> 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p>
<p>针对这种情况下，C++11 标准规定，如果 <code>constexpr</code> 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 <code>constexpr</code> 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p><strong>constexpr与const的区别</strong></p>
<p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达只读语义的场景都使用 const，表达常量语义的场景都使用 constexpr。</p>
<p><code>只读</code>和<code>不允许被修改</code>之间并没有必然的联系</p>
<div class="highlight" id="id-46"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">con_b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">con_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">con_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>程序中用 const 修饰了 con_b 变量，表示该变量只读，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p>
<table><tr><td bgcolor=yellow>在大部分实际场景中，const 和 constexpr 是可以混用的:</td></tr></table>
<div class="highlight" id="id-47"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在某些场景中，必须明确使用 constexpr</p>
<div class="highlight" id="id-48"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">sqr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="nf">sqr2</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 可以，因为sqr1时constexpr函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">sqr1</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mylist1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 不可以，因为sqr2不是constexpr函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">sqr2</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mylist1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="214-long-long超长整形">2.14 long long超长整形</h3>
<p>将 long long 整形写入 C++ 11 标准中，如同 long 类型整数需明确标注 L 或者 l 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p>
<ul>
<li>对于有符号 long long 整形，后缀用 LL 或者 ll 标识。如，10LL 就表示有符号超长整数 10。</li>
<li>对于无符号 long long 整形，后缀用 ULL、ull、Ull 或者 uLL 标识。如，10ULL 就表示无符号超长整数 10；</li>
</ul>
<p><mark>注意:</mark> 如果不添加任何标识，则所有的整数都会默认为 int 类型。</p>
<p>了解当前平台上 long long 整形的取值范围，可以使用<climits>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：</p>
<ul>
<li>LLONG_MIN：代表当前平台上最小的 long long 类型整数；</li>
<li>LLONG_MAX：代表当前平台上最大的 long long 类型整数；</li>
<li>ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）；</li>
</ul>
<div class="highlight" id="id-49"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;long long最大值：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MIN</span> <span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MIN</span> <span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span><span class="s">&#34;long long最小值：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MAX</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">LLONG_MAX</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;unsigned long long最大值：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ULLONG_MAX</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="215-右值引用">2.15 右值引用</h3>
<table><tr><td bgcolor=yellow>C++左值和右值</td></tr></table>
在 C++/C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。
<p><mark>注意：</mark>左值的英文简写为lvalue，右值的英文简写为rvalue。很多人认为它们分别是left value、right value 的缩写。其实不然，lvalue 是loactor value的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 read value，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
<p>通常情况下，判断某个表达式是<code>左值</code>还是<code>右值</code>，最常用的有以下 2 种方法:</p>
<ul>
<li>可位于赋值号(=)左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</li>
<li></li>
</ul>
<div class="highlight" id="id-50"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误，5 不能为左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">5</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// b 是一个左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a、b 都是左值，只不过将 b 可以当做右值使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>有名称的、可以获取到存储地址的表达式即为<code>左值</code>；反之则是<code>右值</code>。</li>
</ul>
<p>以上面定义的变量 <code>a</code>、<code>b</code> 为例，<code>a</code> 和 <code>b</code> 是变量名，且通过 &amp;<code>a</code> 和 &amp;<code>b</code> 可以获得他们的存储地址，因此 <code>a</code> 和 <code>b</code> 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。</p>
<p><strong>右值引用</strong></p>
<p><code>右值引用</code>可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。</p>
<p><code>C++98/03</code> 标准中有引用，使用 <code>&amp;</code> 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。</p>
<div class="highlight" id="id-51"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark> 虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值。</p>
<div class="highlight" id="id-52"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark> <code>C++11</code> 标准中对右值做了更细致的划分，分别称为 <font color=red>纯右值（pure value，简称 pvalue）</font>和 <font color=red>将亡值（expiring value，简称 xvalue ）</font>。其中纯右值就是 C++98/03 标准中的右值，而<u>将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）</u>。对于纯右值和将亡值，都属于右值。</p>
<h3 id="216-移动构造函数的功能和用法">2.16 移动构造函数的功能和用法</h3>
<p><code>右值引用</code>主要用于实现<code>移动（move）语义</code>和<code>完美转发</code>。</p>
<p><strong>完美转发及其实现</strong></p>
<p>C++11 标准为 C++ 引入右值引用语法的同时，还解决了一个 C++ 98/03 标准长期存在的短板，即使用简单的方式即可在函数模板中实现参数的完美转发。</p>
<ol>
<li>
<p><strong><font color=red>完美转发</font></strong>
指的是函数模板可以将自己的参数&quot;完美&quot;地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。如：</p>
<div class="highlight" id="id-53"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述示例中，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。
function() 函数模板并没有实现完美转发。</p>
<ul>
<li>参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；</li>
<li>无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</li>
</ul>
<p>如果使用 C++ 98/03 标准下的 C++ 语言，可以采用函数模板重载的方式实现完美转发，例如：</p>
<div class="highlight" id="id-54"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重载被调用函数，查看完美转发的效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;rvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重载函数模板，分别接收左值和右值
</span></span></span><span class="line"><span class="cl"><span class="c1">// 接收右值参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 接收左值参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 5 是右值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">function</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>  <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// x 是左值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于右值5 来说，它实际调用的参数类型为 const T&amp; 的函数模板，由于 t 为 const 类型，所以 otherdef() 函数实际调用的也是参数用 const 修饰的函数，所以输出“rvalue”；对于左值 x 来说，2 个重载模板函数都适用，C++编译器会选择最适合的参数类型为 T&amp; 的函数模板，进而 therdef() 函数实际调用的是参数类型为非 const 的函数，输出“lvalue”。
使用重载的模板函数实现完美转发也是有弊端的，此方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。
在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：</p>
<div class="highlight" id="id-55"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：</p>
<div class="highlight" id="id-56"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// T 为 int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">function</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// T 为 int &amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">function</span><span class="p">(</span><span class="n">num2</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由 function(num) 实例化的函数底层就变成了 function(int &amp;&amp; t)，同样由 function(num2) 实例化的函数底层则变成了 function(int &amp;&amp; &amp;&amp; t)。C++98/03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：</p>
<ul>
<li>
<p>当实参为左值或者左值引用（A&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; = A&amp;）；</p>
</li>
<li>
<p>当实参为右值或者右值引用（A&amp;&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; = A&amp;&amp;）。</p>
</li>
</ul>
<p><mark>注意：</mark>在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。</p>
<p>将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数方法：<code>引入一个模板函数 forword()</code>:</p>
<div class="highlight" id="id-57"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 重载被调用函数，查看完美转发的效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">otherdef</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;rvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现完美转发的函数模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">otherdef</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">function</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>  <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong><font>移动语义</font></strong>
指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p>
<div class="highlight" id="id-58"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">demo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">demo</span><span class="p">()</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;construct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">demo</span><span class="p">(</span><span class="k">const</span> <span class="n">demo</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">.</span><span class="n">num</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy construct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 移动构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">demo</span><span class="p">(</span><span class="n">demo</span> <span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">num</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="n">d</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;move construct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="o">~</span><span class="n">demo</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;class destruct!&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="o">*</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">demo</span> <span class="nf">get_demo</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">demo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">      <span class="n">demo</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_demo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>demo类的其中一个构造函数(<code>demo(demo &amp;&amp;d)</code>)使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，<code>num</code> 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 <code>d.num</code>，有效避免了“同一块对空间被释放多次”情况的发生。</p>
<p><code>非 const 右值引用</code>只能操作右值，程序执行结果中产生的<code>临时对象</code>（例如函数返回值、lambda 表达式等）既<code>无名称</code>也无法获取其<code>存储地址</code>，所以属于<code>右值</code>。当类中同时包含<code>拷贝构造函数</code>和<code>移动构造函数</code>时，<mark>如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</mark></p>
<p><mark>注意:</mark>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
<p>默认情况下，<code>左值</code>初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则<code>必须使用右值进行初始化</code>。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 <code>std::move()</code> 函数，<font color=red>它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数</font>。</p>
<h3 id="217-move函数将左值转换为右值">2.17 <code>move()</code>函数:将左值转换为右值</h3>
<p>C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>移动构造函数的调用时机是：<code>用同类的右值对象初始化新对象</code>。用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，调用移动构造函数方法：<code>调用 move() 函数</code>。</p>
<p>move 的功能很简单，就是将某个左值强制转化为右值。</p>
<p><strong>引用限定符的用法</strong></p>
<p>首先，我们定义左值的类对象称为左值对象，右值的类对象称为右值对象。</p>
<p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用:</p>
<div class="highlight" id="id-59"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<code>demo</code> 类中的 <code>get_num()</code> 成员函数既可以被 <code>a 左值对象</code>调用，也可以被 <code>move(a)</code> 生成的右值 <code>demo</code> 对象调用，运行程序会输出两个 <code>10</code>。</p>
<p>某些场景中，可能需要限制调用成员函数的对象的类型（<code>左值</code>还是<code>右值</code>），为此 C++11 新添加了<code>引用限定符</code>。所谓引用限定符，就是在成员函数的后面添加 &amp; 或者 &amp;&amp;，从而限制调用者的类型（<code>左值</code>还是<code>右值</code>）。</p>
<div class="highlight" id="id-60"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">()</span><span class="o">&amp;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-61"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">()</span><span class="o">&amp;&amp;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>注意:</mark>引用限定符不适用于静态成员函数和友元函数。</p>
<p><strong>const和引用限定</strong></p>
<p>const 也可以用于修饰类的成员函数，习惯称为<code>常成员函数</code>。</p>
<div class="highlight" id="id-62"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">get_num</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>const</code> 和<code>引用限定符</code>修饰类的成员函数时，都位于函数的末尾。</p>
<p><mark>注意:</mark> <code>C++11</code> 标准规定，当<code>引用限定符</code>和 <code>const</code> 修饰同一个类的成员函数时，const 必须位于引用限定符前面。</p>
<p>当 <code>const &amp;&amp;</code> 修饰类的成员函数时，调用它的对象只能是<code>右值对象</code>；当 <code>const &amp;</code> 修饰类的成员函数时，调用它的对象既可以是<code>左值对象</code>，也可以是<code>右值对象</code>。无论是 <code>const &amp;&amp;</code> 还是 <code>const &amp;</code> 限定的成员函数，内部都不允许对当前对象做修改操作。</p>
<div class="highlight" id="id-63"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span><span class="kt">int</span> <span class="n">num2</span><span class="p">)</span> <span class="o">:</span><span class="n">num</span><span class="p">(</span><span class="n">num</span><span class="p">),</span><span class="n">num2</span><span class="p">(</span><span class="n">num2</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//左值和右值对象都可以调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">get_num</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//仅供右值对象调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">get_num2</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">num2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">demo</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_num2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="217-nullptr初始化空指针">2.17 nullptr：初始化空指针</h3>
<p>实际开发中，避免产生<code>野指针</code>最有效的方法，就是在<u>定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针</u>。</p>
<p><code>野指针</code>，又称<code>悬挂指针</code>，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 <code>&amp;p</code>），极可能导致程序发生异常。</p>
<p>C++98/03 标准中，将一个指针初始化为空指针的方式：</p>
<div class="highlight" id="id-64"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 推荐使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，可以将指针明确指向 <code>0（0x0000 0000）</code>这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。</p>
<p>相比第一种方式，推荐将指针初始化为 NULL。NULL 并不是 C++ 的关键字，它是 C++ 事先定义好的一个<strong>宏</strong>，并且它的值往往就是字面量 <code>0（#define NULL 0）</code>。</p>
<p><code>C++</code> 中将 <code>NULL</code> 定义为字面常量 <code>0</code>，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和预期不符。</p>
<div class="highlight" id="id-65"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;void*c&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;int n&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码都将输出<code>int n</code>。对于 <code>isnull(0)</code> 来说，显然它真正调用的是参数为整形的 <code>isnull()</code> 函数；而对于 <code>isnull(NULL)</code>，我们期望它实际调用的是参数为 <code>void*c</code> 的 <code>isnull()</code> 函数，但程序的执行结果并不符合预期。</p>
<p><code>C++ 98/03</code> 标准中，如果想令 <code>isnull(NULL)</code> 实际调用的是 <code>isnull(void* c)</code>，就需要对 <code>NULL</code>（或者 0）进行强制类型转换：</p>
<div class="highlight" id="id-66"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">isnull</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">NULL</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">isnull</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于 <code>C++ 98</code> 标准使用期间，<code>NULL</code> 已经得到了广泛的应用，出于兼容性的考虑，<code>C++11</code> 标准并没有对 <code>NULL</code> 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，在 <code>C++11</code> 标准中引入一个新关键字，即 <code>nullptr</code>。</p>
<p><code>nullptr</code> 是 <code>nullptr_t</code> <code>类型的右值常量，专用于初始化空类型指针。nullptr_t</code> 是 <code>C++11</code> 新增加的数据类型，可称为<font color=red>指针空值类型</font>。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要完全定义出多个同 nullptr 完全一样的实例对象。<font color=red>nullptr 可以被隐式转换成任意的指针类型</font>。</p>
<p>通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题:</p>
<div class="highlight" id="id-67"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;void*c&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">isnull</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;int n&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">isnull</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="218-智能指针">2.18 智能指针</h3>
<p><code>智能指针</code>，可以从字面上理解为“智能”的指针。具体来讲，<code>智能指针</code>和<code>普通指针</code>的用法是相似的，不同之处在于，<code>智能指针</code><font color=red>可以在适当时机自动释放分配的内存</font>。也就是说，<u>使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现</u>。</p>
<p><code>C++ 智能指针</code>底层是采用<strong>引用计数</strong>的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p>
<p>关于智能指针的具体使用方法，请参考《C++标准库》</p>
<table><tr><td bgcolor=yellow>shared_ptr</td></tr></table>
<p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr（其中 T 表示指针指向的具体数据类型）的定义位于<memory>头文件，并位于 std 命名空间中。</p>
<p><font color=red>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存</font>。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的使用权（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<table><tr><td bgcolor=yellow>unique_ptr</td></tr></table>
<p>unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。</p>
<p>注意：每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
<p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr（T 为指针所指数据的类型）定义在<memory>头文件，并位于 std 命名空间中。</p>
<table><tr><td bgcolor=yellow>weak_ptr</td></tr></table>
<p>和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr（ T 为指针所指数据的类型）定义在<memory>头文件，并位于 std 命名空间中。</p>
<p>C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。</p>
<p>当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。</p>
]]></description></item><item><title>CMake 笔记 | [6] 设置编译选项</title><link>https://jianye0428.github.io/posts/cmake_note_6/</link><pubDate>Tue, 16 Jan 2024 08:11:33 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_6/</guid><description><![CDATA[<h2 id="一编译器选项相关概念">一、编译器选项相关概念</h2>
<p><code>编译器选项</code>是指在编译程序时，可以通过设置不同的选项来控制编译器的行为和生成的代码的特性。常见的编译器选项包括<code>优化选项</code>、<code>调试选项</code>、<code>警告选项</code>、<code>链接选项</code>等。</p>
<ul>
<li><code>优化选项</code>可以控制编译器对代码进行优化的程度，以提高程序的性能。</li>
<li><code>调试选项</code>可以生成调试信息，以便在程序出现问题时进行调试。</li>
<li><code>警告选项</code>可以控制编译器是否生成警告信息，以帮助开发者发现潜在的问题。</li>
<li><code>链接选项</code>可以控制编译器如何将多个目标文件链接在一起，以生成最终的可执行文件。</li>
</ul>
<p>不同的编译器可能支持不同的选项，具体的选项和使用方法可以参考编译器的文档或者官方网站。</p>
<p>本篇内容涉及到的编译器选项有:</p>
<ul>
<li>优化选项: <code>-fPIC</code>、<code>-fno-rtti</code>、<code>-fno exception</code>
<ul>
<li><code>-fPIC</code>:表示生成位置无关代码。具体来说，位置无关代码可以在不同的进程空间中加载和执行，而不需要进行重定位操作。fPIC选项通常用于生成动态库，因为动态库需要在不同的进程空间中加载和执行。使用-fPIC选项可以确保动态库中的代码可以在不同的进程空间中正确地执行。需要注意的是，使用<code>-fPIC</code>选项会增加代码的大小和运行时开销，因此需要根据具体情况来决定是否使用该选项。</li>
<li><code>-fno-rtti</code>: 选项可以控制编译器是否生成与C++运行时类型信息（RTTI）相关的代码，以减小程序的大小和运行时开销。需要注意的是，禁用RTTI可能会影响程序的可靠性和可维护性，因为RTTI可以帮助开发者在运行时获取对象的类型信息。因此，需要根据具体情况来决定是否使用该选项。</li>
<li><code>-fno exception</code>: 表示禁用C++异常处理机制。具体来说，使用该选项可以使编译器不生成与异常处理相关的代码，从而减小程序的大小和运行时开销。需要注意的是，禁用异常处理机制可能会影响程序的可靠性和可维护性，因为异常处理机制可以帮助开发者处理程序中的异常情况。因此，需要根据具体情况来决定是否使用该选项。</li>
</ul>
</li>
<li>警告选项:<code>-Wall</code>、<code>-Wextra</code>和<code>-Wpedantic</code>
<ul>
<li><code>-Wall</code>: 表示开启所有警告信息。具体来说，编译器会生成所有可能的警告信息，包括一些可能会被忽略的警告信息。开启<code>-Wall</code>选项可以帮助开发者发现潜在的问题，提高代码的质量和可靠性。但是，由于<code>-Wall</code>会生成大量的警告信息，有时候会影响开发效率，因此需要根据具体情况来决定是否开启该选项。</li>
<li><code>-Wextra</code>: 表示开启额外的警告信息。具体来说，编译器会生成一些不属于<code>-Wall</code>选项的警告信息，例如一些不符合标准的代码风格、一些未使用的变量等。同理，开启<code>-Wextra</code>选项可以帮助开发者发现更多的潜在问题，提高代码的质量和可靠性。但是，由于<code>-Wextra</code>会生成更多的警告信息，有时候会影响开发效率，因此需要根据具体情况来决定是否开启该选项。</li>
<li><code>-Wpedantic</code>: 表示开启严格的警告信息。具体来说，编译器会生成一些不符合C或C++标准的代码警告信息，例如使用了不推荐的语法、未定义的行为等。开启<code>-Wpedantic</code>选项可以帮助开发者编写符合标准的代码，提高代码的可移植性和可靠性。同理，由于<code>-Wpedantic</code>会生成更多的警告信息，有时候会影响开发效率，因此需要根据具体情况来决定是否开启该选项</li>
</ul>
</li>
</ul>
<h2 id="二编译器选项设置">二、编译器选项设置</h2>
<p>为目标准备了标志列表，其中一些将无法在Windows上使用：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">compile_flags</span> <span class="s2">&#34;-fPIC&#34;</span> <span class="s2">&#34;-Wall&#34;</span> <span class="s2">&#34;-fPIC&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="s">WIN32</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">compile_flags</span> <span class="s2">&#34;-Wextra&#34;</span> <span class="s2">&#34;-Wpedantic&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为库设置编译选项：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">target_compile_options</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PRIVATE</span> <span class="o">${</span><span class="nv">compile_flags</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>编译选项可以添加三个级别的可见性：<code>INTERFACE</code>、<code>PUBLIC</code>和<code>PRIVATE</code>。</p>
<ul>
<li><code>PRIVATE</code>:编译选项会应用于给定的目标，不会传递给与目标相关的目标。</li>
<li><code>INTERFACE</code>:给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。</li>
<li><code>PUBLIC</code>:编译选项将应用于指定目标和使用它的目标。</li>
</ul>
<p><font color=red>如何确定</font>项目在<code>CMake</code>构建时，实际使用了哪些编译标志？</p>
<p>一种方法是，使用CMake将额外的参数传递给本地构建工具。本例中会设置环境变量VERBOSE=1：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir -p build
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">$ cmake ..
</span></span><span class="line"><span class="cl">$ cmake --build . -- <span class="nv">VERBOSE</span><span class="o">=</span><span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">... lots of output ...
</span></span><span class="line"><span class="cl">Scanning dependencies of target test_message
</span></span><span class="line"><span class="cl">make<span class="o">[</span>2<span class="o">]</span>: 离开目录“/home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/build”
</span></span><span class="line"><span class="cl">/usr/bin/make -f message-module/CMakeFiles/test_message.dir/build.make message-module/CMakeFiles/test_message.dir/build
</span></span><span class="line"><span class="cl">make<span class="o">[</span>2<span class="o">]</span>: 进入目录“/home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/build”
</span></span><span class="line"><span class="cl"><span class="o">[</span> 25%<span class="o">]</span> Building CXX object message-module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/build/message-module <span class="o">&amp;&amp;</span> /usr/bin/c++   -I/home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/message-module/include  -O3 -DNDEBUG   -fPIC -Wall -Wextra -Wpedantic -std<span class="o">=</span>gnu++11 -o CMakeFiles/test_message.dir/src/message.cpp.o -c /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/13/message-module/src/message.cpp
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Linking CXX static library ../lib/libtest_message_release.a
</span></span><span class="line"><span class="cl">... lots of output ...</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种，使用CMake参数进行配置：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cmake -D <span class="nv">CMAKE_CXX_FLAGS</span><span class="o">=</span><span class="s2">&#34;-fno-exceptions -fno-rtti&#34;</span> ..</span></span></code></pre></td></tr></table>
</div>
</div><p>这个命令将编译项目，禁用异常和运行时类型标识(RTTI)。</p>
<h2 id="三补充">三、补充</h2>
<p>大多数时候，编译器有特性标示。当前的例子只适用于GCC和Clang；其他编译器不确定是否会理解这些标志。如果项目是真正跨平台，那么这个问题就必须得到解决，以下为两种解决方案：</p>
<p>第一种，所需编译器标志列表附加到每个配置类型CMake变量<code>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</code>。标志确定设置为给定编译器有效的标志，因此将包含在if-endif子句中，用于检查<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>变量：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">GNU</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wsuggest-final-types&#34;</span> <span class="s2">&#34;-Wsuggest-final-methods&#34;</span> <span class="s2">&#34;-Wsuggest-override&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">Clang</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span> <span class="s2">&#34;-Qunused-arguments&#34;</span> <span class="s2">&#34;-fcolor-diagnostics&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wdocumentation&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第二种，定义特定的标志列表：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">COMPILER_FLAGS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">COMPILER_FLAGS_DEBUG</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">COMPILER_FLAGS_RELEASE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">GNU</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wsuggest-final-types&#34;</span> <span class="s2">&#34;-Wsuggest-final-methods&#34;</span> <span class="s2">&#34;-Wsuggest-override&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_ID</span> <span class="s">MATCHES</span> <span class="s">Clang</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS</span> <span class="s2">&#34;-fno-rtti&#34;</span> <span class="s2">&#34;-fno-exceptions&#34;</span> <span class="s2">&#34;-Qunused-arguments&#34;</span> <span class="s2">&#34;-fcolor-diagnostics&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_DEBUG</span> <span class="s2">&#34;-Wdocumentation&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CXX_FLAGS_RELEASE</span> <span class="s2">&#34;-O3&#34;</span> <span class="s2">&#34;-Wno-unused&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>稍后，使用生成器表达式来设置编译器标志的基础上，为每个配置和每个目标生成构建系统:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">target_compile_option</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">  <span class="s">PRIVATE</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CXX_FLAGS</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${CXX_FLAGS_DEBUG}&gt;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${CXX_FLAGS_RELEASE}&gt;&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们推荐使用第二种方法。</p>
<p>两种方法都有效，并在许多项目中得到广泛应用。不过，每种方式都有缺点。<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>不能保证为所有编译器都定义。此外，一些标志可能会被弃用，或者在编译器的较晚版本中引入。</p>
<p>与<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>类似，<code>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</code>变量不能保证为所有语言和供应商都提供定义。尽管检查这些变量的方式非常流行，但我们认为更健壮的替代方法是检查所需的标志集是否与给定的编译器一起工作，这样项目中实际上只使用有效的标志。</p>
]]></description></item><item><title>CMake 笔记 | [5] 构建类型(Debug、Release以及其他)</title><link>https://jianye0428.github.io/posts/cmake_note_5/</link><pubDate>Mon, 15 Jan 2024 12:54:34 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_5/</guid><description><![CDATA[<h2 id="一基本概念构建类型">一、基本概念构建类型</h2>
<p><code>CMake</code>可以识别的构建类型是：</p>
<ul>
<li>Debug：用于在没有优化的情况下，使用带有调试符号构建库或者可执行文件</li>
<li>Release: 用于构建的优化的库或者可执行文件，不包含调试符号</li>
<li>RelWithDebInfo：用于构建较少的优化库或者可执行文件，包含调试符号</li>
<li>MinSizeRel：用于不增加目标代码大小的优化方式，来构建库或者可执行文件</li>
</ul>
<p>控制生成构建系统使用的配置变量是<code>CMAKE_BUILD_TYPE</code>，该变量默认为空。</p>
<p>这里我们仍然选择<a href="https://jianye0428.github.io/posts/cmake_note_3/"target="_blank" rel="external nofollow noopener noreferrer">CMake第三篇—动态库和静态库的补充中的代码<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，但是这里我们对CMakeLists.txt稍作修改。</p>
<h2 id="二项目结构">二、项目结构</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── cmake
</span></span><span class="line"><span class="cl">│   └── message_config.cmake.in
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   ├── message_export_lib.h
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   └── src
</span></span><span class="line"><span class="cl">│       └── message.cpp
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">└── hello_world.cpp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">4</span> directories, <span class="m">9</span> files</span></span></code></pre></td></tr></table>
</div>
</div><p>项目源码: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_5/message_module_lib_standard"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_5/message_module_lib_standard<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="21-message-module模块下的cmakeliststxt">2.1 message-module模块下的CMakeLists.txt</h3>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PUBLIC</span> <span class="s">-DMESSAGE_LIB_SHARED_BUILD</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PRIVATE</span> <span class="s">-DMESSAGE_LIB_EXPORTS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">STATIC</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加别名，以便库可以在构建树中使用，例如在测试时
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">DEBUG_POSTFIX</span> <span class="s2">&#34;_debug&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">RELEASE_POSTFIX</span> <span class="s2">&#34;_release&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.h&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.hpp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILE</span> <span class="s">message_lib.cmake</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">CMakePackageConfigHelpers</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the config file that is includes the exports
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">configure_package_config_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake.in</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">INSTALL_DESTINATION</span> <span class="s2">&#34;lib/cmake/test_message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the version file for the config file
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">write_basic_package_version_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config_version.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">VERSION</span> <span class="s2">&#34;${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">COMPATIBILITY</span> <span class="s">AnyNewerVersion</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">FILES</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">export</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span> <span class="s">FILE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:
这里，我们基本上没有做修改，只添加了以下内容：
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>引用<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">DEBUG_POSTFIX</span> <span class="s2">&#34;_debug&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">RELEASE_POSTFIX</span> <span class="s2">&#34;_release&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这将在 <code>debug</code> 构建模式下将库名后缀设置为 <code>_debug</code>，在 <code>release</code> 构建模式下将库名后缀设置为 <code>_release</code>。
然后，可以使用 <code>test_message_debug</code> 或 <code>test_message_release</code> 来引用库。当然，我们其实可以使用<code>find_package</code>，然后直接使用库的别名<code>test_message</code>即可。</p></div>
    </div>
  </div></p>
<h3 id="22-根目录下的cmakeliststxt">2.2 根目录下的CMakeLists.txt</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Set install direcotory
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="s">CMAKE_BUILD_TYPE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_BUILD_TYPE</span> <span class="s">Release</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;Build type&#34;</span> <span class="s">FORCE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Build type:                                       ${CMAKE_BUILD_TYPE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Debug configuration:                     ${CMAKE_C_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration:                   ${CMAKE_C_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration with Debug info:   ${CMAKE_C_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, minimal Release configuration:           ${CMAKE_C_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Debug configuration:                   ${CMAKE_CXX_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration:                 ${CMAKE_CXX_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration with Debug info: ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, minimal Release configuration:         ${CMAKE_CXX_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，我们添加了以下内容：</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>引用<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="s">CMAKE_BUILD_TYPE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_BUILD_TYPE</span> <span class="s">Release</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;Build type&#34;</span> <span class="s">FORCE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Build type:                                       ${CMAKE_BUILD_TYPE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Debug configuration:                     ${CMAKE_C_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration:                   ${CMAKE_C_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, Release configuration with Debug info:   ${CMAKE_C_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C flags, minimal Release configuration:           ${CMAKE_C_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Debug configuration:                   ${CMAKE_CXX_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration:                 ${CMAKE_CXX_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, Release configuration with Debug info: ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;C++ flags, minimal Release configuration:         ${CMAKE_CXX_FLAGS_MINSIZEREL}&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，检查是否设置了<strong>构建类型</strong>。如果没有，则将构建类型设置为 <code>Release</code>。然后，它使用 <code>message</code> 命令输出各种编译标志，包括 <code>C</code> 和 <code>C++</code> 的 <code>Debug</code> 和 <code>Release</code> 配置，以及最小 <code>Release</code> 配置和<font color=red>带有调试信息的 <code>Release</code></font>配置。这些信息对于调试和优化构建非常有用。</p></div>
    </div>
  </div>
<h3 id="23-验证输出">2.3 验证输出</h3>
<p>我们执行以下命令，这里没有指定构建类型，即默认构建类型为<code>Release</code>。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 7.5.0
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ - skipped
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build type:                                       Release
</span></span><span class="line"><span class="cl">-- C flags, Debug configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration with Debug info:
</span></span><span class="line"><span class="cl">-- C flags, minimal Release configuration:
</span></span><span class="line"><span class="cl">-- C++ flags, Debug configuration:                   -g
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration:                 -O3 -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, minimal Release configuration:         -Os -DNDEBUG
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/build</span></span></code></pre></td></tr></table>
</div>
</div><p>执行<code>make</code>:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span> 25%<span class="o">]</span> Building CXX object message_module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Linking CXX static library ../lib/libtest_message_release.a
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span> 75%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们执行<code>make</code>命令后，生成的库命名为<code>libtest_message_release.a</code>,并将其存入lib目录中。</p>
<p>执行:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make install</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果如下:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world
</span></span><span class="line"><span class="cl">Install the project...
</span></span><span class="line"><span class="cl">-- Install configuration: <span class="s2">&#34;Release&#34;</span>
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/libtest_message_release.a
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include/message_export_lib.h
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include/message.h
</span></span><span class="line"><span class="cl">-- Up-to-date: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_lib.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_lib-release.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_config.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/12/output/lib/cmake/test_message/message_config_version.cmake</span></span></code></pre></td></tr></table>
</div>
</div><p>设置构建类型为debug:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake .. -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug</span></span></code></pre></td></tr></table>
</div>
</div><p>则输出:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 7.5.0
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ - skipped
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build type:                                       Debug
</span></span><span class="line"><span class="cl">-- C flags, Debug configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration:
</span></span><span class="line"><span class="cl">-- C flags, Release configuration with Debug info:
</span></span><span class="line"><span class="cl">-- C flags, minimal Release configuration:
</span></span><span class="line"><span class="cl">-- C++ flags, Debug configuration:                   -g
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration:                 -O3 -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG
</span></span><span class="line"><span class="cl">-- C++ flags, minimal Release configuration:         -Os -DNDEBUG
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/build</span></span></code></pre></td></tr></table>
</div>
</div><p>执行<code>make</code>:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><p>输出如下:</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span> 25%<span class="o">]</span> Building CXX object message_module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Linking CXX static library ../lib/libtest_message_debug.a
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span> 75%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们执行<code>make</code>命令后，生成的库命名为<code>libtest_message_debug.a</code>,并将其存入lib目录中。</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make install</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Consolidate compiler generated dependencies of target test_message
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Built target test_message
</span></span><span class="line"><span class="cl">Consolidate compiler generated dependencies of target hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world
</span></span><span class="line"><span class="cl">Install the project...
</span></span><span class="line"><span class="cl">-- Install configuration: <span class="s2">&#34;Debug&#34;</span>
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/libtest_message_debug.a
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include/message_export_lib.h
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include/message.h
</span></span><span class="line"><span class="cl">-- Up-to-date: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/include
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_lib.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_lib-debug.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_config.cmake
</span></span><span class="line"><span class="cl">-- Installing: /home/yejian/yejian_personal/c++_playground/CMake_Learning_Notes/Note_5/message_module_lib_standard/output/lib/cmake/test_message/message_config_version.cmake</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="三补充">三、补充</h2>
<p><code>Release</code>和<code>Debug</code>在构建项目通常很有用，如评估编译器优化级别的效果。对于单配置生成器，如Unix Makefile、MSYS Makefile或者Ninja，因为要对项目重新配置，这里需要运行CMake两次。</p>
<p>不过，CMake也支持<strong>符合配置生成器</strong>。这些通常是集成开发环境提供的项目文件，最显著的是Visual Studio和XCode，它们可以同时处理多个配置。可以使用CMAKE_CONFIGURATION_TYPES变量对这些生成器的可用配置进行调整。</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir -p build
</span></span><span class="line"><span class="cl"> <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl"> cmake .. -G<span class="s2">&#34;Visual Studio 14 2019 Win64&#34;</span> -D <span class="nv">CMAKE_CONFIGURATION_TYPES</span><span class="o">=</span><span class="s2">&#34;Release;Debug&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将为Release和Debug配置生成一个构建树。然后，您可以使–config标志来决定构建这两个中的哪一个:</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --build . --config Release</span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CMake 笔记 | [4] 条件语句、选项命令以及指定编译器</title><link>https://jianye0428.github.io/posts/cmake_note_4/</link><pubDate>Mon, 15 Jan 2024 09:07:13 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_4/</guid><description><![CDATA[<h2 id="一条件语句">一、条件语句</h2>
<p>首先，我们还是拿我们上一篇根目录下的CMakeLists.txt文件进行讲解。</p>
<p>源码地址为：https://gitee.com/jiangli01/tutorials/tree/master/cmake-tutorial/chapter1/11</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Set install direcotory
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，我们使用了一个条件语句<code>if()...endif()</code>和一个选项命令<code>option</code>。这一节我们先对条件语句<code>if()...endif()</code>进行讲解，关于选项<code>option</code>命令，将在下一节进行讲解。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>判断CMake自带的宏<code>CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</code>有没有处于开启状态，如果是默认状态的话，则<code>CMAKE_INSTALL_PREFIX</code>将被设置为<code>${CMAKE_SOURCE_DIR}/output/</code>。</p></div>
    </div>
  </div>
<p>这里，我们只写一个<code>CMakeLists.txt</code>对条件语句<code>if()...else()</code>和宏<code>CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</code>、<code>CMAKE_INSTALL_PREFIX</code>进行探索。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">condition</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;CMAKE_INSTALL_PREFIX is &#34;</span> <span class="o">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们对<code>CMAKE_INSTALL_PREFIX</code>提前进行了定义</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">condition</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span> <span class="s">off</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/test</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;CMAKE_INSTALL_PREFIX is &#34;</span> <span class="o">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二命令选项">二、命令选项</h2>
<p>当然，上述内容我们也可以在编译时，使用如下命令，而不用显式地在<code>CMakeLists.txt</code>中对<code>CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</code>进行设置，但我们需要在<code>CMakeLists.txt</code>中添加<code>option</code>命令。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">condition</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span> <span class="s2">&#34;Set default install path&#34;</span> <span class="s">off</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/test</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;CMAKE_INSTALL_PREFIX is &#34;</span> <span class="o">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake .. -DCMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT<span class="o">=</span>OFF</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，-D开关用于为CMake设置任何类型的变量：逻辑变量、路径等等。</p>
<p>源码地址: <a href="https://gitee.com/jiangli01/tutorials/tree/master/cmake-tutorial/chapter1/11"target="_blank" rel="external nofollow noopener noreferrer">https://gitee.com/jiangli01/tutorials/tree/master/cmake-tutorial/chapter1/11<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="三指定编译器">三、指定编译器</h2>
<p>到目前为止，我们还没有考虑过使用CMake如何选择编译器。<code>CMake</code>可以根据平台和生成器选择编译器，还能将编译器标志设置为默认值。</p>
<p>在实际工作中，指定编译器十分重要，比如我们要交叉编译嵌入式的项目，亦或是我们可以将<code>Qt</code>、<code>OpenCV</code>等三方库交叉编译到我们的嵌入式项目中。具体关于如何编译其他三方库生成指定的形式，我们将在之后讲到交叉编译时会详细讲解。</p>
<h3 id="31-通过命令行的形式指定">3.1 通过命令行的形式指定</h3>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake -D <span class="nv">CMAKE_CXX_COMPILER</span><span class="o">=</span>clang++ ..</span></span></code></pre></td></tr></table>
</div>
</div><p>指定<code>c++</code>的编译器为<code>clang++</code></p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CMAKE_CXX_COMPILER 指定C++编译器
</span></span><span class="line"><span class="cl">CMAKE_C_COMPILER 指定C编译器
</span></span><span class="line"><span class="cl">CMAKE_Fortran_COMPILER 指定Fortran编译器</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="32-通过导出环境变量指定">3.2 通过导出环境变量指定</h3>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">env <span class="nv">CXX</span><span class="o">=</span>clang++ cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>导出环境变量，指定C++的编译器为Clang++</p>
<p><code>CXX</code>(<code>C++</code>编译器)、<code>CC</code>(C编译器)和<code>FC</code>(Fortran编译器)</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>引用<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>注意: CMake了解运行环境，可以通过-D开关或者环境变量设置许多选项。第一种方法覆盖第二种方法，但是建议使用-D的显式设置选项。显式由于隐式，因为环境变量可能被设置为不合适的值（当前项目）。
注意: 这里，我们假设，其他的编译器，如clang++在标准的路径中可以用，CMake可以在标准路径中执行查找编译器。如果在标准路径中不可以用使用，则用户需要将完整的编译器可执行文件或者包装器路径传递给CMake。如：</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake -D <span class="nv">CMAKE_CXX_COMPILER</span><span class="o">=</span>/mnt/usr/bin/clang++ ..</span></span></code></pre></td></tr></table>
</div>
</div><p>注意: 这里，建议使用<code>-DCMAKE_&lt;LANG&gt;_COMPILER</code>选项设置编译器，而不是导出CXX、CC和FC。这是确保跨平台并与非POSIX兼容的唯一方法。为了避免变量污染环境，这些变量会影响与项目一起构建的外部库环境。</p>
</div>
    </div>
  </div>
<h3 id="33-在cmake中指定">3.3 在CMake中指定</h3>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER</span> <span class="s">/mnt/usr/bin/clang++</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在使用CMake进行构建时，CMake会进行一系列的平台测试，以确定哪些编译器可以使用以及它们是否适合当前的项目。</p>
<p>一个合适的编译器不仅取决于我们使用的平台，还取决于我们想要的生成器。CMake执行的第一个测试基于项目语言的编译器名称。如，CC是一个工作i的C编译器，那么它将用作C项目的默认编译器。</p>
<p>GNU/Linux上，使用Unix Makefile或Ninja时，GCC家族中的编译器很可能是C++、C和Fortran的默认选择。Windows上，将选择Visual Studio中C++和C编译器。如果选择MinGW或MSYS Makefile作为生成器，则默认使用MinGW编译器。</p>
<h3 id="34-编译器的补充">3.4 编译器的补充</h3>
<p>我们平台上的CMake可以找到可用的编译器和编译器标志的方法是：<code>CMake</code>提供<code>--system-information</code>标志，他将把关于系统的所有信息转储到屏幕或者文件中。</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --system-information information.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中可以看到<code>CMAKE_CXX_COMPILER</code>、<code>CMAKE_C_COMPILER</code>和<code>CMAKE_Fortran_COMPILER</code>的默认值，以及默认标志。</p>
<p>CMake提供了额外的变量来与编译器交互：</p>
<ul>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_LOADED</code>:如果为项目启用了语言<LANG>，则将设置为TRUE。</li>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>:编译器标识字符串，编译器供应商所特有。例如，GCC用于GNU编译器集合，AppleClang用于macOS上的Clang, MSVC用于Microsoft Visual Studio编译器。注意，不能保证为所有编译器或语言定义此变量。</li>
<li><code>CMAKE_COMPILER_IS_GNU&lt;LANG&gt;</code>:如果语言<LANG>是GNU编译器集合的一部分，则将此逻辑变量设置为TRUE。注意变量名的<LANG>部分遵循GNU约定：C语言为CC, C++语言为CXX, Fortran语言为G77。</li>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</code>:此变量包含一个字符串，该字符串给定语言的编译器版本。版本信息在major[.minor[.patch[.tweak]]]中给出。但是，对于CMAKE_<LANG>_COMPILER_ID，不能保证所有编译器或语言都定义了此变量。</li>
</ul>
<p>我们可以使用不同的编译器，构建下面的CMakeLists.txt。</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">recipe-06</span> <span class="s">LANGUAGES</span> <span class="s">C</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C++ compiler loaded? ${CMAKE_CXX_COMPILER_LOADED}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_CXX_COMPILER_LOADED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C++ compiler ID is: ${CMAKE_CXX_COMPILER_ID}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C++ from GNU? ${CMAKE_COMPILER_IS_GNUCXX}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C++ compiler version is: ${CMAKE_CXX_COMPILER_VERSION}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C compiler loaded? ${CMAKE_C_COMPILER_LOADED}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_C_COMPILER_LOADED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C compiler ID is: ${CMAKE_C_COMPILER_ID}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Is the C from GNU? ${CMAKE_COMPILER_IS_GNUCC}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;The C compiler version is: ${CMAKE_C_COMPILER_VERSION}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CMake 笔记 | [3] 静态库和动态的补充</title><link>https://jianye0428.github.io/posts/cmake_note_3/</link><pubDate>Sun, 14 Jan 2024 09:46:26 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_3/</guid><description><![CDATA[<h2 id="一导言">一、导言</h2>
<p>对CMake在不同平台上构建动态库和静态库做进一步的探索，即如何利用一个比较统一的模板在不同的平台构建静态库和动态库，以及对add_library命令的其他参数做进一步的探索。</p>
<h2 id="二库模板">二、库模板</h2>
<h3 id="21-项目结构">2.1 项目结构</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── cmake
</span></span><span class="line"><span class="cl">│  └── message_config.cmake.in
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │  ├── message_export_lib.h
</span></span><span class="line"><span class="cl">│   │  └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>本项目的结构相对比较复杂，为了能够生成一套比较标准的库（静态库/动态库），所以项目中会包含很多配置项，接下来我们会对项目中的所有内容进行一一讲解。</p>
<h3 id="22">2.2</h3>
<p>根目录下的CMakeLists.txt</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># Set install direcotory
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">option</span><span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span> <span class="s2">&#34;Specifies the type of libraries (SHARED or STATIC) to build&#34;</span> <span class="s">OFF</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，我们提供了在执行<code>cmake</code>命令时的参数选项，默认默认情况下<code>BUILD_SHARED_LIBS</code>的状态是关闭的(OFF)，即默认情况下我们默认构建的是静态库。</p>
<p>当我们要构建动态库时，我们需执行以下命令（假设你已经在项目中构建了build文件夹,并且你现在在build目录中）</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake .. -DBUILD_SHARED_LIBS<span class="o">=</span>ON</span></span></code></pre></td></tr></table>
</div>
</div></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们没有指定在<code>make install</code>后的输出路径，则<code>CMAKE_INSTALL_PREFIX</code> 将设置为<code>${CMAKE_SOURCE_DIR}/output/</code>，即当前项目下的<code>output</code>目录。</p></div>
    </div>
  </div>
<h3 id="23-cmake目录下的message_configcmakein">2.3 cmake目录下的message_config.cmake.in</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">@PACKAGE_INIT@
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span> <span class="p">(</span> <span class="s2">&#34;${CMAKE_CURRENT_LIST_DIR}/message_config.cmake&#34;</span> <span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了能够生成一个标准的库，我们写了一个<code>message_config.cmake.in</code>文件，该文件执行<code>make install</code>时将被调用，调用时我们再进行讲解。</p>
<h3 id="24-message-module下message_export_libh">2.4 message-module下message_export_lib.h</h3>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_EXPORT_LIB_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_EXPORT_LIB_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef MESSAGE_LIB_SHARED_BUILD
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#ifdef MESSAGE_LIB_EXPORTS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="cp">#define MESSAGE_LIB_API __declspec(dllexport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="cp">#define MESSAGE_LIB_API __declspec(dllimport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#endif  </span><span class="c1">// MESSAGE_LIB_EXPORTS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="cp">#define MESSAGE_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#endif  </span><span class="c1">// _WIN32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#define MESSAGE_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// MESSAGE_LIB_SHARED_BUILD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_EXPORT_LIB_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先，如果我们定义了宏定义<font color=red><code>MESSAGE_LIB_SHARED_BUILD</code></font>(即我们要构建动态库时)，我们将执行以下命令：如果是<code>Windows</code>平台，并且是在生成动态库时，即定义了(MESSAGE_LIB_EXPORTS)，将<code>__declspec(dllexport)</code>定义为<code>MESSAGE_LIB_API</code>；如果是使用动态库时，即未定义(MESSAGE_LIB_EXPORTS)，则将<code>__declspec(dllimport)</code>定义为<code>MESSAGE_LIB_API</code>。如果是非Windows平台，则对宏MESSAGE_LIB_API不做任何操作(因为在非Windows平台上可以动态库的生成和使用与静态库是一样的)。</p>
<p>然后，如果我们未定义宏定义MESSAGE_LIB_SHARED_BUILD(即我们要构建静态库时)，我们对宏MESSAGE_LIB_API不做任何操作。</p>
<p>注意：关于宏定义MESSAGE_LIB_SHARED_BUILD和MESSAGE_LIB_EXPORTS是否要添加利用message-module下的CMakeLists.txt进行配置。</p>
<h3 id="25-message-module下messageh">2.5 message-module下message.h</h3>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message_export_lib.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">MESSAGE_LIB_API</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们将头文件<code>message_export_lib.h</code>包含进来，来控制在不同平台生成不同的库时的选项。</p>
<h3 id="26-message-module下的cmakeliststxt">2.6 message-module下的CMakeLists.txt</h3>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">BUILD_SHARED_LIBS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PUBLIC</span> <span class="s">-DMESSAGE_LIB_SHARED_BUILD</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">target_compile_definitions</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PRIVATE</span> <span class="s">-DMESSAGE_LIB_EXPORTS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">STATIC</span> <span class="o">${</span><span class="nv">SOURCE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加别名，以便库可以在构建树中使用，例如在测试时
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.h&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.hpp&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILE</span> <span class="s">message_lib.cmake</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">CMakePackageConfigHelpers</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the config file that is includes the exports
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">configure_package_config_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake.in</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">INSTALL_DESTINATION</span> <span class="s2">&#34;lib/cmake/test_message&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># generate the version file for the config file
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">write_basic_package_version_file</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;${CMAKE_SOURCE_DIR}/cmake/message_config_version.cmake&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">VERSION</span> <span class="s2">&#34;${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">COMPATIBILITY</span> <span class="s">AnyNewerVersion</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">FILES</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span>
</span></span><span class="line"><span class="cl">    <span class="s">DESTINATION</span> <span class="s">lib/cmake/test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">export</span><span class="p">(</span><span class="s">EXPORT</span> <span class="s">message_export_target</span> <span class="s">FILE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/cmake/message_config_version.cmake</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们让宏<code>BUILD_SHARED_LIBS</code>为开启状态(即我们要构建动态库)，我们要将宏定义<code>MESSAGE_LIB_SHARED_BUILD</code>和<code>MESSAGE_LIB_EXPORTS</code>添加到编译器中，这样我们的头文件<code>message_export_lib.h</code>中便知道我们要构建<strong>动态库</strong>。</p>
<p>否则(即我们没有让BUILD_SHARED_LIBS开启)，我们将构建<strong>静态库</strong>。</p>
<p>利用<code>CMakePackageConfigHelpers</code>模块生成关于<code>test_message</code>库的cmake的配置文件，且可以使用命令<code>find_package</code>命令找到库<code>test_message</code>库。关于以上命令的具体参数使用，我们将在具体的命令学习章节进行具体的讲解和学习。</p>
<h2 id="三add_library其他参数的一些探索">三、add_library其他参数的一些探索</h2>
<h3 id="31-生成对象库">3.1 生成对象库</h3>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.5</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">recipe-03</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-objs</span>
</span></span><span class="line"><span class="cl">    <span class="s">OBJECT</span>
</span></span><span class="line"><span class="cl">        <span class="s">Message.hpp</span>
</span></span><span class="line"><span class="cl">        <span class="s">Message.cpp</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># this is only needed for older compilers
</span></span></span><span class="line"><span class="cl"><span class="c"># but doesn&#39;t hurt either to have it
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">message-objs</span>
</span></span><span class="line"><span class="cl">    <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">        <span class="s">POSITION_INDEPENDENT_CODE</span> <span class="s">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-shared</span>
</span></span><span class="line"><span class="cl">    <span class="s">SHARED</span>
</span></span><span class="line"><span class="cl">        <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-static</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">        <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">hello-world.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">message-static</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了保证编译的目标文件与生成位置无关，可以通过使用set_target_properties命令，设置message-objs目标的相应属性来实现。</p>
<p>**注意:**可能在某些平台和/或使用较老的编译器上，需要显式地为目标设置<code>POSITION_INDEPENDENT_CODE</code>属性。</p>
<p>现在，可以使用这个对象库来获取静态库(message-static)和动态库(message-shared)。要注意引用对象库的生成器表达式语法:$&lt;TARGET_OBJECTS:message-objs&gt;。生成器表达式是CMake在生成时(即配置之后)构造，用于生成特定于配置的构建输出。</p>
<h3 id="32-将静态库和动态库同时命名为同名的两个库">3.2 将静态库和动态库同时命名为同名的两个库</h3>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-shared</span>
</span></span><span class="line"><span class="cl">  <span class="s">SHARED</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">message-shared</span>
</span></span><span class="line"><span class="cl">    <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">        <span class="s">OUTPUT_NAME</span> <span class="s2">&#34;message&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">message-static</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">        <span class="o">$&lt;</span><span class="nv">TARGET_OBJECTS:message-objs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">message-static</span>
</span></span><span class="line"><span class="cl">    <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">        <span class="s">OUTPUT_NAME</span> <span class="s2">&#34;message&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>CMake 笔记 | [2] 多目录多文件的CMake构建方式</title><link>https://jianye0428.github.io/posts/cmake_note_2/</link><pubDate>Fri, 12 Jan 2024 15:16:22 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_2/</guid><description><![CDATA[<h3 id="一项目结构">一、项目结构</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── include
</span></span><span class="line"><span class="cl">│   └── message.h
</span></span><span class="line"><span class="cl">├── src
</span></span><span class="line"><span class="cl">│   └── message.cpp
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>项目结构是为了让我们开发人员对项目更加清晰，使代码结构更加清晰（模块化）。一般我们的项目比较简单时，可以构建为如上的项目结构。但是在构建大型项目时，项目结构会更加复杂，具体请参考下节内容。</p>
<p>这里我们构建了include目录和src目录，include目录主要存放的是CPP文件的头文件，即函数的声明，为使用它的文件提供API。src目录主要是存放的函数的具体实现。</p>
<blockquote>
<p>源码地址:</p>
</blockquote>
<h3 id="二messageh">二、message.h</h3>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="三messagecpp">三、message.cpp</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="四hello_worldcpp">四、hello_world.cpp</h3>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span> <span class="n">message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="s">&#34;Hello, CMake World!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="s">&#34;Goodbye, CMake World!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="五cmake文件">五、CMake文件</h3>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong></p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将<code>include</code>目录下的所有文件包含进来，这样include目录下的message.h将会被包含到整个项目中。如果我们在细分目录中使用包含某一模块的头文件，我们可以在具体模块的CMakeLists.txt中使用该命令，且要包含的头文件的可见性只有该模块，其他模块不可见，具体使用方法，请参考下节内容。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-43"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果<code>include</code>目录和<code>src</code>目录中有多个头文件和源文件，使用如上命令可以将所有头文件集合到HEADER和SOURCE自定义宏定义中，使用时的命令为<code>${HEADER}</code>和<code>${SOURCE}</code>。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-44"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这将结合<code>include</code>目录下的文件和src目录下的文件以及<code>hello_world.cpp</code>生成名为<code>hello-world</code>的可执行文件。</p></div>
    </div>
  </div>
<h3 id="六构建及编译">六、构建及编译</h3>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>构建过程:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/02/build</span></span></code></pre></td></tr></table>
</div>
</div><p>构建可执行文件并输出:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Scanning dependencies of target hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span> 33%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 66%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>上一篇我们没有讲将执行cmake命令后生成的MakeFile文件，其如何构建出可执行文件的具体操作，只是简单的说MakeFile需要make命令执行。</p>
<p>在我们执行完cmake ..后，将生成MakeFile文件，然后执行make后便可以生成可执行文件。</p>
<p>这里我们进行补充说明：如果我们在GNU/Linux上，执行CMake ..后会生成MakeFile文件，然后执行make命令即可生成可执行文件；在Windows上，执行cmake ..后会生成sln文件，需要使用VS进行打开，然后对其进行生成操作。Windows生成sln文件后的具体操作过程请参考最后一些补充内容。除此之外，我们可以执行以下命令，不分平台直接构建出可执行文件:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --build .</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="七静态库和动态库简介">七、静态库和动态库简介</h3>
<p>首先，如果对程序的生命周期的不清楚，请先移步<a href="https://mp.weixin.qq.com/s?__biz=MzkxMzI5Mjk4Mg==&amp;mid=2247483658&amp;idx=1&amp;sn=70144d3480b23fe13f447e3ef715a6a9&amp;chksm=c17eaad3f60923c50560d65017f44bff5e95b79765d4fce5e3f0f2f586c95799d1d671c4d945&amp;token=1465071518&amp;lang=zh_CN&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>进行学习。</p>
<h4 id="71-静态库">7.1 静态库</h4>
<p>在链接阶段，会将汇编生成的目标文件<code>.o</code>与引用到的库<strong>一起链接打包到可执行文件中</strong>。这个链接方式为<strong>静态链接</strong>，所需要的.o（unix系统）称为静态库。</p>
<ul>
<li>静态库对函数库的链接是放在编译时期完成的。</li>
<li>程序在运行时与函数库再无瓜葛，移植方便。</li>
<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接成一个可执行文件。</li>
<li>静态库对程序的更新、部署和发布会带来麻烦。如果静态库libxxx.o更新了，所有使用它的应用程序都需要重新编译、发布给用户。</li>
</ul>
<h4 id="72-动态库">7.2 动态库</h4>
<p>动态库在程序编译时并不会链接到目标代码中，而是<strong>在程序运行时才被载入</strong>。不同的应用程序如果调用相同的库，那么在内存只需要有一份该共享库的实例，规避了空间浪费。</p>
<p>动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的问题，用户只需要更新动态库即可，增量更新。</p>
<p>Windows与Linux执行文件格式不同，在创建动态库的时候有一些差异：</p>
<ul>
<li>在Windows系统下的执行文件格式是PE格式，动态库需要一个DllMain函数做初始化的入口，通常在导出函数的声明时需要有_declspec(dllexport)关键字。</li>
<li>Linux下gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便</li>
</ul>
<h3 id="八构建和链接静态库">八、构建和链接静态库</h3>
<h4 id="81-项目结构">8.1 项目结构</h4>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>在实际的项目开发过程中，我们的项目结构往往会由很多个模块组成，每个模块通过一个单独的CMakeLists.txt去控制，最后在根目录下的CMakeLists.txt中将各个模块组合使用。</p>
<p>本项目中为了简化学习，只构建了一个message-module模块，构建多个模块的方式同理。其中项目中的所有CPP源文件与第一节内容相同，这里就不展开描述了。</p>
<p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_static_lib</p>
<h4 id="82-message-module目录下的cmakelists">8.2 message-module目录下的CMakeLists</h4>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-45"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_library</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">STATIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">HEADER</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>add_library</code>生成必要的构建指令，将指定的源码编译到库中。第一个参数是目标名。整个项目中，可使用相同的名称来引用库。生成的库的实际名称将由CMake通过在前面添加前缀lib和适当的扩展名作为后缀来形成。生成库是根据第二个参数(STATIC或SHARED)和操作系统确定的，本项目是将目标文件生成静态库。</p></div>
    </div>
  </div></p>
<h4 id="83-根目录下的cmakelists">8.3 根目录下的CMakeLists</h4>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置静态库到lib文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIB_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span>  <span class="o">${</span><span class="nv">LIB_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong></p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-46"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置静态库到lib文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIB_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span>  <span class="o">${</span><span class="nv">LIB_FILE</span><span class="o">}</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在构建项目时，我们为了使得项目结构更加清晰，使得生成的可执行文件、静态库以及动态库等文件能够存放在合适的位置。这样的构建方式有助于我们在项目重构、项目优化、debug的时候逻辑更加清晰。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-47"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个命令同第一节内容，因为hello_world.cpp要使用message-module模块的API，且与该CMakeLists.txt在相同层级的目录，所以需要将message-module模块的API包含进去。</p></div>
    </div>
  </div>
<p>如果hello_world.cpp中使用到了多个模块，则此处可以包含多个模块的API：</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/xxx-module/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-48"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_subdirectory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将我们的message-module添加进来进行编译，这个函数命令将寻找message-module目录下的CMakeLists.txt，如果该目录下没有CMakeLists.txt将报错。</p></div>
    </div>
  </div>
<p>由于在本项目中，hello_world.cpp要使用message-module模块中编译生成的静态库，所以add_subdirectory命令将message-module添加到项目中, add_subdirectory的顺序必须要先于add_executable命令。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-49"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>add_executable</code>命令将<code>hello_world.cpp</code>编译成可执行文件，其名字为项目名称<code>hello-world</code>，该可执行文件使用<code>target_link_libraries</code>命令将<code>message-module</code>模块下编译生成的静态库<code>test_message</code>链接到可执行文件中。</p>
<p>注意：在子模块message-module中编译生成的test_message是全局可见的，即任何模块或者根目录下的CMakeLists.txt都可以直接使用test_message进行调用。</p>
</div>
    </div>
  </div>
<h4 id="84-构建以及编译">8.4 构建以及编译</h4>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>构建及编译过程:</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/03/build</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># cmake --build .</span>
</span></span><span class="line"><span class="cl">make</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Scanning dependencies of target test_message
</span></span><span class="line"><span class="cl">[ 25%] Building CXX object message-module/CMakeFiles/test_message.dir/src/message.cpp.o
</span></span><span class="line"><span class="cl">[ 50%] Linking CXX static library ../lib/libtest_message.a
</span></span><span class="line"><span class="cl">[ 50%] Built target test_message
</span></span><span class="line"><span class="cl">Scanning dependencies of target hello-world
</span></span><span class="line"><span class="cl">[ 75%] Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl">[100%] Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl">[100%] Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过编译日志看到，首先编译了<code>message-module</code>模块，并将编译生成的<code>libtest_message.a</code>存档到了<code>../lib/</code>，即build文件夹中的lib目录中。然后链接<code>hello-world</code>所需要的依赖项，此时便将<code>test-message</code>链接到了<code>hello-world</code>中，最终生成可执行文件<code>hello-world</code>，并将其存放到<code>bin</code>目录中，即build文件夹下的bin目录。</p>
<h3 id="九只链接链接三方库静态">九、只链接链接三方库（静态）</h3>
<p>我们在构建实际项目过程中，一个项目往往需要链接许多的三方库，抑或是我们将自己的算法以静态库的形式发布，通常需要为我们的项目链接三方库。本节讲其中的一种，后续涉及到三方库的链接将讲述所有链接的方式。关于<code>third-party</code>模块下<code>include</code>文件夹下的<code>message.h</code>头文件与前面相同，lib文件夹下的<code>libtest_message.a</code>是第三节编译生成的静态库。</p>
<h4 id="91-项目结构">9.1 项目结构</h4>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── third-party
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   └── lib
</span></span><span class="line"><span class="cl">│       └── libtest_message.a
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>一般，我们将三方库放到项目中一个<code>third-party</code>的文件夹下，当然你也可以随意命名。三方库<code>third-party</code>中包含<code>include</code>和<code>lib</code>分别存放三方库的API和静态库。</p>
<p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_static_lib_third_party</p>
<h4 id="92-cmakeliststxt">9.2 CMakeLists.txt</h4>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/libtest_message.a</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">TEST_MESSAGE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-50"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/libtest_message.a</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将三方库中的静态库定义为TEST_MESSAGE，方便后续使用${TEST_MESSAGE}进行调用。当然你也可以直接在target_link_libraries命令中使用${CMAKE_SOURCE_DIR}/third-party/lib/libtest_message.a进行链接，但是这么做是不推荐的。如果多个模块都使用到了该库，那么定义为宏的方式更加方便和清晰。</p>
<p>今后，我们都将定义出来的宏统一采用了大写，意和CMake自身变量命名对其。</p>
</div>
    </div>
  </div>
<h4 id="93-构建及编译">9.3 构建及编译</h4>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>构建及编译过程:</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/04/build</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --build .</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Scanning dependencies of target hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span> 50%<span class="o">]</span> Building CXX object CMakeFiles/hello-world.dir/hello_world.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX executable bin/hello-world
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target hello-world</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="十编译和连接动态库">十、编译和连接动态库</h3>
<p>动态库的编写需要区分平台，在GNU/Linux平台上，动态库的编写和调用与静态库没有差别，但是在Windows平台上动态库的编写和调用需要做一定的修改。</p>
<h4 id="101-gnulinux平台上动态库的编译和链接">10.1 GNU/Linux平台上动态库的编译和链接</h4>
<p>在GNU/Linux上生成动态库的方法和静态库生成的方法类似，其目录结构等都与静态库相同，只有在使用<code>add_library</code>命令时，参数<code>STATIC</code>改为<code>SHARE</code>即可,相关项目结构和<code>CMakeLists.txt</code>如下。</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>源码地址: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>配置动态库的<code>CMakeLists.txt</code>:</p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake_minimum_required<span class="o">(</span>VERSION 3.10 FATAL_ERROR<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">project<span class="o">(</span>hello-world LANGUAGES CXX<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 设置可执行文件到bin文件夹下</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>EXECUTE_FILE <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/bin<span class="o">)</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="si">${</span><span class="nv">EXECUTE_FILE</span><span class="si">}</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 设置动态库到lib文件夹下</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>LIB_FILE <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/lib<span class="o">)</span>
</span></span><span class="line"><span class="cl">set<span class="o">(</span>CMAKE_LIBRARY_OUTPUT_DIRECTORY  <span class="si">${</span><span class="nv">LIB_FILE</span><span class="si">}</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">include_directories<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/message-module/include
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_subdirectory<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/message-module
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_executable<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/hello_world.cpp
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target_link_libraries<span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    test_message
</span></span><span class="line"><span class="cl"><span class="o">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们设置动态库存放的路径的宏为CMAKE_LIBRARY_OUTPUT_DIRECTORY。</p>
<p>源码地址：</p>
<h4 id="102-gnulinux只链接三方库动态库">10.2 GNU/Linux只链接三方库（动态库）</h4>
<p>在<code>GNU/Linux</code>上链接动态库的方法和静态库生成的方法类似，其目录结构等都与静态库相同，只有在使用add_library命令时，参数STATIC改为SHARE即可,相关项目结构和<code>CMakeLists.txt</code>如下。</p>
<p>目录结构:</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── third-party
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   └── lib
</span></span><span class="line"><span class="cl">│       └── libtest_message.so
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>源码地址: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib_third_party"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_dynamic_lib_third_party<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><code>CMakeLists.txt</code>文件:</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/libtest_message.so</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">TEST_MESSAGE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="103-windows平台上动态库的编译和链接">10.3 Windows平台上动态库的编译和链接</h4>
<p>注意：通过实践发现，Windows中<code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>没有作用。在Windows中生成的动态库将会自动生成到可执行文件所在的目录。</p>
<p>前面我们说Windows平台中生成动态库的源码和静态库是不同的，在Windows平台中，在导出动态库时除了会生成<code>.dll</code>动态库之外，还会生成一个<code>.lib</code>文件。注意，这个<code>.lib</code>文件和静态库的<code>.lib</code>文件是不同的，它里面并不保存代码生成的二进制文件，而是所有需要导出符号的符号表。因此这个<code>.lib</code>文件和编译生成的静态库<code>.lib</code>相比较而言会小的多。</p>
<p>符号表是需要我们在编写源码时进行指定的，如果我们将一个符号导出（符号可以指类、函数等各种类型）,需要在其前面加上<code>__declspec(dllexport)</code>标志，这样这个符号的相关信息就会在导出的<code>.lib</code>中的符号表中了。</p>
<p>如果在源码中没有任何的<code>__declspec(dllexport)</code>,依然可以成功的编译出动态库，但是并不会生成保存符号表的<code>.lib</code>文件。</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>除了导出符号标识符<code>__declspec(dllexport)</code>以外，作为用户使用动态库的时候，对应的头文件的符号还需要<code>__declspec(dllimport)</code>标识符来表示这个符号是从动态库导入的。</p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一般，一个库文件我们并不想对导入和导出分别写两个几乎同样的头文件，因此可以使用宏定义来代替直接使用<code>__declspec(dllexport)</code>和<code>__declspec(dllimport)</code>关键字。</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED_LIB_EXPORT
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_EXPORT __declspec(dllexport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_EXPORT __declspec(dllimport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SHARED_LIB_EXPORT</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样我们只需要在编译（导出）这个库的时候，给编译器添加<code>SHARED_LIB_EXPORT</code>宏。而在使用该库的时候什么都不定义即可。</p>
<p><font color=red>我们通常编写一个头文件来专门管理<code>SHARED_LIB_EXPORT</code>宏定义。</font>为了使得我们的代码在Linux中平台以及静态库的情况，我们的头文件编写如下：</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef EXPORT_LIB_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define EXPORT_LIB_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED_LIB_BUILD
</span></span></span><span class="line"><span class="cl"><span class="cp">#ifdef _WIN32
</span></span></span><span class="line"><span class="cl"><span class="cp">#ifdef SHARED_LIB_EXPORT
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API __declspec(dllexport)
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API __declspec(dllimport)
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// SHARED_LIB_EXPORT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// _WIN32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHARED_LIB_API
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif  </span><span class="c1">// SHARED_LIB_BUILD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! EXPORT_LIB_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们除了使用<code>SHARED_LIB_API</code>宏定义来判断是否导出为动态库以外，还使用了编译器自带的<code>_WIN32</code>宏来判断是实在windows平台上以及使用。<code>SHARED_LIB_BUILD</code>来判断是否正在编译动态库。</p>
<p>有了这个头文件之后，我们只需要在导出符号表的头文件中包含该头文件，就可以使用<code>SHARED_LIB_API</code>宏定义了。</p>
<p>除此之外，上述的头文件可以通过CMake提供的<code>GenerateExportHeader</code>命令自动生成。关于该命令的使用在后续介绍中会详细的进行探索。</p>
<p><strong>项目结构:</strong></p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── message-module
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │  └── message.h
</span></span><span class="line"><span class="cl">│   ├── src
</span></span><span class="line"><span class="cl">│   │   └── message.cpp
</span></span><span class="line"><span class="cl">│   └── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_shared_lib_in_windows</p>
<p><strong>message.h</strong></p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MESSAGE_HEADER_H_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// ! MESSAGE_HEADER_H_
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>message.cpp</strong></p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;message.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>message-module下的CMakeLists.txt</strong></p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">HEADER</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SOURCE</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SOURCE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.h&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">install</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/</span>
</span></span><span class="line"><span class="cl">        <span class="s">DESTINATION</span> <span class="s2">&#34;include&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">FILES_MATCHING</span> <span class="s">PATTERN</span> <span class="s2">&#34;*.hpp&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-51"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">add_library</span><span class="p">(</span><span class="s">test_message::test_message</span> <span class="s">ALIAS</span> <span class="s">test_message</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>添加别名，以便库可以在构建树中使用，例如在测试时。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-52"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">test_message</span>
</span></span><span class="line"><span class="cl">    <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">  <span class="o">$&lt;</span><span class="nv">BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}</span><span class="o">&gt;</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">    <span class="o">$&lt;</span><span class="nv">INSTALL_INTERFACE:include</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>设置 test_message 的包含路径。其中，<code>PUBLIC</code> 表示这些头文件路径将会被暴露给该目标的依赖项，即其他目标可以通过依赖该目标来访问这些头文件路径。
<code>BUILD_INTERFACE</code>表示在构建时使用的头文件路径;INSTALL_INTERFACE表示在安装时使用的头文件路径，即将该目标安装到其他地方时，头文件将会被安装到 include 目录下。
综上，这段代码的作用是将当前项目的根目录添加到 “test_message” 目标的头文件包含路径中，以便在编译和安装时能够正确地访问这些头文件。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-53"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">test_message</span> <span class="s">PROPERTIES</span>
</span></span><span class="line"><span class="cl">    <span class="s">CXX_STANDARD</span> <span class="s">11</span>
</span></span><span class="line"><span class="cl">    <span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>设置 <code>test_message</code> 的相关属性，关于<code>target_include_directories</code>和<code>set_target_properties</code>的具体使用情况，我们将在以后做详细讲解。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-54"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">install</span><span class="p">(</span><span class="s">TARGETS</span> <span class="s">test_message</span>
</span></span><span class="line"><span class="cl">        <span class="s">EXPORT</span> <span class="s">message_export_target</span>
</span></span><span class="line"><span class="cl">        <span class="s">RUNTIME</span> <span class="s">DESTINATION</span> <span class="s2">&#34;bin&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">LIBRARY</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">ARCHIVE</span> <span class="s">DESTINATION</span> <span class="s2">&#34;lib&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>安装一个名为 “test_message” 的目标（在Windows上需要将编译出来的sln文件使用vs打开，然后再属性栏中的INSTALL右键生成，即可执行install命令）。其中，TARGETS 表示要安装的目标名称，即 test_message。
<code>EXPORT message_export_target</code> 表示将该目标导出到一个名为 “message_export_target” 的 CMake 配置文件中，以便其他项目可以使用该目标。
<strong>注意:</strong> 我们在根目录下已经指定了’install’安装目录的根目录。
<code>RUNTIME DESTINATION ${CMAKE_SOURCE_DIR}/output/bin</code>表示将该目标的可执行文件安装到当前项目的 bin 目录下。
<code>LIBRARY DESTINATION ${CMAKE_SOURCE_DIR}/output/lib</code>表示将该目标的共享库文件安装到 当前项目的 lib 目录下。
<code>ARCHIVE DESTINATION ${CMAKE_SOURCE_DIR}/output/lib</code>)表示将该目标的静态库文件安装到 当前项目的 lib 目录下。
<strong>注意:</strong> 在Windows构建动态库时，动态库dll会被安装到当前项目的bin目录下，目标文件.lib文件会被安装到项目的lib目录下。
综上，这段代码的作用是将 “test_message” 目标的可执行文件、共享库文件和静态库文件安装到指定的目录下，并将该目标导出到一个 CMake 配置文件中，以便其他项目可以使用该目标。关于生成cmake相关配置文件详见下一篇内容。本项目仅用此命令做输出库的相关文件的功能。</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-55"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">install</span><span class="p">(</span><span class="n">DIRECTORY</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">include</span><span class="o">/</span>
</span></span><span class="line"><span class="cl">        <span class="n">DESTINATION</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">output</span><span class="o">/</span><span class="n">include</span>
</span></span><span class="line"><span class="cl">        <span class="n">FILES_MATCHING</span> <span class="n">PATTERN</span> <span class="s">&#34;*.h&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">install</span><span class="p">(</span><span class="n">DIRECTORY</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">include</span><span class="o">/</span>
</span></span><span class="line"><span class="cl">        <span class="n">DESTINATION</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">output</span><span class="o">/</span><span class="n">include</span>
</span></span><span class="line"><span class="cl">        <span class="n">FILES_MATCHING</span> <span class="n">PATTERN</span> <span class="s">&#34;*.hpp&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将当前目录下的<code>include</code>目录中的<code>.hpp</code>和<code>.h</code>安装到当前项目下的<code>output</code>目录下的<code>include</code>文件中。关于install命令的具体使用方法，我们将以后做详细解释。</p></div>
    </div>
  </div>
<p><strong>根目录下的CMakeLists.txt</strong></p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置可执行文件到bin文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置动态库到lib文件夹下
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIB_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span>  <span class="o">${</span><span class="nv">LIB_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/message-module</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">test_message</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码释义:</strong></p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-56"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_INSTALL_PREFIX</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/output/</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果没有指定<code>install</code>的目录，则设置install的目录为<code>${CMAKE_SOURCE_DIR}/output/</code>。</p></div>
    </div>
  </div>
<h4 id="104-windows上只链接第三方库动态库">10.4 Windows上只链接第三方库（动态库）</h4>
<p>Windows平台上链接动态库的使用方法和GNU/Linux平台上有所不同，我们在链接时需要将符号表文件lib进行连接，然后将对应的动态库文件dll文件拷贝到环境变量或者可执行文件所在的目录下，可知行文件才可以正常过执行。</p>
<p><strong>项目结构</strong></p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── third-party
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   └── message.h
</span></span><span class="line"><span class="cl">│   ├── lib
</span></span><span class="line"><span class="cl">│   │   └── test_message.lib
</span></span><span class="line"><span class="cl">│  └── bin
</span></span><span class="line"><span class="cl">│    └── test_message.dll
</span></span><span class="line"><span class="cl">├── hello_world.cpp
</span></span><span class="line"><span class="cl">└── CMakeLists.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>项目中使用的<code>third-party</code>使用的是上一节内容中在Windows上生成的动态库。文件hello_world.cpp与上一节内容相同，我们不再对其进行描述。</p>
<p>源码地址:https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_2/message_shared_lib_third_party_in_windows</p>
<p><strong>CMakeLists.txt</strong></p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTE_FILE</span> <span class="o">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="o">${</span><span class="nv">EXECUTE_FILE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/test_message.lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">TEST_MESSAGE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">MSVC</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">MODEL</span> <span class="s2">&#34;${CMAKE_SOURCE_DIR}/third-party/bin/*.dll&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">add_custom_command</span><span class="p">(</span><span class="s">TARGET</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">POST_BUILD</span>
</span></span><span class="line"><span class="cl">                     <span class="s">COMMAND</span> <span class="o">${</span><span class="nv">CMAKE_COMMAND</span><span class="o">}</span> <span class="s">-E</span> <span class="s">copy_if_different</span>
</span></span><span class="line"><span class="cl">                     <span class="o">${</span><span class="nv">MODEL</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">                     <span class="o">$&lt;</span><span class="nv">TARGET_FILE_DIR:${PROJECT_NAME}</span><span class="o">&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码释义:</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-57"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set</span><span class="p">(</span><span class="s">TEST_MESSAGE</span> <span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/third-party/lib/test_message.lib</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>链接三方库的符号表</p></div>
    </div>
  </div>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><div class="highlight" id="id-58"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">if</span> <span class="p">(</span><span class="s">MSVC</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">MODEL</span> <span class="s2">&#34;${CMAKE_SOURCE_DIR}/third-party/bin/*.dll&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">add_custom_command</span><span class="p">(</span><span class="s">TARGET</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">POST_BUILD</span>
</span></span><span class="line"><span class="cl">                     <span class="s">COMMAND</span> <span class="o">${</span><span class="nv">CMAKE_COMMAND</span><span class="o">}</span> <span class="s">-E</span> <span class="s">copy_if_different</span>
</span></span><span class="line"><span class="cl">                     <span class="o">${</span><span class="nv">MODEL</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">                     <span class="o">$&lt;</span><span class="nv">TARGET_FILE_DIR:${PROJECT_NAME}</span><span class="o">&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将我们之前生成的动态库文件dll文件手动复制到可执行文件所在的目录中。关于add_custom_command用法我们之后章节将作详细详解。</p></div>
    </div>
  </div>
<h3 id="十一补充">十一、补充</h3>
<p>在window上使用vs生成可执行文件和执行install命令。
首先，我们首先新建一个build目录，并进入该目录。</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build</span></span></code></pre></td></tr></table>
</div>
</div><p>然后使用<code>cmake</code>进行构建项目。</p>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在<code>build</code>目录下可以看到<code>sln</code>文件，使用<code>vs</code>打开。</p>
<p><strong>构建所有</strong>: 在vs中的解决方案资源管理器中右键ALL_BUILD，然后点击生成</p>
<p>编译生成hello-world进程，右键hello-world,然后点击生成。如果我们使用CMake在一个项目中生成了多个进程，我们在测试某一个进程时，在对应的进程上右键设为启动项目即可。</p>
<p><strong>执行install安装命令</strong>: 在INSTALL上右键，然后点击生成即可。注意：只有当我们的CMake中有install命令时，VS中才会出现INTALL选项。</p>
]]></description></item><item><title>CMake 笔记 | [1] 单个源文件编译为可执行文件</title><link>https://jianye0428.github.io/posts/cmake_note_1/</link><pubDate>Fri, 12 Jan 2024 14:19:06 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/cmake_note_1/</guid><description><![CDATA[<h3 id="一项目结构">一、项目结构</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">└── hello_world.cpp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0 directories, 2 files</span></span></code></pre></td></tr></table>
</div>
</div><p>本项目只包含了一个源文件hello_world.cpp和一个CMake文件。</p>
<blockquote>
<p>源码地址: <a href="https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_1/hello-world"target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jianye0428/CMake_Learning_Notes/tree/main/Note_1/hello-world<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</blockquote>
<div class="details admonition quote open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">注意: CMake文件的名字只能是CMakeLists.txt，当然如果使用include命令（后续会讲到），可以以任何名字进行命名，只要以.cmake结尾即可。</div>
    </div>
  </div>
<h3 id="二cpp源文件">二、CPP源文件</h3>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">SayHello</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">SayHello</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">SayHello</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Hello, CMake World!&#34;</span><span class="p">);</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="三cmake文件">三、CMake文件</h3>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span> <span class="s">FATAL_ERROR</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">hello-world</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="s">hello_world.cpp</span>
</span></span><span class="line"><span class="cl"><span class="s">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong><code>cmake_minimum_required(VERSION 3.10 FATAL_ERROR)</code></strong></p>
<p>设置CMake所需的最低版本的最低版本，如果使用的CMake版本低于该版本，则会发出致命错误。
今后，笔记中CMake的版本要求都为3.10。vscode中CMake Tool插件使用debug功能要求CMake版本不低于3.10。如果使用的系统ubuntu 16.04的话，需要升级CMake版本，windows请自行安装高于3.10版本的CMake。</p>
</li>
<li>
<p><strong><code>project(hello-world LANGUAGES CXX)</code></strong></p>
<p>声明了项目的名称和支持的编程语言，且该命令必须生命在cmake_minimum_required之后。一旦声明了项目的名称后，可以使用宏定义${PROJECT_NAME}进行调用。
在CMake中，C++是默认的编程语言。不过在实际编写代码过程中，仍建议使用LANGUAGES选项在project命令中显示地声明项目的语言。</p>
</li>
<li>
<p><strong><code>add_executable(${PROJECT_NAME} hello_world.cpp}</code></strong></p>
<p>CMake创建一个新可执行文件，其名字为${PROJECT_NAME}（也可以使用其他任意的名字）。这个可执行文件是通过编译和链接源文件hello_world.cpp生成的。</p>
<p>CMake将为编译器使用默认设置，并自动生成工具。</p>
</li>
</ul>
<h3 id="四操作">四、操作</h3>
<p>在工程文件夹下，执行如下操作:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">cmake ..</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-- The CXX compiler identification is GNU 9.4.0
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++
</span></span><span class="line"><span class="cl">-- Check <span class="k">for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info
</span></span><span class="line"><span class="cl">-- Detecting CXX compiler ABI info - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features
</span></span><span class="line"><span class="cl">-- Detecting CXX compile features - <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Configuring <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Generating <span class="k">done</span>
</span></span><span class="line"><span class="cl">-- Build files have been written to: /home/jiangli/repo/tutorials/cmake-tutorial/chapter1/01/build</span></span></code></pre></td></tr></table>
</div>
</div><p>CMake的构建方式有两种: <strong>源内构建</strong>和<strong>源外构建</strong>。源内构建即在CMakeLists.txt同级目录中进行构建，构建出来的CMake文件将在该目录中，<font color=red><u>这通常是不推荐的，因为这会混合源代码和项目的目录树</u></font>。源外构建的构建方式，就是笔记的构建方式，往后我们都采用源外构建的方式。</p>
<p>CMake是一个构建系统生成器。将描述构建系统，如Unix Makefile、Ninja、sln等应当如何操作才能编译代码。然后，CMake为所选的构建系统生成相应的指令。默认情况下，在GNU/Linux和macOS系统上，CMake使用Unix Makefile生成器。Windows上，sln是默认的生成器。</p>
<p>GNU/Linux上，CMake默认生成 Makefile来构建项目:</p>
<ol>
<li><strong>Makefile</strong>: make将运行指令来构建项目。</li>
<li><strong>CMakefile</strong>: 包含临时文件的目录，CMake用于检测操作系统、编译器等。此外，根据所选的生成器，它还包含特定的文件。</li>
<li><strong>cmake_install.cmake</strong>: 处理安装规则的CMake脚本，在项目安装时使用（命令为执行为make后执行make install）。</li>
<li><strong>CMakeCache.txt</strong>: 如文件名所示，CMake缓存。CMake在重新运行配置时使用这个文件。</li>
</ol>
]]></description></item><item><title>Argoverse 2 数据集</title><link>https://jianye0428.github.io/posts/argoverse2/</link><pubDate>Fri, 05 Jan 2024 17:34:44 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/argoverse2/</guid><description><![CDATA[<h2 id="一简介">一、简介</h2>
<p>Argoverse数据集是由Argo AI、卡内基梅隆大学、佐治亚理工学院发布的用于支持自动驾驶汽车3D Tracking和Motion Forecasting研究的数据集。
数据集包括:</p>
<ul>
<li><strong>带标注的传感器数据集:</strong> 含1000个多模态数据序列，包括来自七个环视摄像机和两个双目摄像机的高分辨率图像，以及激光雷达点云和6自由度地图配准位姿。序列包含26个目标类别的三维长方体标注，所有这些标注都是充分采样的，以支持训练和三维感知模型的评估。</li>
<li><strong>激光雷达数据集:</strong> 包含20,000个未标记的激光雷达点云序列和地图配准位姿。该数据集是有史以来最大的激光雷达传感器数据集合，支持自监督学习和新兴的点云预测任务。</li>
<li><strong>运动预测数据集:</strong> 包含250,000个场景，挖掘每个场景中自车与其他参与者之间有趣和具有挑战性的交互。模型的任务是预测每个场景中scored actors的未来运动，并提供跟踪历史，捕捉目标的位置、航向、速度和类别。</li>
</ul>
<p>在所有三个数据集中，每个场景都包含自己的高精地图，带有3D车道和人行横道几何形状&ndash;来自六个不同城市的数据。所有数据集都是在CC BY-NC-SA 4.0许可下发布的。</p>
<h2 id="二argoverse-2-datasets">二、Argoverse 2 Datasets</h2>
<h3 id="21-sensor-dataset-传感器数据集">2.1 Sensor Dataset 传感器数据集</h3>
<p>Argoverse 2传感器数据集是Argoverse 1 3D跟踪数据集的后续。AV2更大，有1000个场景，高于Argoverse 1中的113个，但每个AV2场景也更丰富&ndash;AV2中有23倍的非车辆、非行人长方体。作者手工选择Argoverse 2传感器数据集中的30s组成场景，以包含拥挤的场景，其中包含未被表示的对象、值得注意的天气和有趣的行为，如插队和乱穿马路。每个场景的持续时间为15秒。表1将AV2传感器数据集与自动驾驶数据集进行了比较。图1、2和3显示了AV2的场景在标注范围、目标多样性、目标密度和场景动态性方面如何优于其他数据集。</p>
<p>与本文最相似的传感器数据集是非常有影响力的nuScenes[4]&ndash;这两个数据集都有1000个场景和高清地图，尽管Argoverse在拥有地面高度地图方面是独一无二的。nuScenes包含毫米波雷达数据，而AV2包含双目图像。nuScenes有一个很大的分类学&ndash;23个目标类别，其中10个有适合训练和评估（evaluation）的数据。本文的数据集包含30个目标类别，其中26个被很好地采样，足以用于训练和评估。nuScenes横跨两个城市，而本文的提出的数据集横跨六个城市。</p>
<p><strong>传感器套件。</strong> 激光雷达扫描收集在10赫兹，以及20 fps图像从7个摄像头定位，以提供一个完整的全景视野。此外，还提供了全局坐标系下的摄像机内参、外参和6自由度 ego-vehicle 姿态。激光雷达回波由两个32波束激光雷达捕获，激光雷达在同一方向以10赫兹旋转，但在方向上相隔180°。摄像机触发与两个激光雷达同步，导致20赫兹的帧率。七个全局快门摄像机与激光雷达同步，使它们的曝光集中在激光雷达上，扫描它们的视野。在附录中，本文提供了一个示意图，说明了汽车传感器套件及其坐标框架。</p>
<p><strong>激光雷达同步精度。</strong> 在AV2中，本文改进了摄像机和激光雷达的同步比Argoverse 1明显。本文的同步精度在[-1.39,1.39]ms，与Waymo开放数据集[-6,7]ms[45]相比较。</p>
<p><strong>标注。</strong> AV2传感器数据集包含本文30个类分类法中的对象的10 Hz 3D长方体标注（图1）。长方体的轨道标识符随着时间的推移对于相同的目标实例是一致的。如果对象在“感兴趣区域”(ROI)内&ndash;在映射的“可驾驶”区域的五米内，则对其进行标注。</p>
<p><strong>隐私。</strong> 为了保护隐私，所有的脸和车牌，无论是在车辆内还是在可驾驶区域外，都被广泛模糊。</p>
<p>传感器数据集分割。 本文随机地将数据集划分为700、150和150个场景的训练、验证和测试拆分。</p>
<h3 id="22-lidar-dataset-激光雷达数据集">2.2 Lidar Dataset 激光雷达数据集</h3>
<p>Argoverse 2 激光雷达数据集旨在支持激光雷达域中的自监督学习研究以及点云预测[48,49]。由于激光雷达数据比完整的传感器套件更紧凑，本文可以包括两倍长度的场景（30秒而不是15秒），和更多 （20,000 而不是 1,000），相当于大约40倍的驾驶小时，空间预算是5倍。AV2激光雷达数据集的挖掘标准与预测数据集（第3.3.2节）相同，以确保每个场景都是有趣的。虽然激光雷达数据集没有3D目标标注，但每个场景都带有一张高清地图，其中包含关于场景的丰富的3D信息。</p>
<p>本文的数据集是迄今为止最大的此类集合，有20,000个30秒序列。唯一一个类似的数据集，是同时发布的ONCE[36]，包含1M激光雷达帧，而本文的是6M激光雷达帧。本文的数据集以10 Hz采样，而不是像ONCE[36]中那样以2 Hz采样，使本文的数据集更适合于点云预测或自监督任务，这些任务点云随时间的演变是重要的。</p>
<p><strong>激光雷达数据集分割。</strong> 本文用分别为16,000个、2000个和2000个场景的train、validation和test拆分 随机划分数据集。</p>
<h3 id="23-motion-forecasting-dataset-运动预测数据集">2.3 Motion Forecasting Dataset 运动预测数据集</h3>
<p>运动预测解决了预测局部环境中动态行为者的未来状态（或占用图）的问题。自动驾驶相关行为者的一些例子包括：车辆（停车和移动）、行人、骑自行车的人、滑板车和宠物。由预测系统生成的预测未来被用作运动规划的主要输入，运动规划根据这种预测条件进行轨迹选择。生成这些预测提出了一个复杂的、多模态的问题，涉及许多不同的、部分观察的和社会交互的主体。然而，通过利用观察到的ground truth futures 来“自我标记”数据的能力，运动预测成为机器学习应用的理想领域（ideal domain）。</p>
<p>在Argoverse 1成功的基础上，Argoverse 2运动预测数据集提供了从自动驾驶车队收集的一组更新的预测场景。下面列举的设计决策总结了本文从内部研究/开发中吸取的集体经验教训，以及来自3个竞赛中近260个独特团队提交的2700多份submissions的反馈意见[43]:</p>
<ol>
<li>
<p>运动预测是长尾域中的一个安全关键系统。 因此，本文的数据集偏向于包含不同类型focal agent的不同和有趣的场景（见第3.3.2节）。本文的目标是鼓励开发确保尾部事件（tail events）期间安全的方法，而不是优化“轻松里程”上的预期性能。</p>
</li>
<li>
<p>There is a “Goldilocks zone” of task difficulty. Argoverse1测试集的性能已经开始稳定下来，如附录的图10所示。Argoverse 2的设计是为了增加预测的难度，在未来几年刺激富有成效的重点研究。这些变化旨在激励在扩展预测范围(3s→6s)上表现良好的方法，处理多种类型的动态对象(1→5)，并确保长尾场景的安全性。未来的Argoverse releases可能会通过减少观测窗口和增加预测层位来继续增加问题的难度。</p>
</li>
<li>
<p>可用性很重要。 Argoverse 1受益于一个庞大而活跃的研究社区&ndash;在很大程度上是由于设置和使用的简单性。因此，本文注意确保现有的Argoverse模型可以很容易地移植到Argoverse 2上运行。特别是，本文优先考虑对地图元素的直观访问，鼓励使用车道图作为强优先级的方法。为了提高训练和泛化，所有姿态也被插值和重新采样在精确的10赫兹（Argoverse 1是近似的）。新的数据集包括更少，但更长和更复杂的场景；这确保总的数据集大小保持足够大，可以训练复杂的模型，但足够小，可以方便地访问。</p>
</li>
</ol>
<h3 id="24-hd-maps-高精地图">2.4 HD Maps 高精地图</h3>
<p>上述三个数据集中的每个场景共享相同的HD地图表示。每个场景都带有自己的本地地图区域，类似于Waymo Open Motion[12]数据集。这与最初的Argoverse数据集不同，在最初的数据集中，所有场景都被本地化到两张城市地图上&ndash;一张是匹兹堡的，一张是迈阿密的。在附录中，本文提供了例子。每个场景映射的优点包括更高效的查询和处理映射更改的能力。在本文的数据集中，一个特定的十字路口可能会被观察多次，在此期间车道、人行横道甚至地面高度都可能发生变化。</p>
<p><strong>车道图。</strong> HD地图的核心特征是车道图，由图组成，其中是单个车道段。在附录中，本文列举并定义了本文为每个车道段提供的属性。与Argoverse 1不同，本文提供了实际的3D车道边界，而不仅仅是中心线。但是，本文的API提供了代码，可以在任何期望的采样分辨率下快速推断中心线。折线被量化到1cm分辨率。本文的表示比nuScenes更丰富，它只在2D中提供车道几何，而不是3D。</p>
<p><strong>可驾驶区域。</strong> 而不是像在Argoverse 1中所做的那样，以光栅化格式提供可驾驶区域分割，本文以矢量格式释放它，即作为3D多边形。这提供了多种优势，主要是在压缩方面，允许本文为成千上万的场景存储单独的地图，然而光栅格式仍然很容易衍生。将多边形顶点量化到1cm分辨率。</p>
<p>**地表高度。**只有传感器数据集包括密集的地表高度图（尽管其他数据集仍然有关于折线的稀疏的三维高度信息）。地地面高度为可行驶区域边界5m等值线内的区域提供，本文将其定义为感兴趣区域(ROI)[6]。本文这样做是因为对于建筑物内部和建筑密集的城市街区内部，地面车辆由于遮挡而无法观察的区域，地表高度的概念定义不清(ill-defined)。光栅栅格被量化到30cm分辨率，比Argoverse 1中的1m分辨率更高。</p>
<p>**本地地图的面积。**每个场景的局部地图都包括在ego-vehicle轨迹的l2范数中100米膨胀范围内找到的所有实体。</p>
<h2 id="三argoverse-2-api-简介">三、Argoverse 2 API 简介</h2>
<p>轨迹预测常用的有场景数据<code>ArgoverseScenario</code>和地图<code>ArgoverseStaticMap</code></p>
<p>轨迹序列读取的API为<code>scenario_serialization</code></p>
<p>可视化的API为<code>visualize_scenario</code></p>
<p>argoverse2和argoverse1不一样的地方是，每一段轨迹序列（Scenario）内有自己的json地图文件（虽然说都是同一幅HD map，但是对应HD map中的不同的位置），而argoverse1是所有轨迹序列共享一个地图文件</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 存放轨迹序列的类</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.data_schema</span> <span class="kn">import</span> <span class="n">ArgoverseScenario</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 用于读取轨迹序列的API</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting</span> <span class="kn">import</span> <span class="n">scenario_serialization</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 用于可视化的API</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.viz.scenario_visualization</span> <span class="kn">import</span> <span class="n">visualize_scenario</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 用于读取地图的API</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_api</span> <span class="kn">import</span> <span class="n">ArgoverseStaticMap</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>ArgoverseScenario</strong>
每个scenario有11s长的序列，包含actor的历史轨迹集合，就是这里面的tracks，对于每一个scenario，提供了以下的顶层属性:</p>
<ul>
<li><code>scenario_id</code>: 该scenario的特有ID</li>
<li><code>timestamps_ns</code>: 该scenario的所有时间戳</li>
<li><code>tracks</code>: 该scenario的所有轨迹序列</li>
<li><code>focal_track_id</code>: 该scenario的焦点agent(focal agent)的track ID</li>
<li><code>city_name</code>: 该scenario对应的城市名</li>
</ul>
<p>每个<code>track</code>包含以下属性:</p>
<ul>
<li><code>track_id</code>: 该track的特有ID</li>
<li><code>object_states</code>: 该轨迹序列对应的object在这11s内的有效观测的状态，以timestep表示时间步，一般来说最多有110步，因为采样频率为10Hz，一步对应0.1s</li>
<li><code>object_type</code>: 该轨迹序列对应的object的类型，如vehicle等</li>
<li><code>category</code>: 给轨迹序列分配种类，用于给轨迹预测的数据质量提供参考，一般来说，有四种：SCORED_TRACK，UNSCORED_TRACK，FOCAL_TRACK，TRACK_FRAGMENT。其中FOCAL_TRACK和SCORED_TRACK数据质量较好，UNSCORED_TRACK用于当作上下文输入，数据质量一般，而TRACK_FRAGMENT的时间长度不定，数据质量较差
<ul>
<li><code>TRACK_FRAGMENT</code>: Lower quality track that may only contain a few timestamps of observations. 在数据中以整数0表示</li>
<li><code>UNSCORED_TRACK</code>: Unscored track used for contextual input. 在数据中以整数1表示</li>
<li><code>SCORED_TRACK</code>: High-quality tracks relevant to the AV - scored in the multi-agent prediction challenge. 在数据中以整数2表示</li>
<li><code>FOCAL_TRACK</code>: The primary track of interest in a given scenario - scored in the single-agent prediction challenge. 在数据中以整数3表示</li>
</ul>
</li>
</ul>
<p>每个<code>object_states</code>包含以下属性，对应某一actor在某一时间点的所有信息：</p>
<ul>
<li><code>observed</code>: Boolean 指示这个object state是否在该scenario的观测区间内(observed segment)</li>
<li><code>timestep</code>: 时间步，范围是[0, num_scenario_timesteps) Time step corresponding to this object state [0, num_scenario_timesteps).</li>
<li><code>position</code>: (x, y) Coordinates of center of object bounding box. object bounding box的xy坐标</li>
<li><code>heading</code>: Heading associated with object bounding box (in radians, defined w.r.t the map coordinate frame). object bounding box的航向角，单位是弧度，是在地图坐标系下的</li>
<li><code>velocity</code>: (x, y) Instantaneous velocity associated with the object (in m/s). object的xy方向的速度</li>
</ul>
<p>每个track有以下10种label:</p>
<ul>
<li><code>Dynamic</code>
<ul>
<li><code>VEHICLE</code></li>
<li><code>PEDESTRIAN</code></li>
<li><code>MOTORCYCLIST</code></li>
<li><code>CYCLIST</code></li>
<li><code>BUS</code></li>
</ul>
</li>
<li><code>Static</code>
<ul>
<li><code>STATIC</code></li>
<li><code>BACKGROUND</code></li>
<li><code>CONSTRUCTION</code></li>
<li><code>RIDERLESS_BICYCLE</code></li>
</ul>
</li>
<li><code>UNKNOWN</code></li>
</ul>
<p><strong>ArgoverseStaticMap</strong></p>
<ul>
<li>
<p>Vector Map: Lane Graph and Lane Segments</p>
<blockquote>
<p>The core feature of the HD map is the lane graph, consisting of a graph G = (V, E), where V are individual lane segments.</p>
</blockquote>
<p>Argoverse2 提供了3D的道路边界线，而不是仅仅有centerlines，也提供了快速获取特定采样分辨率的centerlines的API，在release中多边形的分辨率被设置为1cm</p>
<p>地图以json文件的形式提供, 可以通过以下方式读取：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_api</span> <span class="kn">import</span> <span class="n">ArgoverseStaticMap</span>
</span></span><span class="line"><span class="cl"><span class="n">log_map_dirpath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&#34;av2&#34;</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&#34;00a6ffc1-6ce9-3bc3-a060-6006e9893a1a&#34;</span> <span class="o">/</span> <span class="s2">&#34;map&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">avm</span> <span class="o">=</span> <span class="n">ArgoverseStaticMap</span><span class="o">.</span><span class="n">from_map_dir</span><span class="p">(</span><span class="n">log_map_dirpath</span><span class="o">=</span><span class="n">log_map_dirpath</span><span class="p">,</span> <span class="n">build_raster</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>LaneSegment
LaneSegment中包含以下属性：</p>
<ul>
<li><code>id:</code> unique identifier for this lane segment (guaranteed to be unique only within this local map). 该lane segment的特有ID（仅在局部地图中保证是特有的ID）</li>
<li><code>is_intersection:</code> boolean value representing whether or not this lane segment lies within an intersection. boolean value，用来表示该lane segment是否位于一个路口内</li>
<li><code>lane_type:</code> designation of which vehicle types may legally utilize this lane for travel. 表示车道线类型</li>
<li><code>right_lane_boundary:</code> 3d polyline representing the right lane boundary. 3D线条，表示右车道边界线</li>
<li><code>left_lane_boundary:</code> 3d polyline representing the left lane boundary. 3D线条，表示左车道边界线</li>
<li><code>right_mark_type:</code> type of painted marking found along the right lane boundary . 右车道边界线的线型</li>
<li><code>left_mark_type:</code> type of painted marking found along the left lane boundary. 左车道边界线的线型</li>
<li><code>predecessors:</code> unique identifiers of lane segments that are predecessors of this object. 该lane segment的前继lane segment的unique ID</li>
<li><code>successors:</code> unique identifiers of lane segments that represent successor of this object. Note: this list will be empty if no successors exist. 该lane segment的后继lane segment的unique ID</li>
<li><code>right_neighbor_id:</code> unique identifier of the lane segment representing this object’s right neighbor. 该lane segment的右邻lane segment的unique ID</li>
<li><code>left_neighbor_id:</code> unique identifier of the lane segment representing this object’s left neighbor. 该lane segment的左邻lane segment的unique ID</li>
</ul>
</li>
<li>
<p>Vector Map: Drivable Area
多边形向量的分辨率也是1cm, 包含以下属性：</p>
<ul>
<li><code>id:</code> unique identifier. 特有ID</li>
<li><code>area_boundary:</code> 3d vertices of polygon, representing the drivable area’s boundary. 3D多边形，用来表示可行驶区域的边</li>
</ul>
</li>
<li>
<p>Vector Map: Pedestrian Crossings
代表人行道，由两条沿同一主轴的edge构成</p>
<ul>
<li><code>id:</code> unique identifier of pedestrian crossing. 人行道的特有ID</li>
<li><code>edge1:</code> 3d polyline representing one edge of the crosswalk, with 2 waypoints. 3D多边形，代表人行道的其中一边，由2个waypoints组成</li>
<li><code>edge2:</code> 3d polyline representing the other edge of the crosswalk, with 2 - waypoints. 3D多边形，代表人行道的其中一边，由2个waypoints组成</li>
</ul>
</li>
<li>
<p>Area of Local Maps
Each scenario’s local map includes all entities found within a 100 m dilation in l2-norm from the ego-vehicle trajectory.
每个scenario的局部地图包含距离ego-vehicle的轨迹100m l2距离内的所有实体</p>
</li>
</ul>
<p>常用API汇总:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.data_schema</span> <span class="kn">import</span> <span class="n">ArgoverseScenario</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting</span> <span class="kn">import</span> <span class="n">scenario_serialization</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.datasets.motion_forecasting.viz.scenario_visualization</span> <span class="kn">import</span> <span class="n">visualize_scenario</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_api</span> <span class="kn">import</span> <span class="n">ArgoverseStaticMap</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.map.map_primitives</span> <span class="kn">import</span> <span class="n">Polyline</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">av2.utils.io</span> <span class="kn">import</span> <span class="n">read_json_file</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 利用pandas读取轨迹序列parquet文件</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet文件</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_dir</span><span class="p">,</span> <span class="n">raw_file_name</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;scenario_</span><span class="si">{</span><span class="n">raw_file_name</span><span class="si">}</span><span class="s1">.parquet&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 加载地图json文件</span>
</span></span><span class="line"><span class="cl"><span class="n">map_data</span> <span class="o">=</span> <span class="n">read_json_file</span><span class="p">(</span><span class="n">map_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 从地图的json文件读取车道中心线</span>
</span></span><span class="line"><span class="cl"><span class="n">centerlines</span> <span class="o">=</span> <span class="p">{</span><span class="n">lane_segment</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]:</span> <span class="n">Polyline</span><span class="o">.</span><span class="n">from_json_data</span><span class="p">(</span><span class="n">lane_segment</span><span class="p">[</span><span class="s1">&#39;centerline&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                           <span class="k">for</span> <span class="n">lane_segment</span> <span class="ow">in</span> <span class="n">map_data</span><span class="p">[</span><span class="s1">&#39;lane_segments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 加载地图API</span>
</span></span><span class="line"><span class="cl"><span class="n">map_api</span> <span class="o">=</span> <span class="n">ArgoverseStaticMap</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">map_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 以某个query中心搜索附近一定半径的的lane_segments</span>
</span></span><span class="line"><span class="cl"><span class="n">query_center</span> <span class="o">=</span> <span class="n">scenario_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;position_x&#39;</span><span class="p">,</span> <span class="s1">&#39;position_y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
</span></span><span class="line"><span class="cl"><span class="n">search_radius_m</span> <span class="o">=</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl"><span class="n">nearby_lane_segments</span> <span class="o">=</span> <span class="n">map_api</span><span class="o">.</span><span class="n">get_nearby_lane_segments</span><span class="p">(</span><span class="n">query_center</span><span class="p">,</span> <span class="n">search_radius_m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 通过map_api获取lane_segments的车道中心线</span>
</span></span><span class="line"><span class="cl"><span class="n">nearby_lane_centerlines</span> <span class="o">=</span> <span class="n">get_lane_centerlines</span><span class="p">(</span><span class="n">map_api</span><span class="p">,</span> <span class="n">nearby_lane_segments</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 获取地图内的所有pedestrian crossings（目前av2 API没有提供获取附近pedestrian crossings的API）</span>
</span></span><span class="line"><span class="cl"><span class="n">crosswalks</span> <span class="o">=</span> <span class="n">map_api</span><span class="o">.</span><span class="n">get_scenario_ped_crossings</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="四argoverse-2-数据提取">四、Argoverse 2 数据提取</h2>
<p>raw_dir 文件夹内包含<code>.parquet</code>和<code>.json</code>文件，其中文件组织形式为<code>log_map_archive_{$scenario_name}.parquet</code>和<code>scenario_{$scenario_name}.json</code>，分别代表<strong>障碍物时序信息</strong>和<strong>地图信息</strong>。</p>
<ul>
<li>设置原始数据路径:
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">raw_dir</span> <span class="o">=</span> <span class="s2">&#34;/home/yejian/yejian_personal/QCNet/train/&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">raw_file_name</span> <span class="o">=</span> <span class="s2">&#34;ffffe3df-8d26-42c3-9e7a-59de044736a0&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>读取障碍物信息和地图信息
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">parquet_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">raw_dir</span><span class="p">,</span> <span class="n">raw_file_name</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;scenario_</span><span class="si">{</span><span class="n">raw_file_name</span><span class="si">}</span><span class="s1">.parquet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;parquet_file: </span><span class="si">{</span><span class="n">parquet_file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1"># 障碍物信息</span>
</span></span><span class="line"><span class="cl"><span class="n">map_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">raw_dir</span><span class="p">,</span> <span class="n">raw_file_name</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;log_map_archive_</span><span class="si">{</span><span class="n">raw_file_name</span><span class="si">}</span><span class="s1">.json&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;map_file: </span><span class="si">{</span><span class="n">map_file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span><span class="c1"># 地图信息</span>
</span></span><span class="line"><span class="cl"><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_from_parquet</span><span class="p">(</span><span class="n">parquet_file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">map_file</span> <span class="o">=</span> <span class="n">read_json_file</span><span class="p">(</span><span class="n">map_file</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>查看障碍物信息文件内容
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><code>['observed', 'track_id', 'object_type', 'object_category', 'timestep', 'position_x', 'position_y', 'heading', 'velocity_x', 'velocity_y', 'scenario_id', 'start_timestamp', 'end_timestamp', 'num_timestamps', 'focal_track_id', 'city']</code></li>
</ul>
<h2 id="reference">Reference</h2>
<p>[1]. <a href="https://blog.csdn.net/Yong_Qi2015/article/details/128731798"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Yong_Qi2015/article/details/128731798<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
[2]. <a href="https://blog.csdn.net/m0_56423263/article/details/134593815"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/m0_56423263/article/details/134593815<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br></p>
]]></description></item><item><title>长短期记忆网络 -- LSTM</title><link>https://jianye0428.github.io/posts/lstm/</link><pubDate>Thu, 28 Dec 2023 21:50:25 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/lstm/</guid><description><![CDATA[<h2 id="一传统的bp网络和cnn网络">一、传统的BP网络和CNN网络</h2>
<p>BP网络和CNN网络没有时间维，和传统的机器学习算法理解起来相差无几，CNN在处理彩色图像的3通道时，也可以理解为叠加多层，图形的三维矩阵当做空间的切片即可理解，写代码的时候照着图形一层层叠加即可。如下图是一个普通的BP网络和CNN网络。
<br></p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9;
  display:  inline-block;
  color:  #999;
  padding:  2px;">BP Network</div>
</center>
<br>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9;
  display:  inline-block;
  color:  #999;
  padding:  2px;">CNN Network</div>
</center>
<br>
<p>图中的隐含层、卷积层、池化层、全连接层等，都是实际存在的，一层层前后叠加，在空间上很好理解，因此在写代码的时候，基本就是看图写代码，比如用keras就是:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 示例代码，没有实际意义</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>  <span class="c1"># 添加卷积层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>         <span class="c1"># 添加池化层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.25</span><span class="p">))</span>                          <span class="c1"># 添加dropout层</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>  <span class="c1"># 添加卷积层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>         <span class="c1"># 添加池化层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.25</span><span class="p">))</span>                          <span class="c1"># 添加dropout层</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">....</span>   <span class="c1"># 添加其他卷积操作</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>                            <span class="c1"># 拉平三维数组为2维数组</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>        <span class="n">添加普通的全连接层</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">....</span>  <span class="c1"># 训练网络</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二lstm网络">二、LSTM网络</h2>
<p>当我们在网络上搜索看LSTM结构的时候，看最多的是下面这张图:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">RNN Architecture Overview</div>
</center>
<br>
<p>这是RNN循环神经网络经典的结构图，LSTM只是对隐含层节点A做了改进，整体结构不变，因此本文讨论的也是这个结构的可视化问题。</p>
<p>中间的A节点隐含层，左边是表示只有一层隐含层的LSTM网络，所谓LSTM循环神经网络就是在时间轴上的循环利用，在时间轴上展开后得到右图。</p>
<p>看左图，很多同学以为LSTM是单输入、单输出，只有一个隐含神经元的网络结构，看右图，以为LSTM是多输入、多输出，有多个隐含神经元的网络结构，A的数量就是隐含层节点数量。</p>
<p>WTH？思维转不过来啊。这就是传统网络和空间结构的思维。</p>
<p><strong>实际上，右图中，我们看Xt表示序列，下标t是时间轴，所以，A的数量表示的是时间轴的长度，是同一个神经元在不同时刻的状态(Ht)，不是隐含层神经元个数。</strong></p>
<p>我们知道，LSTM网络在训练时会使用上一时刻的信息，加上本次时刻的输入信息来共同训练。</p>
<p>举个简单的例子: 在第一天我生病了(初始状态H0)，然后吃药(利用输入信息X1训练网络)，第二天好转但是没有完全好(H1)，再吃药(X2),病情得到好转(H2),如此循环往复知道病情好转。因此，输入Xt是吃药，时间轴T是吃多天的药，隐含层状态是病情状况。因此我还是我，只是不同状态的我。</p>
<p>实际上，LSTM的网络是这样的:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">LSTM Network</div>
</center>
<p>上面的图表示包含2个隐含层的LSTM网络，在T=1时刻看，它是一个普通的BP网络，在T=2时刻看也是一个普通的BP网络，只是沿时间轴展开后，T=1训练的隐含层信息H,C会被传递到下一个时刻T=2，如下图所示。上图中向右的五个常常的箭头，所指的也是隐含层状态在时间轴上的传递。</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">LSTM Architecture Overview</div>
</center>
<p>注意，图中H表示隐藏层状态，C是遗忘门，后面会讲解它们的维度。</p>
<h2 id="三lstm的输入结构">三、LSTM的输入结构</h2>
<p>为了更好理解LSTM结构，还必须理解LSTM的数据输入情况。仿照3通道图像的样子，再加上时间轴后的多样本的多特征的不同时刻的数据立方体如下图所示:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">Input Structure of LSTM Network</div>
</center>
<p>右边的图是我们常见模型的输入，比如XGBOOST，lightGBM，决策树等模型，输入的数据格式都是这种(N<em>F)的矩阵，而左边是加上时间轴后的数据立方体，也就是时间轴上的切片，它的维度是(N</em>T*F),第一维度是样本数，第二维度是时间，第三维度是特征数，如下图所示:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">天气数据立方体</div>
</center>
<p>这样的数据立方体很多，比如天气预报数据，把样本理解成城市，时间轴是日期，特征是天气相关的降雨风速PM2.5等，这个数据立方体就很好理解了。在NLP里面，一句话会被embedding成一个矩阵，词与词的顺序是时间轴T，索引多个句子的embedding三维矩阵如下图所示:</p>
<center>
  
  <br>
  <div style="color: orange; border-bottom:  1px solid #d9d9d9; display:  inline-block; color:  #999; padding:  2px;">NLP Embedding Matrix</div>
</center>
<h2 id="四pytorch中的lstm">四、pytorch中的LSTM</h2>
<h3 id="41-pytorch中定义的lstm模型">4.1 pytorch中定义的LSTM模型</h3>
<p>pytorch中定义的LSTM模型的参数如下</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">参数有</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">input_size</span><span class="p">:</span> <span class="n">x的特征维度</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">hidden_size</span><span class="p">:</span> <span class="n">隐藏层的特征维度</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">num_layers</span><span class="p">:</span> <span class="n">lstm隐层的层数</span><span class="err">，</span><span class="n">默认为1</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">bias</span><span class="p">:</span> <span class="n">False则bihbih</span><span class="o">=</span><span class="mi">0</span><span class="n">和bhhbhh</span><span class="o">=</span><span class="mf">0.</span> <span class="n">默认为True</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">batch_first</span><span class="p">:</span> <span class="n">True则输入输出的数据格式为</span> <span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">feature</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">dropout</span><span class="p">:</span> <span class="n">除最后一层</span><span class="err">，</span><span class="n">每一层的输出都进行dropout</span><span class="err">，</span><span class="n">默认为</span><span class="p">:</span>  <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">bidirectional</span><span class="p">:</span> <span class="n">True则为双向lstm默认为False</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结合前面的图形，我们一个个看。</p>
<p>(1)input_size: x的特征维度，就是数据立方体中的F，在NLP中就是一个词被embedding后的向量长度，如下图所示:</p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">LSTM Feature Matrix</div>
</center>
<p>(2)hidden_size: 隐藏层的特征维度(隐藏层神经元个数)，如下图所示，我们有两个隐含层，每个隐藏层的特征维度都是5。注意，<strong>非双向LSTM的输出维度等于隐藏层的特征维度</strong>。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">隐藏层特征维度</div>
</center>
<br>
<p>(3)num_layers: lstm隐层的层数，上面的图我们定义了2个隐藏层。
(4)batch_first: 用于定义输入输出维度，后面再讲。
(5)bidirectional: 是否是双向循环神经网络，如下图是一个双向循环神经网络，因此在使用双向LSTM的时候我需要特别注意，正向传播的时候有(Ht, Ct),反向传播也有(Ht&rsquo;, Ct&rsquo;),前面我们说了非双向LSTM的输出维度等于隐藏层的特征维度，而<strong>双向LSTM的输出维度是隐含层特征数<em>2，而且H,C的维度是时间轴长度</em>2</strong>。</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Bidirectional RNN</div>
</center>
<br>
<h3 id="42-喂给lstm的数据格式">4.2 喂给LSTM的数据格式</h3>
<p>pytorch中LSTM的输入数据格式默认如下:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">参数有</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">seq_len</span><span class="p">:</span> <span class="n">序列长度</span><span class="err">，</span><span class="n">在NLP中就是句子长度</span><span class="err">，</span><span class="n">一般都会用pad_sequence补齐长度</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">batch</span><span class="p">:</span> <span class="n">每次喂给网络的数据条数</span><span class="err">，</span><span class="n">在NLP中就是一次喂给网络多少个句子</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">input_size</span><span class="p">:</span> <span class="n">特征维度</span><span class="err">，</span><span class="n">和前面定义网络结构的input_size一致</span><span class="err">。</span></span></span></code></pre></td></tr></table>
</div>
</div><p>前面也说到，如果LSTM的参数 batch_first=True，则要求输入的格式是:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>刚好调换前面两个参数的位置。其实这是比较好理解的数据形式，下面以NLP中的embedding向量说明如何构造LSTM的输入。</p>
<p>之前我们的embedding矩阵如下图:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Embedding Matrix</div>
</center>
<br>
<p>如果把batch放在第一位，则三维矩阵的形式如下:</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Batch First</div>
</center>
<br>
<p>其转换过程如下图所示:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">将三维矩阵转换成二维形式</div>
</center>
<br>
<p>看懂了吗，这就是输入数据的格式，是不是很简单。
LSTM的另外两个输入是 h0 和 c0，可以理解成网络的初始化参数，用随机数生成即可。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">h0</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c0</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">参数</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">num_layers</span><span class="p">:</span> <span class="n">隐藏层数</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">num_directions</span><span class="p">:</span> <span class="n">如果是单向循环网络</span><span class="err">，</span><span class="n">则num_directions</span><span class="o">=</span><span class="mi">1</span><span class="err">，</span><span class="n">双向则num_directions</span><span class="o">=</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">batch</span><span class="p">:</span> <span class="n">输入数据的batch</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">hidden_size</span><span class="p">:</span> <span class="n">隐藏层神经元个数</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，如果我们定义的input格式是:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>则H和C的格式也是要变的:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">h0</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c0</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="43-lstm的output格式">4.3 LSTM的output格式</h3>
<p>LSTM的输出是一个tuple，如下:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">output</span><span class="p">,(</span><span class="n">ht</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">output</span><span class="p">:</span>  <span class="n">最后一个状态的隐藏层的神经元输出</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">ht</span><span class="p">:</span> <span class="n">最后一个状态的隐含层的状态值</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span> <span class="n">ct</span><span class="p">:</span> <span class="n">最后一个状态的隐含层的遗忘门值</span></span></span></code></pre></td></tr></table>
</div>
</div><p>output的默认维度是:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">output</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ht</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ct</span><span class="p">(</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>和input的情况类似，如果我们前面定义的input格式是:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">input_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>则ht和ct的格式也是要变的:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">ht</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ct</span><span class="p">(</span><span class="n">batc</span><span class="err">，</span><span class="n">num_layers</span> <span class="o">*</span> <span class="n">num_directions</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>说了这么多，我们回过头来看看ht和ct在哪里，请看下图:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">LSTM Network</div>
</center>
<br>
<p>output在哪里？请看下图:
<br></p>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">输出层</div>
</center>
<br>
<h2 id="五lstm和其他网络组合">五、LSTM和其他网络组合</h2>
<p>还记得吗，output的维度等于隐藏层神经元的个数，即hidden_size，在一些时间序列的预测中，会在output后，接上一个全连接层，全连接层的输入维度等于LSTM的hidden_size，之后的网络处理就和BP网络相同了，如下图:</p>
<br>
<center>
  
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">在LSTM网络后接上全连接层</div>
</center>
<br>
<p>用pytorch实现上面的结构:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">torch</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RegLSTM</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">super</span><span class="p">(</span><span class="n">RegLSTM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 定义LSTM</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">hidden_num_layers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 定义回归层网络，输入的特征维度等于LSTM的输出，输出维度为1</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">reg</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">ht</span><span class="p">,</span><span class="n">ct</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，有些模型则是将输出当做另一个LSTM的输入，或者使用隐藏层ht,ct的信息进行建模，不一而足。
好了，以上就是我对LSTM的一些学习心得，看完记得关注点赞。</p>
<p>REF:
[[1]. 漂亮，LSTM模型结构的可视化](https: //mp.weixin.qq.com/s?__biz=MzU1OTYzNjg5OQ==&amp;mid=2247545117&amp;idx=1&amp;sn=670ba155d94b229d39c5bf0bf20239d5&amp;chksm=fc1639d1cb61b0c72434a00454b2af8f9022e7ac3030a4186cda22ef5594ef5994620dc5fd52&amp;mpshare=1&amp;scene=1&amp;srcid=0617kfSozC3sKY1lRjYg1f0u&amp;sharer_shareinfo=6833fdea9df7fee2c423a9474c0928be&amp;sharer_shareinfo_first=6833fdea9df7fee2c423a9474c0928be#rd)
[2].https: //zhuanlan.zhihu.com/p/94757947
[3].https: //zhuanlan.zhihu.com/p/59862381
[4].https: //zhuanlan.zhihu.com/p/36455374
[5].https: //www.zhihu.com/question/41949741/answer/318771336
[6].https: //blog.csdn.net/android_ruben/article/details/80206792
to be added: <br>
[7].https: //www.analyticsvidhya.com/blog/2021/01/understanding-architecture-of-lstm/</p>
]]></description></item><item><title>C++ Concurrency in Action [8] | CH08 Designing Concurrent Code</title><link>https://jianye0428.github.io/posts/ch08_designing_concurrent_code/</link><pubDate>Tue, 28 Nov 2023 18:59:30 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ch08_designing_concurrent_code/</guid><description><![CDATA[<h2 id="线程间的工作划分">线程间的工作划分</h2>
<ul>
<li>为了提高线程利用率并最小化开销，必须决定要使用的线程数量，并为每个线程合理分配任务</li>
</ul>
<h3 id="开始处理之前的线程间数据划分">开始处理之前的线程间数据划分</h3>
<ul>
<li>简单算法最容易并行化，比如要并行化 <a href="https://en.cppreference.com/w/cpp/algorithm/for_each"target="_blank" rel="external nofollow noopener noreferrer">std::for_each<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，把元素划分到不同的线程上执行即可。如何划分才能获取最优性能，取决于数据结构的细节，这里用一个最简单的划分为例，每 N 个元素分配给一个线程，每个线程不需要与其他线程通信，直到独立完成各自的处理任务</li>
</ul>
<p></p>
<ul>
<li>如果使用过 <a href="https://www.mpi-forum.org/"target="_blank" rel="external nofollow noopener noreferrer">MPI<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 或 <a href="https://www.openmp.org/"target="_blank" rel="external nofollow noopener noreferrer">OpenMP<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，会很熟悉这个结构，即把一个任务划分成一系列并行任务，工作线程独立完成任务，最后 reduce 合并结果。不过对 for_each 来说，最后的 reduce 实际不需要执行操作，但对其他需要合并结果的并行算法来说，最后一步很重要</li>
<li>尽管这个技术很强大，但不是万能的，有时数据不能灵活划分，只有在处理数据时划分才明显，最能明显体现这点的就是递归算法，比如快速排序</li>
</ul>
<h3 id="递归划分数据">递归划分数据</h3>
<ul>
<li>要并行化快速排序，无法直接划分数据，因为只有处理之后才知道某一项应该置于基数的哪一边。因此，很容易想到的是使用递归，其中的递归调用完全独立，各自处理不同的元素集，十分适合并发执行</li>
</ul>
<p></p>
<ul>
<li>如果数据集很大，为每个递归生成新线程就会生成大量线程，如果线程过多就会影响性能。因此需要严格控制线程数，不过这个问题可以直接抛给 <a href="https://en.cppreference.com/w/cpp/thread/async"target="_blank" rel="external nofollow noopener noreferrer">std::async<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                           <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">res</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">low</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">low</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">low</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">l</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parallel_quick_sort</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">low</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="nf">r</span><span class="p">(</span><span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">l</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>也可以通过 <a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency"target="_blank" rel="external nofollow noopener noreferrer">hardware_concurrency<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 得知硬件可支持的线程数，再自己管理线程数。下面是一个使用 stack 存储已排序数据的并行快速排序</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;concurrent_stack.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sorter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Sorter</span><span class="p">()</span> <span class="o">:</span> <span class="n">max_thread_count</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">Sorter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">end_of_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                             <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">res</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">ChunkToSort</span> <span class="n">low</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">low</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">low</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">low</span><span class="p">.</span><span class="n">promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">chunks</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">low</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">max_thread_count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sorter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sort_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">r</span><span class="p">{</span><span class="n">do_sort</span><span class="p">(</span><span class="n">v</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">try_sort_chunk</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">l</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">ChunkToSort</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">sort_chunk</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChunkToSort</span><span class="o">&gt;&amp;</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">do_sort</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">try_sort_chunk</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChunkToSort</span><span class="o">&gt;</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sort_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">sort_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">end_of_data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">try_sort_chunk</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentStack</span><span class="o">&lt;</span><span class="n">ChunkToSort</span><span class="o">&gt;</span> <span class="n">chunks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_thread_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">end_of_data</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Sorter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{}.</span><span class="n">do_sort</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="基于任务划分">基于任务划分</h3>
<ul>
<li>如果数据动态生成或来自外部输入，上述划分方式都不适用，此时应该基于任务而非基于数据来划分。一种基于任务的划分方式是让线程针对性处理任务，对同一数据进行不同的操作，而不是都做相同的工作。这样线程是独立的，每个线程只需要负责完成总任务的某一部分。这就是 SoC（separation of concerns，关注点分离）设计原则</li>
<li>单线程中，如果有多个任务需要执行，只能依次执行任务，任务需要保存完成状态，并周期性地返回控制流给主循环。如果循环中添加了很多任务，就会导致程序变慢，对于一个用户发起的事件可能很久才会响应</li>
<li>这就是使用线程的原因，如果每个任务分离在线程上，保存状态和返回控制流给主循环这些事都抛给了操作系统，此时只需要关注任务本身，并且任务还可以并发运行，这样用户也能及时得到响应</li>
<li>但现实不一定这么顺利。如果任务都是独立的，线程之间不需要通信，那就很简单了。然而，这些后台运行的任务经常需要处理用户请求，因此就需要在完成时更新用户接口，以通知用户。此外，用户还可能想取消任务，这样就需要用户接口发送一条通知后台任务终止的消息。这些情况都要求周全的考虑和设计，以及合适的同步</li>
<li>虽然如此，但关注点仍然是分离的。用户接口线程线程仍处理用户接口，只是可能在被其他线程请求时要更新接口。同理，后台任务线程仍然关注自己的任务，只是允许被其他线程请求终止</li>
<li>多线程不是一定要 SoC，比如线程间有很多共享数据，或者需要互相等待。对于这样存在过多通信的线程，应该先找出通信的原因，如果所有的通信都关联同一个问题，合并成一个单线程来处理可能更好一些</li>
<li>基于任务划分不要求完全隔离，如果多个输入数据集合适用相同顺序的操作，可以把这个操作序列划分为多个子阶段来分配给每个线程，当一个线程完成操作后就把数据放进队列，供下一线程使用，这就是 pipeline。这也是另一种划分数据的方式，适用于操作开始前输入数据不是完全已知的情况，比如来自网络的数据或者扫描文件系统以识别要处理的文件</li>
<li>对于序列中耗时的操作，pipeline 就能提高响应速度。比如，如果操作包含 4 步，每步 5 秒，处理完一个数据就要 20秒，如果有 4 个包含整个操作的线程，虽然每 20 秒能处理 4 个数据，但每个数据仍要 20 秒处理。使用 pipeline，每个线程只处理一步，对于第一个数据需要 20 秒处理，之后处理每个数据都只需要 5 秒</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 非 pipeline：每 20 秒 4 个数据（每个数据仍要 20 秒）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">线程</span><span class="n">A</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="n">B</span><span class="err">：</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">6</span><span class="o">-</span> <span class="o">-</span><span class="mi">6</span><span class="o">-</span> <span class="o">-</span><span class="mi">6</span><span class="o">-</span> <span class="o">-</span><span class="mi">6</span><span class="o">-</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="n">C</span><span class="err">：</span><span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">7</span><span class="o">-</span> <span class="o">-</span><span class="mi">7</span><span class="o">-</span> <span class="o">-</span><span class="mi">7</span><span class="o">-</span> <span class="o">-</span><span class="mi">7</span><span class="o">-</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="n">D</span><span class="err">：</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">8</span><span class="o">-</span> <span class="o">-</span><span class="mi">8</span><span class="o">-</span> <span class="o">-</span><span class="mi">8</span><span class="o">-</span> <span class="o">-</span><span class="mi">8</span><span class="o">-</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// pipeline：第一个数据 20 秒，之后每个 5 秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">线程</span><span class="n">A</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span> <span class="o">-</span><span class="mi">6</span><span class="o">-</span> <span class="o">-</span><span class="mi">7</span><span class="o">-</span> <span class="o">-</span><span class="mi">8</span><span class="o">-</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="n">B</span><span class="err">：</span><span class="o">---</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span> <span class="o">-</span><span class="mi">6</span><span class="o">-</span> <span class="o">-</span><span class="mi">7</span><span class="o">-</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="n">C</span><span class="err">：</span><span class="o">---</span> <span class="o">---</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span> <span class="o">-</span><span class="mi">6</span><span class="o">-</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="n">D</span><span class="err">：</span><span class="o">---</span> <span class="o">---</span> <span class="o">---</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span> <span class="o">-</span><span class="mi">4</span><span class="o">-</span> <span class="o">-</span><span class="mi">5</span><span class="o">-</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>以视频解码为例，每 4 秒 120 帧，第一秒达到 120 帧，卡顿 3 秒后播放下一个 120 帧，这样远不如稳定的每秒 30 帧</li>
</ul>
<h2 id="影响并发代码性能的因素">影响并发代码性能的因素</h2>
<h3 id="处理器数量">处理器数量</h3>
<ul>
<li>处理器数量是影响多线程程序性能的首要因素，一个并发程序在不同环境下的表现迥异，而开发者的环境和用户很可能不同，比如开发环境是双核或四核系统，但用户是任意多核或单核，因此必须谨慎考虑可能的影响并对其测试</li>
<li>单个 16 核、4 个四核、16 个单核是近似的，都能并发运行 16 个线程，要利用好这点，开发的程序必须至少用上 16 个线程。如果少于 16 个，就会浪费处理器性能（不考虑系统运行其他程序的情况），另一方面，如果多于 16 个，就会让处理器浪费时间在切换线程上，这种情况就是 oversubscription</li>
<li>使用 <a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency"target="_blank" rel="external nofollow noopener noreferrer">hardware_concurrency<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 可以获取硬件支持的线程数，但要注意它不会考虑已运行在系统上的其他线程，如果多个线程都用它给出的线程数，就会导致巨大的 oversubscription。这个问题可以抛给 <a href="https://en.cppreference.com/w/cpp/thread/async"target="_blank" rel="external nofollow noopener noreferrer">std::async<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，它会适度处理并安排所有调用。这个问题也能用线程池解决</li>
<li>随着处理器数量增加，另一个影响性能的问题也随之而来，即多处理器尝试访问同一数据</li>
</ul>
<h3 id="乒乓缓存cache-ping-pong">乒乓缓存（cache ping-pong）</h3>
<ul>
<li>如果两个线程在不同处理器上并发执行，读取同一数据一般不会带来问题，数据将拷贝到它们的 cache，处理器可以同时处理。但如果一个线程修改数据，这个修改传给其他核的 cache 就需要花费时间，从而可能导致第二个处理器停止以等待改变传到内存硬件（取决于两个线程上的操作和这个操作使用的内存序）。从 CPU 指令的角度来看，这个操作慢到惊人，等价于数百个独立指令（具体取决于硬件的物理结构）</li>
</ul>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">n</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 任何线程都能调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 每次n自增，处理器都要确保 cache 中的拷贝是最新的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 修改值后再告知其他处理器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// fetch_add 是读改写操作，每次都要检索最新值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果另一线程在另一处理器运行此代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// n 的数据就要在两个处理器之间来回传递
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 这样 n 增加时两个处理器的 cache 才能有最新值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">task</span><span class="p">();</span>  <span class="c1">// 如果很快完成或者有很多处理器运行此代码，处理器就要互相等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一个处理器在更新值，另一个更新值的处理器就要等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 直到第一个更新完成并把改变传过来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这种情况就是 high contention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 反之处理器很少要互相等待的情况就是 low contention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在类似这样的循环中，n 的数据在 cache 之间来回传递
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这就是 cache ping-pong
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果处理器由于等待 cache 转移而挂起，就只能干等着而不能做任何工作。上例的情况可能不常见，但有一些和上例没有本质区别的常见情况，比如在循环中获取 mutex</li>
</ul>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 现在需要来回传递的是 m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">done_processing</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>要避免乒乓缓存，就要尽量减少多个线程对同一内存位置的竞争。但即使一个特定内存位置只能被一个线程访问，仍然可能存在乒乓缓存，原因就是伪共享</li>
</ul>
<h3 id="伪共享false-sharing">伪共享（false sharing）</h3>
<ul>
<li>处理器 cache 不是独立的，而是以 cache line 作为最小单位，一般为 32 或 64 字节，因此小数据可能位于同一 cache line。有时这是好事，如果一个线程访问的数据都位于同一 cache line，性能会比分散在多个 cache line 好。但如果 cache line 中的数据项不相关，需要被多个线程访问，就会导致性能问题</li>
<li>假如有一个 int 数组，一组线程频繁访问和更新其中的数据。通常 int 大小不超过一个 cache line，因此一个 cache line 可以存储多个数据项，此时即使每个线程只访问自己需要的数据，cache 硬件也会造成乒乓缓存。比如访问 0 号数据的线程要更新数据，cache line 的所有权就要被转移到运行这个线程的处理器</li>
<li>数据可能不共享，但 cache line 是共享的，这就是伪共享。这个问题的解决方案是，构造数据，让能被同一线程访问的数据项位于内存中的临近位置，让能被不同线程访问的数据在内存中相距很远。C++17 提供了 <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size"target="_blank" rel="external nofollow noopener noreferrer">std::hardware_destructive_interference_size<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 来指定当前编译目标伪共享的最大连续字节数，只要数据间隔大于此字节数就可以避免伪共享</li>
</ul>
<h3 id="data-proximity">data proximity</h3>
<ul>
<li>造成伪共享的原因是两个线程访问的数据过于接近，相应的，直接影响单线程的性能则是数据布局。如果单线程访问的数据分散在内存中，就类似位于不同的 cache line，如果在内存中十分靠近，就类似位于同一 cache line。如果数据是分散的，就需要从内存加载更多的 cache line 到处理器 cache，这就会增加内存访问延迟并降低性能</li>
<li>如果数据是分散的，一个包含当前线程数据的 cache line很可能会包含非当前线程的数据，极端情况下，cache 中将包含很多不需要的数据，这就会浪费宝贵的 cache 空间并增加处理器 cache miss 的概率，导致必须从主存获取数据。而这个数据可能曾在 cache 中保留过，但为了给其他数据让出空间必须从 cache 中移除</li>
<li>这看上去只对单线程很重要，但其实对多线程也很重要，原因在于任务切换（task switching）。如果线程数超过核数，就一定会有核要运行多线程，这就增加了 cache 的压力，因为为了避免伪共享必须确保不同的线程访问不同的 cache line，当处理器切换线程时，如果数据分散，很可能会重新载入 cache line。C++17 提供了<a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size"target="_blank" rel="external nofollow noopener noreferrer">std::hardware_constructive_interference_size<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 来指定保证同一 cache line 的最大连续字节数，如果数据尺寸小于此字节数就能降低 cache miss 的几率</li>
<li>如果线程数超过处理器核数，操作系统可能会调度线程，在某个时间片上给一个核，在下一个时间片上给另一个核，这就要求把第一个核的 cache 传给第二个，从而增加了时间开销。虽然操作系统一般会尽量避免这点，但如果发生了就会对性能造成影响</li>
<li>当大量线程准备运行而非等待时，就会经常出现任务切换问题，这种处理器在任务切换上花费大量时间的情况就是 oversubscription</li>
</ul>
<h3 id="oversubscription-超额申请">oversubscription 超额申请</h3>
<ul>
<li>线程经常花费时间来等待额外的 I/O、mutex 阻塞、条件变量，因此使用超过处理器核数的线程以确保没有闲置的处理器是合理的。但如果有过多的额外线程，操作系统确保为每个线程公平分配时间片，就会有沉重的任务切换负担。当一个任务重复而无限制地生成新线程，就会导致 oversubscription</li>
<li>如果生成的线程数过多的原因是数据划分，可以限制工作线程的数量。如果 oversubscription 是因为自然的工作划分，除了选择其他的划分方式，没有什么直接改善的办法。但选择合适的划分需要对目标平台有更多的了解，只有性能不可接受，而改变划分方式可以明显提高性能时才值得这样做</li>
<li>影响多线程代码性能的因素非常多，以上只是一些有明显可见影响的主要因素，比如乒乓缓存的开销在两个单核处理器和一个双核处理器上区别很大，即使两者有相同的CPU类型和时钟速度</li>
</ul>
<h2 id="适用多线程性能的数据结构">适用多线程性能的数据结构</h2>
<ul>
<li>如果有两个上千行列的矩阵相乘，现在要用多线程来优化计算。一般非稀疏矩阵可以用一个大的一维数组表示，矩阵的每行在数组中连续排列。这个计算需要三个数组，其中一个存储计算结果。为了优化性能，就要仔细考虑数据访问模式，尤其是向结果数组的写入</li>
<li>划分方式有很多，如果行列数超过处理器数，每个线程可以计算结果的某些行或列，或者一个子矩阵</li>
<li>访问相邻元素可以减少对 cache 的使用，以及降低伪共享的概率。如果让线程计算结果的某列，就需要依次访问左矩阵的行（最终读取整个左矩阵），并读取右矩阵某列。矩阵保存于一维数组，行是相邻的，但列不是，因此写入结果时，其他线程可能访问同一行的其他元素。为了避免伪共享，需要让每行元素所占的空间正好是 cache line 的数量</li>
<li>如果让线程计算结果的某行，就需要读取左矩阵的某行，并依次读取右矩阵的列（最终读取整个右矩阵）。此时线程按行写入结果，由于一维数组里矩阵行是连续存储的，这个连续内存块不用被其他线程访问，比起上面按列写入结果是一个改进，伪共享只可能发生于一个结果块的最后几个元素与下一个块的前几个元素</li>
<li>如果划分为子矩阵，可以看成先按列划分再按行划分，因此它和按列划分一样存在伪共享的可能。如果可以避免这个可能，这个划分就有一个明显的好处，即不需要读取整个源矩阵，因此计算子矩阵比计算行好一些。当然，如果性能非常重要，必须针对目标架构 profile 各种选项并检索相关领域的文献</li>
<li>对于其他数据结构的数据访问模式进行优化时，需要考虑的本质上与优化对数组的访问类似
<ul>
<li>调整线程间的数据分布，让同一线程访问的数据尽量紧密</li>
<li>尽量减少线程所需的数据量</li>
<li>依据 <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size"target="_blank" rel="external nofollow noopener noreferrer">std::hardware_destructive_interference_size<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，确保不同线程访问的数据距离足够远，以避免伪共享</li>
</ul>
</li>
<li>这些用在其他数据结构上并不容易，比如二叉树很难在子树以外的任何单元中再分割，并且二叉树的节点一般是动态分配的，从而会分布在堆的不同位置上。数据位于堆的不同位置不是什么特别的问题，但确实意味着处理器需要在 cache 中保存更多东西。不过这是有益的，如果多个线程要遍历树，就都需要访问树节点，如果树节点只包含保存数据的指针，处理器只要在需要时从内存加载数据，如果数据被需要它的线程修改了，这能避免节点数据本身和提供树结构的数据之间的伪共享带来的性能问题</li>
<li>用 mutex 保护数据也有类似问题。假如有一个类，它包含一个 mutex 和一些被保护的数据，如果 mutex 和数据在内存中很接近，这对获取 mutex 的线程是很理想的，为了修改 mutex，需要的数据可能已经跟着加载在处理器 cache 中了。但这也有一个缺点，如果其他线程尝试获取 mutex，就会需要访问那块内存</li>
<li>互斥锁的典型实现为，一个操作在 mutex 内存位置上以尝试获取 mutex 的读改写原子操作，如果 mutex 已锁定，就接着调用操作系统内核。这个读改写操作可能会导致，持有该 mutex 的线程的 cache 中保存的数据无效。这对于 mutex 不是问题，在 mutex 解锁之前线程不会接触 mutex，但如果 mutex 与数据共享同一 cache line，另一个线程尝试获取 mutex 时，持有 mutex 的线程就会受到性能影响</li>
<li>一个测试这种伪共享是否会带来影响的方法是，在能被并发访问的数据之间添加巨大的填充块。比如用如下方式测试 mutex 竞争问题</li>
</ul>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ProtectedData</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 使用超过一个 cache line 字节数的填充即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">padding</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">hardware_destructive_interference_size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 不支持 C++17 则可以 padding[65536];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Data</span> <span class="n">data_to_protect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>用如下方式测试数组数据伪共享，如果性能提高了就说明伪共享影响了性能，并且可以保留填充或者用其他方式重排数据访问来消除伪共享</li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Data</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">data_item1</span> <span class="n">d1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">data_item2</span> <span class="n">d2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">padding</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">hardware_destructive_interference_size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Data</span> <span class="n">some_array</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="并发设计的其他注意事项">并发设计的其他注意事项</h2>
<ul>
<li>除了上述问题，设计并发代码时还需要考虑异常安全和可扩展性。如果代码不是异常安全的，就可能导致破坏不变量或 race condition，或由于一个操作抛出异常导致程序意外终止。可扩展性指的是，性能会随着处理器核数的提升而提升，如果处理器核数是之前的 100 倍，则最理想的情况下性能也应该之前的 100 倍</li>
</ul>
<h3 id="并发算法的异常安全">并发算法的异常安全</h3>
<ul>
<li>并行算法比串行算法更注重异常问题。在串行算法中，如果一个操作抛出异常，只需要保证吞下此异常以避免资源泄漏或破坏不变量，它可以愉快地允许异常传播给调用者处理。但在并行算法中，许多操作运行在不同的线程上，异常就不允许传播，因为它在错误的调用栈上。如果新线程上的函数存在异常，程序就会终止</li>
<li>回顾以前提到的并行版本的 <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate"target="_blank" rel="external nofollow noopener noreferrer">std::accumulate<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，它就是非异常安全的，代码可能抛出异常的位置如下</li>
</ul>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">accumulate_block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>  <span class="c1">// 可能抛异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>  <span class="c1">// 此时没做任何事，抛异常无影响
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num_threads</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">hardware_threads</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">num_threads</span><span class="p">);</span>  <span class="c1">// 仍未做任何事，抛异常无影响
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>                       <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>  <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 下面创建 std::thread，抛异常就导致析构对象，并调用 std::terminate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 终止程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{},</span> <span class="n">block_start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="n">block_end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">    <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// accumulate_block::operator() 调用的 std::accumulate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 可能抛异常，此时抛异常造成问题同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 最后调用 std::accumulate 可能抛异常，但不引发大问题，因为所有线程已 join
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">init</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>上面已经分析了所有可能抛出异常的位置，下面来处理这些问题。新线程想做的是返回计算结果，但可能抛出异常导致 <a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 析构，而析构没被 join 的 <a href="https://en.cppreference.com/w/cpp/thread/thread"target="_blank" rel="external nofollow noopener noreferrer">std::thread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 将导致程序终止。解决这个问题很简单，结合使用 <a href="https://en.cppreference.com/w/cpp/thread/packaged_task"target="_blank" rel="external nofollow noopener noreferrer">std::packaged_task<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 和 <a href="https://en.cppreference.com/w/cpp/thread/future"target="_blank" rel="external nofollow noopener noreferrer">std::future<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，再把工作线程的异常抛出到主线程，让主线程处理即可</li>
</ul>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">accumulate_block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num_threads</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">hardware_threads</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">fts</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 改用 std::future 获取值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用 std::packaged_task 替代直接创建 std::thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pt</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">    <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pt</span><span class="p">),</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">last_res</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">res</span> <span class="o">+=</span> <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">+=</span> <span class="n">last_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不过 try-catch 很难看，并且导致了重复代码（正常控制流和 catch 块都对线程执行 join），因此可以用 RAII 来处理</li>
</ul>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">threads_guard</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">threads_guard</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">threads_</span><span class="p">(</span><span class="n">threads</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">threads_guard</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">accumulate_block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num_threads</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">hardware_threads</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">fts</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">threads_guard</span> <span class="n">g</span><span class="p">{</span><span class="n">threads</span><span class="p">};</span>  <span class="c1">// threads 元素析构时自动 join
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pt</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">    <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pt</span><span class="p">),</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">last_res</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">+=</span> <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span> <span class="o">+=</span> <span class="n">last_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++20 引入了能自动析构的 <a href="https://en.cppreference.com/w/cpp/thread/jthread"target="_blank" rel="external nofollow noopener noreferrer">std::jthread<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">accumulate_block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num_threads</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">hardware_threads</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">fts</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pt</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">    <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pt</span><span class="p">),</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">last_res</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">+=</span> <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span> <span class="o">+=</span> <span class="n">last_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>更优雅的方式是使用 <a href="https://en.cppreference.com/w/cpp/thread/async"target="_blank" rel="external nofollow noopener noreferrer">std::async<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_chunk_size</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">max_chunk_size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span> <span class="n">mid_point</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">parallel_accumulate</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid_point</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 递归调用如果抛出异常，std::async 创建的 std::future 将在异常传播时被析构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果异步任务抛出异常，get 就会捕获异常并重新抛出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">l</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="可扩展性与阿姆达尔定律amdahls-law">可扩展性与阿姆达尔定律（Amdahl’s law）</h3>
<ul>
<li>可扩展性代表了程序对处理器的利用率。单线程程序就是不可扩展的，因为处理器增加完全不能提高单线程程序的性能。对于多线程程序，线程经常需要花费时间等待（等待其他线程、获取 mutex、修改条件变量、完成 I/O 操作&hellip;&hellip;），一种简化看待多线程程序的方式是将其分为串行和并行部分，由此可以得到如下公式，即阿姆达尔定律</li>
</ul>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">S</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">a</span> <span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="c1">// a 为串行部分占比，N 为处理器倍数，S 为性能倍数
</span></span></span><span class="line"><span class="cl"><span class="c1">// 正常情况下 S &lt; 1 / a，最理想的情况是 a 为 0，S = N
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="用多线程隐藏延迟lantency">用多线程隐藏延迟（lantency）</h3>
<ul>
<li>如果在线程等待期间让系统做一些有用的事，就相当于隐藏了等待。如果只有和处理器单元一样多的线程，阻塞就意味着浪费 CPU 时间，因此可以利用这个时间去运行额外的线程。比如一个用 pipeline 划分工作的病毒扫描程序，一个线程检索文件系统并将文件放入队列，这是一个费时的 I/O 操作，因此同时可以让另一线程从队列获取文件名，加载并扫描文件</li>
<li>利用空闲的 CPU 时间也可能不需要运行额外的线程。比如，如果一个线程因为等待 I/O 操作而阻塞，使用异步 I/O 就是合理的，当 I/O 操作异步运行在后台时，线程就能做有用的工作。又比如，一个线程等待另一线程执行一个操作时，与其阻塞，不如自己执行操作（如lock-free queue）。更极端的例子是，如果线程等待一个未被任何线程启动的任务完成，这个线程可能自己执行此任务，或执行另一个未完成的任务</li>
</ul>
<h3 id="用并发提高响应度responsiveness">用并发提高响应度（responsiveness）</h3>
<ul>
<li>添加线程不一定是为了确保使用所有可用的处理器，有时是为了确保及时处理外部事件，以提高系统响应度。现代 GUI 框架大多是事件驱动的，为了确保处理所有事件和消息，GUI 程序一般包含一个如下循环</li>
</ul>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">event_data</span> <span class="n">event</span> <span class="o">=</span> <span class="n">get_event</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">quit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">process</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果是单线程程序，就很难编写长期运行的任务。为了确保即使响应用户输入，就要以合理频率调用 get_event 和 process，这意味着任务要被周期性悬挂（suspend）并把控制流返回给事件循环，或者在代码中的一个适当点调用 get_event 和 process，二者任一都会复杂化任务实现</li>
<li>通过 SoC（separation of concerns）可以把很长的任务放在一个全新的线程上，而让 GUI 线程来处理事件，线程可以通过简单的机制进行通信，而不需要混入处理事件的代码，这样即使任务耗费很长时间，用户线程也总能及时响应事件</li>
</ul>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">task_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">task_cancelled</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">gui_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">event_data</span> <span class="n">event</span> <span class="o">=</span> <span class="n">get_event</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">quit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">process</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">task</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">task_complete</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">task_cancelled</span><span class="p">)</span> <span class="n">do_next_operation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">task_cancelled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">perform_cleanup</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">post_gui_event</span><span class="p">(</span><span class="n">task_complete</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="k">const</span> <span class="n">event_data</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">start_task</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">task_cancelled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">task_thread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">stop_task</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">task_cancelled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">task_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">task_complete</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">task_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">display_results</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="实践">实践</h2>
<ul>
<li>下面为标准库的三个算法实现并行版本，这些实现仅是为了阐述技术的运用，而不是最先进高效的实现。更先进的实现可以在学术文献或专业的多线程库（如 <a href="https://github.com/intel/tbb"target="_blank" rel="external nofollow noopener noreferrer">Intel 的 Threading Building Blocks<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>） 中找到</li>
</ul>
<h3 id="并行版-stdfor_eachhttpsencppreferencecomwcppalgorithmfor_each">并行版 <a href="https://en.cppreference.com/w/cpp/algorithm/for_each"target="_blank" rel="external nofollow noopener noreferrer">std::for_each<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/for_each"target="_blank" rel="external nofollow noopener noreferrer">std::for_each<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 会按顺序依次作用于每个元素，而并行版不保证顺序，元素最好被并发处理，为此需要把元素划分给每个线程。实际上，并行版 <a href="https://en.cppreference.com/w/cpp/algorithm/for_each"target="_blank" rel="external nofollow noopener noreferrer">std::for_each<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 与并行版 <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate"target="_blank" rel="external nofollow noopener noreferrer">std::accumulate<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>的实现思路基本一样：使用 <a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency"target="_blank" rel="external nofollow noopener noreferrer">hardware_concurrency<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 决定线程数，使用连续数据块避免伪共享，使用 <a href="https://en.cppreference.com/w/cpp/thread/packaged_task"target="_blank" rel="external nofollow noopener noreferrer">std::packaged_task<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 和 <a href="https://en.cppreference.com/w/cpp/thread/future"target="_blank" rel="external nofollow noopener noreferrer">std::future<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 在线程间传递异常</li>
</ul>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">parallel_for_each</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Func</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num_threads</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">hardware_threads</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">fts</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pt</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pt</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">fts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>  <span class="c1">// 只是为了传递异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>也可以使用 <a href="https://en.cppreference.com/w/cpp/thread/async"target="_blank" rel="external nofollow noopener noreferrer">std::async<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 来简化实现</li>
</ul>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">parallel_for_each</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Func</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">min_per_thread</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">Iterator</span> <span class="n">mid_point</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parallel_for_each</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">Func</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid_point</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">parallel_for_each</span><span class="p">(</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">l</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="并行版-stdfindhttpsencppreferencecomwcppalgorithmfind">并行版 <a href="https://en.cppreference.com/w/cpp/algorithm/find"target="_blank" rel="external nofollow noopener noreferrer">std::find<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/find"target="_blank" rel="external nofollow noopener noreferrer">std::find<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的不同之处在于，只要找到目标值就应该停止继续查找。在并行版本中，一个线程找到了值，不仅自身要停止继续查找，还应该通知其他线程停止，这点可以使用一个原子变量作为标记来实现</li>
<li>有两种可选方式来返回值和传播异常，一是使用 <a href="https://en.cppreference.com/w/cpp/thread/future"target="_blank" rel="external nofollow noopener noreferrer">std::future<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 数组和 <a href="https://en.cppreference.com/w/cpp/thread/packaged_task"target="_blank" rel="external nofollow noopener noreferrer">std::packaged_task<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 将返回值和异常交给主线程处理，二是使用 <a href="https://en.cppreference.com/w/cpp/thread/promise"target="_blank" rel="external nofollow noopener noreferrer">std::promise<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 直接设置最终结果。如果想在首个异常上终止（即使没有处理完所有元素）则使用 <a href="https://en.cppreference.com/w/cpp/thread/promise"target="_blank" rel="external nofollow noopener noreferrer">std::promise<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，如果想让其他线程继续搜索则使用 <a href="https://en.cppreference.com/w/cpp/thread/packaged_task"target="_blank" rel="external nofollow noopener noreferrer">std::packaged_task<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 保存所有异常，并在没有找到目标值时重新抛出其中一个异常。这里选择使用行为更接近 <a href="https://en.cppreference.com/w/cpp/algorithm/find"target="_blank" rel="external nofollow noopener noreferrer">std::find<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的 <a href="https://en.cppreference.com/w/cpp/thread/promise"target="_blank" rel="external nofollow noopener noreferrer">std::promise<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Iterator</span> <span class="n">parallel_find</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">match</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">find_element</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="n">match</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;*</span> <span class="n">res</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;*</span> <span class="n">done_flag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(;</span> <span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done_flag</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">();</span> <span class="o">++</span><span class="n">begin</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span> <span class="o">==</span> <span class="n">match</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">res</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="n">begin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">done_flag</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">res</span><span class="o">-&gt;</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">          <span class="n">done_flag</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num_threads</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">hardware_threads</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">done_flag</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="p">(</span><span class="n">find_element</span><span class="p">{},</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="o">&amp;</span><span class="n">done_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">find_element</span><span class="p">{}(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_flag</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>也可以使用 <a href="https://en.cppreference.com/w/cpp/thread/async"target="_blank" rel="external nofollow noopener noreferrer">std::async<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 实现</li>
</ul>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Iterator</span> <span class="n">parallel_find_impl</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">match</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">done_flag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">min_per_thread</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done_flag</span><span class="p">.</span><span class="n">load</span><span class="p">();</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">==</span> <span class="n">match</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">done_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Iterator</span> <span class="n">mid_point</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;</span> <span class="n">async_res</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parallel_find_impl</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mid_point</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">done_flag</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Iterator</span> <span class="n">direct_res</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">parallel_find_impl</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">mid_point</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">done_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">direct_res</span> <span class="o">==</span> <span class="n">mid_point</span> <span class="o">?</span> <span class="n">async_res</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">:</span> <span class="n">direct_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">done_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Iterator</span> <span class="n">parallel_find</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">match</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">done_flag</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">parallel_find_impl</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">done_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="并行版-stdpartial_sumhttpsencppreferencecomwcppalgorithmpartial_sum">并行版 <a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum"target="_blank" rel="external nofollow noopener noreferrer">std::partial_sum<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum"target="_blank" rel="external nofollow noopener noreferrer">std::partial_sum<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 会依次累加元素的和（默认是加，也可以是其他二元操作）</li>
</ul>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">partial_sum</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hi&#34;</span><span class="p">),</span>  <span class="c1">// 输出到的迭代器起始位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span>  <span class="c1">// 使用的二元运算符，不指定则默认累加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>  <span class="c1">// 输出 hi13610
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>其实现为</li>
</ul>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">OutputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">OutputIt</span> <span class="n">partial_sum</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutputIt</span> <span class="n">d_first</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">d_first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIt</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">d_first</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sum</span><span class="p">),</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*++</span><span class="n">d_first</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">++</span><span class="n">d_first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>实现并行版本时，第一种划分方式就是传统的按块划分</li>
</ul>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="c1">// 输入 9 个 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// 划分为三部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 得到三个部分的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将第一部分的尾元素（即 3）加到第二部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 再将第二部分的尾元素（即 6）加到第三部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>由于需要线程间同步，这个实现不容易简单地用 <a href="https://en.cppreference.com/w/cpp/thread/async"target="_blank" rel="external nofollow noopener noreferrer">std::async<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 重写</li>
</ul>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">parallel_partial_sum</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Iterator</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">process_chunk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;*</span> <span class="n">previous_end_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;*</span> <span class="n">end_value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">partial_sum</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">begin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">previous_end_value</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 不是第一个块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">value_type</span> <span class="n">addend</span> <span class="o">=</span> <span class="n">previous_end_value</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="o">*</span><span class="n">last</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">end_value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">end_value</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="p">[</span><span class="n">addend</span><span class="p">](</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="n">item</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">end_value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">end_value</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">);</span>  <span class="c1">// 是第一个块则可以为下个块更新尾元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果抛出异常则存储到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// std::promise，异常会传播给下一个块（获取这个块的尾元素时）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">end_value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">end_value</span><span class="o">-&gt;</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">throw</span><span class="p">;</span>  <span class="c1">// 异常最终传给最后一个块，此时再抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">num_threads</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">hardware_threads</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// end_values 存储块内尾元素值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;&gt;</span> <span class="n">end_values</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// prev_end_values 检索前一个块的尾元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;&gt;</span> <span class="n">prev_end_values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">prev_end_values</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Iterator</span> <span class="n">block_last</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_last</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 指向尾元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="p">(</span><span class="n">process_chunk</span><span class="p">{},</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">prev_end_values</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="o">&amp;</span><span class="n">end_values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">prev_end_values</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">end_values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_future</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span> <span class="n">final_element</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">final_element</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">process_chunk</span><span class="p">{}(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">final_element</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">prev_end_values</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果处理器核数非常多，就没必要使用上面的方式了，因为还有并发度更高的方式，即隔一定距离计算，每轮计算完成，下一轮计算使用的距离变为之前的两倍。这种方式不再需要进一步同步，因为所有中间的结果都直接传给了下一个需要这些结果的处理器，但实际上很少有处理器可以在多条数据上同时执行同一条指令（即 SIMD），因此必须为通用情况设计代码，在每步操作上显式同步线程，比如使用 barrier 的同步机制，直到所有线程到达 barrier 时才能继续执行下一步</li>
</ul>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="c1">// 输入 9 个 1
</span></span></span><span class="line"><span class="cl"><span class="c1">// 先让距离为 1 的元素相加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 再让距离为 2 的元素相加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">4</span> <span class="mi">4</span> <span class="mi">4</span> <span class="mi">4</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 再让距离为 4 的元素相加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 再让距离为 8 的元素相加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>C++ Concurrency in Action [11] | CH11 Testing and Debugging Multithreaded Applications</title><link>https://jianye0428.github.io/posts/ch11_testing_and_debugging_multithreaded_application/</link><pubDate>Tue, 28 Nov 2023 18:58:58 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ch11_testing_and_debugging_multithreaded_application/</guid><description><![CDATA[<h2 id="并发相关的-bug-类型">并发相关的 bug 类型</h2>
<ul>
<li>与并发直接相关的 bug 一般可以分为两大类，一是非预期阻塞，二是 race condition</li>
<li>非预期阻塞包含以下几种情况
<ul>
<li>死锁（deadlock）：两个线程互相等待，导致均无法完成工作。最明显的情况是，如果负责用户界面的线程死锁，界面将失去响应。也有一些情况是，界面可以保持响应，但一些任务无法完成，比如搜索不返回结果，或者文档不被打印</li>
<li>活锁（livelock）：类似于死锁，不同的是线程不是阻塞等待，而是在忙碌于一个检查循环中，比如自旋锁。严重时，其表现的症状就和死锁一样，比如程序不进行，此外由于线程仍在运行，CPU 会处于高使用率状态。在不太严重的情况下，活锁最终会被操作系统的随机调度解决，但仍然会造成任务的长时间延迟，并且延迟期间 CPU 使用率很高</li>
<li>I/O 阻塞或其他外部输入：如果线程阻塞等待外部输入，就无法继续处理工作。因此如果一个线程执行的任务会被其他线程等待，就不要让这个线程等待外部输入</li>
</ul>
</li>
<li>许多死锁和活锁都是由于 race condition 造成的，不过很大一部分 race condition 是良性的，比如要处理任务队列的下一个任务，决定用哪个工作线程去处理是无关紧要的。造成问题的 race condtion 包含以下几种情况
<ul>
<li>数据竞争（data race）：数据竞争是一种特定类型的 race condtion，由于对共享内存位置的不同步的并发访问，它将导致未定义行为。数据竞争通常发生于不正确地使用原子操作来同步线程，或者不加锁访问共享数据</li>
<li>被破坏的不变量（broken invariant）：它可以表现为空悬指针（其他线程可以删除被访问的数据）、随机内存损坏（由于局部更新导致线程读取的值不一致）、双重释放（比如两个线程弹出队列的同一个数据）等。不变量的破坏是暂时的，因为它是基于值的。如果不同线程上的操作要求以一个特定顺序执行，不正确的同步就会导致 race condition，有时就会违反这个执行顺序</li>
<li>生命周期问题（lifetime issue）：这个问题可以归入 broken invariant，但这里单独提出来。这个问题表现为，线程比其访问的数据活得更长。一般这个问题发生于线程引用了超出范围的局部变量，但也不仅限于此，比如调用 <a href="https://en.cppreference.com/w/cpp/thread/thread/join"target="_blank" rel="external nofollow noopener noreferrer">join<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，要考虑异常抛出时，调用不被跳过</li>
</ul>
</li>
<li>通常可以通过调试器来确认死锁和活锁的线程以及它们争用的同步对象。对于数据竞争、不变量的破坏、生命周期问题，可见症状（如随机崩溃或不正确的输出）可以显示在代码的任何位置，代码可能重写系统其他部分使用的内存，并且很久以后才被触及，这个错误可能在程序执行的后期出现在与 bug 代码完全无关的位置。这就是共享内存的真正祸端，无论如何限制线程对数据的访问和确保正确的同步，任何线程都可以重写其他线程中的数据</li>
</ul>
<h2 id="定位-bug-的方法">定位 bug 的方法</h2>
<h3 id="code-review">code review</h3>
<ul>
<li>让其他人或自己过段时间来 code review，因为对代码不熟悉，需要思考代码的工作方式，看待的角度也不一样，更有可能发现潜在的问题。多线程代码一般有以下问题
<ul>
<li>哪些数据需要被保护，以避免并发访问</li>
<li>如何确保数据得到保护</li>
<li>其他线程此时可能运行到代码的哪个位置</li>
<li>这个线程持有哪些锁</li>
<li>其他线程持有哪些锁</li>
<li>在这个线程中完成的操作和另一个线程中完成的操作之间是否有任何排序要求，如何执行这些要求</li>
<li>这个线程读的数据是否仍然有效，是否可能被其他线程修改过</li>
<li>假设另一个线程在修改数据，这意味着什么，如何确保这种情况永远不会发生</li>
</ul>
</li>
</ul>
<h3 id="测试">测试</h3>
<ul>
<li>测试多线程程序的困难在于，具体的线程调度顺序是不确定的，对于相同的输入，得到的结果却不一定相同，结果可能有时是正确的，有时是错误的。因此存在潜在的 race condition 也不意味着总会得到失败的结果，有时可能也会成功</li>
<li>由于重现并发相关的 bug 很困难，所以值得仔细设计测试。最好让每个测试运行最小数量的代码，这样在测试失败时可以最好地隔离出错误代码。比如测试一个并发队列，分别测试并发的 push 和 pop 的工作，就直接比测试整个队列的功能要好</li>
<li>为了验证问题是否与并发相关，应该从测试中消除并发性。多线程中的 bug 并不意味着一定是并发相关的，如果一个问题在单线程中也总是出现，这就是一个普通的 bug，而不是并发相关的 bug。如果一个问题在单核系统中消失，而在多核或多处理器系统中总会出现，一般这就可能是一个 race condition，或同步、内存序相关的问题</li>
<li>测试用例
<ul>
<li>单线程调用 push() 或 pop()，以验证 queue 的基本功能</li>
<li>空 queue，一个线程 push()，另一个线程 pop()</li>
<li>空 queue，多线程 push()</li>
<li>满 queue，多线程 push()</li>
<li>空 queue，多线程 pop()</li>
<li>满 queue，多线程 pop()</li>
<li>有部分数据但不够所有线程用的 queue，多线程 pop()</li>
<li>空 queue，一个线程 pop()，多线程 push()</li>
<li>满 queue，一个线程 pop()，多线程 push()</li>
<li>空 queue，多线程 pop()，多线程 push()</li>
<li>满 queue，多线程 pop()，多线程 push()</li>
</ul>
</li>
<li>测试环境
<ul>
<li>多线程在每种 case 中具体指多少线程 (3, 4, 1,024?)</li>
<li>是否有足够的处理器，让每个线程运行在自己的核上</li>
<li>在哪些处理器架构上进行测试</li>
<li>如何合理对测试中的 while 部分 suitable scheduling</li>
</ul>
</li>
<li>一般满足以下条件的代码就是易于测试的，这些条件单线程和多线程中同样适用
<ul>
<li>每个函数和类的责任是清晰的</li>
<li>函数简明扼要（short and to the point）</li>
<li>测试可以完全控制被测代码所在环境</li>
<li>执行特定操作的被测代码在系统中是紧密而非分散的</li>
<li>代码在写下之前已被考虑过如何测试</li>
</ul>
</li>
<li>为了测试设计并发代码的一个最好方法是消除并发，如果可以把代码分解成负责线程间通信路径的部分，以及在单线程中操作通信数据的部分，就可以极大地简化问题。对于操作通信数据的部分就可以用常规的单线程技术测试，对于负责线程间通信的部分，代码小了很多，测试也更容易</li>
</ul>
<h3 id="多线程测试技术">多线程测试技术</h3>
<ul>
<li>第一种测试技术是压力测试，随着代码运行次数的增加，bug 出现的几率也更高，如果代码运行十亿次都通过，代码就很可能是没有问题的。如果测试是细粒度的（fine-grained），比如前面对并发队列的测试，压力测试就更可靠。如果粒度非常大，可能的组合也非常多，即使十亿次的测试的结果也不算可靠</li>
<li>压力测试的缺点是，如果测试本来就保证了问题不会发生，那么无论测试多少次都不会出现失败的情况，这就会造成误导。比如在单核系统上测试多线程程序，race condition 和乒乓缓存的问题根本不会出现，但这不表示这个程序在多核系统上是没问题的。又比如，不同处理器架构提供了不同的同步和内存序工具，在 x86 和 x86-64 架构上，无论使用 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"target="_blank" rel="external nofollow noopener noreferrer">memory_order_relaxed<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 还是 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order"target="_blank" rel="external nofollow noopener noreferrer">memory_order_seq_cst<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 内存序，原子 load 操作总是一样的，这意味着在 x86 架构上使用 relaxed 语义总是可行的，但如果换成细粒度内存序指令的系统（比如 SPARC）就会失败</li>
<li>第二种测试技术是组合仿真测试（combination simulation testing），即使用一个特殊的软件来仿真真实的运行时环境。仿真软件将记录数据访问、锁定、原子操作的序列，然后使用 C++ 内存模型的规则来重复运行所有可能的操作组合，以确定 race condition 和死锁</li>
<li>虽然这种详尽的组合测试可以保证找到设计所要检测的所有问题，但会花费大量时间，因为组合的数量随线程 数和每个线程执行的操作数呈指数增长，它最好用于单个代码片段的细粒度测试，而非用于整个程序。这种技术的另一个明显缺点是，它要求访真软件能处理代码中的操作</li>
<li>第三种测试技术是使用专门的库。比如共享数据通常会用 mutex 保护，如果在访问数据时能检查哪些 mutex 被锁定了，就能验证线程在访问数据时是否锁定了相应的 mutex，如果没有锁定就报告失败。库实现也能记录上锁的顺序，如果另一个线程对同一个 mutex 以不同顺序上锁，这就会被记录为潜在的死锁</li>
<li>另一种类型的库是，同步原语的实现允许测试编写者在多线程等待时，可以控制哪个线程来获得锁，或者哪个线程被 <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one"target="_blank" rel="external nofollow noopener noreferrer">notify_one<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 通知。这就允许设置特定方案，来验证代码是否在这些方案中按预期运行</li>
<li>一些测试工具已经作为标准库实现的一部分提供了，其他的则可以基于标准库的部分手动实现</li>
</ul>
<h3 id="构建多线程测试代码">构建多线程测试代码</h3>
<ul>
<li>多线程测试代码可以分为以下几部分
<ul>
<li>必须先执行的总体设置</li>
<li>必须运行在每个线程上的线程特定的设置</li>
<li>要并发运行在每个线程上的代码</li>
<li>并发执行结束后的状态断言</li>
</ul>
</li>
<li>如下是对一个队列的测试代码</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">test_concurrent_push_and_pop_on_empty_queue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>  <span class="c1">// 总体设置：先创建一个队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">go</span><span class="p">,</span> <span class="n">push_ready</span><span class="p">,</span> <span class="n">pop_ready</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">ready</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">push_done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pop_done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">push_done</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>  <span class="c1">// 指定异步策略保证每个任务运行在自己的线程上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">[</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">ready</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">push_ready</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">push_ready</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="n">ready</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="c1">// 线程特定的设置：存入一个 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">pop_done</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">ready</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pop_ready</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pop_ready</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">ready</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">q</span><span class="p">.</span><span class="n">try_pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">push_ready</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>  <span class="c1">// 等待开始测试的通知
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pop_ready</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>   <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">go</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>                  <span class="c1">// 通知开始真正的测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">push_done</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>                 <span class="c1">// 获取结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">pop_done</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span>    <span class="c1">// 获取结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">go</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>  <span class="c1">// 避免空悬指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">throw</span><span class="p">;</span>           <span class="c1">// 再抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="测试多线程代码的性能">测试多线程代码的性能</h3>
<ul>
<li>使用并发的一个主要目的就是利用多核处理器来提高程序性能，因此测试代码来确保性能确实提升了是很重要的。性能相关的一个主要方面就是可扩展性，性能应该随着核数一起提升。在测试多线程代码性能时，最好在尽可能多的不同配置上进行测试</li>
</ul>
]]></description></item><item><title>C++ Concurrency in Action [10] | CH10 Parallel Algorithm</title><link>https://jianye0428.github.io/posts/ch10_parallel_algorithm/</link><pubDate>Tue, 28 Nov 2023 18:58:34 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ch10_parallel_algorithm/</guid><description><![CDATA[<h2 id="执行策略execution-policyhttpsencppreferencecomwcppalgorithmexecution_policy_tag_t"><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">执行策略（execution policy）<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h2>
<ul>
<li>C++17 对标准库算法重载了并行版本，区别是多了一个指定执行策略的参数</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag"target="_blank" rel="external nofollow noopener noreferrer">std::execution::par<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 表示允许多线程并行执行此算法，注意这是一个权限（permission）而非强制要求（requirement），此算法依然可以被单线程执行</li>
<li>另外，如果指定了执行策略，算法复杂度的要求也更宽松，因为并行算法为了利用好系统的并行性通常要做更多工作。比如把工作划分给 100 个处理器，即使总工作是原来的两倍，也仍然能获得原来的五十倍的性能</li>
<li><a href="https://en.cppreference.com/w/cpp/header/execution"target="_blank" rel="external nofollow noopener noreferrer">&lt;execution&gt;<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中指定了如下执行策略类</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">sequenced_policy</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">parallel_policy</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">parallel_unsequenced_policy</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">unsequenced_policy</span>  <span class="c1">// C++20
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>并指定了对应的全局对象</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">seq</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par_unseq</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">unseq</span>  <span class="c1">// C++20
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果使用执行策略，算法的行为就会受执行策略影响，影响方面包括：算法复杂度、抛异常时的行为、算法步骤的执行位置（where）、方式（how）、时刻（when）</li>
<li>除了管理并行执行的调度开销，许多并行算法会执行更多的核心操作（交换、比较、使用函数对象等），这样可以减少总的实际消耗时间，从而全面提升性能。这就是算法复杂度受影响的原因，其具体改变因算法不同而异</li>
<li>在不指定执行策略时，如下对算法的调用，抛出的异常会被传播</li>
</ul>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="nf">my_exception</span><span class="p">();</span> <span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>而指定执行策略时，如果算法执行期间抛出异常，则行为结果由执行策略决定。如果有任何未捕获的异常，执行策略将调用 <a href="https://en.cppreference.com/w/cpp/error/terminate"target="_blank" rel="external nofollow noopener noreferrer">std::terminate<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 终止程序，唯一可能抛出异常的情况是，内部操作不能获取足够的内存资源时抛出 <a href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc"target="_blank" rel="external nofollow noopener noreferrer">std::bad_alloc<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。如下操作将调用 <a href="https://en.cppreference.com/w/cpp/error/terminate"target="_blank" rel="external nofollow noopener noreferrer">std::terminate<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 终止程序</li>
</ul>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">              <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="nf">my_exception</span><span class="p">();</span> <span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不同的执行策略的执行方式也不相同。执行策略会指定执行算法步骤的代理，可以是常规线程、矢量流、GPU 线程或其他任何东西。执行策略也会指定算法步骤运行的顺序限制，比如是否要以特定顺序运行、不同算法步骤的一部分是否可以互相交错或并行运行等。下面对不同的执行策略进行详细解释</li>
</ul>
<h3 id="stdexecutionsequenced_policyhttpsencppreferencecomwcppalgorithmexecution_policy_tag_t"><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::sequenced_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::sequenced_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略要求可以不（may not）并行执行，所有操作将执行在一个线程上。但它也是执行策略，因此与其他执行策略一样会影响算法复杂度和异常行为</li>
<li>所有执行在一个线程上的操作必须以某个确定顺序执行，因此这些操作是不能互相交错的。但不规定具体顺序，因此对于不同的函数调用可能产生不同的顺序</li>
</ul>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把 1-1000 存入容器，存入顺序可能是顺序也可能是乱序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">              <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="o">++</span><span class="n">n</span><span class="p">;</span> <span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>因此 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::sequenced_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略很少要求算法使用迭代器、值、可调用对象，它们可以自由地使用同步机制，可以依赖于同一线程上调用的操作，尽管不能依赖于这些操作的顺序</li>
</ul>
<h3 id="stdexecutionparallel_policyhttpsencppreferencecomwcppalgorithmexecution_policy_tag_t"><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略提供了基本的跨多个线程的并行执行，操作可以执行在调用算法的线程上，或执行在由库创建的线程上，在一个给定线程上的操作必须以确定顺序执行，并且不能相互交错。同样这个顺序是未指定的，对于不同的调用可能会有不同的顺序。一个给定的操作将在一个固定的线程上运行完整个周期</li>
<li>因此 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略对于迭代器、值、可调用对象的使用就有一定要求，它们在并行调用时不能造成数据竞争，并且不能依赖于统一线程上的其他操作，或者说只能依赖于不运行在同一线程上的其他操作</li>
<li>大多数情况都可以使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略</li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>只有在元素之间有特定顺序或对共享数据的访问不同步时，它才有问题</li>
</ul>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>  <span class="c1">// 如果多个线程执行 lambda 就会对 n 产生数据竞争
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>因此使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略时，应该事先考虑可能出现的未定义行为。可以用 mutex 或原子变量来解决竞争问题，但这就影响了并发性。不过这个例子只是为了阐述此情况，一般使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略时都是允许同步访问共享数据的</li>
</ul>
<h3 id="stdexecutionparallel_unsequenced_policyhttpsencppreferencecomwcppalgorithmexecution_policy_tag_t"><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_unsequenced_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_unsequenced_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略提供了最大可能的并行化，代价是对算法使用的迭代器、值和可调用对象有最严格的的要求</li>
<li>使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_unsequenced_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略的算法允许以无序的方式在任意未指定的线程中执行，并且在每个线程中彼此不排序。也就是说，操作可以在单个线程上互相交错，同一线程上的第二个操作可以开始于第一个操作结束前，并且可以在线程间迁移，一个给定的操作可以开始于一个线程，运行于另一线程，而完成于第三个线程</li>
<li>使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t"target="_blank" rel="external nofollow noopener noreferrer">std::execution::parallel_unsequenced_policy<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 策略时，提供给算法的迭代器、值、可调用对象上的操作不能使用任何形式的同步，也不能调用与其他代码同步的任何函数。这意味着操作只能作用于相关元素，或任何基于这些元素的可访问数据，并且不能修改任何线程间或元素间的共享数据</li>
</ul>
<h2 id="标准库并行算法">标准库并行算法</h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm"target="_blank" rel="external nofollow noopener noreferrer">&lt;algorithm&gt;<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 和 <a href="https://en.cppreference.com/w/cpp/header/numeric"target="_blank" rel="external nofollow noopener noreferrer">&lt;numberic&gt;<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中的大部分算法都重载了并行版本。<a href="https://en.cppreference.com/w/cpp/algorithm/accumulate"target="_blank" rel="external nofollow noopener noreferrer">std::accumlate<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 没有并行版本，但 C++17 提供了 <a href="https://en.cppreference.com/w/cpp/algorithm/reduce"target="_blank" rel="external nofollow noopener noreferrer">std::reduce<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果常规算法有并行版的重载，则并行版对常规算法原有的所有重载都有一个对应重载版本</li>
</ul>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">RandomIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">RandomIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomIt</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">RandomIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Compare</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">RandomIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 并行版对应有两个重载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">RandomIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">RandomIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomIt</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">RandomIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Compare</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">RandomIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomIt</span> <span class="n">last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>但并行版的重载对部分算法有一些区别，如果常规版本使用的是输入迭代器（input iterator）或输出迭代器（output iterator），则并行版的重载将使用前向迭代器（forward iterator）</li>
</ul>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">OutputIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">OutputIt</span> <span class="n">copy</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutputIt</span> <span class="n">d_first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIt1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIt2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardIt2</span> <span class="n">copy</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">ForwardIt1</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt1</span> <span class="n">last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">ForwardIt2</span> <span class="n">d_first</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>输入迭代器只能用来读取指向的值，迭代器自增后就再也无法访问之前指向的值，它一般用于从控制台或网络输入，或生成序列，比如 <a href="https://en.cppreference.com/w/cpp/iterator/istream_iterator"target="_blank" rel="external nofollow noopener noreferrer">std::istream_iterator<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。同理，输出迭代器一般用来输出到文件，或添加值到容器，也是单向的，比如 <a href="https://en.cppreference.com/w/cpp/iterator/ostream_iterator"target="_blank" rel="external nofollow noopener noreferrer">std::ostream_iterator<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li>前向迭代器返回元素的引用，因此可以用于读写，它同样只能单向传递，<a href="https://en.cppreference.com/w/cpp/container/forward_list"target="_blank" rel="external nofollow noopener noreferrer">std::forward_list<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的迭代器就是前向迭代器，虽然它不可以回到之前指向的值，但可以存储一个指向之前元素的拷贝（比如 <a href="https://en.cppreference.com/w/cpp/container/forward_list/begin"target="_blank" rel="external nofollow noopener noreferrer">std::forward_list::begin<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>）来重复利用。对于并行性来说，可以重复利用迭代器很重要。此外，前向迭代器的自增不会使其他的迭代器拷贝失效，这样就不用担心其他线程中的迭代器受影响。如果使用输入迭代器，所有线程只能共用一个迭代器，显然无法并行</li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag"target="_blank" rel="external nofollow noopener noreferrer">std::execution::par<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 是最常用的策略，除非实现提供了更符合需求的非标准策略。一些情况下也可以使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag"target="_blank" rel="external nofollow noopener noreferrer">std::execution::par_unseq<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，虽然这不保证更好的并发性，但它给了库通过重排和交错任务来提升性能的可能性，不过代价就是不能使用同步机制，要确保线程安全只能让算法本身不会让多个线程访问同一元素，并在调用该算法的外部使用同步机制来避免其他线程对数据的访问</li>
<li>内部带同步机制只能使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag"target="_blank" rel="external nofollow noopener noreferrer">std::execution::par<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，如果使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag"target="_blank" rel="external nofollow noopener noreferrer">std::execution::par_unseq<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 会出现未定义行为</li>
</ul>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">inc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">n_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果使用 <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag"target="_blank" rel="external nofollow noopener noreferrer">std::execution::par_unseq<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 则应该在外部使用同步机制</li>
</ul>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">inc</span><span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">n_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">v_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par_unseq</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="p">[](</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>下面是一个更实际的例子。假如有一个网站，访问日志有上百万条，为了方便查看数据需要对日志进行处理。对日志每行的处理是独立的工作，很适合使用并行算法</li>
</ul>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Log</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">time_t</span> <span class="n">visit_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// any other fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="n">Log</span> <span class="nf">parse</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Map</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Map</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Combine</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// log、Map 两个参数有四种组合，所以需要四个重载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Map</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Map</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Map</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">lhs</span><span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">lhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Map</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Log</span> <span class="n">l</span><span class="p">,</span> <span class="n">Map</span> <span class="n">m</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">m</span><span class="p">[</span><span class="n">l</span><span class="p">.</span><span class="n">page</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Map</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Map</span> <span class="n">m</span><span class="p">,</span> <span class="n">Log</span> <span class="n">l</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">m</span><span class="p">[</span><span class="n">l</span><span class="p">.</span><span class="n">page</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Map</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Log</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Log</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">Map</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">m</span><span class="p">[</span><span class="n">lhs</span><span class="p">.</span><span class="n">page</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">m</span><span class="p">[</span><span class="n">rhs</span><span class="p">.</span><span class="n">page</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">transform_reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="n">Map</span><span class="p">{},</span>      <span class="c1">// 初始值，一个空的 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                               <span class="n">Combine</span><span class="p">{},</span>  <span class="c1">// 结合两个元素的二元操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                               <span class="n">parse</span><span class="p">);</span>  <span class="c1">// 对每个元素执行的一元操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>C++ Concurrency in Action [9] | CH09 Advanced Thread Management</title><link>https://jianye0428.github.io/posts/ch09_advanced_thread_management/</link><pubDate>Tue, 28 Nov 2023 18:58:13 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ch09_advanced_thread_management/</guid><description><![CDATA[<h2 id="线程池">线程池</h2>
<ul>
<li>线程池一般会用一个表示线程数的参数来初始化，内部需要一个队列来存储任务。下面是一个最简单的线程池实现</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">auto</span> <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">q_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">done_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}}.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// cv_.wait 使用了 done_ 判断所以要加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">submit</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">q_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">done_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">q_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果想让提交的任务带参数会麻烦很多</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">ThreadPool</span><span class="o">::</span><span class="n">submit</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">RT</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// std::packaged_task 不允许拷贝构造，不能直接传入 lambda，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 因此要借助 std::shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">RT</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 但 std::bind 会按值拷贝实参，因此这个实现不允许任务的实参是 move-only 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">q_</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="n">task</span><span class="p">]()</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">task</span><span class="p">)();</span> <span class="p">});</span>  <span class="c1">// 捕获指针以传入 std::packaged_task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">cv_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>书上实现的线程池都在死循环中使用了 <a href="https://en.cppreference.com/w/cpp/thread/yield"target="_blank" rel="external nofollow noopener noreferrer">std::this_thread::yield<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 来转让时间片</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;concurrent_queue.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">submit</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">q_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">worker_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">done_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">q_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">;</span>  <span class="c1">// 要在 done_ 和 q_ 之后声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>这样做的问题是，如果线程池处于空闲状态，就会无限转让时间片，导致 CPU 使用率达 100%，下面是对书中的线程池的 CPU 使用率测试结果</li>
</ul>
<p></p>
<ul>
<li>对相同任务用之前实现的线程池的测试结果</li>
</ul>
<p></p>
<ul>
<li>这里还是把书上的内容列出来，下文均为书中内容</li>
<li>这个线程池只能执行无参数无返回值的函数，并且可能出现死锁，下面希望能执行无参数但有返回值的函数。为了得到返回值，就应该把函数传递给 <a href="https://en.cppreference.com/w/cpp/thread/packaged_task"target="_blank" rel="external nofollow noopener noreferrer">std::packaged_task<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 再加入队列，并返回 <a href="https://en.cppreference.com/w/cpp/thread/packaged_task"target="_blank" rel="external nofollow noopener noreferrer">std::packaged_task<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中的 <a href="https://en.cppreference.com/w/cpp/thread/future"target="_blank" rel="external nofollow noopener noreferrer">std::future<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。由于 <a href="https://en.cppreference.com/w/cpp/thread/packaged_task"target="_blank" rel="external nofollow noopener noreferrer">std::packaged_task<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 是 move-only 类型，而 <a href="https://en.cppreference.com/w/cpp/utility/functional/function"target="_blank" rel="external nofollow noopener noreferrer">std::function<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 要求存储的函数实例可以拷贝构造，因此这里需要实现一个支持 move-only 类型的函数包裹类，即一个带 call 操作的类型擦除（type-erasure）类</li>
</ul>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FunctionWrapper</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">FunctionWrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">FunctionWrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">FunctionWrapper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">FunctionWrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">FunctionWrapper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">FunctionWrapper</span><span class="p">(</span><span class="n">FunctionWrapper</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">impl_</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">FunctionWrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">FunctionWrapper</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">impl_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">impl_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FunctionWrapper</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="k">new</span> <span class="n">ImplType</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">call</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">ImplBase</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">call</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ImplBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">ImplType</span> <span class="o">:</span> <span class="n">ImplBase</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ImplType</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">f_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">call</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">f_</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">F</span> <span class="n">f_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ImplBase</span><span class="o">&gt;</span> <span class="n">impl_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>用这个包裹类替代 <code>std::function&lt;void()&gt;</code></li>
</ul>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;concurrent_queue.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;function_wrapper.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">submit</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">q_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">worker_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">FunctionWrapper</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">done_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="n">FunctionWrapper</span><span class="o">&gt;</span> <span class="n">q_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">;</span>  <span class="c1">// 要在 done_ 和 q_ 之后声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>往线程池添加任务会增加任务队列的竞争，lock-free 队列可以避免这点但存在乒乓缓存的问题。为此需要把任务队列拆分为线程独立的本地队列和全局队列，当线程队列无任务时就去全局队列取任务</li>
</ul>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;concurrent_queue.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;function_wrapper.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">submit</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">local_queue_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">local_queue_</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pool_queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">worker_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">local_queue_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">FunctionWrapper</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">FunctionWrapper</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">local_queue_</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">local_queue_</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">local_queue_</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">local_queue_</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pool_queue_</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">done_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="n">FunctionWrapper</span><span class="o">&gt;</span> <span class="n">pool_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="k">static</span> <span class="k">thread_local</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">FunctionWrapper</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">local_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>这可以避免数据竞争，但如果任务分配不均，就会导致某个线程的本地队列中有很多任务，而其他线程无事可做，为此应该让没有工作的线程可以从其他线程获取任务</li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;concurrent_queue.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;function_wrapper.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">WorkStealingQueue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">WorkStealingQueue</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">WorkStealingQueue</span><span class="p">(</span><span class="k">const</span> <span class="n">WorkStealingQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">WorkStealingQueue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">WorkStealingQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">FunctionWrapper</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">q_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">q_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">try_pop</span><span class="p">(</span><span class="n">FunctionWrapper</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">q_</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">try_steal</span><span class="p">(</span><span class="n">FunctionWrapper</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">q_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">FunctionWrapper</span><span class="o">&gt;</span> <span class="n">q_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">work_stealing_queue_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">WorkStealingQueue</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ThreadPool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">done_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">threads_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">submit</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">local_queue_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">local_queue_</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pool_queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">pop_task_from_local_queue</span><span class="p">(</span><span class="n">FunctionWrapper</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">local_queue_</span> <span class="o">&amp;&amp;</span> <span class="n">local_queue_</span><span class="o">-&gt;</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">pop_task_from_pool_queue</span><span class="p">(</span><span class="n">FunctionWrapper</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pool_queue_</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">pop_task_from_other_thread_queue</span><span class="p">(</span><span class="n">FunctionWrapper</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">work_stealing_queue_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">work_stealing_queue_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">work_stealing_queue_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">try_steal</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">index_</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">local_queue_</span> <span class="o">=</span> <span class="n">work_stealing_queue_</span><span class="p">[</span><span class="n">index_</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">FunctionWrapper</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">pop_task_from_local_queue</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">||</span> <span class="n">pop_task_from_pool_queue</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="n">pop_task_from_other_thread_queue</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">done_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="n">FunctionWrapper</span><span class="o">&gt;</span> <span class="n">pool_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">WorkStealingQueue</span><span class="o">&gt;&gt;</span> <span class="n">work_stealing_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">thread_local</span> <span class="n">WorkStealingQueue</span><span class="o">*</span> <span class="n">local_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">thread_local</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">thread_local</span> <span class="n">WorkStealingQueue</span><span class="o">*</span> <span class="n">ThreadPool</span><span class="o">::</span><span class="n">local_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">thread_local</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">ThreadPool</span><span class="o">::</span><span class="n">index_</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="中断">中断</h2>
<ul>
<li>可中断线程的简单实现</li>
</ul>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">InterruptFlag</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">is_set</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">thread_local</span> <span class="n">InterruptFlag</span> <span class="n">this_thread_interrupt_flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">InterruptibleThread</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">InterruptibleThread</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">InterruptFlag</span><span class="o">*&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_thread_interrupt_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">interrupt</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">flag</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">InterruptFlag</span><span class="o">*</span> <span class="n">flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">interruption_point</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">is_set</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="n">thread_interrupted</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在函数中使用</li>
</ul>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">process_next_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>更好的方式是用 <a href="https://en.cppreference.com/w/cpp/thread/condition_variable"target="_blank" rel="external nofollow noopener noreferrer">std::condition_variable<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 来唤醒，而非在循环中持续运行</li>
</ul>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">InterruptFlag</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">set</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">b_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cv_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cv_</span><span class="o">-&gt;</span><span class="n">notify_all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">set_condition_variable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">clear_condition_variable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">ClearConditionVariableOnDestruct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">ClearConditionVariableOnDestruct</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">clear_condition_variable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">b_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">*</span> <span class="n">cv_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">interruptible_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">set_condition_variable</span><span class="p">(</span><span class="n">cv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 之后的 wait_for 可能抛异常，所以需要 RAII 清除标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">InterruptFlag</span><span class="o">::</span><span class="n">ClearConditionVariableOnDestruct</span> <span class="n">guard</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置线程看到中断前的等待时间上限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">cv</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">interruptible_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">set_condition_variable</span><span class="p">(</span><span class="n">cv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">InterruptFlag</span><span class="o">::</span><span class="n">ClearConditionVariableOnDestruct</span> <span class="n">guard</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">is_set</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>和 <a href="https://en.cppreference.com/w/cpp/thread/condition_variable"target="_blank" rel="external nofollow noopener noreferrer">std::condition_variable<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 不同的是，<a href="https://en.cppreference.com/w/cpp/thread/condition_variable_any"target="_blank" rel="external nofollow noopener noreferrer">std::condition_variable_any<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 可以使用不限于 <a href="https://en.cppreference.com/w/cpp/thread/unique_lock"target="_blank" rel="external nofollow noopener noreferrer">std::unique_lock<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的任何类型的锁，这意味着可以使用自定义的锁类型</li>
</ul>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">InterruptFlag</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">set</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">b_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cv_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cv_</span><span class="o">-&gt;</span><span class="n">notify_all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">cv_any_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cv_any_</span><span class="o">-&gt;</span><span class="n">notify_all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lockable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable_any</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">,</span> <span class="n">Lockable</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">Mutex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">Mutex</span><span class="p">(</span><span class="n">InterruptFlag</span><span class="o">*</span> <span class="n">self</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">condition_variable_any</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">,</span> <span class="n">Lockable</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">:</span> <span class="n">self_</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">lock_</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">self_</span><span class="o">-&gt;</span><span class="n">m_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">self_</span><span class="o">-&gt;</span><span class="n">cv_any_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="o">~</span><span class="n">Mutex</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">self_</span><span class="o">-&gt;</span><span class="n">cv_any_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">self_</span><span class="o">-&gt;</span><span class="n">m_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">self_</span><span class="o">-&gt;</span><span class="n">m_</span><span class="p">,</span> <span class="n">lock_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">lock_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">self_</span><span class="o">-&gt;</span><span class="n">m_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">InterruptFlag</span><span class="o">*</span> <span class="n">self_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Lockable</span><span class="o">&amp;</span> <span class="n">lock_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Mutex</span> <span class="nf">m</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">cv</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// rest as before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">b_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">*</span> <span class="n">cv_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable_any</span><span class="o">*</span> <span class="n">cv_any_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Lockable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">interruptible_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable_any</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">,</span> <span class="n">Lockable</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>对于其他阻塞调用（比如 mutex、future）的中断，一般也可以像对 <a href="https://en.cppreference.com/w/cpp/thread/condition_variable"target="_blank" rel="external nofollow noopener noreferrer">std::condition_variable<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 一样设置超时时间，因为不访问内部 mutex 或 future 无法在未满足等待的条件时中断等待</li>
</ul>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">interruptible_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">ft</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">is_set</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ft</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>从被中断的线程角度来看，中断就是一个 <code>thread_interrupted</code> 异常。因此检查出中断后，可以像异常一样对其进行处理</li>
</ul>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">internal_thread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{[</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_thread_interrupt_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">thread_interrupted</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 异常传入 std::thread 的析构函数时将调用 std::terminate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 为了防止程序终止就要捕获异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>假如有一个桌面搜索程序，除了与用户交互，程序还需要监控文件系统的状态，以识别任何更改并更新其索引。为了避免影响 GUI 的响应性，这个处理通常会交给一个后台线程，后台线程需要运行于程序的整个生命周期。这样的程序通常只在机器关闭时退出，而在其他情况下关闭程序，就需要井然有序地关闭后台线程，一个关闭方式就是中断</li>
</ul>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">config_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">InterruptibleThread</span><span class="o">&gt;</span> <span class="n">background_threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">background_thread</span><span class="p">(</span><span class="kt">int</span> <span class="n">disk_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">interruption_point</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">fs_change</span> <span class="n">fsc</span> <span class="o">=</span> <span class="n">get_fs_changes</span><span class="p">(</span><span class="n">disk_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fsc</span><span class="p">.</span><span class="n">has_changes</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">update_index</span><span class="p">(</span><span class="n">fsc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">start_background_processing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">background_threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">background_thread</span><span class="p">,</span> <span class="n">disk_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">background_threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">background_thread</span><span class="p">,</span> <span class="n">disk_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">start_background_processing</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">process_gui_until_exit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">config_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">background_threads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">.</span><span class="n">interrupt</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 中断所有线程后再join
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">background_threads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 不直接在一个循环里中断并 join 的目的是为了并发，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 因为中断不会立即完成，它们必须进入下一个中断点，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 再在退出前必要地调用析构和异常处理的代码，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果对每个线程都中断后立即 join，就会造成中断线程的等待，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 即使它还可以做一些有用的工作，比如中断其他线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>C++ Concurrency in Action [7] | CH07 Designing Lock free Concurrent Data Structure</title><link>https://jianye0428.github.io/posts/ch07_designing_lock_free_concurrent_data_structure/</link><pubDate>Tue, 28 Nov 2023 18:57:01 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ch07_designing_lock_free_concurrent_data_structure/</guid><description><![CDATA[<h2 id="非阻塞数据结构">非阻塞数据结构</h2>
<ul>
<li>阻塞的算法和数据结构使用 mutex、条件变量、期值来同步数据，但非阻塞不等价于 lock-free，比如自旋锁没有使用任何阻塞函数的调用，是非阻塞的，但并非 lock-free</li>
<li>非阻塞数据结构由松到严可分为三个等级：obstruction-free、lock-free、wait-free
<ul>
<li>obstruction-free（无障碍）：如果其他线程都暂停了，任何一个给定的线程都会在有限步数内完成操作。上例就是这种情况，但这种情况很少见，所以满足这个条件只能算一个失败的 lock-free 实现</li>
<li>lock-free（无锁）：如果多线程在同一个数据结构上操作，其中一个将在有限步数内完成操作。满足 lock-free 必定满足 obstruction-free</li>
<li>wait-free（无等待）：如果多线程在同一个数据结构上操作，每个线程都会在有限步数内完成操作。满足 wait-free 必定满足 lock-free，但 wait-free 很难实现，因为要保证有限步数内完成操作，就要保证操作一次通过，并且执行到某一步不能导致其他线程操作失败</li>
</ul>
</li>
<li>lock-free 数据结构必须允许多线程并发访问，但它们不能做相同操作，比如一个 lock-free 的 queue 允许一个线程 push、另一个线程 pop，但不允许两个线程同时 push。此外，如果一个访问 lock-free 数据结构的线程被中途挂起，其他线程必须能完成操作而不需要等待挂起的线程</li>
<li>使用 lock-free 数据结构主要是为了最大化并发访问，不需要阻塞。第二个原因是鲁棒性，如果线程在持有锁时死掉就会导致数据结构被永久破坏，而对 lock-free 数据结构来说，除了死掉的线程里的数据，其他的数据都不会丢失。lock-free 没有任何锁，所以一定不会出现死锁</li>
<li>但 lock-free 可能造成更大开销，用于 lock-free 的原子操作比非原子操作慢得多，且 lock-free 数据结构中的原子操作一般比 lock-based 中的多，此外，硬件必须访问同一个原子变量以在线程间同步数据。无论 lock-free 还是 lock-based，性能方面的检查（最坏情况等待时间、平均等待时间、总体执行时间或其他方面）都是非常重要的</li>
</ul>
<h2 id="lock-free-thread-safe-stack">lock-free thread-safe stack</h2>
<ul>
<li>最简单的 stack 实现方式是包含头节点指针的链表。push 的过程很简单，创建一个新节点，然后让新节点的 next 指针指向当前 head，最后 head 设为新节点</li>
<li>这里的 race condition 在于，如果两个线程同时 push，让各自的新节点的 next 指针指向当前 head，这样必然导致 head 最终设为二者之一的新节点，而另一个被丢弃</li>
<li>解决方法是，在最后设置 head 时先进行判断，只有当前 head 与新节点的 next 相等，才将 head 设为新节点，如果不等则让 next 指向当前 head 并重新判断。而这个操作必须是原子的，因此就需要使用 <a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange"target="_blank" rel="external nofollow noopener noreferrer">compare_exchange_weak<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，不需要使用 <a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange"target="_blank" rel="external nofollow noopener noreferrer">compare_exchange_strong<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，因为 <a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange"target="_blank" rel="external nofollow noopener noreferrer">compare_exchange_weak<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 在相等时可能替换失败，但替换失败也会返回 false，放在循环里带来的效果是一样的，而 <a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange"target="_blank" rel="external nofollow noopener noreferrer">compare_exchange_weak<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 在一些机器架构上可以产生比 <a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange"target="_blank" rel="external nofollow noopener noreferrer">compare_exchange_strong<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 更优化的代码</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>pop 的过程很简单，先存储当前头节点指针，再将头节点设为下一节点，最后返回存储的头节点并删除指针。这里的 race condition 在于，如果两个线程同时 pop，如果一个已经删除了头节点，另一个线程读取头节点的下一节点就访问了空悬指针</li>
<li>先绕开删除指针这一步，考虑前几步的实现</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">LockFreeStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>  <span class="c1">// 未考虑头节点为空指针的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>传引用来保存结果的原因是，如果直接返回值，返回前一定会先移除元素，如果拷贝返回值时抛出异常，移除的元素就丢失了。但传引用的问题是，如果其他线程移除了节点，被移除的节点不能被解引用，当前线程就无法安全地拷贝数据。因此，如果想安全地返回值，应该返回智能指针</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 还未考虑释放原来的头节点指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span> <span class="o">?</span> <span class="n">t</span><span class="o">-&gt;</span><span class="nl">v</span> <span class="p">:</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>释放被移除的节点的难点在于，一个线程在释放内存时，无法得知其他线程是否持有要释放的指针</li>
<li>只要没有其他线程调用 pop，就能安全释放，因此可以用一个计数器来记录调用 pop 的线程数，计数不为 1 时，先把节点添加到待删除节点列表中，计数为 1 则安全释放</li>
</ul>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">pop_cnt_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">res</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">try_delete</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="n">delete_list</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">delete</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">head</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">append_to_delete_list</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">to_delete_list_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 确保 last-&gt;next 为 to_delete_list_，再设置 first 为新的头节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">to_delete_list_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">first</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">append_to_delete_list</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">last</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">append_to_delete_list</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">try_delete</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pop_cnt_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pop_cnt_</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">append_to_delete_list</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">--</span><span class="n">pop_cnt_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">to_delete_list_</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">pop_cnt_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">delete_list</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">append_to_delete_list</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">pop_cnt_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">to_delete_list_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果要释放所有节点，必须有一个时刻计数器为 0。在高负载的情况下，往往不会存在这样的时刻，从而导致待删除节点的列表无限增长</li>
</ul>
<h3 id="hazard-pointer风险指针">Hazard Pointer（风险指针）</h3>
<ul>
<li>另一个释放的思路是，在线程访问节点时，设置一个保存了线程 ID 和该节点的风险指针。用一个全局数组保存所有线程的风险指针，释放节点时，如果数组中不存在包含该节点的风险指针，则可以直接释放，否则将节点添加到待删除列表中。风险指针实现如下</li>
</ul>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">MaxSize</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">HazardPointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">HazardPointer</span> <span class="n">HazardPointers</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HazardPointerHelper</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">HazardPointerHelper</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">HazardPointers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">default_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">default_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">hazard_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>  <span class="c1">// 取一个未设置过的风险指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hazard_pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;No hazard pointers available&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">HazardPointerHelper</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">hazard_pointer</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">hazard_pointer</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">HazardPointerHelper</span><span class="p">(</span><span class="k">const</span> <span class="n">HazardPointerHelper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">HazardPointerHelper</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HazardPointerHelper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hazard_pointer</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">HazardPointer</span><span class="o">*</span> <span class="n">hazard_pointer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&amp;</span> <span class="n">hazard_pointer_for_this_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">thread_local</span> <span class="n">HazardPointerHelper</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">is_existing</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">HazardPointers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>使用风险指针</li>
</ul>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;hazard_pointer.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&amp;</span> <span class="n">hazard_pointer</span> <span class="o">=</span> <span class="n">hazard_pointer_for_this_thread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>  <span class="c1">// 外循环确保 t 为最新的头节点，循环结束后将头节点设为下一节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Node</span><span class="o">*</span> <span class="n">t2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">do</span> <span class="p">{</span>  <span class="c1">// 循环至风险指针保存当前最新的头节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">hazard_pointer</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">t2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">hazard_pointer</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">res</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">is_existing</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">append_to_delete_list</span><span class="p">(</span><span class="k">new</span> <span class="n">DataToDelete</span><span class="p">{</span><span class="n">t</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">try_delete</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">DataToDelete</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DataToDelete</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">deleter</span><span class="p">([](</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="p">})</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">DataToDelete</span><span class="p">()</span> <span class="p">{</span> <span class="n">deleter</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">deleter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DataToDelete</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">append_to_delete_list</span><span class="p">(</span><span class="n">DataToDelete</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">to_delete_list_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">to_delete_list_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">try_delete</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DataToDelete</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">to_delete_list_</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">DataToDelete</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_existing</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">append_to_delete_list</span><span class="p">(</span><span class="k">new</span> <span class="n">DataToDelete</span><span class="p">{</span><span class="n">cur</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">cur</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">pop_cnt_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">DataToDelete</span><span class="o">*&gt;</span> <span class="n">to_delete_list_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>风险指针实现简单并达到了安全释放的目的，但每次删除节点前后都要遍历数组并原子访问内部指针来检查，增加了很多开销</li>
<li>无锁内存回收技术领域十分活跃，大公司都会申请自己的专利，风险指针包含在 IBM 提交的专利申请中，在 GPL 协议下允许免费使用</li>
</ul>
<h3 id="引用计数">引用计数</h3>
<ul>
<li>另一个方案是使用引用计数记录访问每个节点的线程数量，<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"target="_blank" rel="external nofollow noopener noreferrer">std::shared_ptr<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的操作是原子的，但要检查是否 lock-free</li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atomic_is_lock_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果是，则可以用于实现 lock-free stack</li>
</ul>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">LockFreeStack</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">pop</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">atomic_compare_exchange_weak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">atomic_compare_exchange_weak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">atomic_store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++20 支持 <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2"target="_blank" rel="external nofollow noopener noreferrer">std::atomic&lt;std::shared_ptr&gt;<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">LockFreeStack</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">pop</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>但 VS2022 上测试发现 <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2"target="_blank" rel="external nofollow noopener noreferrer">std::atomic&lt;std::shared_ptr&gt;<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 并非 lock-free</li>
</ul>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">{}.</span><span class="n">is_lock_free</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>更通用的方法是手动管理引用计数，为每个节点设置内外部两个引用计数，两者之和就是节点的引用计数，外部计数默认为 1，访问对象时递增外部计数并递减内部计数，访问结束后则不再需要外部计数，将外部计数减 2 并加到内部计数上</li>
</ul>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">LockFreeStack</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">pop</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">external_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">increase_count</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>  <span class="c1">// 外部计数递增表示该节点正被使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>      <span class="c1">// 因此可以安全地访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将外部计数减 2 后加到内部计数，减 2 是因为，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 节点被删除减 1，该线程无法再次访问此节点再减 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">external_cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">inner_cnt</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// 内外部计数和为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">inner_cnt</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// 内部计数为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">ReferenceCount</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">external_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inner_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">increase_count</span><span class="p">(</span><span class="n">ReferenceCount</span><span class="o">&amp;</span> <span class="n">old_cnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">new_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">new_cnt</span> <span class="o">=</span> <span class="n">old_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">new_cnt</span><span class="p">.</span><span class="n">external_cnt</span><span class="p">;</span>  <span class="c1">// 访问 head_ 时递增外部计数，表示该节点正被使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">old_cnt</span><span class="p">,</span> <span class="n">new_cnt</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">old_cnt</span><span class="p">.</span><span class="n">external_cnt</span> <span class="o">=</span> <span class="n">new_cnt</span><span class="p">.</span><span class="n">external_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">ReferenceCount</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>不指定内存序则默认使用开销最大的 <code>std::memory_order_seq_cst</code>，下面根据操作间的依赖关系优化为最小内存序</li>
</ul>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LockFreeStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">LockFreeStack</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">pop</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">external_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 下面比较中 release 保证之前的语句都先执行，因此 load 可以使用 relaxed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">increase_count</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>  <span class="c1">// acquire
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将外部计数减 2 后加到内部计数，减 2 是因为，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 节点被删除减 1，该线程无法再次访问此节点再减 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">external_cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// swap 要先于 delete，因此使用 release
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">inner_cnt</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// 内外部计数和为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">inner_cnt</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">inner_cnt</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>  <span class="c1">// 只是用 acquire 来同步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// acquire 保证 delete 在之后执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// 内部计数为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">ReferenceCount</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">external_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inner_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">increase_count</span><span class="p">(</span><span class="n">ReferenceCount</span><span class="o">&amp;</span> <span class="n">old_cnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReferenceCount</span> <span class="n">new_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>  <span class="c1">// 比较失败不改变当前值，并可以继续循环，因此可以选择 relaxed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">new_cnt</span> <span class="o">=</span> <span class="n">old_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">new_cnt</span><span class="p">.</span><span class="n">external_cnt</span><span class="p">;</span>  <span class="c1">// 访问 head_ 时递增外部计数，表示该节点正被使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">old_cnt</span><span class="p">,</span> <span class="n">new_cnt</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">old_cnt</span><span class="p">.</span><span class="n">external_cnt</span> <span class="o">=</span> <span class="n">new_cnt</span><span class="p">.</span><span class="n">external_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">ReferenceCount</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>C++ Concurrency in Action [6] | CH06 Designing Lock-based Concurrent Data Structure</title><link>https://jianye0428.github.io/posts/ch06_designing_lock_based_concurrent_data_structure/</link><pubDate>Tue, 28 Nov 2023 18:56:22 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ch06_designing_lock_based_concurrent_data_structure/</guid><description><![CDATA[<ul>
<li>设计并发数据结构要考虑两点，一是确保访问 thread-safe，二是提高并发度
<ul>
<li>thread-safe 基本要求如下
<ul>
<li>数据结构的不变量（invariant）被一个线程破坏时，确保不被线程看到此状态</li>
<li>提供操作完整的函数来避免数据结构接口中固有的 race condition</li>
<li>注意数据结构出现异常时的行为，以确保不变量不被破坏</li>
<li>限制锁的范围，避免可能的嵌套锁，最小化死锁的概率</li>
</ul>
</li>
<li>作为数据结构的设计者，要提高数据结构的并发度，可以从以下角度考虑
<ul>
<li>部分操作能否在锁的范围外执行</li>
<li>数据结构的不同部分是否被不同的 mutex 保护</li>
<li>是否所有操作需要同级别的保护</li>
<li>在不影响操作语义的前提下，能否对数据结构做简单的修改提高并发度</li>
</ul>
</li>
<li>总结为一点，即最小化线程对共享数据的轮流访问，最大化真实的并发量</li>
</ul>
</li>
</ul>
<h2 id="thread-safe-queue">thread-safe queue</h2>
<ul>
<li>之前实现过的 thread-safe stack 和 queue 都是用一把锁定保护整个数据结构，这限制了并发性，多线程在成员函数中阻塞时，同一时间只有一个线程能工作。这种限制主要是因为内部实现使用的是 <a href="https://en.cppreference.com/w/cpp/container/queue"target="_blank" rel="external nofollow noopener noreferrer">std::queue<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，为了支持更高的并发，需要更换内部的实现方式，使用细粒度的（fine-grained）锁。最简单的实现方式是包含头尾指针的单链表，不考虑并发的单链表实现如下</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Queue</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Queue</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Queue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">new_tail_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tail_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">head_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">tail_</span> <span class="o">=</span> <span class="n">new_tail_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">try_pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">head_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>即使用两个 mutex 分别保护头尾指针，这个实现在多线程下也有明显问题。push 可以同时修改头尾指针，会对两个 mutex 上锁，另外仅有一个元素时头尾指针相等，push 写和 try_pop 读的 next 节点是同一对象，产生了竞争，锁的也是同一个 mutex</li>
<li>该问题很容易解决，在头节点前初始化一个 dummy 节点即可，这样 push 只访问尾节点，不会再与 try_pop 竞争头节点</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">head_</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">),</span> <span class="n">tail_</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Queue</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Queue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">new_tail_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tail_</span> <span class="o">=</span> <span class="n">new_tail_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">try_pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">tail_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">head_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>接着加上锁，锁的范围应该尽可能小</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConcurrentQueue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="p">()</span> <span class="o">:</span> <span class="n">head_</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">),</span> <span class="n">tail_</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">new_tail_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">tail_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tail_</span> <span class="o">=</span> <span class="n">new_tail_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">try_pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">pop_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">head_node</span> <span class="o">?</span> <span class="n">head_node</span><span class="o">-&gt;</span><span class="nl">v</span> <span class="p">:</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pop_head</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">head_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">get_tail</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">head_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">head_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">*</span> <span class="nf">get_tail</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">tail_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tail_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">head_mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">tail_mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>push 中创建新值和新节点都没上锁，多线程可用并发创建新值和新节点。虽然同时只有一个线程能添加新节点，但这只需要一个指针赋值操作，锁住尾节点的时间很短，try_pop 中对尾节点只是用来做一次比较，持有尾节点的时间同样很短，因此 try_pop 和 push 几乎可以同时调用。try_pop 中锁住头节点所做的也只是指针赋值操作，开销较大的析构在锁外进行，这意味着虽然同时只有一个线程能 pop_head，但允许多线程删除节点并返回数据，提升了 try_pop 的并发调用数量</li>
<li>最后再结合 <a href="https://en.cppreference.com/w/cpp/thread/condition_variable"target="_blank" rel="external nofollow noopener noreferrer">std::condition_variable<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 实现 wait_and_pop，即得到与之前接口相同但并发度更高的 thread-safe queue</li>
</ul>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConcurrentQueue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="p">()</span> <span class="o">:</span> <span class="n">head_</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">),</span> <span class="n">tail_</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentQueue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">new_tail_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">tail_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">tail_</span> <span class="o">=</span> <span class="n">new_tail_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">try_pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">try_pop_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">head_node</span> <span class="o">?</span> <span class="n">head_node</span><span class="o">-&gt;</span><span class="nl">v</span> <span class="p">:</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">try_pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">try_pop_head</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">head_node</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">wait_and_pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">wait_pop_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">head_node</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">wait_and_pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span> <span class="n">wait_pop_head</span><span class="p">(</span><span class="n">res</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">head_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">get_tail</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">try_pop_head</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">head_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">get_tail</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">pop_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">try_pop_head</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">head_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">get_tail</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">head_</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">pop_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">wait_pop_head</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">wait_for_data</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">pop_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">wait_pop_head</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">wait_for_data</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">head_</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">pop_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">wait_for_data</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">head_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="n">get_tail</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pop_head</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">head_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">head_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">*</span> <span class="nf">get_tail</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">tail_mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tail_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">head_mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">tail_mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="thread-safe-map">thread-safe map</h2>
<ul>
<li>并发访问 <a href="https://en.cppreference.com/w/cpp/container/map"target="_blank" rel="external nofollow noopener noreferrer">std::map<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 和 <a href="https://en.cppreference.com/w/cpp/container/unordered_map"target="_blank" rel="external nofollow noopener noreferrer">std::unordered_map<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 的接口的问题在于迭代器，其他线程删除元素时会导致迭代器失效，因此 thread-safe map 的接口设计就要跳过迭代器</li>
<li>为了使用细粒度锁，就不应该使用标准库容器。可选的关联容器数据结构有三种，一是二叉树（如红黑树），但每次查找修改都要从访问根节点开始，也就表示根节点需要上锁，尽管沿着树向下访问节点时会解锁，但这个比起覆盖整个数据结构的单个锁好不了多少</li>
<li>第二种方式是有序数组，这比二叉树还差，因为无法提前得知一个给定的值应该放在哪，于是同样需要一个覆盖整个数组的锁</li>
<li>第三种方式是哈希表。假如有一个固定数量的桶，一个 key 属于哪个桶取决于 key 的属性和哈希函数，这意味着可以安全地分开锁住每个桶。如果使用读写锁，就能将并发度提高相当于桶数量的倍数</li>
</ul>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;shared_mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Hash</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConcurrentMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 桶数默认为 19（一般用 x % 桶数作为 x 的桶索引，桶数为质数可使桶分布均匀）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ConcurrentMap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span> <span class="k">const</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">Hash</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">buckets_</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">hasher_</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">buckets_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Bucket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentMap</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentMap</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentMap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentMap</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">V</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">default_value</span> <span class="o">=</span> <span class="n">V</span><span class="p">{})</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">get_bucket</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">default_value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">get_bucket</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">get_bucket</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 为了方便使用，提供一个到 std::map 的映射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">to_map</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;&gt;</span> <span class="n">locks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">buckets_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">locks</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">buckets_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Bucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">// 每个桶都用这个锁保护
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">default_value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 没有修改任何值，异常安全
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 只读锁，可共享
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                             <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">k</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">it</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="nl">default_value</span> <span class="p">:</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 写，单独占用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                             <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">k</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>  <span class="c1">// emplace_back 异常安全
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// 赋值可能抛异常，但值是用户提供的，可放心让用户处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 写，单独占用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                             <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">k</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Bucket</span><span class="o">&amp;</span> <span class="n">get_bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>  <span class="c1">// 桶数固定因此可以无锁调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">buckets_</span><span class="p">[</span><span class="n">hasher_</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">buckets_</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bucket</span><span class="o">&gt;&gt;</span> <span class="n">buckets_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Hash</span> <span class="n">hasher_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="thread-safe-list">thread-safe list</h2>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConcurrentList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentList</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ConcurrentList</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">remove_if</span><span class="p">([](</span><span class="k">const</span> <span class="n">Node</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentList</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentList</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ConcurrentList</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ConcurrentList</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">head_lock</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">head_</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">for_each</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">head_lock</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">next_lock</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">head_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>  <span class="c1">// 锁住了下一节点，因此可以释放上一节点的锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>                        <span class="c1">// 当前节点指向下一节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">head_lock</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next_lock</span><span class="p">);</span>  <span class="c1">// 转交下一节点锁的所有权，循环上述过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">find_first_if</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">head_lock</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">next_lock</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">head_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>  <span class="c1">// 返回目标值，无需继续查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">head_lock</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">remove_if</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">head_lock</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">next_lock</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 为 true 则移除下一节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">old_next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>  <span class="c1">// 下一节点设为下下节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">next_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 否则继续转至下一节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">head_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">head_lock</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Node</span> <span class="n">head_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>C++ Concurrency in Action | Processes and Threads</title><link>https://jianye0428.github.io/posts/processesandthreads/</link><pubDate>Sun, 19 Nov 2023 13:06:06 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/processesandthreads/</guid><description><![CDATA[<h2 id="进程">进程</h2>
<ul>
<li>
<p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程(sequential process)，简称进程(process)，一个进程就是就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值</p>
</li>
<li>
<p>概念上来说，每个进程有自己的虚拟 CPU，但实际上真正的 CPU(假设只有一个 CPU)在各进程之间来回切换，同一时刻实际只有一个进程在运行</p>
</li>
<li>
<p>实际只有一个物理程序计数器。每个进程运行时，它的逻辑程序计数器被装入实际的程序计数器。当进程结束时，物理程序计数器保存到内存中该进程的逻辑程序计数器中</p>
</li>
<li>
<p>进程创建主要有四种形式</p>
<ul>
<li>系统初始化：启动系统时会创建若干进程，包括和用户交互的前台进程和停在后台的守护进程，守护进程可以通过 UNIX 的 ps 指令或 Window 的任务管理器查看</li>
<li>运行中的程序执行创建进程的系统调用：比如启动一个程序，该程序要启动更多进程来分配任务</li>
<li>用户请求创建一个新进程：比如用户双击图标启动程序</li>
<li>大型机批处理作业的初始化</li>
</ul>
</li>
<li>
<p>创建进程的系统调用在 UNIX 中是 <code>fork</code>，在 Windows 中是 <code>CreateProcess</code>，进程创建后，父子进程有不同的地址空间</p>
</li>
<li>
<p>进程终止通常也有四种形式</p>
<ul>
<li>正常退出(自愿的)：比如点击浏览器的关闭图标。进程退出的系统调用在 UNIX 中是 <code>exit</code>，在 Windows 中是 <code>ExitProcess</code></li>
<li>出错退出(自愿的)：比如执行 <code>cc foo.c</code> 编译 <code>foo.c</code> 而该文件不存在</li>
<li>严重错误(非自愿)：比如执行非法指令、引用不存在的内存、除数是零，UNIX中会希望自行处理这些错误以通知操作系统，进程会收到信号被中断而非终止</li>
<li>被其他进程杀死(非自愿)：UNIX 中是 <code>kill</code>，Windows 中是 <code>TerminateProcess</code></li>
</ul>
</li>
<li>
<p>UNIX中，进程和其所有子进程(包括其后裔)组成一个进程组，当用户发出一个键盘信号，该信号会发送给进程组所有成员</p>
</li>
<li>
<p>Windows中没有进程层次的概念，所有进程地位相同</p>
</li>
<li>
<p>进程阻塞有两种情况，一是正常情况，比如操作系统调度另一个进程占用 CPU，二是异常情况，比如没有足够的 CPU 可调用</p>
</li>
<li>
<p>进程有三种状态：运行、就绪、阻塞</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">运行 &lt;-&gt; 就绪
</span></span><span class="line"><span class="cl">  ↘    ↗
</span></span><span class="line"><span class="cl">    阻塞
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">运行：该时刻实际占用 CPU
</span></span><span class="line"><span class="cl">就绪：操作系统调度了其他进程运行而暂时停止
</span></span><span class="line"><span class="cl">阻塞：逻辑上不能继续运行，比如等待用户输入</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>操作系统通过维护一张进程表(一个结构数组)来实现进程模型，每个进程占一个表项(即进程控制块，Processing Control Block)。PCB 包含了进程状态的主要信息，如程序计数器、堆栈指针、内存分配状态、所打开的文件状态、账号和调度信息、进程状态切换时必须保存的信息</p>
</li>
<li>
<p>所有中断都从保存寄存器开始，通常会保存到当前进程的 PCB 中。一个进程在执行过程中可能中断几千次，但恢复时，被中断的进程都将返回到与中断发生前完全相同的状态</p>
</li>
<li>
<p>发生中断后，操作系统最底层的工作过程</p>
<ul>
<li>中断硬件将程序计数器、程序状态字、寄存器压入堆栈</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>通过汇编保存寄存器值(因为这类操作无法用高级语言完成)</li>
<li>通过汇编设置新的堆栈</li>
<li>运行C语言(假设操作系统用C编写)中断服务例程</li>
<li>调用调度程序，决定接下来要运行的进程</li>
<li>C返回到汇编</li>
<li>通过汇编运行新进程</li>
</ul>
</li>
<li>
<p>假设一个进程等待 I/O 操作与其在内存中停留的时间比为 <code>p</code>，则 <code>n</code> 个进程都在等待(此时 CPU 空转)的概率为 <code>p ^ n</code>，CPU 利用率为 <code>1 - p ^ n</code>，因此一般(该模型只是粗略情况)I/O 时间越短、运行进程越多，CPU 利用率越高</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">假如内存为 8G，操作系统和相关表格占 2G，用户程序也占 2G，内存最多容纳 3 个用户程序
</span></span><span class="line"><span class="cl">假设 80% 时间用于等待 I/O 操作
</span></span><span class="line"><span class="cl">CPU 利用率 = 1 - 0.8 ^ 3 = 49%
</span></span><span class="line"><span class="cl">如果增加 8G 内存，则最多容纳 7 个用户程序
</span></span><span class="line"><span class="cl">CPU 利用率 = 1 - 0.8 ^ 7 = 79%，吞吐量提高为 79% - 49% = 30%
</span></span><span class="line"><span class="cl">如果再增加 8G 内存，则最多容纳 11 个用户程序
</span></span><span class="line"><span class="cl">CPU 利用率 = 1 - 0.8 ^ 11 = 91%，吞吐量只提高了 12%，可见第一次增加内存比较划算</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="线程">线程</h2>
<ul>
<li>正如进程提供的抽象使得避免了对中断、定时器、上下文切换的考虑，多线程提供了一种新抽象，即并行实例共享同一地址空间和所有可用数据，这正是多进程模型(地址空间不同)无法表达的</li>
<li>第二个需要多线程的理由是，线程更轻量，创建和撤销都更快(通常创建一个线程比创建一个进程快 10 - 100 倍)</li>
<li>第三个理由是多核 CPU 系统中，多线程为真正的并行提供了可能</li>
<li>线程包含一个程序计数器(记录接下来要执行哪一条指令)、寄存器(保存线程当前的工作变量)、堆栈指针(记录执行历史，每个线程的堆栈有一帧，每一帧保存一个已调用但还未返回的过程，如局部变量、返回地址)</li>
<li>各线程可以访问进程地址空间的每一个内存地址，因此一个线程可以读写甚至清除另一个线程的堆栈。线程之间没有保护，因为不可能，也没必要</li>
<li>除了共享地址空间，线程还共享同一个打开文件集、子进程、定时器及相关信号量</li>
<li>线程可以处在运行、就绪、阻塞、终止等状态中的任何一个</li>
<li>thread_yield 允许线程自动放弃 CPU 转让给另一个线程运行，提供这个调用是因为，不同于进程，线程库不能利用时钟中断强制线程让出 CPU</li>
<li>实现线程包主要有两种方式，一是用户级线程(User-Level Thread)，二是内核级线程(Kernel-Level Thread)，另外也有混合实现</li>
<li>用户级线程把整个线程包放在用户空间中，内核对其一无所知，不需要内核支持，可以在不支持线程的操作系统上实现。在用户空间管理线程时，每个进程需要有其专用的线程表(thread table)，这些表和内核中的进程表类似，只不过记录的是各个线程的属性，如程序计数器、寄存器、堆栈指针和状态等。该线程表由运行时系统管理，当线程转换到就绪或阻塞状态时，在线程表中存放重启该线程所需的信息，与内核在进程表中存放进程的信息完全一样</li>
<li>用户级线程允许进程有自己定制的调度算法，具有更好的可扩展性(因为内核级线程需要一些固定表格空间和堆栈空间)，性能更好。用户级线程的切换需要少量机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延迟</li>
<li>用户级线程的问题是如何实现阻塞系统调用，比如线程读取键盘，在没有按下任何按键之前不能让该线程实际进行该系统调用，因为这会停止所有线程。另一个问题是，如果一个线程开始运行，则其所在进程的其他线程就不能运行，除非运行线程自动放弃 CPU。而使用内核级线程时，线程阻塞在 I/O 上时，不需要将整个进程挂起</li>
<li>内核级线程的线程表(和用户级线程的线程表一样，记录寄存器、状态和其他信息)存在于内核中，当一个线程希望创建一个新线程或撤销一个已有线程时，将进行一个系统调用，这个系统调用通过对线程表的更新完成创建或撤销工作</li>
<li>当内核级线程阻塞时，内核可以运行同一进程中的另一线程，或者运行另一个进程的线程。而对于用户级线程，运行时系统始终运行其所在进程的线程，直到内核剥夺 CPU(或没有可运行的线程存在)为止</li>
<li>在内核中创建或撤销线程的代价较大，因此内核级线程被撤销时，系统会将其标记为不可运行的，但其内核数据结构未受影响，之后必须创建新线程时就重新启动一个旧线程。用户级线程也可以这样回收，但因为管理代价很小，所以没必要</li>
</ul>
<h2 id="进程间通信inter-process-communication">进程间通信(Inter Process Communication)</h2>
<ul>
<li>
<p>对共享内存进行访问的程序片段称为临界区(critical region、critical section)，如果同一时刻临界区只有一个进程，就能避免 race condition</p>
</li>
<li>
<p>单处理器系统中实现这点的简单做法是，在每个进程刚进入临界区后立即屏蔽所有中断，在即将离开时再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU 只有发生时钟中断或其他中断才会进行进程切换，这样 CPU 就不会切换到其他进程</p>
</li>
<li>
<p>但这个方案并不好，因为把屏蔽中断的权力交给用户进程是不明智的，如果一个进程屏蔽中断后不打开，就可能导致整个系统终止。此外如果系统是多处理器，则屏蔽中断只对执行了 disable 指令的 CPU 有效，其他 CPU 仍将运行</p>
</li>
<li>
<p>对于内核来说，更新变量或列表的几条指令期间屏蔽中断很方便，因此屏蔽中断对操作系统本身是一项很有用的技术，但对用户进程则不是一种合适的互斥机制</p>
</li>
<li>
<p>第二种方式是一种软件方案，假设有一个共享锁变量，其初始值为 0，当进程要进入临界区时，首先测试锁，如果值为 0 则将锁设为1并进入临界区，如果锁的值已经为 1，则进程等待其值为 0</p>
</li>
<li>
<p>这种方式的问题在于，如果在一个进程检查到锁为 0，并要将锁设为 1 之前，恰好另一个线程被调度运行将锁设为 1，而第一个进程恢复运行时也将把锁设为 1 并进入临界区，此时临界区就有了两个进程</p>
</li>
<li>
<p>第三种方式是忙等待(busy waiting)，用一个循环不断测试变量值，直到变量值改变才进入临界区，用于忙等待的锁称为自旋锁(spin lock)。这种方式的问题是，在循环中浪费了大量 CPU 时间，应该避免，除非等待时间非常短才有使用的理由</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 进程 A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// 允许进程 B 进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">noncritical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程 B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 允许进程 A 进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">noncritical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第四种方式是 1981 年由 G. L. Peterson 提出的 Peterson 算法</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 进程数量为2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// 轮到的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">interested</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enter_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">process</span><span class="p">;</span>  <span class="c1">// 另一进程(进程号为 0 或 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">turn</span> <span class="o">=</span> <span class="n">process</span><span class="p">;</span>  <span class="c1">// turn 只有一个，即使两个进程调用也只有后一个赋值会保留
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">process</span> <span class="o">&amp;&amp;</span> <span class="n">interested</span><span class="p">[</span><span class="n">other</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">leave_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 调用上述函数完成后调用此函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 若进程 A 调用 enter_region 则很快返回，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 此时进程 B 调用将在 while 循环挂起，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 直到进程 A 调用 leave_region
</span></span></span><span class="line"><span class="cl"><span class="c1">// 若进程 AB 同时调用 enter_region，
</span></span></span><span class="line"><span class="cl"><span class="c1">// turn 为后赋值者，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 则先赋值者退出循环并调用 leave_region，后赋值者再退出循环
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第五种方式是一种硬件方式，需要借助 TSL 指令，即测试并加锁(test and set lock)，该指令是一个原子操作，执行 TSL 指令的 CPU 将锁住内存总线以禁止其他 CPU 在指令结束前访问该内存</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">TSL</span> <span class="n">RX</span><span class="p">,</span> <span class="n">LOCK</span> <span class="c1">// 将内存字 LOCK 读到寄存器 RX 中，然后在该内存地址写一个非零值，读写是原子操作
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>为了使用 TSL 指令实现互斥，用一个共享变量 <code>LOCK</code> 来协调对内存的访问，其值为 0 时任何进程都能用 TSL 指令将值设为 1 并读写共享内存，操作结束时再用 move 指令将值重置为 0</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">enter_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">TSL</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="no">LOCK</span>  <span class="c1">;复制锁到寄存器并设置值为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMP</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#0    ;值是否为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span> <span class="no">enter_region</span>    <span class="c1">;不是 0 则循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>                 <span class="c1">;返回，进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">leave_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">LOCK</span><span class="p">,</span> <span class="c1">#0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>可以用 XCHG 指令替代 TSL 指令，它原子交换两个位置的内容</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">enter_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#1    ;在寄存器放一个 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">XCHG</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="no">LOCK</span>  <span class="c1">;原子交换寄存器和锁变量的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMP</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#0     ;值是否为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span> <span class="no">enter_region</span>     <span class="c1">;不是 0 则循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>                  <span class="c1">;返回，进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">leave_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">LOCK</span><span class="p">,</span> <span class="c1">#0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Peterson 算法和 TSL 或 XCHG 解法同样都有忙等待的问题，它们的本质都是在进程进入临界区时检查是否允许进入，不允许则原地等待直到允许为止</p>
</li>
</ul>
<h2 id="生产者-消费者问题">生产者-消费者问题</h2>
<ul>
<li>
<p>两个进程共享一个固定大小的缓冲区，生产者进程将消息放入缓冲区，消费者进程从缓冲区取出消息</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 缓冲区的槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>            <span class="c1">// 缓冲区数据数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>  <span class="c1">// 生成新数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sleep</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>  <span class="c1">// 将消息放入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>              <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">wakeup</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>  <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sleep</span><span class="p">();</span>  <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span>  <span class="c1">// 从缓冲区取一个数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">--</span><span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">wakeup</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>  <span class="c1">// 打印数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 问题在于 cnt 的访问存在 race condition，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果消费者执行到 3 处，cnt 为 0，在即将 sleep 之前，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 生产者在此之后才执行到 1 处，此时 cnt 为 1，执行到 2 处，调用 wakeup，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但此时消费者还未 sleep，因此 wakeup 的信号丢失，没有实际作用，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 接着消费者 sleep，生产者开始下一轮循环，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 生产者下一轮循环到 1 处，cnt 为 2，到 2 处，不再调用 wakeup，消费者保持 sleep，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 生产者继续之后的循环，并且每一轮都不会唤醒消费者，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 最终生产者执行到 cnt 为 N 时 sleep，两个进程都将永久 sleep
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="信号量semaphore">信号量(semaphore)</h2>
<ul>
<li>
<p>信号量是由 E. W. Dijkstra 于 1965 年提出的一种方法，它使用一个整型变量作为信号量，值为 0 表示没有保存下来的唤醒操作，值为正数表示唤醒操作的次数</p>
</li>
<li>
<p>信号量有 down 和 up 两种操作，Dijkstra 在论文中称其为 P 和 V 操作(荷兰语中的 Proberen 意为尝试，Verhogen 意为增加或升高)</p>
</li>
<li>
<p>down 操作检查值是否大于 0，若大于 0 则减 1 并继续，若为 0 则进程睡眠，并且此时 down 操作未结束</p>
</li>
<li>
<p>up 操作对值加 1。如果有进程在信号量上睡眠，无法完成一个先前的 down 操作，则由系统选择其中一个以允许完成其 down 操作。于是，对一个有睡眠进程的信号量执行一次 up 操作，信号量值仍为 0，但睡眠进程少了一个</p>
</li>
<li>
<p>down 操作和 up 操作中的所有操作都是原子的，一般作为系统调用实现。操作系统只要在执行测试信号量、更新信号量、使进程睡眠等操作时暂时屏蔽全部中断，这些动作只需要几条指令，所以屏蔽中断不会带来什么副作用。如果使用多个 CPU，则每个信号量应由一个一个锁保护，使用 TSL 或 XCHG 指令来确保同一时刻只有一个 CPU 对信号量进行操作</p>
</li>
<li>
<p>注意，这里使用 TSL 或 XCHG 指令来防止多 CPU 同时访问一个信号量，与生产者或消费者用忙等待来等待对方腾出或填充缓冲区是完全不同的。信号量操作只需要几毫秒，而生产者或消费者则可能需要任意长时间</p>
</li>
<li>
<p>使用三个信号量解决生产者-消费者问题：full 记录已充满的缓冲槽数，初值为 0；empty 记录空的缓冲槽数，初值为缓冲区中槽的数目；mutex 确保生产者和消费者不会同时访问缓冲区，初值为 1</p>
</li>
<li>
<p>供多个进程使用的信号量初值为 1，保证同时只有一个进程可以进入临界区，这种信号量称为二元信号量(binary semaphore)。如果每个进程进入临界区前执行一个 down 操作，并在刚退出时执行一个 up 操作，就能实现互斥</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 缓冲区的槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>  <span class="c1">// 缓冲区空槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 缓冲区满槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>信号量的另一个作用是实现同步(synchronization)，这里 full 和 empty 保证缓冲区满时生产者停止运行，缓冲区空时消费者停止运行</p>
</li>
</ul>
<h2 id="互斥量mutex">互斥量(mutex)</h2>
<ul>
<li>
<p>如果不需要信号量的计数功能，可以使用其称为互斥量的简化版本。互斥量仅适用于管理共享资源或一小段代码。互斥量实现简单且有效，在实现用户空间线程包时十分有用</p>
</li>
<li>
<p>互斥量只有加锁和解锁两种状态，只需要一个二进制位表示，不过实际上一般用整型量，0 表示解锁，其他值表示加锁</p>
</li>
<li>
<p>线程需要访问临界区时调用 mutex_lock，如果互斥量是解锁的则临界区可用，调用成功，线程可以进入临界区，否则线程被阻塞，直到临界区中的线程完成并调用 mutex_unlock。如果多个线程阻塞在该互斥量上，则随机选择一个线程并允许它获得锁</p>
</li>
<li>
<p>用 TSL 或 XCHG 指令就可以很容易地在用户空间实现互斥量</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">mutex_lock:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">TSL</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="no">MUTEX</span>  <span class="c1">;将互斥量复制到寄存器，并将互斥量置为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMP</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JZE</span> <span class="no">ok</span>               <span class="c1">;如果互斥量为 0，它被解锁，所以返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span> <span class="no">thread_yield</span>    <span class="c1">;互斥量忙，调度另一个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">mutex_lock</span>       <span class="c1">;稍后再试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">ok:</span> <span class="nf">RET</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">mutex_unlock:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">MUTEX</span><span class="p">,</span> <span class="c1">#0       ;将互斥量置0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>thread_yield 只是调用用户空间线程调度程序，运行十分快捷，这样 mutex_lock 和 mutex_unlock 都不需要任何内核调用。用户级线程通过互斥量的这个过程即可实现同步，而同步过程仅需要少量指令</p>
</li>
</ul>
<h2 id="管程monitor">管程(monitor)</h2>
<ul>
<li>如果把生产者代码中的两个 down 操作交换顺序，使得 mutex 在 empty 之前减 1，就会导致死锁，因此使用信号量要十分小心。为了更易于编写正确的程序，Brinch Hansen 和 Hoare 提出了一种称为管程的高级同步原语</li>
<li>一个管程是由过程、变量、数据结构等组成的一个集合，它们组成一个特殊的模块或软件包，进程可以在任何需要的时候调用管程中的过程，但不能在管程之外声明的过程中直接访问管程内的数据结构</li>
<li>任一时刻管程中只能有一个活跃进程，这一特性使得管程能有效地完成互斥。管程是编程语言的组成部分，编译器知道其特殊性，进入管程时的互斥由编译器负责，通常做法是使用互斥量或二元信号量。这样就不需要程序员安排互斥，出错的可能性就小很多</li>
<li>管程提供了互斥的简便途径，但此外还需要一种方法使得进程在无法继续运行时被阻塞，这个方法就是引入条件变量(condition variable)</li>
<li>当一个管程过程发现它无法继续运行时(如生产者发现缓冲区满)，则会在某个条件变量(如 full)上执行 wait 操作，该操作将阻塞当前进程，并将另一个在管程外的进程调入管程。另一个进程可以通过对同一条件变量执行 signal 操作唤醒阻塞进程</li>
<li>为了避免管程中有两个活跃进程，执行 signal 操作之后有两种规则。Hoare 建议让新唤醒的进程运行，挂起另一个进程。Brinch Hansen 建议执行 signal 的进程必须立即退出管程，即 signal 语句只能作为一个管程过程的最后一条语句。后者在概念上更简单，并且更容易实现。第三种方法是，让发信号者继续运行，直到其退出管程，才允许等待的进程开始运行</li>
<li>如果一个条件变量上有若干进程正在等待，则对其执行 signal 操作之后，系统调度程序只能选择其中一个恢复运行</li>
<li>如果一个条件变量没有等待进程，则对其执行 signal 会丢失信号，因此 wait 操作必须在 signal 之前。这与之前提到的 sleep 和 wakeup 的关键区别是，管程的自动互斥保证了在 wait 完成之前不会先 signal</li>
</ul>
<h2 id="消息传递message-passing">消息传递(message passing)</h2>
<ul>
<li>管程和信号量通过共享内存解决 CPU 互斥问题，但没有提供不同机器间(比如局域网中的机器)的信息交换方法</li>
<li>消息传递使用 send 和 receive 原语来实现进程间通信，它们像信号量而不像管程，是系统调用而非语言成分</li>
</ul>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">send</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">receive</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>send 向一个给定目标发送一条消息，receive 从一个给定源(或者任意源)接收一条消息，如果没有消息可用则接收者可能被阻塞直至有一条消息到达，或者带着一个错误码立即返回</p>
</li>
<li>
<p>消息传递系统面临许多设计难点：比如消息可能被网络丢失，需要三次握手来确认信息到达情况；比如发送方未收到确认，因此重发消息导致接收方收到两条相同消息，接收方需要区分新老消息；比如身份认证(authentication)问题，客户端如何确认通信的是一个文件服务器还是冒充者</p>
</li>
<li>
<p>消息传递方式可以有许多变体，一种对消息进行编址的方式是，为每个进程分配一个唯一地址，让消息按进程的地址编址。另一种方式是引入一种称为信箱(mailbox)的数据结构，用来对一定数量的消息进行缓冲。使用信箱时，send 和 receive 调用的地址参数就是信箱而非进程的地址</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">// 消息缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">receive</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>    <span class="c1">// 等待消费者发送空缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">build_message</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>  <span class="c1">// 建立一个待发送的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">send</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>       <span class="c1">// 发送数据项给消费者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">send</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 发送 N 个空缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">receive</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>        <span class="c1">// 接收包含数据项的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">extract_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 将数据项从消息中提取出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">send</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>           <span class="c1">// 将空缓冲区发送回生产者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用信箱的另一种极端方法是彻底取消缓冲。采取这种方法时，如果 send 在 receive 之前执行则发送进程被阻塞，直到 receive 发生，反之亦然。执行 receive 时，消息可以直接从发送者复制到接收者，不用任何中间缓冲。这种方案常被称为会和(rendezvous)，实现起来更容易，但降低了灵活性，因为发送者和接收者一定要以步步紧接的方式运行</p>
</li>
<li>
<p>通常在并行程序设计系统中使用消息传递，一个著名的消息传递系统是消息传递接口(Message-Passing Interface，MPI)，它广泛应用于科学计算</p>
</li>
</ul>
<h2 id="屏障barrier">屏障(barrier)</h2>
<ul>
<li>屏障是一种用于进程组的同步机制，只有所有进程就绪时才能进入下一阶段。每个阶段的结尾设置一个屏障，当一个进程到达屏障时将被阻拦，直到所有进程到达屏障为止</li>
</ul>
<h2 id="调度">调度</h2>
<ul>
<li>几乎所有进程的 I/O 请求和计算都是交替突发的，如果进程花费大量时间在计算上，则称为计算密集型(compute-bound)，如果大量时间花费在等待 I/O 上，则称为 I/O 密集型(I/O-bound)</li>
<li>随着 CPU 变得越来越快，更多的进程倾向为 I/O 密集型。这种现象的原因是 CPU 的改进比磁盘的改进快得多，所以未来对 I/O 密集型进程的调度处理更为重要</li>
<li>调度的基本思想是，如果需要运行 I/O 密集型进程，就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌</li>
<li>根据如何处理时钟中断，可以把调度算法分为非抢占式和抢占式两类</li>
<li>非抢占式调度算法挑选一个进程，然后让该进程运行直至阻塞，或直到该进程自动释放 CPU。即使该进程运行了几个小时也不会被强迫挂起，这样导致时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程，则被中断的进程将继续运行</li>
<li>抢占式调度算法挑选一个进程，让该进程运行某个固定时段的最大值，时段结束时将挂起该进程，并挑选另一个进程运行。抢占式调度需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序，如果没有可用的时钟，就只能选择非抢占式调度</li>
<li>不同的应用领域有不同的目标，也就需要不同的调度算法。环境可以划分为三种
<ul>
<li>批处理：广泛用于商业领域，比如处理薪水清单、账目收入、账目支出、利息计算，批处理系统不会有用户在旁边急切等待响应，因此通常使用非抢占式算法，或对每个进程都有长时间周期的抢占式算法，这样减少了进程切换从而改进了性能</li>
<li>交互式：必须使用抢占式算法，以避免 CPU 被一个进程霸占而拒绝为其他进程服务。服务器也归于此类，因为通常要服务多个突发的远程用户</li>
<li>实时：有时不需要抢占，因为进程了解它们可能会长时间得不到运行，所以通常很快地完成各自工作并阻塞</li>
</ul>
</li>
</ul>
<h2 id="调度算法的评价指标">调度算法的评价指标</h2>
<ul>
<li>对于批处理系统，调度算法的评价指标主要有三个
<ul>
<li>吞吐量(throughout)：系统单位时间内完成的作业数量，比如 10 道作业花费 100 秒，则吞吐量为 0.1 道/秒</li>
<li>周转时间(turnaround time)：一个批处理作业从提交开始到完成的统计平均时间</li>
<li>CPU 利用率：CPU 忙碌时间相对总时间的占比</li>
</ul>
</li>
<li>对于交互式系统，评价指标最重要的是最小响应时间，即从发出命令到得到响应之间的时间</li>
<li>实时系统的特点是或多或少必须满足截止时间，多数实时系统中，可预测性十分重要，比如如果多媒体实时系统的音频进程运行错误太多，音质就会明显下降，为此实时系统的调度算法必须是高度可预测和有规律的</li>
</ul>
<h2 id="批处理系统中的调度">批处理系统中的调度</h2>
<h3 id="先来先服务first-come-first-servedfcfs">先来先服务(First-Come First-Served，FCFS)</h3>
<ul>
<li>
<p>非抢占式。进程按照请求 CPU 的先后顺序调度，优点是公平，算法实现简单，不会导致进程饥饿(Starvation，等待时间对进程响应带来明显影响)</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">先到先服务，因此调度顺序为 P1 -&gt; P2 -&gt; P3 -&gt; P4
</span></span><span class="line"><span class="cl">P1      P2   P3 P4
</span></span><span class="line"><span class="cl">------- ---- -  ----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">周转时间 = 完成时间 - 到达时间
</span></span><span class="line"><span class="cl">P1 = 7 - 0 = 7
</span></span><span class="line"><span class="cl">P2 = 11 - 2 = 9
</span></span><span class="line"><span class="cl">P3 = 12 - 4 = 8  // 只运行 1，却需要等待 8，可见 FCFS 算法对短作业不利
</span></span><span class="line"><span class="cl">P4 = 16 - 5 = 11
</span></span><span class="line"><span class="cl">平均周转时间 = 8.75
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">带权周转时间 = 周转时间 / 运行时间
</span></span><span class="line"><span class="cl">P1 = 7 / 7 = 1
</span></span><span class="line"><span class="cl">P2 = 9 / 4 = 2.25
</span></span><span class="line"><span class="cl">P3 = 8 / 1 = 8
</span></span><span class="line"><span class="cl">P4 = 11 / 4 = 2.75
</span></span><span class="line"><span class="cl">平均带权周转时间 = 3.5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">等待时间 = 周转时间 - 运行时间(不考虑等待 I/O 操作的时间)
</span></span><span class="line"><span class="cl">P1 = 7 - 7 = 0
</span></span><span class="line"><span class="cl">P2 = 9 - 4 = 5
</span></span><span class="line"><span class="cl">P3 = 8 - 1 = 7
</span></span><span class="line"><span class="cl">P4 = 11 - 4 = 7
</span></span><span class="line"><span class="cl">平均等待时间 = 4.75</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="最短作业优先shortest-job-firstsjf">最短作业优先(Shortest Job First，SJF)</h3>
<ul>
<li>
<p>非抢占式。选择已到达的且运行时间最短的进程，运行时间相同则先到达的先运行。目标是追求最短的平均周转时间、平均带权周转时间、平均等待时间，缺点是不公平，对短作业有利，对长作业不利，如果一直有短作业到达可能导致长作业饥饿</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P1 先到达，P1 运行结束时 P2、P3、P4 均到达，P3 运行时间最短先运行
</span></span><span class="line"><span class="cl">P2、P4 运行时间相同，P2 先到达，因此 P2 先于 P4 运行
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最终调度顺序为 P1 -&gt; P3 -&gt; P2 -&gt; P4
</span></span><span class="line"><span class="cl">P1      P3 P2    P4
</span></span><span class="line"><span class="cl">------- -  ----  ----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">周转时间 = 完成时间 - 到达时间
</span></span><span class="line"><span class="cl">P1 = 7 - 0 = 7
</span></span><span class="line"><span class="cl">P2 = 12 - 2 = 10
</span></span><span class="line"><span class="cl">P3 = 8 - 4 = 4
</span></span><span class="line"><span class="cl">P4 = 16 - 5 = 11
</span></span><span class="line"><span class="cl">平均周转时间 = 8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">带权周转时间 = 周转时间 / 运行时间
</span></span><span class="line"><span class="cl">P1 = 7 / 7 = 1
</span></span><span class="line"><span class="cl">P2 = 10 / 4 = 2.5
</span></span><span class="line"><span class="cl">P3 = 4 / 1 = 4
</span></span><span class="line"><span class="cl">P4 = 11 / 4 = 2.75
</span></span><span class="line"><span class="cl">平均带权周转时间 = 2.56
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">等待时间 = 周转时间 - 运行时间(不考虑等待 I/O 操作的时间)
</span></span><span class="line"><span class="cl">P1 = 7 - 7 = 0
</span></span><span class="line"><span class="cl">P2 = 10 - 4 = 6
</span></span><span class="line"><span class="cl">P3 = 4 - 1 = 3
</span></span><span class="line"><span class="cl">P4 = 11 - 4 = 7
</span></span><span class="line"><span class="cl">平均等待时间 = 4</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="最短剩余时间优先shortest-remaining-time-nextsrtn">最短剩余时间优先(Shortest Remaining Time Next，SRTN)</h3>
<ul>
<li>
<p>SRTN 是 SJF 的抢占式版本，每当新进程加入时，调度程序总是选择剩余运行时间最短的进程运行，如果当前进程剩余运行时间比新进程长，则挂起当前进程而运行新进程</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P2 到达时，P1 剩余 5，P2 为 4，运行 P2
</span></span><span class="line"><span class="cl">P3 到达时，P1 剩余 5，P2 剩余 2，P3 为 1，运行 P3
</span></span><span class="line"><span class="cl">P4 到达时，P3 运行结束，P1 剩余 5，P2 剩余 2，P4 为 4，运行 P2
</span></span><span class="line"><span class="cl">最后依次运行 P4 和 P1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最终调度顺序为 P1 -&gt; P2 -&gt; P3 -&gt; P2 -&gt; P4 -&gt; P1
</span></span><span class="line"><span class="cl">P1 P2 P3 P2 P4    P1
</span></span><span class="line"><span class="cl">-- -- -  -- ----  -----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">周转时间 = 完成时间 - 到达时间
</span></span><span class="line"><span class="cl">P1 = 16 - 0 = 16
</span></span><span class="line"><span class="cl">P2 = 7 - 2 = 5
</span></span><span class="line"><span class="cl">P3 = 5 - 4 = 1
</span></span><span class="line"><span class="cl">P4 = 11 - 5 = 6
</span></span><span class="line"><span class="cl">平均周转时间 = 7
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">带权周转时间 = 周转时间 / 运行时间
</span></span><span class="line"><span class="cl">P1 = 16 / 7 = 2.29
</span></span><span class="line"><span class="cl">P2 = 5 / 4 = 1.25
</span></span><span class="line"><span class="cl">P3 = 1 / 1 = 1
</span></span><span class="line"><span class="cl">P4 = 6 / 4 = 1.5
</span></span><span class="line"><span class="cl">平均带权周转时间 = 1.51
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">等待时间 = 周转时间 - 运行时间(不考虑等待 I/O 操作的时间)
</span></span><span class="line"><span class="cl">P1 = 16 - 7 = 9
</span></span><span class="line"><span class="cl">P2 = 5 - 4 = 1
</span></span><span class="line"><span class="cl">P3 = 1 - 1 = 0
</span></span><span class="line"><span class="cl">P4 = 6 - 4 = 2
</span></span><span class="line"><span class="cl">平均等待时间 = 3</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="高响应比优先highest-response-ratio-nexthrrn">高响应比优先(Highest Response Ratio Next，HRRN)</h3>
<ul>
<li>
<p>非抢占式。在所有已到达进程中选择响应比(<code>等待时间 / 运行时间 + 1</code>)最高的运行，综合 FCFS 和 SJF 的优点，等待时间长、运行时间短的优先，避免长作业饥饿的问题</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">响应比 = (等待时间 + 运行时间) / 运行时间
</span></span><span class="line"><span class="cl">P1 运行至结束，P2、P3、P4 均到达，响应比分别为
</span></span><span class="line"><span class="cl">P2 = (5 + 4) / 4 = 2.25
</span></span><span class="line"><span class="cl">P3 = (3 + 1) / 1 = 4
</span></span><span class="line"><span class="cl">P4 = (2 + 4) / 4 = 1.5
</span></span><span class="line"><span class="cl">运行 P3，P3 结束时，响应比分别为
</span></span><span class="line"><span class="cl">P2 = (6 + 4) / 4 = 2.5
</span></span><span class="line"><span class="cl">P4 = (3 + 4) / 4 = 1.75
</span></span><span class="line"><span class="cl">运行 P2，最后运行 P4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最终调度顺序为 P1 -&gt; P3 -&gt; P2 -&gt; P4
</span></span><span class="line"><span class="cl">P1      P3 P2    P4
</span></span><span class="line"><span class="cl">------- -  ----  ----</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="交互式系统中的调度">交互式系统中的调度</h2>
<h3 id="时间片轮转调度round-robin-schedulingrr">时间片轮转调度(Round-Robin Scheduling，RR)</h3>
<ul>
<li>
<p>RR 是一种简单公平的抢占式调度算法，并且可以避免饥饿。每个进程被分配一个时间片(quantum)。时间片结束时，如果进程还在运行，则剥夺 CPU 并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即切换。RR 算法实现很容易，只需要维护一张进程队列表</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A -&gt; B -&gt; C -&gt; D
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">若 A 用完时间片，但仍在运行，则插入到队列尾
</span></span><span class="line"><span class="cl">B -&gt; C -&gt; D -&gt; A
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">若 B 用完时间片，但仍在运行，并到达一个新进程 E，则先插入新进程
</span></span><span class="line"><span class="cl">C -&gt; D -&gt; A -&gt; E -&gt; B
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">若 C 用完时间片之前就结束了，则直接切换到下一个进程
</span></span><span class="line"><span class="cl">D -&gt; A -&gt; E -&gt; B</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>需要考虑的是时间片的长度，假设时间片为 4 ms，上下文切换为 1 ms，则 CPU 完成 4 ms 工作后将浪费 1 ms 进行上下文切换(context switch)，即浪费了 20% 的时间。但如果时间片太大，就会退化为 FCFS，导致增大响应时间。通常为了提高 CPU 效率，设置时间片时，切换开销占比应不超过 1%</p>
</li>
</ul>
<h3 id="优先级调度">优先级调度</h3>
<ul>
<li>为每个进程设置优先级，在已到达进程中，选择优先级最高的运行，可以为抢占式或非抢占式</li>
<li>比如对于操作系统来说，I/O 密集型进程的优先级应该更高。I/O 密集型继承多数时间用于等待 I/O 结束，因此需要 CPU 时应立即分配给它以便启动下一个 I/O 请求，这样就可以在另一个进程计算的同时执行 I/O 操作</li>
<li>一种简单做法是将优先级设置为 <code>1 / f</code>，<code>f</code> 为该进程在上一时间片中的运行时间占比。比如在 50 ms 时间片中，使用 1 ms 的进程优先级为 50，使用 25 ms 的进程优先级为 2。将进程按优先级分组，再使用 RR 算法调度高优先级组中的进程</li>
</ul>
<h3 id="多级反馈队列调度">多级反馈队列调度</h3>
<ul>
<li>CTSS(Compatible Time Sharing System)是最早使用优先级调度的系统之一，但存在进程切换速度太慢的问题，其设计者意识到设置较长的时间片可以减少切换次数，但长时间片又会影响到响应时间。最终的解决方法是多级反馈队列调度，它是对 FCFS、SJF、RR、优先级调度的折中权衡</li>
<li>设置多个优先级队列，每个级别对应不同长度的时间片，比如第一级(最高级)时间片为 1，第二级为 2，第三级为 4，以此类推</li>
<li>如果一个进程用完当前级别时间片后仍未运行完，则加入下一级队列队尾，如果已经位于最后一级则放回该级队尾</li>
<li>高优先级队列为空时，才会调度低优先级队列，因此可能导致低优先级进程饥饿</li>
<li>比如一个进程需要 100 个时间片，第一次分配 1 个时间片，第二次分配 2 个，接下来是 4、8、16、32、64，最后一次使用 64 中的 37 个即可结束工作，一共进行 7 次切换。如果使用 RR 算法，则需要 100 次切换</li>
</ul>
<h3 id="最短进程优先">最短进程优先</h3>
<ul>
<li>
<p>关键在于如何从可运行进程中找出最短的一个</p>
</li>
<li>
<p>一种方法是根据过去的行为进行预测。假设某终端每条命令的估计运行时间为 <code>T0</code>，测量到下一次运行时间为 <code>T1</code>，则估计时间可以修正为 <code>a * T0 + (1 - a) * T1</code>，比如设 <code>a</code> 为 <code>1 / 2</code> 可以得到序列如下</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">T0
</span></span><span class="line"><span class="cl">T0/2 + T1/2
</span></span><span class="line"><span class="cl">T0/4 + T1/4 + T2/2
</span></span><span class="line"><span class="cl">T0/8 + T1/8 + T2/4 + T3/2  // T0 在此时估计时间中的占比下降到 1/8</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="保证调度">保证调度</h3>
<ul>
<li>向用户作出明确的性能保证，然后实现它。比如有 <code>n</code> 个进程运行的单用户系统中，如果所有进程等价，则每个进程获得 <code>1 / n</code> 的CPU时间，为了实现所作的保证，系统跟踪每个进程已使用的 CPU 时间，并计算应获得的时间，然后转向已用时间最少的进程，直到超过最接近的竞争者</li>
</ul>
<h3 id="彩票调度lottery-scheduling">彩票调度(Lottery Scheduling)</h3>
<ul>
<li>保证调度的想法不错，但很难实现。彩票调度既可以给出类似预测结果，并且实现非常简单。其基本思想是为进程提供各种系统资源(如 CPU 时间)的彩票，一旦需要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程获取该资源</li>
<li>比如系统掌握每秒 50 次的一种彩票，作为奖励每个获奖者可以获得 20 ms 的 CPU 时间</li>
<li>可以给更重要的进程额外的彩票，以增加其获胜的机会，比如出售 100 张彩票，一个进程持有其中 20 张，则每次抽奖该进程就有 20% 的取胜机会，在较长运行时间中该进程就会得到 20% 的 CPU</li>
<li>彩票调度可以解决其他方法很难解决的问题，比如一个视频服务器上有若干提供视频流的进程，每个流的帧率不同，假设帧率分别为 10、20、25，那么给这些进程分别分配 10、20、25 张彩票，它们就会自动按照接近 10:20:25 的比例划分 CPU 的使用</li>
</ul>
<h3 id="公平分享调度">公平分享调度</h3>
<ul>
<li>之前的调度关注的都是进程本身，而没有关注进程所有者。假设两个用户分别启动 9 个进程和 1 个进程，使用 RR 算法，则两者分别得到 90% 和 10% 的 CPU 时间。为了避免这种情况，在调度处理之前应该考虑进程拥有者</li>
</ul>
]]></description></item><item><title>C++ Concurrency in Action | Memory Management</title><link>https://jianye0428.github.io/posts/memorymanagement/</link><pubDate>Sun, 19 Nov 2023 13:05:52 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/memorymanagement/</guid><description><![CDATA[<h2 id="无存储器抽象">无存储器抽象</h2>
<ul>
<li>
<p>早期计算机没有存储器抽象，每个程序都直接访问物理内存</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REGISTER1</span><span class="p">,</span> <span class="mi">1000</span>  <span class="err">;将位置</span><span class="mi">1000</span><span class="err">的物理内存中的内容移到</span> <span class="no">REGISTER1</span> <span class="err">中</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>因此那时呈现给程序员的存储器模型就是简单的物理内存：从 0 到某个上限的地址集合，每个地址对应一个可容纳一定数目（通常是 8 个）二进制位的存储单元</p>
</li>
<li>
<p>这种情况下，在内存中同时运行两个程序是不可能的，如果一个程序在 2000 的位置写入一个新值，就会擦掉另一个程序在相同位置上的内容，因此无法同时运行两个程序，这两个程序会立刻崩溃</p>
</li>
<li>
<p>为了运行多个程序，一个解决方法是，操作系统把当前内存中所有内容保存到磁盘，然后把下一个程序读入到内存中再运行即可。同一时刻，只要内存中只有一个程序，就不会发生冲突</p>
</li>
<li>
<p>但这种方法有一个重要的缺陷，即重定位（即逻辑地址到物理地址的转换）问题。假设有两个程序，第一个程序在 0 处的指令是 <code>JMP 24</code>，第二个程序在 0 处的指令是 <code>JMP 28</code>，当第一个程序运行一段时间后再运行第二个程序，第二个程序会跳到第一个程序 28 处的指令。由于对内存地址的不正确访问，程序立刻崩溃</p>
</li>
<li>
<p>一个补救方法是静态重定位，即装入时将逻辑地址转换为物理地址。当一个程序被装载到地址 16384 时，常数 16384 被加到每一个程序地址上。虽然这个机制在不出错误的情况下可行，但不是一种通用的解决方法，同时会减慢装载速度，并且它要求所有的可执行程序提供额外的信息，以区分哪些内存字中存有可重定位的地址，哪些没有</p>
</li>
<li>
<p>虽然直接引用物理地址对大型计算机、小型计算机、台式计算机、笔记本都已经成为了历史，但在嵌入式系统、智能卡系统中，缺少存储器抽象的情况仍然很常见。像收音机、洗衣机、微波炉都是采用访问绝对内存地址的寻址方式，其中的程序都是事先确定的，用户不能在其上运行自己的软件，因此它们可以正常工作</p>
</li>
<li>
<p>总之，把物理地址暴露给进程带来的严重问题有：</p>
<ul>
<li>如果用户程序可以寻址内存的每个字节，就可以轻易破坏操作系统</li>
<li>想要运行多个程序很困难</li>
</ul>
</li>
</ul>
<h2 id="一种存储器抽象地址空间">一种存储器抽象：地址空间</h2>
<ul>
<li>要使多个程序同时存在于内存中并且互不影响，需要解决保护（进程只能访问自己的内存）和重定位两个问题。对前者的一个原始的解决方法是，给内存标记上一个保护键，并且比较执行进程的键和其访问的每个内存字的保护键，比如进程能访问的空间是 0-100，CPU 标记此范围，然后在访问内存时检查是否为该进程可访问空间。不过这种方法并没有解决重定位问题</li>
<li>更好的方法是创造一个新的存储器抽象：地址空间。地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了一些情况下进程需要共享地址空间）</li>
<li>地址空间的概念非常通用，比如 7 位数字的电话号码的地址空间是 <code>0 000 000</code> 到 <code>9 999 999</code>，x86 的 I/O 端口的地址空间是 <code>0</code> 到 <code>16383</code>，IPv4 的地址空间是 <code>0</code> 到 <code>2 ^ 32 - 1</code>。地址空间也可以是非数字的，比如以 <code>.com</code> 结尾的网络域名的集合</li>
<li>比较难的是给每个程序一个独有的地址空间，使得两个程序的相同地址（如地址 28）对应不同的物理地址</li>
<li>一个简单的方法是使用动态重定位，即运行时将逻辑地址转换为物理地址。把每个进程的地址空间映射到物理内存的不同部分，当一个进程运行时，程序的起始物理地址装载到基址寄存器（又称重定位寄存器），程序的长度装载到界限寄存器（又称限长寄存器）。进程访问内存，CPU 在把地址发送到内存总线前会自动把基址加到进程发出的地址值上，同时检查程序提供的地址是否超出了界限寄存器中的值，如果超出了就会产生错误并终止访问。对于之前的例子，比如第二个程序的 <code>JMP 28</code>，CPU 会将其解释为 <code>JMP 16412</code></li>
<li>使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算，比较运算可以很快，但加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢</li>
<li>但物理内存是有限的，把所有进程一直保存在内存中需要巨大的内存，内存不足就无法支持这点。处理内存超载有两种通用方法，最简单的是交换（swapping）技术，即把进程完整调入内存运行一段时间，然后把它存回磁盘，这样空闲进程主要存储在磁盘上，不运行就不会占用内存。另一种方法是虚拟内存（virtual memory），它能使程序只有一部分调入内存的情况下运行</li>
<li>交换可能在内存中产生多个空闲区（hole）。把进程尽可能靠近，将这些小的间隙合并成一大块，这种技术称为内存紧缩（memory compaction）。通常不进行这个操作，因为它需要耗费大量 CPU 时间</li>
<li>如果进程的数据段可以增长（比如从堆中动态分配内存），进程与空闲区相邻，则可以把空闲区分配给进程使其增大。如果进程之间紧紧相邻，就需要把要增长的进程移到内存中一个足够大的区域，或者把一个或多个进程交换出去以生成足够大的空闲区。如果进程在内存中不能增长，并且磁盘上的交换区已满，则这个进程只能挂起直到有空间空闲，或者结束</li>
<li>如果大部分进程在运行时需要增长，为了减少因内存区不够而引起的进程交换和移动开销，一种方法是在换入或移动进程时额外分配一些预留内存</li>
<li>动态分配内存时，操作系统必须对其进行管理，一般跟踪内存使用情况有两种方法：位图和空闲区链表</li>
<li>使用位图法时，把内存划分成分配单元（每个单元小到几个字节或大到几千字节），用位图中的一位来记录每个分配单元的使用情况，比如 0 表示空闲 1 表示占用（或者相反）。分配单元越小，位图越大，不过即使 4 个字节大小的分配单元，32 位的内存只需要 1 位位图，位图只占用了 <code>1 / 32</code> 的内存</li>
<li>位图法的主要问题是，在决定把一个占 <code>k</code> 个分配单元的进程调入内存时，存储管理器必须搜索位图，在位图中找出有 <code>k</code> 个连续 0 的串，这个查找操作很耗时，因为在位图中该串可能跨越字的边界</li>
<li>另一个记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点包含一个进程或者两个进程间的一块空闲区</li>
<li>使用链表法时，为进程分配内存的最简单的算法是首次适配（first fit）算法，存储管理器沿链表搜索，直到找到一个足够大的空闲区，然后将空闲区分为两部分，一部分为要分配的大小，供进程使用，另一部分形成新的空闲区</li>
<li>对首次适配算法进行小修改可以得到下次适配（next fit）算法，区别是在每次找到合适的空闲区时记录位置，这样下次就可以从上次结束的地方开始搜索。Bays 的仿真程序证明下次适配算法性能略低于首次适配算法</li>
<li>另一个著名并广泛使用的算法是最佳适配（best fit）算法，搜索整个链表，找到能容纳进程的最小空闲区。因为每次都要搜索整个链表，所以它比首次适配算法慢。有些令人意外的是，它比前两种算法浪费更多的内存，因为它会产生大量无用的小空闲区。为了避免分裂出很多非常小的空闲区，可以考虑最差适配（worst fit）算法，即总是分配最大的可用空闲区，但仿真程序表明这也不是一个好方法</li>
<li>一个提高算法速度的方式是，为进程和空闲区分别维护链表，代价是增加复杂度和内存释放速度变慢，因为必须将回收的段从进程链表删除并插入到空闲区链表</li>
<li>如果分别维护进程和空闲区的链表，就可以对空闲区链表按大小排序，以提高最佳适配算法的速度，比如按从小到大排序，第一个合适的空间就是最小的空闲区，就是最佳适配。排序后，首次适配算法与最佳适配算法一样快，下次适配算法无意义</li>
<li>单独维护空闲区链表时可以做一个小优化，利用空闲区存储信息，每个空闲区的第一个字就是空闲区大小，第二个字指向下一空闲区</li>
<li>另一种分配算法是快速分配（quick fit）算法，它为常用大小的空闲区维护单独的链表，比如链表第一项是 4 KB 大小空闲区的链表头指针，第二项是 8 KB 大小空闲区的链表头指针，以此类推。像 21 KB 的空闲区，既可以放在 20 KB 的链表中，也可以放在一个专门存放特殊大小的链表中。这种算法查找指定大小的空闲区很快，但同样存在的缺点是，进程终止或换出时，寻找它的相邻块并查找是否可以合并的过程非常费时，如果不合并，内存将很快分裂出大量无法利用的小空闲区</li>
</ul>
<h2 id="虚拟内存">虚拟内存</h2>
<ul>
<li>当程序大到内存无法容纳时，交换技术就有所缺陷，一个典型 SATA 磁盘的峰值传输率高达每秒几百兆，交换一个 1 GB 的程序就需要好几秒</li>
<li>程序大于内存的问题在一些应用领域早就存在了，比如模拟宇宙的创建就要花费大量内存。20 世纪 60 年代的解决方案是，将程序分割为多个覆盖区（overlay）。程序开始运行时，将覆盖管理模块装入内存，该模块立刻装入并运行第一个覆盖区，执行完成后，第一个覆盖区通知管理模块装入下一个覆盖区</li>
<li>程序员必须把程序分割成多个片段，这个工作非常费时枯燥，并且易出错。不久后有了虚拟内存（virtual memory）的方法，这些工作都可以交给计算机去做</li>
<li>虚拟内存的基本思想是，程序的地址空间被分割成多个页（page），每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有页必须在内存中才能运行程序。当程序引用到一部分物理内存中的地址空间时，由硬件执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令</li>
</ul>
<h2 id="分页paging">分页（paging）</h2>
<ul>
<li>
<p>大部分虚拟内存系统都使用了分页技术</p>
</li>
<li>
<p>由程序产生的地址称为虚拟地址（virtual address）</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REG</span><span class="p">,</span> <span class="mi">1000</span>  <span class="err">;将地址为</span> <span class="mi">1000</span> <span class="err">的内存单元的内容复制到</span> <span class="no">REG</span><span class="err">，</span><span class="mi">1000</span> <span class="err">是虚拟地址</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>虚拟地址构成了虚拟地址空间（virtual address space）。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用相同地址的物理内存字。在使用虚拟内存时，虚拟地址被送到内存管理单元（Memory Management Unit，MMU），MMU 把虚拟地址映射为物理内存地址</p>
</li>
<li>
<p>页表给出虚拟地址与物理内存地址之间的映射关系</p>
</li>
<li>
<p>虚拟地址空间按固定大小划分为页面（page），物理内存中对应的单元称为页框（page frame），页面和页框的大小通常相同，页表说明了每个页面对应的页框。RAM 和磁盘之间的交换总是以整个页面为单元进行的</p>
</li>
</ul>
<p></p>
<ul>
<li>
<p>对应 64 KB 的虚拟地址空间和 32 KB 的物理内存，可以得到 16 个页面和 8 个页框</p>
</li>
<li>
<p>比如执行指令访问地址 0 时</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REG</span><span class="p">,</span> <span class="mi">0</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>虚拟地址 0 被送到 MMU，MMU 发现其位于页面 0（0 - 4095），根据映射结果，页面 0 对应页框 2（8192 - 12287），于是 MMU 将地址转换为 8192，并把地址 8192 送到总线上。内存并不需要知道 MMU 做的事，只看到一个访问地址 8192 的请求并执行</p>
</li>
<li>
<p>当虚拟地址空间比物理内存大时，就会存在未被映射的页面。当程序执行指令访问未映射的页面</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REG</span><span class="p">,</span> <span class="mi">32780</span>  <span class="err">;位于页面</span> <span class="mi">8</span><span class="err">（从</span> <span class="mi">32768</span> <span class="err">开始）</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>MMU 发现该页面未被映射，于是使 CPU 陷入（traps）到操作系统，这称为缺页中断（page fault）。操作系统找到一个很少使用的页框并把其内容写入磁盘，比如找到页面 1 对应的页框 1。将页面 1 标记为未映射，再把页面 8 映射到这个页框 1，然后重新启动访问指令，此时虚拟地址 32780 就可以映射到物理地址 4108（4096 + 32780 - 32768）</p>
</li>
<li>
<p>页面大小一般是 2 的整数次幂。比如页面大小为 4 KB，即 <code>2 ^ 12</code>，对于一个 16 位的虚拟地址，即可用前 4 位表示页面的页号，后 12 位表示偏移量。比如虚拟地址 <code>8192</code>，二进制为 <code>0010 0000 0000 0100</code>，<code>0010</code> 即为页号，<code>0000 0000 0100</code> 即为偏移，因此 <code>8192</code> 位于页号 <code>2</code> 偏移 <code>4</code> 的位置</p>
</li>
<li>
<p>页表中，查找页号 <code>2</code> 对应的页框号为 <code>6</code>，把页框号 <code>110</code> 复制到输出寄存器的高 3 位，后 12 位保持不变，<code>110 0000 0000 0100</code> 即为物理地址</p>
</li>
<li>
<p>除了页框号，页表还会有一些其他的位</p>
<ul>
<li>有效位，如果该位为 1 则说明存在映射，如果为 0，则访问该页面将引起缺页中断</li>
<li>保护（protection）位，指出一个页允许的访问方式，比如用一个位表示，0 表示读写，1 表示只读</li>
<li>修改（modified）位，记录页面使用情况，写入页面后由硬件自动设置修改位，该位也称为脏位（dirty bit），在重新分配页框时很有用，比如一个页是脏的（已被修改过），则必须把它写回磁盘，是干净的则可以直接丢弃</li>
<li>访问（referenced）位，在页面被访问时设置，主要用来帮助操作系统在发生缺页中断时选择要淘汰的页面</li>
<li>禁止高速缓存位，该位对于映射到设备寄存器而非常规内存的页面十分重要，比如操作系统持续等待 I/O 设备的响应，必须保证硬件读取的数据来自设备而非高速缓存</li>
</ul>
</li>
</ul>
<h2 id="加速分页过程">加速分页过程</h2>
<ul>
<li>在任何分页系统中都需要考虑两个问题
<ul>
<li>虚拟地址到物理地址的映射必须非常快：每次访问内存都要进行映射，所有的指令最终都来自内存，并且很多指令也会访问内存中的操作数，因此每条指令进行一两次或更多页表访问是必要的。如果指令一条指令要 1 ns，页表查询必须在 0.2 ns 内完成，以避免映射成为主要瓶颈</li>
<li>如果虚拟地址空间很大，页表也会很大：现代计算机至少使用 32 位虚拟地址，假设页面大小为 4 KB，32 位的地址空间将有 100 万页，页表也必然有 100 万条表项。每个进程都有自己的虚拟地址空间，都需要自己的页表，于是需要为进程分配非常多的连续页框</li>
</ul>
</li>
<li>大多数程序总是对少量页面多次访问，没有必要让将整个页表保存在内存中，由此得出的一种解决方案是，设置一个转换检测缓冲区（Translation Lookaside Buffer，TLB），也称相联存储器（associate memory）或快表，将虚拟内存直接映射到物理地址，而不必再访问页表</li>
<li>TLB 通常在 MMU 中，包含少量表项，实际中很少会超过 256 个。将一个虚拟地址放入 MMU 中进行转换时，硬件先将页号与 TLB 中所有表项进行匹配，如果匹配成功且操作不违反保护位，则直接从 TLB 中取出页框号，而不再访问页表。如果匹配失败，则进行正常的页表查询，并从 TLB 淘汰一个表项，然后用新找到的页表项代替它</li>
<li>处理巨大的虚拟地址空间有两种解决方法：多级页表和倒排页表</li>
<li>比如 32 位地址空间中，页面大小为 4 KB，偏移量占 12 位，则页号占 20 位。将页号分组，页表项大小为 4 B，4 KB 的页面就能放 1024 个表项，于是每 1024 个页号分为一组。这样分组得到的页表为二级页表，再用一个顶级页表映射页号到二级页表的物理地址即可</li>
<li>使用多级页表时，32 位的地址划分为 10 位的 PT1 域、10 位的 PT2 域、12 位的 Offset 域。比如对于虚拟地址 <code>0000 0000 0100 0000 0011 0000 0000 0100</code>，PT1 为 1，PT2 为 3，Offset 为 4，MMU 先访问顶级页表 1 处，得到二级页表的物理地址，由此访问二级页表 3 处，得到页框号，最后加上 Offset 即为最终的物理地址</li>
<li>二级页表可以扩充为更多级。每级页表大小不能超过一个页面，比如 4 KB 页面，偏移为 12 位，页表项大小为 4 B，每 1024 分为一组，则每级最多 10 位，如果是 40 位，则除去 12 位，剩余可以划分为一级 8 位、二级 10 位、三级 10 位的三级页表</li>
<li>单级页表只要进行两次访存（第一次访问页表得到物理地址，第二次访问物理地址），而每多一级页表就要多一次访存（不考虑 TLB）</li>
<li>另一种方式是倒排页表（inverted page table），让每个页框（而非页面）对应一个表项。比如对于 64 位虚拟地址，4 KB 的页，4 GB 的 RAM，一个倒排页表仅需要 <code>2 ^ 20</code> 个表项，表项记录了一个页框对应的页面（进程）</li>
<li>虽然倒排页表节省了大量空间，但从虚拟地址到物理地址的转换变得很困难，必须搜索整个倒排页表来找到页面，每一次搜索都要执行访问操作。这个问题可以通过 TLB 解决</li>
<li>倒排页表在 64 位机器中很常见，因为 64 位机器中，即使使用大页面页表项数量也很庞大，比如对于 4 MB 页面和 64 位虚拟地址，需要的页表项目数为 <code>2 ^ 42</code></li>
</ul>
<h2 id="页面置换算法">页面置换算法</h2>
<ul>
<li>发生缺页中断时，操作系统必须换出内存中的一个页面，以腾出空间。如果换出的页面在内存驻留期间被修改过，就必须把它写回磁盘以更新其在磁盘上的副本，如果未被修改过则不需要写回</li>
<li>如果一个经常用到的页面被换出内存，短时间内它可能又被调入内存，这会带来不必要的开销。因此发生缺页中断时，如何选择要换出的页面是一个值得考虑的问题</li>
</ul>
<h3 id="最优页面置换算法optimal-replacementopt">最优页面置换算法（OPTimal replacement，OPT）</h3>
<ul>
<li>
<p>OPT 算法的思路很简单，从所有页面中选出下次访问时间距现在最久的淘汰</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">432143543215</span>  <span class="c1">// 页面队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">444444444222</span>  <span class="c1">// 页 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">33333333311</span>  <span class="c1">// 页 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="mi">2111555555</span>  <span class="c1">// 页 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TTTT</span>  <span class="n">T</span>  <span class="n">TT</span>   <span class="c1">// 是否发生缺页中断（共发生 7 次缺页中断，4 次页面置换）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">|</span>
</span></span><span class="line"><span class="cl">  <span class="err">把</span> <span class="mi">2</span> <span class="err">替换掉，因为</span> <span class="mi">432</span> <span class="err">中，</span><span class="mi">2</span> <span class="err">下一次被访问的时间最靠后</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>这个算法的唯一问题在于，它是无法实现的，因为发生缺页中断时，操作系统无法得知各个页面下一次在什么时候被访问</p>
</li>
<li>
<p>作为理论最优算法，可以用它衡量其他算法的性能。如果操作系统的页面置换性能只比最优算法差 1%，那么花费大量精力来优化算法就不是特别必要的</p>
</li>
</ul>
<h3 id="最近未使用页面置换算法not-recently-usednru">最近未使用页面置换算法（Not Recently Used，NRU）</h3>
<ul>
<li>操作系统为每个页面设置了两个状态位，当页面被访问时设置 R 位，被修改时设置 M 位。启动进程时，所有页面的 RM 均设为 0，并且 R 被定期（比如每次时钟中断时）清零</li>
<li>发生缺页中断时，根据 RM 位的值，可以将页面分为 4 类
<ul>
<li>第 0 类：未访问未修改（R 位为 0，M 位为 0）</li>
<li>第 1 类：未访问已修改（R 位为 0，M 位为 1，看起来似乎不可能，实际可以由第 3 类转换而来）</li>
<li>第 2 类：已访问未修改（R 位为 1，M 位为 0）</li>
<li>第 3 类：已访问已修改（R 位为 1，M 位为 1，R 在清零后即变为第 1 类）</li>
</ul>
</li>
<li>NRU 算法随机从第0类中选择一个页面淘汰，如果第 0 类中没有页面则选择第 1 类，以此类推，优先选择编号最小的类</li>
<li>这个算法的隐含思想是，淘汰一个未访问已修改页面（第 1 类），比淘汰一个频繁使用的干净页面（第 2 类）好</li>
<li>NRU 的主要优点是易理解且能有效实现，虽然性能不是最好的，但已经够用了</li>
</ul>
<h3 id="先进先出页面置换算法first-in-first-outfifo">先进先出页面置换算法（First-In First-Out，FIFO）</h3>
<ul>
<li>顾名思义，淘汰最早进入的页面</li>
<li>操作系统维护一个内存中所有当前页面的链表，最新进入的页面放在表尾，淘汰页面就是表头页面</li>
<li>FIFO 可能淘汰常用页面，甚至可能出现分配页面数增多但缺页率反而提高的异常现象（Belady 异常），因此很少使用纯粹的 FIFO 算法</li>
</ul>
<h3 id="第二次机会页面置换算法second-chance">第二次机会页面置换算法（Second-Chance）</h3>
<ul>
<li>对 FIFO 做一个简单的修改：检查最老页面的 R 位（访问位），如果 R 位是 0 则淘汰，如果是 1 则把 R 位清零，并把该页面放到表尾，然后继续搜索</li>
<li>如果所有页面都被访问过，则该算法就简化为纯粹的 FIFO 算法</li>
</ul>
<h3 id="时钟页面置换算法clock">时钟页面置换算法（clock）</h3>
<ul>
<li>第二次机会算法经常要在链表中移动页面，降低了效率且不是很有必要</li>
<li>一个更好的办法是将所有页面保存在在一个类似钟面的环形链表中，一个表针指向最老的页面。发生缺页中断时，检查表针指向的页面，如果 R 位是 0 则淘汰该页面，并在该位置插入新页面，然后表针后移一步。如果 R 位是 1 则把 R 位清零，然后表针后移一步。如果该页已存在，不发生缺页中断，R 位是 0 则改为 1，表针不需要移动</li>
</ul>
<h3 id="最近最少使用页面置换算法least-recently-usedlru">最近最少使用页面置换算法（Least Recently Used，LRU）</h3>
<ul>
<li>LRU 是 OPT 的一个近似思路，在前几条指令中频繁使用的页面很可能在后几条指令中被使用，反过来说，很久没使用的页面很可能在之后的长时间内仍然不使用</li>
<li>LRU 是可实现的，但代价很高。实现 LRU 需要维护一个所有页面的链表，最常使用的位于表头，每次访问时必须更新整个链表，在链表中找到页面删除后再添加到表头</li>
<li>有一些使用特殊硬件实现 LRU 的方法，比如要求硬件有一个 64 位计数器，它在每条指令执行完后加 1，每个页表项中有一个足够容纳这个计数器值的域。发生缺页中断时，检查所有页表项的计数值，值最小的就是最近最少使用的</li>
<li>只有非常少的计算机有这种硬件，LRU 很优秀但很难实现</li>
</ul>
<h3 id="最不常用页面置换算法not-frequently-usednfu">最不常用页面置换算法（Not Frequently Used，NFU）</h3>
<ul>
<li>NFU 是 LRU 的一个软件实现方案</li>
<li>NFU 将每个页面与一个软件计数器关联，计数器初值为 0，每次时钟中断时，操作系统扫描内存中所有页面，将每个页面的 R 位值加到计数器上，这个计数器大致跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面</li>
<li>NFU 的问题在于，第一遍扫描中频繁使用的页面，第二遍扫描时，计数器值仍然很高。这就会导致后续扫描中，即使该页面使用次数最少，也会由于计数器值较高而不被置换</li>
</ul>
<h3 id="老化aging算法">老化（aging）算法</h3>
<ul>
<li>
<p>老化算法对 NFU 做了一些改进，在R位加进之前先将计数器右移一位，然后把 R 位加到计数器最左端的位</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">页面
</span></span><span class="line"><span class="cl">0    10000000     11000000     11100000     11110000     01111000
</span></span><span class="line"><span class="cl">1    00000000     10000000     11000000     01100000     10110000
</span></span><span class="line"><span class="cl">2    10000000     01000000     00100000     00100000     10001000
</span></span><span class="line"><span class="cl">3    00000000     00000000     10000000     01000000     00100000
</span></span><span class="line"><span class="cl">4    10000000     11000000     01100000     10110000     01011000
</span></span><span class="line"><span class="cl">5    10000000     01000000     10100000     01010000     00101000
</span></span><span class="line"><span class="cl">    |            |            |            |            |
</span></span><span class="line"><span class="cl">    访问页面 024 访问 014     访问 013     访问 04      访问 12</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>发生缺页中断时，置换计数器值最小的页面，因为前面的 0 越多，说明其最近越不常被访问</p>
</li>
<li>
<p>老化算法非常近似 LRU，但有两个区别</p>
<ul>
<li>比如最后一次访问时，如果发生缺页中断，需要置换一个页面。页面 3 和页面 5 开头都是 001，即前两次未被访问，前第三次被访问，如果前第三次是页面 5 先被访问，则 LRU 会替换页面 5，但这里无法区分两者谁先被访问，而只能替换值较小的页面 3</li>
<li>老化算法计数器位数有限，比如这里是 8 位，只能记录过去 8 次的访问，超过该次数的记录无法得知。不过实践中，如果时钟滴答是 20 ms，8 位一般是够用的，如果一个页面 160 ms 未被访问，则很可能不重要</li>
</ul>
</li>
</ul>
<h3 id="工作集页面置换算法">工作集页面置换算法</h3>
<ul>
<li>在单纯的分页系统中，刚开始启动进程时，内存中没有页面，CPU 尝试取第一条指令时就会产生一次缺页中断，使操作系统装入含第一条指令的页面。一段时间后，进程需要的大部分页面都在内存了，进程开始在较少缺页中断的情况下运行。这个策略称为请求调页（demand paging），因为页面在需要时被调入，而不是预先装入</li>
<li>一个进程当前正在使用的页面集合称为它的工作集（Denning），如果整个工作集都被装入内存中，那么进程在运行到下一阶段之前不会产生很多缺页中断。如果内存太小无法容纳整个工作集，进程的运行过程中将产生大量缺页中断，导致运行速度变慢，因为通常执行一条指令只要几纳秒，而从磁盘读入一个页面需要十几毫秒。如果每执行几条指令就发生一次缺页中断，就称这个程序发生了颠簸（Denning）</li>
<li>请求调页策略中，每次装入一个进程都要产生大量缺页中断，速度太慢，并且 CPU 花了很多时间处理缺页中断，浪费了许多 CPU 时间，因此不少分页系统会设法跟踪工作集，以确保在进程运行前，工作集已经在内存中了，这个方法称为工作集模型（Denning），也叫预先调页（prepaging），其目的在于大大减少缺页中断率</li>
<li>工作集是随着时间变化的，它是最近k次访存所访问过的页面集合。为了实现该算法，需要一种精确的方法来确定哪些页面在工作集中，为此必须预先选定 k 值。但有了工作集的定义并不意味着就能计算出工作集</li>
<li>假设有一个长度为 k 的移位寄存器，每次访存都把寄存器左移一位，然后在最右端插入刚才访问过的页面号，寄存器中 k 个页面号的集合就是工作集。理论上，发生缺页中断时，只要读出寄存器中的内容并排序，然后删除重复的页面，结果就是工作集。但维护该寄存器并在缺页中断时处理它需要很大的开销，因此该技术从未被使用过</li>
<li>有几种近似的方法作为替代，一种常见近似方法是，不向后查找最近 k 次的内存访问，而是查找过去一定时间内，比如过去 10 ms 访存所用到的页面集合</li>
<li>基于工作集的页面置换算法是，找出一个不在工作集中的页面并淘汰，为此表项中至少需要包含两条信息，一是上次使用该页面的近似时间，二是 R 位（访问位）</li>
<li>处理表项时，如果 R 位是 1，则把上次使用时间改为当前实际时间。如果 R 位是 0，则可以作为置换候选者，计算生存时间（当前实际时间与上次使用时间的差），如果生存时间大于定义工作集范围的时间，则该页面在工作集外，将其置换。如果 R 为 0 且生存时间不超过定义工作集范围的时间，则该页面仍在工作集中，记录该页面。如果扫描完整个页表都没有可淘汰的，则从记录页面中选一个生存时间最长的淘汰，如果记录页面为空，即所有页面 R 位均为 1，则随机选择一个淘汰</li>
</ul>
<h3 id="工作集时钟wsclock页面置换算法">工作集时钟（WSClock）页面置换算法</h3>
<ul>
<li>工作集算法需要扫描整个页表，比较费时，结合时钟算法的思路稍作改进，即可得到 WSClock 算法。它实现简单，性能较好，在实际工作中得到了广泛使用</li>
</ul>
<h2 id="分段segmentation">分段（Segmentation）</h2>
<ul>
<li>一个编译器在编译过程中会建立许多表，其中可能包括
<ul>
<li>被保存起来供打印清单用的源程序正文（用于批处理系统）</li>
<li>包含变量名字和属性的符号表</li>
<li>包含用到的所有整型量和浮点常量的表</li>
<li>包含程序语法分析结果的语法分析树</li>
<li>编译器内部过程调用使用的堆栈</li>
</ul>
</li>
<li>在一维地址空间中，当有多个动态增加的表时，就可能发生碰撞。一种能令程序员不用管理表扩张和收缩的方法是，在机器上提供多个互相独立的段（segment）的地址空间，段的长度可以不同，在运行时可以改变，比如堆栈段的长度在数据压入时会增长，在数据弹出时会减小</li>
<li>每个段都构成一个独立的地址空间，在内存中占据连续空间，可以独立地增长或减小，而不会影响其他段</li>
<li>段是按逻辑功能的划分的实体，程序员使用起来更方便，并且程序的可读性更高。此外，分段有助于共享和保护。分段系统中，可以把共享库放到一个单独的段中由各个进程共享，而不需要在每个进程的地址空间中保存一份。当组成一个程序的所有过程都被编译和链接好以后，如果一个段的过程被修改并重新编译，也不会影响到其他段，因为这个段的起始地址（基址）没有被修改</li>
<li>要在分段的存储器中表示一个地址，必须提供一个段号（段名）和一个段内地址（段内偏移量）</li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">31</span> <span class="p">...</span> <span class="mi">16</span> <span class="mi">15</span> <span class="p">...</span> <span class="mi">0</span>  <span class="c1">// 可用 31 - 16 表示段号，15 - 0 表示段内地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>每个进程需要一张段表，每个段表项记录一个段的起始位置和段的长度。段表项长度是固定的，因此段号可以是隐含的，不占存储空间。查找时，如果段号越界，则产生越界中断。如果段内地址超出段长，则产生越界中断</li>
</ul>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">K 号段的段表存放地址 = 段表起始位置 + K * 段表项长度
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">段号 基址 段长
</span></span><span class="line"><span class="cl">0    20K  3K
</span></span><span class="line"><span class="cl">1    60K  2K
</span></span><span class="line"><span class="cl">2    40K  5K
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">如果一个逻辑地址段号为 1，段内地址为 1024
</span></span><span class="line"><span class="cl">段号 1 的段长为 2K，大于 1024，不产生越界中断
</span></span><span class="line"><span class="cl">存放地址 = 60K + 1024 = 61K</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>分段管理的缺点是，如果段长过大，则不便于分配连续空间，此外会产生外部碎片。分页管理的内存利用率高，不会产生外部碎片，只会有少量页内碎片。因此，两者结合可以互相弥补，实现段页式管理</li>
<li>段页式系统的地址由段号、页号、页内地址（页内偏移量）组成。分段对用户可见，而分页不可见</li>
</ul>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">31</span> <span class="p">...</span> <span class="mi">16</span> <span class="mi">15</span> <span class="p">...</span> <span class="mi">12</span> <span class="mi">11</span> <span class="p">...</span> <span class="mi">0</span>  <span class="c1">// 可用 31 - 16 表示段号，15 - 12 表示页号，11 - 0 表示页内地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>每个段表项记录页表长度、页表起始地址，通过页表起始地址找到页号，通过页号对应的页表项目找到物理地址，一共需要三次访存（如果引入以段号和页号为关键字的 TLB 且命中，则只需要一次访存）。段表项长度是固定的，段号可以是隐含的。同样，每个页表项长度固定，页号是隐含的</li>
</ul>
]]></description></item><item><title>C++ Concurrency in Action | IO</title><link>https://jianye0428.github.io/posts/io/</link><pubDate>Sun, 19 Nov 2023 13:05:24 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/io/</guid><description><![CDATA[<h2 id="io-硬件原理">I/O 硬件原理</h2>
<ul>
<li>I/O 设备就是可以将数据输入到计算机(如鼠标、键盘)，或者可以接收计算机输出数据的外部设备(如显示器)</li>
<li>I/O 设备按信息交换单位可分为两类
<ul>
<li><strong>块设备(block device)</strong>：把信息存储在固定大小的块中，每个块都有自己的地址。块设备的基本特征是，传输速率快，可寻址，每个块都能独立于其他块而读写。磁盘就是最常见的块可寻址设备，无论磁盘臂当前处于什么位置，总是能寻址其他柱面并且等待所需要的磁盘块旋转到磁头下面</li>
<li><strong>字符设备(character device)</strong>：以字符为单位发送或接收一个字符流，而不考虑任何块结构，因此传输速率较慢，不可寻址，也没有任何寻道操作，在输入/输出时常采用中断驱动方式。打印机、鼠标就是常见的字符设备</li>
</ul>
</li>
<li>I/O 设备一般由机械部件和电子部件两部分组成
<ul>
<li>机械部件主要用于执行具体 I/O 操作，如鼠标的按钮、键盘的按键、显示器的屏幕、硬盘的磁盘臂</li>
<li>电子部件也称作设备控制器(device controller)或适配器(adapter)，通常是主板上的芯片，或一块插入主板扩充槽的印刷电路板</li>
</ul>
</li>
<li>CPU 无法直接控制机械部件，因此需要通过设备控制器作为中介来控制机械部件。设备控制器的主要功能有
<ul>
<li>接收和识别 CPU 发出的命令：每个控制器有几个寄存器用于与 CPU 通信，通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行其他某些操作</li>
<li>向 CPU 报告设备的状态：通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等</li>
<li>数据交换：除了控制寄存器外，许多设备还有一个操作系统可以读写的数据缓冲区，比如在屏幕上显示像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，可供程序或操作系统写入数据</li>
<li>地址识别：为了区分设备控制器中的寄存器，需要给每个寄存器设置一个地址，控制器通过 CPU 提供的地址来判断 CPU 要访问的寄存器</li>
</ul>
</li>
<li>设备控制器中有多个寄存器，为这些寄存器编址有两种方式
<ul>
<li>内存映射 I/O(memory-mapped I/O)：所有设备控制器的寄存器映射到内存空间中，每个控制寄存器被分配一个唯一的内存地址，并且不会有内存被分配到这一地址</li>
<li>寄存器独立编址：每个寄存器被分配一个 I/O 端口(port)号，所有端口号形成 I/O 端口空间(I/O port space)，并且受到保护使得普通用户程序不能对其进行访问，只有操作系统可以访问。这一方案中，内存地址空间和 I/O 地址空间是不同且不相关的</li>
</ul>
</li>
</ul>
<h2 id="io-软件原理">I/O 软件原理</h2>
<ul>
<li>I/O 软件的设计有以下目标
<ul>
<li>设备独立性(device independence)：允许编写出的程序可以访问任意 I/O 设备而无需事先指定设备，比如读取一个文件作为输入的程序，应该能在硬盘、DVD 或 USB 盘上读取文件，无需为每一种不同的设备修改程序</li>
<li>统一命名(uniform naming)：一个文件或一个设备的名字应该是一个简单的字符串或一个整数，不应依赖于设备</li>
<li>错误处理(error handling)：一般来说，错误应该尽可能在接近硬件的层面得到处理。当控制器发现一个读错误时，如果它能够处理，就应该自己设法纠正错误。如果控制器处理不了，设备驱动程序就应当予以处理，可能只需要重读一次这块数据就正确了</li>
<li>同步(synchronous，即阻塞)和异步(asynchronous，即中断驱动)传输：大多数物理 I/O 是异步的，比如 CPU 启动传输后便转去做其他工作，直到中断发生。如果 I/O 操作是阻塞的，用户程序就更容易编写，比如 read 系统调用之后程序将自动被挂起，直到缓冲区中的数据准备好，而正是操作系统将实际异步的操作变为了在用户程序看来是阻塞式的操作</li>
<li>缓冲(buffering)：数据离开一个设备之后通常不能直接存放到最终目的地，比如从网络上进来一个数据包时，直到将该数据包存放到某个地方，并对其进行检查，操作系统才知道要将其置于何处。缓冲涉及大量复制工作，经常对 I/O 性能有重大影响</li>
<li>共享设备和独占设备：共享设备能同时让多个用户使用(如磁盘)，独占设备则只能由单个用户独占使用(如磁带机)。独占设备的引入带来了各种问题(如死锁)，操作系统必须能处理共享设备和独占设备以避免问题发生</li>
</ul>
</li>
<li>I/O 有三种实现方式
<ul>
<li>程序控制 I/O(programmed I/O)：这是 I/O 的最简单形式。CPU 轮询设备状态，当设备准备好时，CPU 向控制器发出读指令，从 I/O 设备中读取字，再把这些字写入到存储器。这种方式的优点是实现简单，缺点是在完成全部 I/O 之前，CPU 的所有时间都被其占用，如果 CPU 有其他事情要做，轮询就导致了 CPU 利用率低</li>
<li>中断驱动 I/O ：用中断阻塞等待 I/O 的进程，CPU 在等待 I/O 设备就绪时，通过调度程序先执行其他进程。当 I/O 完成后(比如打印机打印完一个字符，准备接收下一个字符)，设备控制器将向 CPU 发送一个中断信号，CPU 检测到中断信号后保存当前进程的运行环境信息，然后执行中断驱动程序来处理中断。CPU 从设备控制器读一个字的数据传送到 CPU 寄存器，再写入主存，接着 CPU 恢复其他进程的运行环境并继续执行(打印下一个字符)。中断的优点是提高了 CPU 利用率，缺点是每次只能读一个字，每次都要发生一个中断，频繁的中断处理将浪费一定的 CPU 时间</li>
<li>使用 DMA(Direct Memory Access)的 I/O ：让 DMA 控制器来完成 CPU 要做的工作，使得 CPU 可以在 I/O 期间做其他操作。有了 DMA 控制器，就不用每个字中断一次，而是减少到每个缓冲区一次。DMA 控制器通常比 CPU 慢很多，如果 CPU 在等待 DMA 中断时没有其他事情要做，采用中断驱动 I/O 甚至程序控制 I/O 也许更好</li>
</ul>
</li>
</ul>
<h2 id="io-软件层次">I/O 软件层次</h2>
<ul>
<li>I/O 软件通常组织成四个层次，从上层到底层依次为
<ul>
<li>用户级 I/O 软件：实现了与用户交互的接口，为用户提供 I/O 操作相关的库函数接口，如 <code>printf</code></li>
<li>与设备无关的操作系统软件：向用户层提供系统调用，如为 <code>printf</code> 提供 <code>write</code>，另外还要提供设备保护(设置访问权限)、缓冲、错误报告、分配与释放专用设备、建立逻辑设备名到物理设备名的映射关系等功能</li>
<li>设备驱动程序(device driver)：每个连接到计算机上的 I/O 设备都需要某些设备特定的代码来对其进行控制，这样的代码称为设备驱动程序</li>
<li>中断处理程序：进行中断处理</li>
</ul>
</li>
</ul>
<h2 id="盘">盘</h2>
<ul>
<li>盘有多种多样的类型，最常用的是磁盘，它具有读写速度同样快的特点，适合作为辅助存储器(用于分页、文件系统等)</li>
<li>磁盘被组织成柱面，每一个柱面包含若干磁道，磁道数与垂直堆叠的磁头个数相同，磁道又被分为若干扇区，通过 <code>(柱面号, 盘面号, 扇区号)</code> 即可定位一个磁盘块</li>
<li>磁盘臂调度算法有
<ul>
<li>先来先服务算法(First-Come First-Served，FCFS)：按照请求接收顺序完成请求，优点是公平简单易实现，缺点是平均寻道时间较长</li>
<li>最短寻道时间优先算法(Shortest Seek Time First，SSTF)：下一次处理，磁头向所有请求中距离最近的位置移动。缺点是可能出现饥饿现象</li>
<li>扫描算法(SCAN)：也叫电梯算法(elevator algorithm)，磁头持续向一个方向移动，直到到达最内侧或最外侧时才改变方向。优点是平均寻道时间较短，不会产生饥饿现象</li>
<li>LOOK 调度算法：对扫描算法稍作优化，如果磁头移动方向上已没有需要处理的请求，则直接改变方向</li>
<li>循环扫描算法(C-SCAN)：SCAN 算法对于各个位置磁道的响应频率不平均，靠近磁盘两侧的可能更快被下一次访问。为了解决这个问题，C-SCAN 算法的原理是，只在一个移动方向上处理请求，磁头返回时不处理任何请求</li>
<li>C-LOOK：只在一个移动方向上处理请求，如果该方向之后没有要处理的请求，则磁头返回，并且只需要返回到第一个有请求的位置</li>
</ul>
</li>
</ul>
]]></description></item></channel></rss>