<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - yejian's blog</title><link>https://jianye0428.github.io/posts/</link><description>所有文章 | yejian's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>18817571704@163.com (Jian YE)</managingEditor><webMaster>18817571704@163.com (Jian YE)</webMaster><lastBuildDate>Sat, 26 Aug 2023 10:55:58 +0800</lastBuildDate><atom:link href="https://jianye0428.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Effective STL [4] | 用empty来代替检查size()是否为0</title><link>https://jianye0428.github.io/posts/clause_4/</link><pubDate>Mon, 24 Jul 2023 13:15:46 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_4/</guid><description><![CDATA[<h2 id="判断容器是否为空">判断容器是否为空</h2>
<p>对于任意容器 randy, 当判断是否为空的时候，会使用到以下判断语句：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">randy</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">randy</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应该首选empty的构造，而且理由很简单：<strong>对于所有的标准容器，empty是一个常数时间的操作，但对于一些<code>list</code>实现，<code>size</code>花费线性时间</strong></p>
<h2 id="list-size耗时">list size耗时</h2>
<p><strong>Q</strong>：但是什么造成list这么麻烦？为什么不能也提供一个常数时间的size？</p>
<p><strong>A</strong>：对于list特有的splice有很多要处理的东西。</p>
<p>考虑这段代码：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">list1</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span> <span class="c1">// 把list2中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">list2</span><span class="p">,</span> <span class="c1">// 从第一次出现5到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">find</span><span class="p">(</span><span class="n">list2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">list2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">5</span><span class="p">),</span> <span class="c1">// 最后一次出现10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">find</span><span class="p">(</span><span class="n">list2</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">list2</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="mi">10</span><span class="p">).</span><span class="n">base</span><span class="p">()</span> <span class="c1">// 的所有节点移到list1的结尾。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>除非<code>list2</code>在5的后面有一个10，否则这段代码无法工作，但是咱们假设这不是问题。</p>
<p><strong>Q</strong>：假设上述代码可以正常运行，那么接合后<code>list1</code>有多少元素？</p>
<p><strong>A</strong>：结合后<code>list1</code>的元素个数=接合之后前<code>list1</code>的元素个数 + 接合进去的元素个数</p>
<p><strong>Q</strong>：有多少元素接合进去了？</p>
<p><strong>A</strong>：元素个数为<code>find(list2.rbegin(), list2.rend(), 10).base()</code>所定义的区间的元素个数。</p>
<p>到底有多少？</p>
<p>在没有遍历这个区间并计数之前无法知道。</p>
<p><strong>问题剖析</strong></p>
<p>如果size是一个常数时间操作，当操作时每个list成员函数必须更新list的大小。也包括了splice。</p>
<p>让区间版本的splice更新它所更改的list大小的<strong>唯一的方法</strong>是算出接合进来的元素的个数，但<strong>那么做就会使它不可能有你所希望的常数时间的性能。</strong></p>
<p>如果你去掉了splice的区间形式要更新它所修改的list的大小的需求，splice就可以是常数时间，但<strong>size就变成线性时间的操作</strong>。</p>
<p>一般来说，<strong>必须遍历它的整个数据结构来才知道包含多少元素</strong>。</p>
<p>不同的list实现用不同的方式解决这个矛盾，依赖于他们的作者选择的是让size或splice的区间形式达到最高效率。</p>
<p>如果你碰巧使用了一个常数时间的splice的区间形式比常数时间的size优先级更高的list实现，<strong>调用empty比调用size更好，因为empty总是常数时间操作。</strong></p>
<h2 id="结论">结论</h2>
<p>不同的list实现用不同的方式解决这个矛盾，依赖于它们的作者选择的是让size或splice的区间形式达到最高效率。</p>
<p>如果你碰巧使用了一个常数时间的splice的区间形式比常数时间的size优先级更高的list实现，<font color=blue>调用empty比调用size更好，因为empty总是常数时间操作。</font></p>
<h2 id="stl-vector-和-list的empty-及-size--实现源码">STL vector 和 list的empty 及 size  实现源码</h2>
<p><strong>vector</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_type</span>
</span></span><span class="line"><span class="cl">  <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="n">_GLIBCXX_NOEXCEPT</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="k">return</span> <span class="n">size_type</span><span class="p">(</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">());</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="n">_GLIBCXX_NOEXCEPT</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="k">return</span> <span class="n">begin</span><span class="p">()</span> <span class="o">==</span> <span class="n">end</span><span class="p">();</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>list</strong></p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/**  Returns the number of elements in the %list.  */</span>
</span></span><span class="line"><span class="cl"><span class="n">size_type</span>
</span></span><span class="line"><span class="cl"><span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="n">_GLIBCXX_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="n">_M_node_count</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// return the stored size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">size_t</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_M_node_count</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_get_size</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// size() 调用 _M_get_size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">size_t</span> <span class="nf">_M_get_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span><span class="p">.</span><span class="n">_M_size</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// [23.2.2.2] capacity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">*  Returns true if the %list is empty.  (Thus begin() would equal
</span></span></span><span class="line"><span class="cl"><span class="cm">*  end().)
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="n">_GLIBCXX_NODISCARD</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="n">_GLIBCXX_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span><span class="p">.</span><span class="n">_M_next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_node</span><span class="p">;</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Effective STL [5] | 尽量使用区间成员函数代替它们的单元素兄弟</title><link>https://jianye0428.github.io/posts/clause_5/</link><pubDate>Mon, 24 Jul 2023 13:15:50 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_5/</guid><description><![CDATA[<h2 id="example">Example</h2>
<p>Q：给定两个vector，v1和v2，使v1的内容和v2的后半部分一样的最简单方式是什么？</p>
<p>A：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">v1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个测验设计为做两件事:</p>
<ol>
<li>它提供给我一个机会来提醒你assign成员函数的存在</li>
</ol>
<p>太多的程序员没注意到这是一个很方便的方法。<strong>它对于所有标准序列容器（vector，string，deque和list）都有效。</strong></p>
<p>无论何时你必须完全代替一个容器的内容，你就应该想到赋值。</p>
<p>如果你只是拷贝一个容器到另一个同类型的容器，<code>operator=</code>就是选择的赋值函数，但对于示范的那个例子，当你想要给一个容器完全的新数据集时，assign就可以利用，但<code>operator=</code>做不了。</p>
<ol start="2">
<li>演示为什么区间成员函数优先于它们的单元素替代品。</li>
</ol>
<p>区间成员函数是一个像STL算法的成员函数，使用两个迭代器参数来指定元素的一个区间来进行某个操作。</p>
<p>不用区间成员函数来解决这个条款开头的问题，你就必须写一个显式循环，可能就像这样:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Randy</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span> <span class="c1">// 假设v1和v2是Randy的vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v1</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Randy</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ci</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">ci</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">v1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">ci</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>写这段代码比写assign的调用要做多得多的工作。</p>
<p><strong>copy 替代循环</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">v1</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">copy</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">v1</span><span class="p">))</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然在这段代码中没有表现出循环，在copy中的确存在一个循环 。</p>
<p>效率损失仍然存在。</p>
<p>几乎所有目标区间是通过插入迭代器（比如，通过inserter，back_inserter或front_inserter）指定的copy的使用都可以——应该——通过调用区间 成员函数来代替。</p>
<p>比如这里，这个copy的调用可以用一个insert的区间版本代替：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">v1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个输入量稍微比调用copy少，但它发生的也比说的要直接：数据插入v1。</p>
<p>这里insert 也比 copy 好，因为字面上insert 表示有数据插入到了 v1中，而copy 的使用把它变得晦涩。</p>
<p><strong>关于东西被拷贝这个事实并没有什么好关注的，因为STL构建在东西会被拷贝的假定上。拷贝对STL来说很基本。</strong></p>
<p><strong>小结</strong></p>
<p>我们已经确定3个尽量使用区间成员函数代替它们的单元素兄弟的理由。 ● 一般来说使用区间成员函数可以输入更少的代码。 ● 区间成员函数会导致代码更清晰更直接了当。</p>
<h2 id="效率">效率</h2>
<p>当处理标准序列容器时，应用单元素成员函数比完成同样目的的区间成员函数需要更多地内存分配，更频繁地拷贝对象，而且/或者造成多余操作。</p>
<p>对此，我之前还做了个单元素兄弟插入和批量插入的效率比较的文章<a href="https://mp.weixin.qq.com/s?__biz=MzUyMDc2MDMxNg==&amp;mid=2247490268&amp;idx=1&amp;sn=fcf5b24ec09e544f1f0fea544e59bfd6&amp;chksm=f9e4244fce93ad5988926b2cba002426ada65b79d4672b7bad565fff633c52a29f9f451d6494&amp;token=855912511&amp;lang=zh_CN&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">《vector 用 insert 批量插入效率高还是emplace_back效率高》<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，也证实了这个观点。</p>
<p>标准要求区间<code>insert</code>函数直接把现有元素移动到它们最后的位置，也就是，开销是每个元素一次移动。总共开销是n次移动，numValues次容器中的对象类型的拷贝构造函数，剩下的是类型的赋值操作符。</p>
<p>相比单元素插入策略，区间insert少执行了n*(numValues-1)次移动。</p>
<p>花一分钟想想。这意味着如果numValues是100，insert的区间形式会比重复调用insert的单元素形式的代码少花费99%的移动！</p>
<p>仅当可以不用失去两个迭代器的位置就能决定它们之间的距离时，一个区间insert函数才能在一次移动中把一个元素移动到它的最终位置。</p>
<p>这几乎总是可能的，因为所有前向迭代器提供了这个功能，而且前向迭代器几乎到处都是。</p>
<p>所有用于标准容器的迭代器都提供了前向迭代器的功能。非标准的散列容器的迭代器也是。</p>
<p>在数组中表现为迭代器的指针也提供了这样的功能。事实上，唯一不提供前向迭代器能力的标准迭代器是输入和输出迭代器。</p>
<p><strong>单元素插入的问题</strong></p>
<ul>
<li>
<p>当你试图去把一个元素插入内存已经满了的vector时，这个vector会分配具有更多容量的新内存，从旧内存把它的元素拷贝到新内存，销毁旧内存里的元素，回收旧内存。然后它添加插入的元素。</p>
</li>
<li>
<p>每当用完内存时，大部分vector实现都使它们的容量翻倍，所以插入numValues个新元素会导致最多$\log_2{numValues}$次新内存的分配。</p>
</li>
<li>
<p>每次一个地插入1000个元素会导致10次新的分配（包括它们负责的元素拷贝）。</p>
</li>
</ul>
<p>与之对比的是，一个区间插入可以在开始插入东西前计算出需要多少新内存（假设给的是前向迭代器），所以它不用多于一次地重新分配vector的内在内存。</p>
<p>刚才进行分析是用于vector的，但同样的理由也作用于string。</p>
<p><strong>deque</strong></p>
<p>对于deque，理由也很相似，但deque管理它们内存的方式和vector和string不同，所以重复内存分配的论点不能应用。</p>
<p>但是，关于<strong>很多次不必要的元素移动</strong>的论点通常通过对函数调用次数的观察也应用到了（虽然细节不同）。</p>
<p><strong>list</strong></p>
<p>在这里使用insert区间形式代替单元素形式也有一个性能优势。</p>
<p>关于重复函数调用的论点当然继续有效，但因为链表的工作方式，拷贝和内存分配问题没有发生。</p>
<p>取而代之的是，这里有一个新问题：过多重复地对list中的一些节点的next和prev指针赋值。</p>
<p>每当一个元素添加到一个链表时，持有元素的链表节点必须有它的next和prev指针集，而且当然新节点前面的节点（我们叫它B，就是“before”）必须设置它的next指针，新节点后面的节点（我们叫它A，就是“after”）必须设置它的prev指针</p>
<p></p>
<p>当一系列新节点通过调用list的单元素insert一个接一个添加时，除了最后一个以外的其他新节点都会设置它的next指针两次，第一次指向A，第二次指向在它后面插入的元素。每次在A前面插入时，它都会设置它的prev指针指向一个新节点。</p>
<p>如果numValues个节点插入A前面，插入节点的next指针会发生次多余的赋值，而且A的prev指针会发生numValues-1次多余的赋值。合计次没有必要的指针赋值。当然，指针赋值很轻量，但如果不是必须，为什么要为它们花费呢？</p>
<p>**避免开销的关键是使用list的insert区间形式。**因为那个函数知道最后有多少节点会被插入，它可以避免多余的指针赋值，对每个指针只使用一次赋值就能设置它正确的插入后的值</p>
<h2 id="区间函数">区间函数</h2>
<p>参数类型iterator意思是容器的迭代器类型，也就是container::iterator。</p>
<p>参数类型InputIterator意思是可以接受任何输入迭代器。</p>
<ul>
<li><strong>区间构造</strong></li>
</ul>
<p>所有标准容器都提供这种形式的构造函数：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">container</span><span class="o">::</span><span class="n">container</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="c1">// 区间的起点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span> <span class="c1">// 区间的终点
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果传给这个构造函数的迭代器是<code>istream_iterators</code>或<code>istreambuf_iterators</code>，你可能会遇到C++的最惊异的解析，原因之一是你的编译器可能会因为把这个构造看作一个函数声明而不是一个新容器对象的定义而中断。</p>
<ul>
<li><strong>区间插入</strong></li>
</ul>
<p>所有标准序列容器都提供这种形式的insert:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span> <span class="c1">// 区间插入的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="c1">// 插入区间的起点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span> <span class="c1">// 插入区间的终点
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关联容器使用它们的比较函数来决定元素要放在哪里，所以它们了省略position参数。</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">lnputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当寻找用区间版本代替单元素插入的方法时，不要忘记有些单元素变量用采用不同的函数名伪装它们自己。比如，<code>push_front</code>和<code>push_back</code>都把单元素插入容器，即使它们不叫<code>insert</code>。如果你看见一个循环调用<code>push_front</code>或<code>push_back</code>，或如果你看见一个算法——比如copy——的参数是<code>front_inserter</code>或者<code>back_inserter</code>，你就发现了一个<code>insert</code>的区间形式应该作为优先策略的地方。</p>
<ul>
<li><strong>区间删除</strong></li>
</ul>
<p>每个标准容器都提供了一个区间形式的<code>erase</code>，但是序列和关联容器的返回类型不同。</p>
<p><strong>序列容器</strong>提供了这个：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">iterator</span> <span class="n">container</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关联容器提供这个:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Q：为什么不同？</p>
<p>A：解释是，如果erase的关联容器版本返回一个迭代器（被删除的那个元素的下一个）会<strong>招致一个无法接受的性能下降</strong>。</p>
<p>这个条款的对insert的性能分析大部分也同样可以用于erase。单元素删除的函数调用次数仍然大于一次调用区间删除。当使用单元素删除时，每一次元素值仍然必须向它们的目的地移动一位，而区间删除可以在一个单独的移动中把它们移动到目标位置。</p>
<p>关于vector和string的插入和删除的一个论点是必须做很多重复的分配。（当然对于删除，会发生重复的回收。）那是因为用于vector和string的内存自动增长来适应于新元素，但当元素的数目减少时它不自动收缩。</p>
<ul>
<li><strong>区间赋值</strong></li>
</ul>
<p>所有标准列容器都提供了区间形式的assign:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">container</span><span class="o">::</span><span class="n">assign</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>几乎所有目标区间被插入迭代器指定的copy的使用都可以用调用的区间成员函数的来代替 。</p>
<p>尽量使用区间成员函数来代替单元素兄弟的三个可靠的论点。区间成员函数更容易写，它们更清楚地表达你的意图，而且它们提供了更高的性能。那是很难打败的三驾马车。</p>
<p>ref:</br>
[1]. <a href="https://mp.weixin.qq.com/s?__biz=MzUyMDc2MDMxNg==&amp;mid=2247490705&amp;idx=1&amp;sn=830797e69b61fe9693bf4aaea72df4b3&amp;chksm=f9e42202ce93ab1437ad36c37e141b0794328495c0c584d808d0f4ad36251680dbfba257b060&amp;cur_album_id=3009999611861975043&amp;scene=189#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s?__biz=MzUyMDc2MDMxNg==&mid=2247490705&idx=1&sn=830797e69b61fe9693bf4aaea72df4b3&chksm=f9e42202ce93ab1437ad36c37e141b0794328495c0c584d808d0f4ad36251680dbfba257b060&cur_album_id=3009999611861975043&scene=189#wechat_redirect<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [6] | 警惕C++最令人恼怒的解析</title><link>https://jianye0428.github.io/posts/clause_6/</link><pubDate>Mon, 24 Jul 2023 13:15:53 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_6/</guid><description><![CDATA[<h2 id="函数声明的几种方式">函数声明的几种方式</h2>
<ol>
<li>声明一个函数f带有一个double而且返回一个int：</li>
</ol>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>名为d的参数左右的括号是多余的，被忽略：</li>
</ol>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span> <span class="p">(</span><span class="n">d</span><span class="p">));</span> <span class="c1">// 同上；d左右的括号被忽略
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>省略了参数名：</li>
</ol>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span> <span class="c1">// 同上；参数名被省略
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>第一个声明了一个函数g，它带有一个参数，那个参数是指向一个没有参数、返回double的函数的指针：</li>
</ol>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="kt">double</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)());</span> <span class="c1">// g带有一个指向函数的指针作为参数
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>唯一的不同是pf使用非指针语法来声明(一个在C和C++中都有效的语法):</li>
</ol>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="kt">double</span> <span class="n">pf</span><span class="p">());</span> <span class="c1">// 同上；pf其实是一个指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>照常，参数名可以省略，所以这是g的第三种声明，去掉了pf这个名字：</li>
</ol>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="kt">double</span> <span class="p">());</span> <span class="c1">// 同上；参数名省略
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意参数名左右的括号（就像f的第二种声明中的d）和单独的括号（正如本例）之间的区别。</p>
<p><strong>参数名左右的括号被忽略，但单独的括号指出存在一个参数列表：它们声明了存在指向函数的指针的参数。</strong></p>
<h2 id="问题探讨">问题探讨</h2>
<p>假设有一个int的文件，想要把那些int拷贝到一个list中，可能会使用下面代码：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">dataFile</span><span class="p">(</span><span class="s">&#34;ints.dat&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 警告！这完成的并不是像你想象的那样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dataFile</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的想法是传一对<code>istream_iterator</code>给<code>list</code>的区间构造函数，因此把int从文件拷贝到list中。</p>
<p>这段代码可以编译，但是运行时什么都不会做，不会从文件中读出任何数据，甚至不会构建1个<code>list</code>。</p>
<p>第二句并不声明list，也不调用构造函数。</p>
<p>这声明了一个函数data，它的返回类型是<code>list&lt;int&gt;</code>。这个函数data带有两个参数：</p>
<p>● 第1个参数叫做dataFile。它的类型是<code>istream_iterator&lt;int&gt;</code>。dataFile左右的括号是多余的而且被忽略。</p>
<p>● 第2个参数没有名字。它的类型是指向一个没有参数而且返回<code>istream_iterator&lt;int&gt;</code>的函数的指针。</p>
<p>就像下面具有这条规则的代码：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{...};</span> <span class="c1">// 假设Widget有默认构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这并没有声明一个叫做w的Widget，它声明了一个叫作w的没有参数且返回Widget的函数。</p>
<p>本来代码的初衷，是用一个文件的内容来初始化一个<code>list&lt;int&gt;</code>对象，现在并没有达到我们的期望。</p>
<h2 id="解决办法">解决办法</h2>
<ol>
<li>函数调用前后增加括号
用括号包围一个实参的声明是不合法的，但用括号包围一个函数调用的观点是合法的，所以通过增加一对括号，代码变为：</li>
</ol>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">((</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dataFile</span><span class="p">)),</span> <span class="c1">// 注意在list构造函数的第一个实参左右的新括号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是可能的声明数据方法，给予<code>istream_iterators</code>的实用性和区间构造函数。</p>
<ol start="2">
<li>命名迭代器对象</li>
</ol>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">dataFile</span><span class="p">(</span><span class="s">&#34;ints.dat&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dataBegin</span><span class="p">(</span><span class="n">dataFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dataEnd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="n">dataBegin</span><span class="p">,</span> <span class="n">dataEnd</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>命名迭代器对象的使用和普通的STL编程风格相反，但是你得判断这种方法对编译器和必须使用编译器的人都模棱两可的代码是一个值得付出的代价。</p>
]]></description></item><item><title>Transformer Q &amp; A</title><link>https://jianye0428.github.io/posts/transformerqanda/</link><pubDate>Mon, 21 Aug 2023 07:59:36 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/transformerqanda/</guid><description><![CDATA[<h2 id="1-2017年深度学习领域的重大突破是什么">1. 2017年深度学习领域的重大突破是什么？</h2>
<p>Transformer。有两方面的原因:</p>
<p>1.1 一方面，Transformer是深度学习领域继MLP、RNN、CNN之后的第4大特征提取器(也被称为基础模型)。</br>
<strong>什么是特征提取器？</strong></br>
特征提取器是计算机模仿大脑，与外部世界(图像、文字、语音等)交互的方式，如图1所示。举例而言: Imagenet数据集中包含1000类图像，人们已经根据自己的经验把这一百万张图像分好1000类，每一类图像(如美洲豹)都有独特的特征。这时，神经网络(如ResNet18)也是想通过这种分类的方式，把每一类图像的特征尽可能提取或识别出来。分类不是最终目的，而是一种提取图像特征的手段，掩码补全图像也是一种提取特征的方式，图像块顺序打乱也是一种提取特征的方式。</p>
<p></p>
<p>1.2 另一方面，Transformer在深度学习领域扮演的角色: 第3次和第4次热潮的基石，如下图2所示。</p>
<p></p>
<h2 id="2-transformer的提出背景是什么">2. Transformer的提出背景是什么？</h2>
<p><strong>2.1 在领域发展背景层面</strong>: 当时时处2017年，深度学习在计算机视觉领域已经火了几年。从Alexnet、VGG、GoogleNet、ResNet、DenseNet;从图像分类、目标检测再到语义分割;但在自然语言处理领域并没有引起很大反响。</p>
<p><strong>2.2 技术背景层面</strong>:
(1)当时主流的序列转录任务(如机器翻译)的解决方案如下图3所示，在Sequence to Sequence架构下(Encoder-Decoder的一种)，RNN来提取特征，Attention机制将Encoder提取到的特征高效传递给Decoder。
(2)这种做法有两个不足之处，一方面是在提取特征时的RNN天生<strong>从前向后时序传递</strong>的结构决定了其无法并行运算，其次是当序列长度过长时，最前面序列的信息有可能被遗忘掉。因此可以看到，在这个框架下，RNN是相对薄弱急需改进的地方。</p>
<p></p>
<h2 id="3-transformer到底是什么">3. Transformer到底是什么？</h2>
<p>3.1 Transformer是一种由Encoder和Decoder组成的架构。那么什么是架构呢？最简单的架构就是A + B + C。</p>
<p>3.2 Transformer也可以理解为一个函数，输入是“我爱学习”，输出是“I love study”。</p>
<p>3.3 如果把Transformer的架构进行分拆，如图4所示。</p>
<p></p>
<h2 id="4-什么是transformer-encoder">4. 什么是Transformer Encoder？</h2>
<p>4.1 从<font color=red>功能角度</font>，Transformer Encoder的核心作用是<strong>提取特征</strong>，也有使用Transformer Decoder来提取特征。例如，一个人学习跳舞，Encoder是看别人是如何跳舞的，Decoder是将学习到的经验和记忆(key和value的匹配程度)，展现出来</p>
<p>4.2 从<font color=red>结构角度</font>，如图5所示，Transformer Encoder = Embedding + Positional Embedding + N * (子Encoder block1 + 子Encoder block2);</p>
<p>子Encoder block1 = Multi head attention + ADD + Norm;</p>
<p>子Encoder block2 = Feed Forward + ADD + Norm;</p>
<p>4.3 从<font color=red>输入输出角度</font>，N个Transformer Encoder block中的第一个Encoder block的输入为一组向量 X = (Embedding + Positional Embedding)，向量维度通常为512*512，其他N个TransformerEncoder block的输入为上一个 Transformer Encoder block的输出，输出向量的维度也为<code>512*512</code>(输入输出大小相同)。</p>
<p>4.4 为什么是<code>512*512</code>？<font color=red>前者是指token的个数</font>，如“我爱学习”是4个token，这里设置为512是为了囊括不同的序列长度，不够时padding。<font color=red>后者是指每一个token生成的向量维度</font>，也就是每一个token使用一个序列长度为512的向量表示。人们常说，Transformer不能超过512，否则硬件很难支撑;其实512是指前者，也就是token的个数，因为每一个token要做self attention操作;但是后者的512不宜过大，否则计算起来也很慢。</p>
<p></p>
<h2 id="5-什么是transformer-decoder">5. 什么是Transformer Decoder？</h2>
<p>5.1 从功能角度，相比于Transformer Encoder，Transformer Decoder更擅长做<strong>生成式任务</strong>，尤其对于自然语言处理问题。</p>
<p>5.2 从结构角度，如图6所示，Transformer Decoder = Embedding + Positional Embedding + N*(子Decoder block1 + 子Decoder block2 + 子Decoder block3)+ Linear + Softmax;</p>
<p>子Decoder block1 = Mask Multi head attention + ADD + Norm;</p>
<p>子Decoder block2 = Multi head attention + ADD + Norm;</p>
<p>子Decoder block3 = Feed Forward + ADD + Norm;</p>
<p></p>
<p>5.3 从(Embedding+Positional Embedding)(N个Decoder block)(Linear + softmax) 这三个每一个单独作用角度:</p>
<p>Embedding + Positional Embedding: 以机器翻译为例，输入“Machine Learning”，输出“机器学习”; 这里的Embedding是把“机器学习”也转化成向量的形式。</p>
<p>N个Decoder block: 特征处理和传递过程。</p>
<p>Linear + softmax: softmax是预测下一个词出现的概率，如图7所示，前面的Linear层类似于分类网络(ResNet18)最后分类层前接的MLP层。</p>
<p></p>
<p>5.4 Transformer Decoder的输入、输出是什么？在Train和Test时是不同的。</p>
<p>在Train阶段，如图8所示。这时是知道label的，decoder的第一个输入是begin字符，输出第一个向量与label中第一个字符使用cross entropy loss。Decoder的第二个输入是第一个向量的label，Decoder的第N个输入对应的输出是End字符，到此结束。这里也可以看到，在Train阶段是可以进行<strong>并行训练</strong>的。</p>
<p></p>
<p>在Test阶段，下一个时刻的输入是前一个时刻的输出，如图9所示。因此，Train和Test时候，Decoder的输入会出现Mismatch，在Test时候确实有可能会出现一步错，步步错的情况。有两种解决方案: 一种是train时偶尔给一些错误，另一种是Scheduled sampling。</p>
<p></p>
<p>5.5 Transformer Decoder block内部的输入和输出是什么？</p>
<p>前面提到的是在整体train和test阶段，Decoder的输入和输出，那么Transformer Decoder内部的Transformer Decoder block，如图10所示，的输入输出又是什么呢？</p>
<p></p>
<p>对于N=6中的第1次循环(N=1时): 子Decoder block1 的输入是 embedding +Positional Embedding，子Decoder block2 的输入的Q来自子Decoder block1的输出，KV来自Transformer Encoder最后一层的输出。</p>
<p>对于N=6的第2次循环: 子Decoder block1的输入是N=1时，子Decoder block3的输出，KV同样来自Transformer Encoder的最后一层的输出。</p>
<p>总的来说，可以看到，无论在Train还是Test时，Transformer Decoder的输入不仅来自(ground truth或者上一个时刻Decoder的输出)，还来自Transformer Encoder的最后一层。</p>
<p>训练时: 第i个decoder的输入 = encoder输出 + ground truth embedding。</p>
<p>预测时: 第i个decoder的输入 = encoder输出 + 第(i-1)个decoder输出.</p>
<h2 id="6-transformer-encoder和transformer-decoder有哪些不同">6. Transformer Encoder和Transformer Decoder有哪些不同？</h2>
<p>6.1 作用上，Transformer Encoder常用来<strong>提取特征</strong>，Transformer Decoder常用于<strong>生成式任务</strong>。Transformer Encoder和Transformer Decoder是两条不同的技术路线，<strong>Bert采用的前者，GPT系列模型采用的是后者</strong>。</p>
<p>6.2 结构上，Transformer Decoder block包括了3个子Decoder block，而Transformer Encoder block 包括2个子Encoder block，且Transformer Decoder中使用了Mask multi-head Attention。</p>
<p>6.3 从二者的输入输出角度，N个Transformer Encoder运算完成之后，它的输出才正式输入进Transformer Decoder，作为QKV中的K和V，给Transformer Decoder使用。那么TransformerEncoder最后层的输出是如何送给Decoder呢？如图11所示。</p>
<p></p>
<p>那么，为什么Encoder和Decoder必须要用这种交互的方式呢？其实也并不一定，后续有不同交互方式的提出，如图12。</p>
<p></p>
<h2 id="7-什么是embedding">7. 什么是Embedding？</h2>
<p>7.1 Embedding在Transformer架构中的位置如图13所示。</p>
<p>7.2 提出背景:  计算机无法直接处理一个单词或者一个汉字，需要把一个token转化成计算机可以识别的向量，这也就是embedding过程。</p>
<p>7.3 实现方式:  最简单的embedding操作就是one hot vector，但one hot vector有一个弊端就是没有考虑词语前后之间的关系，后来也就产生了WordEmbedding，如图13。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">wordembedding将单词token向量化，并且考虑的单词与单词之间的相关性。</div>
    </div>
  </div>
<p></p>
<h2 id="8-什么是positional-embedding">8. 什么是Positional Embedding？</h2>
<p>8.1 Positional Embedding在Transformer架构中的位置如图14所示。</p>
<p>8.2 提出背景:  RNN作为特征提取器，是自带词的前后顺序信息的;而Attention机制并没有考虑先后顺序信息，但前后顺序信息对语义影响很大，因此需要通过Positional Embedding这种方式把前后位置信息加在输入的Embedding上。</p>
<p>8.3 实现方式:  传统位置编码和神经网络自动训练得到。</p>
<p></p>
<h2 id="9-什么是attention">9. 什么是Attention？</h2>
<p>9.1 介绍Transformer，为什么要介绍Attention呢？因为在Transformer中最多的multi head attention和Mask multi head attention来自Scaled dot product attention，而scaled dot product attention来自self attention，而self attention是attention的一种，因此首先需要了解Attention，如图15所示。</p>
<p></p>
<p>9.2 Attention到底是什么意思呢？</p>
<p>对于图像而言，attention就是人们看到图像中的核心关注的区域，是图像中的重点，如图16所示。对于序列而言，Attention机制本质上是为了找到<strong>输入中不同token之间的相互关系</strong>，通过权重矩阵来自发地找到词与词之间的关系。</p>
<p></p>
<p>9.3 Attention是如何实现的呢？</p>
<p>是通过QKV实现的。</p>
<p>那么什么是QKV呢？Q是query，K是keys，V是values。如图17所示，举例而言，Q是大脑发出的信号，我口渴了;K是环境信息，眼睛看到的世界;V是对环境中不同的物品赋予不同的比重，水的比重加大。</p>
<p>总之，Attention就是通过计算QK的相似度，与V相乘得到注意力数值。</p>
<p>$$\text{Attention}(\mathrm{Query},\mathrm{Source})=\sum\text{Similarity}(\mathrm{Query},\mathrm{Key}<em>\mathrm{i})*\mathrm{Value}</em>\mathrm{i}$$</p>
<p></p>
<p>9.4 为什么必须要有QKV三者？</p>
<p>为什么不是只有Q？因为Q1与Q2之间的关系权重，不止需要a12，也需要a21。你可能会问？我们让a12=a21不行吗？也可以尝试，但从原理上讲效果应该没有a12和a21效果好。</p>
<p>为什么不是只有QK？求得的权重系数需要放到输入中，可以乘Q，也可以乘K，为什么要重新乘V呢？我觉得可能是多了一组可训练参数$W_V$，使网络具有更强的学习能力。</p>
<h2 id="10-什么是self-attention">10. 什么是Self Attention？</h2>
<p>10.1 介绍Transformer，为什么要介绍self Attention呢？因为在Transformer中最多的multi head attention和Mask multi head attention来自Scaled dot product attention，而scaled dot product attention来自self attention，如图15所示。</p>
<p>10.2 什么是Self Attention呢？self attention和local attention、stride attention都是attention的一种;self attention是每一个Q与每一个K依次计算注意力系数，如图18所示，而像local attention是Q只与相邻的K计算注意力系数，stride attention是Q通过跳连的方式与K计算注意力系数。</p>
<p></p>
<p>10.3 Self attention为什么可以用于处理像机器翻译这种序列数据?</p>
<p>输入序列中的每一个位置的数据，可以关注其他位置的信息，由此通过Attention score来提取特征或者捕获输入序列每一个token之间的关系。</p>
<p>10.4 Self attention是如何具体实现的? 总共分为4步，如图19所示</p>
<p></p>
<h2 id="11-什么是scaled-dot-product-attention">11. 什么是Scaled dot product attention？</h2>
<p>11.1 self attention最常见的有两种，一种是dot product attention、另一种是additive attention，如图20所示，前者的计算效率更高。</p>
<p></p>
<p>11.2 什么是Scaled ?</p>
<p>scaled的具体实现方式如图21所示，这一操作的目的是为了防止内积过大，从梯度角度考虑，避免靠近1，易训练;与batch normalization有一些相似的功能。</p>
<p>$$\text{Attention}(Q,K,V)=\text{softmax}(\frac{QK^T}{\sqrt{d_k}})V$$</p>
<h2 id="12-什么是multi-head-attention">12. 什么是Multi head attention？</h2>
<p>12.1 Multi head attention在Transformer架构中的位置如图15所示。</p>
<p>12.2 提出背景: CNN具有多个channel，可以提取图像不同维度的特征信息，那么Self attention是否可以有类似操作，可以提取不同距离token的多个维度信息呢？</p>
<p>12.3 什么是group 卷积？如图22所示，将输入的特征多个channel分成几个group单独做卷积，最后再进行con c操作。</p>
<p></p>
<p>12.4 Multi head attention的实现方式？与self attention根本不同是什么？</p>
<p>如图23所示，以2个head的为例，将输入的Q、K、V分成两份，每一小份的Q与对应的K、V分别操作，最后计算得到的向量再进行conc操作，由此可以看出，Multi head attention与group卷积有着相似的实现方式。</p>
<p></p>
<p>12.5 如何从输入输出的维度来理解Multi head attention？如图24所示。</p>
<p></p>
<h2 id="13-什么是mask-multi-head-attention">13. 什么是Mask Multi head attention？</h2>
<p>13.1 Mask Multi head attention在transformer架构中的位置如图15所示。</p>
<p>13.2 为什么要有Mask这种操作？</p>
<p>Transformer预测第T个时刻的输出，不能看到T时刻之后的那些输入，从而保证训练和预测一致。</p>
<p>通过 Masked 操作可以防止第 i 个单词知道 i+1 个单词之后的信息，如图25所示。</p>
<p></p>
<p>13.3 Mask操作是如何具体实现的呢？</p>
<p>Q1只跟K1计算，Q2只跟K1、K2计算，而对于K3、K4等，在softmax之前给一个非常大的负数，由此经过softmax之后变为0，其在矩阵上的计算原理实现如图26所示。</p>
<p></p>
<h2 id="14-什么是add">14. 什么是ADD？</h2>
<p>14.1 Add就是残差连接，由2015年ResNet这篇文章发扬光大(目前引用量已超过16万)，与Skip connection的区别在于需要大小维度全部相同。</p>
<p>14.2 作为大道至简想法的极致，几乎每一个深度学习模型都会用到这个技术，可以<strong>防止网络退化</strong>，常用于解决多层网络难训练的问题。</p>
<p></p>
<h2 id="15-什么是norm">15. 什么是Norm？</h2>
<p>15.1 Norm就是layer normalization。</p>
<p>15.2 核心作用: 为了训练更加稳定，和batch normalization有相同的作用，都是为了使输入的样本均值为零，方差为1。</p>
<p>15.3 为什么不使用batch normalization，使用的是layer normalization呢？因为一个时序数据，句子输入长度有长有短，如果使用batch normalization，则很容易造成因样本长短不一造成“训练不稳定”。BN是对同一个batch内的所有数据的同一个特征数据进行操作;而LN是对同一个样本进行操作。</p>
<p></p>
<ol start="16">
<li>什么是FFN？</li>
</ol>
<p>16.1 FFN就是feed forward networks。</p>
<p>16.2 为什么有了Self attention层，还要有FFN？Attention已经有了想要的序列信息特征，MLP的作用是把信息投影到特定的空间里，再做一次非线性映射，和Self attention交替使用。</p>
<p>16.3 结构上: 包括两层MLP，第一层的维度为$512<em>2048$，第二层的维度为$2048</em>512$，且第二层MLP没有使用激活函数，如图29所示。</p>
<p></p>
<h2 id="17-transformer是如何训练出来的">17. Transformer是如何训练出来的？</h2>
<p>17.1 数据上，在Transformer论文中有提到，用到了4.5M和36M的翻译句子对。</p>
<p>17.2 硬件上，base模型是8个P100 GPU训练了12个小时，大模型是训练了3.5天。</p>
<p>17.3 模型参数和调参层面:</p>
<p>第一，可训练的参数包括$W_Q$、$W_K$、$W_V$、$W_O$，换包括$FFN$层的参数。</p>
<p>第二，可调的参数包括: 每一个token向量表示的维度(d_model)、head的头数、Encoder和Decoder中block重复的次数N、FFN中间层向量的维度、Label smoothing(置信度0.1)和dropout(0.1)。</p>
<h2 id="18-transformer为什么效果好">18. Transformer为什么效果好？</h2>
<p>18.1 虽然题目是Attention is all you need，但后续一些研究表明，Attention、残差连接、layer normalization、FFN，这些因素共同成就了Transformer。</p>
<p>18.2 Transformer优点包括:</p>
<p>第一，提出深度学习继MLP、CNN、RNN后的第4大特征提取器。</p>
<p>第二，一开始用在机器翻译，随着GPT和Bert彻底出圈;是一个转折点，在这个点之后，NLP领域快速发展，之后多模态、大模型、视觉Transformer等开始兴起。</p>
<p>第三，给人们信心，原来CNN和RNN之后，还可以有效果更好的特征提取器。</p>
<p>18.3 Transformer的不足之处？</p>
<p>第一，计算量大，对硬件要求高。</p>
<p>第二，因为无归纳偏置，需要很多数据才可以取得很好的效果。</p>
<p>Ref:</br>
[1]. <a href="https://mp.weixin.qq.com/s/sNyh3SzhIdsk8feYfQlTSA"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/sNyh3SzhIdsk8feYfQlTSA<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL 精度总结 [6] | 仿函数、仿函数类、函数等</title><link>https://jianye0428.github.io/posts/partsix/</link><pubDate>Tue, 22 Aug 2023 19:22:49 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partsix/</guid><description><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-STL总结系列分为七部分，本文为第六部分，涉及原书第六章，内容范围Rule38~42。为方便书写，Rule38简写为R38。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-STL系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<h2 id="r38-遵循按值传递的原则来设计函数子类">R38: 遵循按值传递的原则来设计函数子类</h2>
<p>函数指针是按值传递的。</p>
<p>函数对象往往按值传递和返回。所以，编写的函数对象必须尽可能地小巧，否则复制的开销大；函数对象必须是<strong>单态</strong>的（不是多态），不得使用虚函数。</p>
<p>如果你希望创建一个包含大量数据并且使用了多态性的函数子类，该怎么办呢？</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFCImpl</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">BPFCImpl</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">friend</span> <span class="k">class</span> <span class="nc">BPFC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>					<span class="c1">// 允许BPFC访问内部数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFC</span><span class="o">:</span>								<span class="c1">// 新的BPFC类：短小、单态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">BPFCImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>					<span class="c1">// BPFC唯一的数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span>	<span class="c1">// 现在这是一个非虚函数，将调用转到BPFCImpl中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pImpl</span><span class="o">-&gt;</span><span class="k">operator</span><span class="p">()(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么你应该创建一个小巧、单态的类，其中包含一个指针，指向另一个实现类，并且将所有的数据和虚函数都放在实现类中（“Pimpl Idiom”）。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFCImpl</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">BPFCImpl</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">friend</span> <span class="k">class</span> <span class="nc">BPFC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>					<span class="c1">// 允许BPFC访问内部数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFC</span><span class="o">:</span>								<span class="c1">// 新的BPFC类：短小、单态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">BPFCImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>					<span class="c1">// BPFC唯一的数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span>	<span class="c1">// 现在这是一个非虚函数，将调用转到BPFCImpl中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pImpl</span><span class="o">-&gt;</span><span class="k">operator</span><span class="p">()(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="r39-确保判别式是-纯函数">R39 确保判别式是 “纯函数”</h2>
<p><strong>判别式（predicate）：一个返回值为 bool 类型的函数。</strong></p>
<p><strong>纯函数：指返回值仅仅依赖于其参数的函数。</strong></p>
<p>判别式类（predicate class）：一个函数子类，它的 operator() 函数是一个判别式（返回 true 或 false）。</p>
<p>STL 中凡是可以接受一个判别式类对象的地方，也就可以接受一个判别式函数。</p>
<p>判别式应该是一个纯函数，而纯函数应该没有状态。</p>
<h2 id="r40-使仿函数类可适配">R40 使仿函数类可适配</h2>
<p>对函数指针，要先应用<code>ptr_fun</code>之后再应用<code>not1</code>之后才可以工作。</p>
<p>4 个标准的函数配接器（<code>not1</code>、<code>not2</code>、<code>bind1st</code>、<code>bind2nd</code>）都要求一些特殊的类型定义，提供这些必要类型定义（<code>argument_type</code>、<code>first_argument_type</code>、<code>second_argument_type</code>、<code>result_type</code>）的函数对象被称为可配接(可适配)（<code>adaptable</code>）的函数对象。</p>
<p>提供这些类型定义最简单的方法：让函数子从一个基结构继承。</p>
<ul>
<li>对于 unary_function，必须指定函数子类 operator() 所带的参数类型，以及 operator() 返回类型。</li>
<li>对于 binary_function，必须指定 3 个类型：operator() 第一个和第二个参数类型，以及 operator() 返回类型。</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MeetsThreshold</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">unary_function</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">T</span> <span class="n">threshold</span><span class="p">;</span>						<span class="c1">// 包含状态信息，使用类封装。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MeetsThreshold</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">threshold</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">WidgetNameCompare</span><span class="o">:</span>					<span class="c1">// STL中所有无状态函数子类一般都被定义成结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">Widget</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，一般情况下，传递给 binary_function 或 unary_function 的非指针类型需要去掉 const 和应用（&amp;）部分。</p>
<h2 id="r41-理解-ptr_funmem_fun-和-mem_fun_ref-的来由">R41 理解 ptr_fun、mem_fun 和 mem_fun_ref 的来由</h2>
<p>STL语法惯例：函数或者函数对象被调用时，总是使用非成员函数的语法形式。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">test</span><span class="p">);</span>					<span class="c1">// 调用1：f(x)，f为非成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">test</span><span class="p">);</span>			<span class="c1">// 调用2：x.f()，f为成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">// x是一个对象或对象的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">*&gt;</span> <span class="n">lpw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">lpw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lpw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Widgettest</span><span class="p">);</span>			<span class="c1">// 调用3：p-&gt;f()，f为成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">// p是一个指向对象x的指针。
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>mem_fun、mem_fun_t：mem_fun 将语法 3 调整为语法 1。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>		<span class="c1">//该mem_fun声明针对不带参数的非const成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mem_fun_t</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span>							<span class="c1">//C是类，R是所指向的成员函数返回的类型。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mem_fun</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">pmf</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>mem_fun 带一个指向某个成员函数的指针参数 pmf，并且返回一个 mem_fun_t 类型的对象。</p>
<p>mem_fun_t 是一个函数子类，它拥有该成员函数的指针，并提供了 operator() 函数，在 operator() 中调用了通过参数传递进来的对象上的该成员函数。</p>
<p>类似地，mem_fun_ref 将语法 2 调整为语法 1。</p>
<p><strong>总结:</strong></p>
<ul>
<li>std::ptr_fun：将函数指针转换为函数对象。</li>
<li>std::mem_fun：将成员函数转换为函数对象(指针版本)。</li>
<li>std::mem_fun_ref：将成员函数转换为函数对象(引用版本)。</li>
</ul>
<h2 id="r42">R42</h2>
<p>Ref:</p>
<p>[1]. <a href="https://www.cnblogs.com/Sherry4869/p/15162253.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/Sherry4869/p/15162253.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[2]. <a href="https://blog.csdn.net/zhuikefeng/article/details/108164117#t35"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/zhuikefeng/article/details/108164117#t35<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[3]. <a href="https://zhuanlan.zhihu.com/p/458156007"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/458156007<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [31] | 了解你的排序选择</title><link>https://jianye0428.github.io/posts/clause_31/</link><pubDate>Sat, 26 Aug 2023 10:19:35 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_31/</guid><description><![CDATA[<h2 id="稳定排序-vs-不稳定排序">稳定排序 VS 不稳定排序</h2>
<p>有些排序算法是稳定的。在稳定排序中，如果一个区间中的两个元素有等价的值，它们的相对位置在排序后不改变。不稳定的算法没做这个保证。</p>
<p>例如，在（未排序的）widgets vector中Widget A在Widget B之前，而且两者都有相同的质量等级，那么稳定排序算法会保证在这个vector排序后，Widget A仍然在Widget B之前。</p>
<h2 id="partial_sort"><code>partial_sort</code></h2>
<p>sort是个令人称赞的算法，如果不需要完全排序时，比如有一个存有Widget 的vector，你想选择20个质量最高的Widget发送给客户，20个之外的Widget可以保持无序，也就是你需要的是部分排序，这时就可以用partial_sort。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">qualityCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回lhs的质量是不是比rhs的质量好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把最好的20个元素（按顺序）放在widgets的前端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">partial_sort</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用widgets...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用完partial_sort后，widgets的前20个元素是容器中最好的而且它们按顺序排列，质量最高的Widget是widgets[0]，第二高的是widgets[1]等。</p>
<p>partial_sort是不稳定的。</p>
<h2 id="nth_element">nth_element</h2>
<p>如果你不关心哪个Widget给哪个客户，你需要的只是任意顺序的20个最好的Widget。STL中nth_element可以精确地完成了你需要的。</p>
<p>nth_element排序一个区间，在n位置（你指定的）的元素是如果区间被完全排序后会出现在那儿的元素。</p>
<p><strong>Example</strong></p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">randy</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//默认求第m大的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">randy</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//定义cmp可求第m小的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">randy</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>函数是将第 m 大的元素放在 arr 数组数组中适当位置，其他元素按照第 m 元素的大小划分。 在[ 0, n ]这个范围内，在第 m 个元素之前的元素都小于或等于第 m 个元素，而且第 m 个元素后面的每个元素都会比它大。</p>
<p><code>nth_element()</code>函数仅将第 m 大/小的数在 randy 数组中排好了位置，并不返回值。输出 randy[m] 即是第 m 大/小的数。</p>
<p><strong>排序Widget数组</strong></p>
<p>使用nth_element来保证最好的20个Widget在widgets vector的前端：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">nth_element</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">19</span><span class="p">,</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把最好的20个元素放在widgets前端，但不用担心它们的顺序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用nth_element本质上等价于调用partial_sort，两个算法都把20个质量最高的Widget移动到vector前端。</p>
<p>它们结果的唯一区别是partial_sort排序了在位置1-20的元素，而nth_element不排序。</p>
<p><strong>其他用法</strong></p>
<p>除了能帮你找到区间顶部的n个元素，它也可以用于找到区间的中值或者找到在指定百分点的元素：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 迭代器的变量方便地表示widgets的起点和终点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这个迭代器指示了下面代码要找的中等质量等级的Widget的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">goalPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 兴趣的Widget会是有序的vector的中间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">goalPosition</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">widgets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 找到widgets中中等质量等级的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">nth_element</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">goalPosition</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// goalPosition现在指向中等质量等级的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 下面的代码能找到质量等级为75%的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1">// 指出兴趣的Widget离开始有多远
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">goalOffset</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">widgets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 找到质量值为75%的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">nth_element</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">goalOffset</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// begin + goalOffset现在指向质量等级为75%的Widget
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="元素有同样质量">元素有同样质量</h2>
<p>假设有12个元素质量是1级（可能是最好的），15个元素质量是2级（第二好的）。在这种情况下，选择20个最好的Widget就是选择12个1级的和15个中的8个2级的。partial_sort和nth_element怎么判断15个中的哪些要放到最好的20个中？对于这个问题，当多个元素有等价的值时sort怎么判断元素的顺序？</p>
<p>partial_sort和nth_element以任何它们喜欢的方式排序值等价的元素，而且你不能控制它们在这方面行为。</p>
<p>nth_element、sort也没有提供稳定性。</p>
<h2 id="stable_sort">stable_sort</h2>
<p>stable_sort 是稳定排序，STL并不包含partial_sort和nth_element的稳定版本。</p>
<p>当指定范围内包含多个相等的元素时，sort() 排序函数无法保证不改变它们的相对位置。那么，如果既要完成排序又要保证相等元素的相对位置，可以使用stable_sort()函数</p>
<p>stable_sort() 函数完全可以看作是 sort() 函数在功能方面的升级版。stable_sort() 和 sort() 具有相同的使用场景，就连语法格式也是相同的（后续会讲），只不过前者在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">//对 [first, last) 区域内的元素做默认的升序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">stable_sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">stable_sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;     // std::cout</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;    // std::stable_sort</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // std::vector</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//以普通函数的方式实现自定义排序规则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">randy_comp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//以函数对象的方式实现自定义排序规则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">kim_comp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">jeff_num</span><span class="p">{</span><span class="mi">88</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>  <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 2 13 22 88 1 30 3 33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//利用STL标准库提供greater&lt;T&gt;进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>  <span class="c1">// 88 22 13 2 1 30 3 33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//通过自定义比较规则进行排序,这里也可以换成 kim_comp()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">randy_comp</span><span class="p">);</span>  <span class="c1">// 1 2 3 13 22 30 33 88
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="partition">partition</h2>
<p>但是完全排序需要很多工作，而且对于这个任务做了很多不必要的工作。一个更好的策略是使用partition算法，它重排区间中的元素以使所有满足某个标准的元素都在区间的开头。</p>
<p>比如，移动所有质量等级为2或更好的Widget到widgets前端：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">hasAcceptableQuality</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 返回w质量等级是否是2或更高;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 把所有满足hasAcceptableQuality的widgets移动到widgets前端，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 并且返回一个指向第一个不满足的widget的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">goodEnd</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">hasAcceptableQuality</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此调用完成后，从widgets.begin()到goodEnd的区间容纳了所有质量是1或2的Widget，从goodEnd到widgets.end()的区间包含了所有质量等级更低的Widget。</p>
<p>如果在分割时保持同样质量等级的Widget的相对位置很重要，我们自然会用stable_partition来代替partition。</p>
<p><strong>list排序</strong></p>
<p>唯一我们可能会但不能使用<code>sort</code>、<code>stable_sort</code>、<code>partial_sort</code>或<code>nth_element</code>的容器是<code>list</code>，<code>list</code>通过提供<code>sort</code>成员函数做了一些补偿。（有趣的是，list::sort提供了<u>稳定排序</u>。）</p>
<p>如果你想要对list中的对象进行partial_sort或nth_element，你必须间接完成：</p>
<ol>
<li>把元素拷贝到一个支持随机访问迭代器的容器中，然后对它应用需要的算法;</li>
<li>建立一个list::iterator的容器，对那个容器使用算法，然后通过迭代器访问list元素;</li>
<li>使用有序的迭代器容器的信息来迭代地把list的元素接合到你想让它们所处的位置。</li>
</ol>
<h2 id="总结">总结</h2>
<p><strong>算法sort、stable_sort、partial_sort和nth_element需要随机访问迭代器，所以它们可能只能用于vector、string、deque和数组。</strong></p>
<p>对标准关联容器排序元素没有意义，因为这样的容器使用它们的比较函数来在任何时候保持有序。</p>
<p>partition和stable_partition与sort、stable_sort、partial_sort和nth_element不同，它们只需要双向迭代器。因此你可以在任何标准序列迭代器上使用partition和stable_partition。</p>
<ol>
<li>如果需要在vector、string、deque或数组上进行<strong>完全排序</strong>，你可以使用<code>sort</code>或<code>stable_sort</code>。</li>
<li>如果你有一个vector、string、deque或数组，<strong>只需要排序前n个元素</strong>，应该用<code>partial_sort</code>。</li>
<li>如果你有一个vector、string、deque或数组，<strong>需要鉴别出第n个元素或你需要鉴别出最前的n个元素，而不用知道它们的顺序</strong>，nth_element是你应该注意和调用的。</li>
<li>如果你需要<strong>把标准序列容器的元素或数组分隔为满足和不满足某个标准</strong>，你大概就要找partition或stable_partition。</li>
<li>如果你的数据是在list中，你可以直接使用partition和stable_partition，你可以使用list的sort来代替sort和stable_sort。如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务。</li>
</ol>
<p>你可以通过把数据放在标准关联容器中的方法以<strong>保持在任何时候东西都有序</strong>。你也可能会考虑标准非STL容器priority_queue，它也可以总是保持它的元素有序。</p>
<p>一般来说，<font color=blue>做更多工作的算法比做得少的要花更长时间，而必须稳定排序的算法比忽略稳定性的算法要花更长时间</font>。</p>
<p>本节讨论的算法需要更少资源（时间和空间）的算法排序：</p>
<ol>
<li>partition</li>
<li>partial_sort</li>
<li>stable_partition</li>
<li>sort</li>
<li>nth_element</li>
<li>stable_sort</li>
</ol>
]]></description></item><item><title>Effective STL [32] | 如果你真的想删除东西的话就在类似remove的算法后接上erase</title><link>https://jianye0428.github.io/posts/clause_32/</link><pubDate>Sat, 26 Aug 2023 10:55:50 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_32/</guid><description><![CDATA[<h2 id="remove实际作用">remove实际作用</h2>
<h3 id="remove的声明">remove的声明</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ForwardIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardIterator</span> <span class="n">remove</span><span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>remove接收指定它操作的元素区间的一对迭代器。它不接收一个容器，所以<strong>remove不知道它作用于哪个容器</strong>。</p>
<p>此外，remove也不可能发现容器，因为没有办法从一个迭代器获取对应于它的容器。</p>
<h3 id="remove不做什么">remove不做什么</h3>
<p>从容器中除去一个元素，唯一的方法是调用那个容器的一个成员函数，几乎都是erase的某个形式，(list有几个除去元素的成员函数不叫erase，但它们仍然是成员函数。)因为唯一从容器中除去一个元素的方法是在那个容器上调用一个成员函数，而且因为remove无法知道它正在操作的容器，所以remove不可能从一个容器中除去元素。</p>
<p>从一个容器中remove元素不会改变容器中元素的个数：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector&lt;int&gt; 用1-10填充它(调用reserve的解释在条款14)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 打印10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设置3个元素为99
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">);</span> <span class="c1">// 删除所有等于99的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// 仍然是10！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=blue>remove并不“真的”删除东西，因为它做不到。</font></p>
<p><strong>remove不知道它要从哪个容器删除东西，而没有容器，它就没有办法调用成员函数。</strong></p>
<h3 id="remove-做了什么">remove 做了什么</h3>
<p>remove移动指定区间中的元素直到所有“不删除的”元素在区间的开头(相对位置和原来它们的一样)。它返回一个指向最后一个的下一个“不删除的”元素的迭代器。返回值是区间的“新逻辑终点”。</p>
<p>举个例子，这是v在调用remove前看起来的样子：</p>
<p></p>
<p>如果我们把remove的返回值存放在一个叫做newEnd的新迭代器中:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">newEnd</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是调用后v看起来的样子:</p>
<p></p>
<p>如果“不删除的”元素在v中的v.begin()和newEnd之间，“删除的”元素就必须在newEnd和v.end()之间。</p>
<p><strong>remove并没有改变区间中元素的顺序，所以不会把所有“删除的”元素放在结尾，并安排所有“不删除的”值在开头。</strong></p>
<p>如果你不想失去任何值，你可能应该调用partition或stable_partition而不是remove。</p>
<h3 id="remove-实际操作流程">remove 实际操作流程</h3>
<p>在内部，remove遍历这个区间，把要“删除的”值覆盖为后面要保留的值。这个覆盖通过对持有被覆盖的值的元素赋值来完成。</p>
<ol>
<li>remove检测v[0]，发现它的值不是要被删除的，然后移动到v[1]。同样的情况发生在v[1]和v[2]。</li>
<li>发现v[3]应该被删除，所以它记录下v[3]的值应该被覆盖，然后它移动到v[4]。这类似记录v[3]是一个需要填充的“洞”。</li>
<li>发现v[4]的值应该被保持，所以它把v[4]赋给v[3]，记录下v[4]应该被覆盖，然后移动到v[5]。继续类似的压缩，它用v[4]“填充”v[3]而且记录v[4]现在是一个洞。</li>
<li>发现v[5]应该被删除，所以忽略并它移动到v[6]。仍然记得v[4]是一个等待填充的洞。</li>
<li>发现v[6]是一个应该保留的值，所以把v[6]赋给v[4]。记得v[5]现在是下一个要被填充的洞，然后移到v[7]。</li>
<li>在某种意义上类似上面的，检查v[7]、v[8]和v[9]。把v[7]赋给v[5]，v[8]赋给v[6]，忽略v[9]，因为v[9]的值是要被删除的。</li>
<li>返回指定下一个要被覆盖的元素的迭代器，在这个例子中这个元素是v[7]。</li>
</ol>
<p></p>
<p>事实上当remove在删除时覆盖的值是指针时，会有重要的影响。但是对于本条款，知道remove不从容器中除去任何元素因为它做不到就够了。</p>
<h2 id="应该在remove后面接上erase">应该在remove后面接上erase</h2>
<p>只有容器成员函数可以除去容器元素，而那是本条款的整个要点：<strong>如果你真的要删除东西的话，你应该在remove后面接上erase</strong>。</p>
<p>要除去那些元素，你要做的所有事情就是用那两个迭代器调用erase的区间形式。因为remove本身很方便地返回了区间新逻辑终点的迭代器:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正如从前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 真的删除所有等于99的元素，现在返回7
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>事实上，remove和erase是亲密联盟，这两个整合到list成员函数remove中。这是STL中唯一名叫remove又能从容器中除去元素的函数：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">li</span><span class="p">;</span>  <span class="c1">// 建立一个list放一些值进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">li</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">99</span><span class="p">);</span> <span class="c1">// 除去所有等于99的元素：真的删除元素，所以它的大小可能改变了
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用这个remove函数是一个STL中的矛盾。在关联容器中类似的函数叫erase，list的remove也可以叫做erase。但它没有，所以我们都必须习惯它。</p>
<p><strong>对于list，调用remove成员函数比应用erase-remove惯用法更高效。</strong></p>
<h2 id="类似remove的算法">类似remove的算法</h2>
<p><code>remove_if</code>和<code>unique</code>。 remove和remove_if之间的相似性很直截了当。</p>
<p>unique行为也像remove。它用来从一个区间删除东西(邻近的重复值)而不用访问持有区间元素的容器。如果你真的要从容器中删除元素，你也必须成对调用unique和erase，unique在list中也类似于remove。正像list::remove真的删除东西(而且比erase-remove惯用法高效得多)。</p>
<p><code>list::unique</code>也真的删除邻近的重复值(也比erase-unique高效)。</p>
]]></description></item><item><title>Effective STL [33] | 提防在指针的容器上使用类似remove的算法</title><link>https://jianye0428.github.io/posts/clause_33/</link><pubDate>Sat, 26 Aug 2023 10:55:54 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_33/</guid><description><![CDATA[<h2 id="删除含有指针的容器元素">删除含有指针的容器元素</h2>
<p>如果你在管理一堆动态分配的Widgets，每一个都可能通过检验，你把结果指针保存在一个vector中：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个Widget是否通过检验
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isCertified</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector然后用动态分配的Widget的指针填充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当和v工作一段时间后，你决定除去未通过检验的Widget，因为你不再需要它们了。</p>
<p><strong>尽量用算法调用代替显式循环和关于remove和erase之间关系的描述</strong>，你自然会想到转向erase-remove惯用法，虽然这次你使用了remove_if：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 删除未通过检验的Widget指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">not1</span><span class="p">(</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">isCertified</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 关于mem_fun的信息参见条款41
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>条款7介绍过摧毁容器中的一个指针也不会删除指针指向的东西的讨论，所以这里当调用erase时，极可能你已经泄漏了资源。</p>
<h2 id="资源泄露分析">资源泄露分析</h2>
<p>我们假设在调用remove_if前，v看起来像这样：</p>
<p></p>
<p>在调用remove_if后，一般来说v看起来像这样（包含从remove_if返回的迭代器）：</p>
<p></p>
<p>资源泄漏的理由现在很明朗了。指向Widget B和C的“删除的”指针被vector中后面的“不删除的”指针覆盖。没有什么指向两个未通过检验的Widget，它们也没有被删除，它们的内存和其他资源泄漏了。</p>
<p>一旦remove_if和erase返回后，情况看起来像这样：</p>
<p></p>
<p>现在你也很清楚为什么应该努力避免在动态分配的指针的容器上使用remove和类似算法（remove_if和unique）。</p>
<p>在很多情况下，你会发现<strong>partition算法是合理的替代品</strong>。</p>
<h2 id="正确删除做法">正确删除做法</h2>
<p>如果你无法避免在那样的容器上使用remove，排除这个问题一种方法是在<strong>应用erase-remove惯用法之前先删除指针并设置它们为空，然后除去容器中的所有空指针</strong>：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">delAndNullifyUncertified</span><span class="p">(</span><span class="n">Widget</span> <span class="o">*&amp;</span><span class="n">pWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果*pWidget是一个未通过检验Widget，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pWidget</span><span class="o">-&gt;</span><span class="n">isCertified</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 删除指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">delete</span> <span class="n">pWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 并且设置它为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pWidget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 把所有指向未通过检验Widget的指针删除并且设置为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">delAndNullifyUncertified</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 从v中除去空指针0必须映射到一个指针，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">               <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">*&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 让C++可以正确地推出remove的第三个参数的类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，这假设vector并不容纳任何你想保留的空指针。如果有的话，你可能必须自己写循环来按你的方式删除指针。</p>
<h3 id="智能指针">智能指针</h3>
<p>如果你把指针的容器替换成<strong>执行引用计数的智能指针的容器</strong>，删除相关的困难就不存在了，你可以直接使用erase-remove惯用法：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RCSP = “引用计数智能指针”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">RCSP</span> <span class="p">{</span> <span class="p">...};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RCSPW = “RCSP to Widget”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">RCSP</span><span class="o">&lt;</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">RCSPW</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector，用动态分配Widget的智能指针填充它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RCSPW</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">RCSPW</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// erase未通过检验的Widget的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">  <span class="n">not1</span> <span class="p">(</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">isCertified</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 没有资源泄漏
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要让这些工作，你的<strong>智能指针类型就必须可以（比如<code>RCSP&lt;Widget&gt;</code>）隐式转换为相应的内建指针类型（比如<code>Widget*</code>）</strong>。那是因为容器持有智能指针，但被调用的成员函数（比如Widget::isCertified）要的是内建指针。如果不存在隐式转换，你的编译器会抗议的。</p>
]]></description></item><item><title>Effective STL [34] | 注意哪个算法需要有序区间</title><link>https://jianye0428.github.io/posts/clause_34/</link><pubDate>Sat, 26 Aug 2023 10:55:58 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_34/</guid><description><![CDATA[<p>不是所有算法可以用于任意区间。比如，<strong>remove需要前向迭代器和可以通过这些迭代器赋值的能力</strong>。所以，它不能应用于由输入迭代器划分的区间，也不能是map或multimap，也不能是set和multiset的一些实现。</p>
<p>同样，<strong>很多排序算法需要随机访问迭代器</strong>，所以不可能在一个list的元素上调用这些算法。</p>
<p>最常见的就是一些算法<strong>需要有序值的区间</strong>。无论何时都应该坚持这个需求，因为冒犯它不仅会导致编译器诊断，而且会造成未定义的运行期行为。</p>
<p>既可以和有序又可以和无序区间合作的算法很少，但<strong>当操作有序区间的时候它们最有用</strong>。</p>
<h2 id="只能操作有序数据的算法的表">只能操作有序数据的算法的表</h2>
<ul>
<li>binary_search</li>
<li>lower_bound</li>
<li>upper_bound</li>
<li>equal_range</li>
<li>set_union</li>
<li>set_intersection</li>
<li>set_difference</li>
<li>set_symmetric_difference</li>
<li>merge</li>
<li>inplace_merge</li>
<li>includes</li>
</ul>
<h2 id="一般用于有序区间但不强制要求">一般用于有序区间，但不强制要求</h2>
<ul>
<li>unique</li>
<li>unique_copy</li>
</ul>
<h2 id="binary_searchlower_boundupper_bound和equal_range"><code>binary_search</code>、<code>lower_bound</code>、<code>upper_bound</code>和<code>equal_range</code></h2>
<p>搜索算法binary_search、lower_bound、upper_bound和equal_range需要<strong>有序区间</strong>，因为它们<strong>使用二分法查找来搜索</strong>值。像C库中的bsearch，这些算法保证了<strong>对数时间的查找</strong>，但作为交换的是，你必须给它们已经排过序的值。</p>
<p>实际上，仅当传给它们的是随机访问迭代器时它们才能保证有那样的性能。</p>
<p>如果给它们威力比较小的迭代器（比如双向迭代器），它们仍然进行对数次比较，但运行是线性时间的。那是因为，缺乏进行“<strong>迭代器算术（arithmetic）</strong>”的能力。它们在搜索的区间中需要花费线性时间来从一个地方移动到另一个地方。</p>
<h2 id="unionset_intersectionset_difference和set_symmetric_difference"><code>union</code>、<code>set_intersection</code>、<code>set_difference</code>和<code>set_symmetric_difference</code></h2>
<p>算法<code>set_union</code>、<code>set_intersection</code>、<code>set_difference</code>和<code>set_symmetric_difference</code>的四人组提供了线性时间设置它们名字所提出的操作的性能。</p>
<p>为什么它们需要有序区间？因为如果不是的话，它们不能以线性时间完成它们的工作。</p>
<p>你会发现，<strong>需要有序区间的算法为了比它们用于可能无序区间提供更好的性能而这么做</strong>。</p>
<h2 id="merge和inplace_merge">merge和inplace_merge</h2>
<p>merge和inplace_merge执行了有效的单遍合并排序算法：它们读取两个有序区间，然后产生一个包含了两个源区间所有元素的新有序区间。</p>
<p>它们以线性时间执行，如果它们不知道源区间已经有序就不能完成。</p>
<h2 id="includes">includes</h2>
<p>includes 用来检测是否一个区间的所有对象也在另一个区间中。</p>
<p>因为includes可能假设它的两个区间都已经有序，所以它保证了线性时间性能。没有那个保证，一般来说它会变慢。</p>
<h2 id="unique和unique_copy">unique和unique_copy</h2>
<p>unique和unique_copy甚至在无序区间上也提供了定义良好的行为。</p>
<p>看看标准是怎么描述unique的行为的：</p>
<blockquote>
<p>从每个相等元素的连续组中去除第一个以外所有的元素。</p>
</blockquote>
<p>如果你要unique从一个区间去除所有重复值（也就是，让区间中所有值“唯一”），你必须先确保所有重复值一个接着一个。那是排序完成的东西之一。</p>
<p>实际上，unique一般用于从区间中去除所有重复值，所以你几乎总是要确保你传递给unique（或unique_copy）的区间是有序的。Unix开发者会发现STL的unique和Unix的uniq之间有惊人的相似。</p>
<p>顺便说说，unique从一个区间除去元素的方式和remove一样，也就是说它只是区分出不除去的元素。</p>
<h2 id="排序">排序</h2>
<p>因为STL允许你指定用于排序的比较函数，<strong>不同的区间可能以不同的方式排序</strong>。</p>
<p>比如，给定两个int的区间，一个可能以默认方式排序（也就是升序），而另一个使用<code>greater&lt;int&gt;</code>排序，因此是降序。</p>
<p>给定Widget的两个区间，一个可能以价格排序而另一个可能以年龄排序。因为有很多不同的方式来排序，所以保证给STL所使用的排序相关信息一致是很重要的。</p>
<p><strong>如果你传一个区间给一个也带有比较函数的算法，确保你传递的比较函数行为和你用于排序这个区间的一样。</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector，把一些数据放进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">// 降序排列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用这个vector（没有改变它）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在这个vector中搜索5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">is3Exists</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 假设它是升序排列！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下，binary_search假设它搜索的区间是以“&lt;”排序（也就是，值是升序），但在本例中，这个vector是降序。当你在值的排列顺序和算法所期望的不同的区间上调用binary_search (或lower_bound等）会导致未定义的结果。</p>
<h3 id="正确排序方式">正确排序方式</h3>
<p>要让代码行为正确，你必须告诉binary_search要使用和sort同样的比较函数：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">is3Exists</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 搜索3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 比较函数把greater作为
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=blue>所有需要有序区间的算法（也就是除了unique和unique_copy外本条款的所有算法）通过等价来判断两个值是否“相同”，就像标准关联容器（它们本身是有序的）。相反，unique和unique_copy判断两个对象“相同”的默认方式是通过相等</font>，但是你可以通过传给这些算法一个定义了“相同”的意义的判断式来覆盖这个默认情况。</p>
<h2 id="总结">总结</h2>
<p>11个需要有序区间的算法为了比其他可能性提供更好的性能而<font color=blue>需要传给它们有序区间，需要保证用于算法的比较函数和用于排序的一致</font>。</p>
]]></description></item><item><title>C++ 基础知识[一]</title><link>https://jianye0428.github.io/posts/basics_one/</link><pubDate>Tue, 11 Jul 2023 19:37:05 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/basics_one/</guid><description><![CDATA[<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">c++ 八股文 第一部分</div>
    </div>
  </div>
<h2 id="1-基础知识一">1. 基础知识(一)</h2>
<h3 id="11-c语言的特点">1.1 C++语言的特点</h3>
<blockquote>
<p>①C++在C的基础上引入了<u><font color=red><strong>面向对象</strong></font></u>机制，同时也兼容C语言；</br>
②C++三大特性：<font color=red><em>封装</em>、<em>继承</em>、<em>多态</em></font>；</br>
③C++程序结构清晰、易于扩充、程序可读性好；</br>
④C++代码质量高，<strong>运行效率高</strong>、仅比汇编语言慢10%~20%；</br>
⑥C++<strong>可复用性高</strong>，C++引入了模板的概念，有专门的模板库(STL)；</br>
⑦C++是不断发展的语言，C++11中新引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。</br></p>
</blockquote>
<p><strong>C++面向对象的三大特征</strong></p>
<blockquote>
<p><font color=red><strong>封装性：</strong></font> 将客观事物抽象成类，每个类对自身的<u>数据</u>和<u>方法</u>实行<font color=darkblue>访问控制</font>，包括(private，protected，public)。</br>
<font color=red><strong>继承性：</strong></font> 广义的继承有三种实现形式：<u>实现继承</u>(使用基类的属性和方法而无需额外编码的能力)、<u>可视继承</u>(子窗体使用父窗体的外观和实现代码)、<u>接口继承</u>(仅使用属性和方法，实现滞后到子类实现)。</br>
<font color=red><strong>多态性：</strong></font> 是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</br></p>
</blockquote>
<h3 id="12-c和c语言的区别">1.2 C++和C语言的区别</h3>
<blockquote>
<p>① C语言是C++的子集，C++可以很好<strong>兼容C语言</strong>。但是C++又有很多新特性，如引用、智能指针、auto变量等；</br>
② C++是面对<strong>对象</strong>(object-oriented)的编程语言；C语言是面对<strong>过程</strong>(process-oriented)的编程语言；</br>
③ C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；</br>
④ C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。</br></p>
</blockquote>
<h3 id="13-c中-struct-和-class-的区别">1.3 C++中 struct 和 class 的区别</h3>
<blockquote>
<p>① struct 一般用于描述一个<u>数据结构集合</u>，而 class 是<u>对一个对象数据的<strong>封装</strong></u>；</br>
② struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的；</br>
③ 在<u>继承关系</u>中，struct 默认是公有继承，而 class 是私有继承；</br>
④ class关键字可以用于定<strong>义模板参数</strong>，就像typename，而 struct 不能用于定义模板参数。</br></p>
</blockquote>
<h3 id="14-include头文件的顺序以及双引号和尖括号的区别">1.4 include头文件的顺序以及双引号&quot;&ldquo;和尖括号&lt;&gt;的区别</h3>
<blockquote>
<p>区别：</br>
① 尖括号<code>&lt; &gt;</code>的头文件是<font color=red>系统文件</font>，双引号<code>&quot; &quot;</code>的头文件是自定义文件；</br>
② 编译器预处理阶段查找头文件的路径不一样；</br>
查找路径：</br>
① 使用尖括号<code>&lt;  &gt;</code>(系统文件)的头文件的查找路径：编译器设置的头文件路径$\rightarrow$系统变量;</br>
② 使用双引号<code>&quot;  &quot;</code>(自定义文件)的头文件的查找路径：当前头文件目录$\rightarrow$编译器设置的头文件路径$\rightarrow$系统变量。</br></p>
</blockquote>
<h3 id="15-c结构体和c结构体的区别">1.5 C++结构体和C结构体的区别</h3>
<blockquote>
<p>①C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数；</br>
②C的结构体对内部成员变量的访问权限<strong>只能是public</strong>，而C++允许public，protected，private三种；</br>
③C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用；</br>
④C语言的结构体是<strong>不可以继承的</strong>，C++的结构体是可以从其他的结构体或者类继承过来的。</br></p>
</blockquote>
<h3 id="16-导入c函数的关键字是什么c编译时和c有什么不同">1.6 导入C函数的关键字是什么，C++编译时和C有什么不同？</h3>
<blockquote>
<p><strong>关键字：</strong> 在C++中，导入C函数的关键字是extern，表达形式为<code>extern &quot;C&quot;</code>， <code>extern &quot;C&quot;</code> 的主要作用就是为了能够正确实现C++代码调用其他C语言代码。<font color=red>加上<code>extern &quot;C&quot;</code>后，会指示编译器这部分代码按C语言的进行编译</font>，而不是C++的。</br></p>
</blockquote>
<blockquote>
<p><strong>编译区别：</strong> 由于C++支持函数重载，因此<u>编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中</u>，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</br>
总结: 区别在于<font color=red>在编译过程中是否带上函数的参数类型，c++带，c不带</font>。</p>
</blockquote>
<h3 id="17-简述c从代码到可执行二进制文件的过程">1.7 简述C++从代码到可执行二进制文件的过程</h3>
<blockquote>
<p><strong>预编译、编译、汇编、链接</strong> </br>
①预编译：这个过程主要的处理操作如下：</br>
<tab>(1) 将所有的#define删除，并且展开所有的宏定义</br>
<tab>(2) 处理所有的<u><font color=purple>条件预编译指令</font></u>，如#if、#ifdef</br>
<tab>(3) 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。</br>
<tab>(4) 过滤所有的注释</br>
<tab>(5) 添加行号和文件名标识</br>
②编译：这个过程主要的处理操作如下：</br>
<tab>(1) 词法分析：将源代码的字符序列分割成一系列的记号。</br>
<tab>(2) 语法分析：对记号进行语法分析，产生语法树。</br>
<tab>(3) 语义分析：判断表达式是否有意义。</br>
<tab>(4) 代码优化：</br>
<tab>(5) 目标代码生成：生成汇编代码。</br>
<tab>(6) 目标代码优化</br>
③汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。</br>
④链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</br>
​ <strong>链接分为<font color=red>静态链接</font>和<font color=red>动态链接</font>。</strong></br>
​<tab> (1) <strong>静态链接</strong>，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你再去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</br></p>
</blockquote>
<p><tab>​ (2) <strong>动态链接</strong>，是在链接的时候没有把调用的函数代码链接进去，而是<font color=red>在执行的过程中</font>，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</br></p>
<h3 id="18-static关键字的作用">1.8 static关键字的作用</h3>
<blockquote>
<p>①<strong>定义全局静态变量和局部静态变量</strong>：在变量前面加上static关键字。static的变量默认初始化为0。初始化的静态变量会在<font color=red><strong>数据段</strong></font>分配内存，未初始化的静态变量会在<font color=red><strong>BSS段</strong></font>分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量(在整个工程文件有效)和局部静态变量(在当前定义的文件内有效)的作用域不一样；</br>
②<strong>定义静态函数</strong>：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；<code>static int func()</code></br>
③在变量类型前加上static关键字，变量即被定义为静态变量。静态变量只能在本源文件中使用;</br>
④<font color=red><strong>类内静态成员变量:</strong></font> 在c++中，static关键字可以用于定义<strong>类中的静态成员变量</strong>：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥<strong>有一块单独的存储区</strong>，而<u>不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间，static修饰的变量要在<font color=purplr><a href="https://blog.csdn.net/sevenjoin/article/details/81772792"target="_blank" rel="external nofollow noopener noreferrer">类外初始化<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></font></u>。</br>
⑤<font color=red><strong>类内静态成员函数:</strong></font>在c++中，static关键字可以用于定义<strong>类中的静态成员函数</strong>：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间，只能访问类的static成员变量，static修饰的变量要在类外初始化。</br></p>
</blockquote>
<h3 id="19-数组和指针的区别">1.9 数组和指针的区别</h3>
<blockquote>
<p><strong>概念：</strong></br>
(1)数组：数组是用于储存多个<strong>相同类型数据</strong>的集合。数组名是首元素的地址。</br>
(2)指针：指针相当于一个变量，但是它和一般变量不一样，它存放的是其它变量在内存中的地址。指针名指向了内存的首地址。</br>
<strong>区别：</strong></br>
赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝；</br>
<strong>存储方式：</strong></br>
数组：数组在<strong>内存中是连续</strong>存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。</br>
指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</br></p>
</blockquote>
<h3 id="110-什么是函数指针如何定义函数指针有什么使用场景">1.10 什么是函数指针，如何定义函数指针，有什么使用场景</h3>
<blockquote>
<p><strong>概念：</strong> 函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该函数入口地址就是函数指针所指向的地址。</br>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">函数指针指向函数的入口地址！</div>
    </div>
  </div></p>
</blockquote>
<blockquote>
<p><strong>定义形式：</strong></br></p>
</blockquote>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>使用场景： 回调(callback)。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。</p>
</blockquote>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//以库函数qsort排序函数为例，它的原型如下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="c1">//void*类型，代表原始数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="c1">//第二个是size_t类型，代表数据数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="c1">//第三个是size_t类型，代表单个数据占用空间大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="c1">//第四个参数是函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//第四个参数告诉qsort，应该使用哪个函数来比较元素，
</span></span></span><span class="line"><span class="cl"><span class="c1">//即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。
</span></span></span><span class="line"><span class="cl"><span class="c1">//在库函数qsort调用我们自定义的比较函数，这就是回调的应用。
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">num</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">cmp_int</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">_a</span> <span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">_b</span><span class="p">){</span><span class="c1">//参数格式固定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">_a</span><span class="p">;</span>    <span class="c1">//强制类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">_b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">a</span> <span class="o">-</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>　　
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">qsort</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">cmp_int</span><span class="p">);</span> <span class="c1">//回调
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="111-静态变量什么时候初始化">1.11 静态变量什么时候初始化</h3>
<blockquote>
<p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于<font color=red><strong>编译期</strong></font>初始化。</br>
而C++标准规定：全局或静态对象当且仅当对象<font color=red>首次用到时</font>才进行构造。</p>
</blockquote>
<h3 id="112-nullptr调用成员函数可以吗为什么">1.12 nullptr调用成员函数可以吗？为什么？</h3>
<p>可以。因为<font color=red>在编译时对象就绑定了函数地址</font>，和指针空不空没关系。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">//给出实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">animal</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">sleep</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;animal sleep&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">breathe</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;animal breathe haha&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">fish</span> <span class="o">:</span><span class="k">public</span> <span class="n">animal</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">breathe</span><span class="p">(){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fish bubble&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">animal</span> <span class="o">*</span><span class="n">pAn</span><span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>    <span class="c1">//类指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pAn</span><span class="o">-&gt;</span><span class="n">breathe</span><span class="p">();</span>   <span class="c1">// 输出：animal breathe haha
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fish</span> <span class="o">*</span><span class="n">pFish</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pFish</span><span class="o">-&gt;</span><span class="n">breathe</span><span class="p">();</span> <span class="c1">// 输出：fish bubble
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。
</span></span></span><span class="line"><span class="cl"><span class="c1">// pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但是若用到this，因为this=nullptr，运行出错。
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="113-什么是野指针怎么产生的如何避免">1.13 什么是野指针，怎么产生的，如何避免？</h3>
<blockquote>
<p><strong>概念：</strong> 野指针就是指针指向的位置是不可知的(随机的、不正确的、没有明确限制的)；</p>
</blockquote>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">指向位置不可知称为野指针！</div>
    </div>
  </div>
<blockquote>
<p>产生原因：<u>释放内存后指针不及时置空(野指针)</u>，依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。(内存泄露)</p>
</blockquote>
<blockquote>
<p>避免办法：</br>
(1)初始化置NULL</br>
(2)申请内存后判空</br>
(3)指针释放后置NULL</br>
(4)使用智能指针</br></p>
</blockquote>
<h3 id="114-静态局部变量全局变量局部变量的特点以及使用场景">1.14 静态局部变量，全局变量，局部变量的特点，以及使用场景</h3>
<blockquote>
<p>①首先从作用域考虑：</br>
C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</br>
全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。</br>
静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。</br>
局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。</br>
静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</br></p>
</blockquote>
<blockquote>
<p>②从所在空间考虑：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</br></p>
</blockquote>
<blockquote>
<p>③生命周期： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</br></p>
</blockquote>
<blockquote>
<p>④使用场景：从它们各自特点就可以看出各自的应用场景，不再赘述。</br></p>
</blockquote>
<h3 id="115-c继承">1.15 C++继承</h3>
<blockquote>
<p>①<strong>公有继承public</strong>：基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。</br>
②<strong>私有继承private</strong>：私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。</br>
③<strong>保护继承protect</strong>：保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的</br></p>
</blockquote>
<h3 id="116-常量指针和指针常量">1.16 常量指针和指针常量</h3>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">常量指针: 内存里的值不变</br>
指针常量: 指针指向的内存地址不变</br></div>
    </div>
  </div>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mf">1.</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>     <span class="c1">//指的是a是一个常量，不允许修改。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mf">2.</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>    <span class="c1">//a指针所指向的内存里的值不变，即(*a)不变  常量指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mf">3.</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>    <span class="c1">//同const int *a;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mf">4.</span> <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">a</span><span class="p">;</span>    <span class="c1">//a指针所指向的内存地址不变，即a不变     指针常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mf">5.</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">a</span><span class="p">;</span>   <span class="c1">//都不变，即(*a)不变，a也不变
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="117-内联函数和函数的区别">1.17 内联函数和函数的区别</h3>
<blockquote>
<p>①内联函数比普通函数多了关键字inline；</br>
②内联函数避免了<strong>函数调用的开销</strong>；普通函数有调用的开销；</br>
③普通函数在被调用的时候，需要寻址(函数入口地址)；<u>内联函数不需要寻址</u>。</br>
④内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句(内联函数内不允许用循环语句和开关语句。普通函数没有这个要求。</br></p>
</blockquote>
<h3 id="118-简述c有几种传值方式之间的区别是什么">1.18 简述C++有几种传值方式，之间的区别是什么？</h3>
<blockquote>
<p><strong>值传递、引用传递、指针传递</strong></br>
①值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</br>
②引用传递：形参在函数体内值发生变化，会影响实参的值；</br>
③指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</br></p>
</blockquote>
<h3 id="119-内联函数和宏函数的区别">1.19 内联函数和宏函数的区别</h3>
<blockquote>
<p><strong>宏常量&amp;宏函数</strong></br></p>
</blockquote>
<p>定义:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// a. 定义一个宏常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MAX 1024 </span><span class="c1">// 宏常量  MAX称为符号常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// b. 定义一个宏函数
</span></span></span><span class="line"><span class="cl"><span class="c1">// 宏函数:宏函数就是使用宏定义定义出来的函数,并不是真正意义上的函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define GETSUM(x, y) ((x) + (y)) </span><span class="c1">// 宏函数
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用宏函数的注意事项: </br></p>
<blockquote>
<ol>
<li>要保证运算的完整性；</br></li>
<li>宏函数的使用场景:频繁调用和短小的函数,封装成宏函数；</br></li>
<li>使用宏函数的优点:以空间换时间；</br></li>
</ol>
</blockquote>
<p>宏定义和函数的区别:</br></p>
<blockquote>
<ol>
<li>宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数；</br></li>
<li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值；</br></li>
<li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型；</br></li>
<li>宏定义不要在最后加分号；</br></li>
</ol>
</blockquote>
<p>宏定义和typedef的区别:</br></p>
<blockquote>
<ol>
<li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名；</br></li>
<li>宏替换发生在<strong>预编译阶段</strong>，属于文本插入替换；typedef是<strong>编译</strong>的一部分；</br></li>
<li>宏不检查类型；typedef会检查数据类型；</br></li>
<li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束；</br></li>
<li>注意对指针的操作，<code>typedef char * p_char</code>和<code>#define p_char char *</code>区别巨大；</br></li>
</ol>
</blockquote>
<p>宏函数和内联函数的区别:</br></p>
<blockquote>
<p>1.在使用时，宏只做简单字符串替换(编译前或者预编译阶段)。而内联函数可以进行参数类型检查(编译时)，且具有返回值；</br>
2.内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载；</br>
3.宏定义时要注意书写(参数要括起来)否则容易出现歧义(保证运算的完整性)，内联函数不会产生歧义；</br>
4.内联函数有类型检测、语法判断等功能，而宏没有；</br></p>
</blockquote>
<p>define宏定义和const的区别:</br></p>
<blockquote>
<p>处理阶段：define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用；</p>
</blockquote>
<blockquote>
<p>安全性：</br></p>
<blockquote>
<ol>
<li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错；</br></li>
<li>const常量有数据类型，编译器可以对其进行类型安全检查；</br></li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>内存占用：</br></p>
<blockquote>
<ol>
<li>define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表；</br></li>
<li>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间；</br></li>
</ol>
</blockquote>
</blockquote>
<h3 id="120四种cast类型转换">1.20 四种cast类型转换</h3>
<blockquote>
<p>作用：克服c语言中强制类型转化带来的风险，C++引入四种更加安全的强制类型转换运算符(明确转换的目的，便于程序的维护和分析)</p>
</blockquote>
<ol>
<li>const_cast：去除const属性</li>
</ol>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 1.去除const属性，将只读变为只读写
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2.针对常量指针、常量引用和常量对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>static_cast: 内置数据类型、基类-派生类之间的转换</li>
</ol>
<blockquote>
<ul>
<li>内置数据类型之间的转换，int转double，char转int</br></li>
<li>基类指针与派生类之间的转换，只能转换有继承或派生关系的类。用于类层次结构之间基类和派生类指针和引用之间的转换，进行向上转型是安全的，但是进行向下转型是不安全的，但是是可以转换的;
<ul>
<li>向上转型(向基类转换 -&gt; 安全)：我们知道基类的引用和指针都可以指向派生类的对象，那么将派生类的指针或者引用强转为基类的指针或者引用，那么这就是向上转型，也就是向父类转;</br></li>
<li>向下转型(向派生类转换 -&gt; 不安全)：向下转型就和向上转型相反，它是将父类的指针或者引用，强制转换为子类的指针或者引用</br></li>
</ul>
</li>
<li>把void类型指针转换为目标类型的指针</br></li>
<li>任何类型的表达式转化为void类型</br></li>
</ul>
</blockquote>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 整形转浮点型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//基类指针转派生类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">A</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">*</span><span class="n">pA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span> <span class="o">*</span><span class="n">pB</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pA</span><span class="p">);</span> <span class="c1">// 向下转换不安全
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>reinterpret_cast:</li>
</ol>
<blockquote>
<ul>
<li>可以将一个类型的<strong>指针</strong>转换为其它任意类型的指针，也可以用在指针和整形数据之间的转换。它是很危险的，如果我们没有使用它的充分理由，那么就不要使用它</br></li>
<li>为运算对象的位模式提供较低层次上的重新解释</br></li>
<li>用于底层的强制转换，依赖于机器，一般使用较少</br></li>
</ul>
</blockquote>
<ol start="4">
<li>dynamic_cast: 运行时处理；基类向派生类转换时比static_cast更安全</li>
</ol>
<blockquote>
<ul>
<li>dynamic_cast是<font color=red>运行时处理</font>的，运行时进行类型检查，其他三种是编译时处理的</br></li>
<li>不能用于内置数据类型之间的转换</br></li>
<li>dynamic_cast在进行上行转换时和static_cast效果是一样的，但是进行下行转换时会进行类型检查，比static_cast更加安全，下行转换是否成功取决于转换对象的实际类型与目标类型是否相同</br></li>
<li>要求基类必须具有虚函数，否则编译不通过</br></li>
<li>若转换成功，返回的是指向目标的指针或引用，不成功返回NULL</br></li>
</ul>
</blockquote>
<h2 id="2-基础知识二">2. 基础知识(二)</h2>
<h3 id="21-写出-int-bool-float-指针变量与-零值比较的if-语句">2.1 写出 int 、bool、 float 、指针变量与 “零值”比较的if 语句</h3>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//int与零值比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//bool与零值比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="c1">// 表示flag为真
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="c1">// 表示flag为假
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//float与零值比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">float</span> <span class="n">EPSINON</span> <span class="o">=</span> <span class="mf">0.00001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="o">-</span> <span class="n">EPSINON</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">EPSINON</span><span class="p">)</span> <span class="c1">//其中EPSINON是允许的误差(即精度)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//指针变量与零值比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="22-变量的声明和定义有什么区别">2.2 变量的声明和定义有什么区别</h3>
<blockquote>
<p>① 变量的定义为变量<u><em>分配地址和存储空间</em></u>， 变量的声明不分配地址。</br>
② 一个变量可以在多个地方声明， 但是只在一个地方定义。<font color=red>声明多次，定义一次。</font></br>
③ 加入extern 修饰的是变量的声明，说明此变量将在文件外部或在文件后面部分定义。</br>
④ 说明：很多时候一个变量，只是声明，不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。</br></p>
</blockquote>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">extern</span> <span class="kt">int</span> <span class="n">A</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//这是个声明而不是定义，声明A是一个已经定义了的外部变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//注意：声明外部变量时可以把变量类型去掉如：extern A;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">dosth</span><span class="p">();</span> <span class="c1">//执行函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="p">;</span> <span class="c1">//是定义，定义了A为整型的外部变量
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="23-简述-ifdefelseendif和ifndef的作用">2.3 简述 <code>#ifdef</code>、<code>#else</code>、<code>#endif</code>和<code>#ifndef</code>的作用</h3>
<p>利用 <code>#ifdef</code>、<code>#endif</code> <u>将某程序功能模块包括进去，以向特定用户提供该功能</u>。在不需要时用户可轻易将其屏蔽。</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="cp">#ifdef MATH
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#include</span> <span class="cpf">“math.c”</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//在子程序前加上标记，以便于追踪和调试。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="cp">#ifdef DEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">printf</span> <span class="p">(</span><span class="err">“</span><span class="n">Indebugging</span><span class="err">…</span><span class="o">!</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cp">#endif</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。</br>
注意：虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长(因为所有语句都编译)，运行时间长(因为在程序运行时间对if语句进行测试)。而采用<u><strong>条件编译</strong></u>，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。</p>
<h3 id="24-结构体可以直接赋值吗">2.4 结构体可以直接赋值吗?</h3>
<blockquote>
<p>①结构体声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。</br>
②注意：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。</p>
</blockquote>
<h3 id="25-sizeof-和strlen-的区别">2.5 sizeof 和strlen 的区别</h3>
<blockquote>
<p>①sizeof是一个<strong>操作符</strong>，strlen是<strong>库函数</strong>。</br>
②sizeof的参数可以是<strong>数据的类型</strong>，也可以是<strong>变量</strong>，而strlen只能以结尾为‘\0’的字符串作参数。</br>
③编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。</br>
④数组做sizeof的参数不退化，传递给strlen就退化为指针了</br></p>
</blockquote>
<h3 id="26-sizeof求类型大小">2.6 sizeof求类型大小</h3>
<p>ref: <a href="https://www.cnblogs.com/maji233/p/11439880.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/maji233/p/11439880.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<blockquote>
<p>①类的大小为类的非静态成员数据的类型大小之和，也就是说<font color=red>静态成员数据不作考虑</font>。
普通成员函数与sizeof无关。</br>
②虚函数由于要维护虚函数表，所以要占据一个指针大小，也就是4字节。
类的总大小也遵守类似class字节对齐的，调整规则。</br></p>
</blockquote>
<p>ref:</br></p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(32 位)
</span></span><span class="line"><span class="cl">指针都是  4个字节
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">char     1个字节
</span></span><span class="line"><span class="cl">short 两个字节
</span></span><span class="line"><span class="cl">int      4个字节
</span></span><span class="line"><span class="cl">long     4个字节
</span></span><span class="line"><span class="cl">long int 4个字节
</span></span><span class="line"><span class="cl">float    4个字节
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">double    8个字节
</span></span><span class="line"><span class="cl">long double  8个字节
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">(64 字节)
</span></span><span class="line"><span class="cl">指针都是一个字长, 8个字节
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">char    1个字节
</span></span><span class="line"><span class="cl">short   2个字节
</span></span><span class="line"><span class="cl">int     4个字节
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">long    8个字节
</span></span><span class="line"><span class="cl">long int  8个字节
</span></span><span class="line"><span class="cl">double    8个字节
</span></span><span class="line"><span class="cl">long double 也可以变长了, 16个字节</span></span></code></pre></td></tr></table>
</div>
</div><p>例如有如下结构体：</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Stu</span>  <span class="c1">//自定义的数据类型，允许用户存储不同的数据类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">sex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">hight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么一个这样的结构体变量占多大内存呢？也就是 <code>cout&lt;&lt;sizeof(Stu)&lt;&lt;endl;</code>  会输出什么？
在了解字节对齐方式之前想当然的会以为：sizeof(Stu) = sizeof(int)+sizeof(char)+sizeof(float) = 9.
然而事实并非如此！</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>字节对齐原则<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">在系统默认的对齐方式下：每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，且最终占用字节数为成员类型中最大占用字节数的整数倍。</div>
    </div>
  </div>
<p>在这个例子中，id的偏移量为0(0=4x0)，sex的偏移量为4(4=1x4)，height的偏移量为8(8=2x4)，此时占用12字节，也同时满足12=3x4.所以sizeof(Stu)=12.</p>
<blockquote>
<p>总结：</br>
①最终大小一定是最大数据类型的整数倍；</br>
②静态变量不占空间</br>
③每种类型的偏移量为自身的n倍；</br>
详细请查阅：<a href="https://blog.csdn.net/weixin_30412577/article/details/95141536?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task"target="_blank" rel="external nofollow noopener noreferrer">struct/class等内存字节对齐问题详解<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
</blockquote>
<p>ref:</br>
<a href="https://www.cnblogs.com/always-chang/p/6084973.html#:~:text=1.%E5%B1%95%E5%BC%80%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%88%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%89%E5%BA%94%E5%BD%93%E6%98%AF%E8%A2%AB%E5%B1%95%E5%BC%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%88%90%E5%91%98%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%8D%EF%BC%9B,2.%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E5%BF%85%E9%A1%BB%E6%98%AF%E6%89%80%E6%9C%89%E6%88%90%E5%91%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%8D%EF%BC%8C%E8%BF%99%E9%87%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%98%AF%E5%B1%95%E5%BC%80%E5%90%8E%E7%9A%84%E6%88%90%E5%91%98%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%B0%86%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9C%8B%E4%BD%9C%E4%B8%80%E4%B8%AA%E6%95%B4%E4%BD%93%E3%80%82"target="_blank" rel="external nofollow noopener noreferrer">struct地址偏移量计算<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="27-c语言的关键字static和c的关键字static有什么区别">2.7 C语言的关键字<code>static</code>和C++的关键字<code>static</code>有什么区别</h3>
<blockquote>
<p>①在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。</br>
②注意：编程时 static 的记忆性和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。</br></p>
</blockquote>
<h3 id="28-ｃ语言的malloc和ｃ中的new有什么区别">2.8 Ｃ语言的<code>malloc</code>和Ｃ＋＋中的<code>new</code>有什么区别</h3>
<blockquote>
<p>①new 、delete 是操作符，可以重载，只能在C++ 中使用。</br>
②malloc、free 是函数，可以覆盖，C、C++ 中都可以使用。</br>
③new 可以调用对象的构造函数，对应的delete 调用相应的析构函数。</br>
④malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数。</br>
⑤new 、delete 返回的是<strong>某种数据类型指针</strong>，malloc、free 返回的是**<code>void</code>指针**。</br>
注意：<code>malloc</code>申请的内存空间要用<code>free</code>释放，而<code>new</code>申请的内存空间要用<code>delete</code>释放，不要混用。</br></p>
</blockquote>
<p>ref: <a href="https://jianye0428.github.io/posts/basics_one/#211-new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%84%E8%87%AA%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-delete-%E5%92%8C-free%E7%B1%BB%E4%BC%BC"target="_blank" rel="external nofollow noopener noreferrer">2.11 new 和 malloc的区别<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="29-写一个-标准-宏min">2.9 写一个 “标准” 宏MIN</h3>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define min(a,b) ((a)&lt;=(b)?(a):(b))</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="210-i和i的区别">2.10 ++i和i++的区别</h3>
<blockquote>
<p>++i先自增1，再返回；i++先返回i,再自增1</br>
前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回。</p>
</blockquote>
<h3 id="211-new和malloc的区别各自底层实现原理delete和free类似">2.11 <code>new</code>和<code>malloc</code>的区别，各自底层实现原理(<code>delete</code>和<code>free</code>类似)</h3>
<blockquote>
<p>①new(delete)是操作符，而malloc(free)是函数。</br>
②new在调用的时候先分配内存，再调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</br>
③malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</br>
④new可以被重载; malloc不行</br>
⑤new分配内存, 更直接和安全。</br>
⑥new发生错误抛出异常，malloc返回null</br></p>
</blockquote>
<h3 id="212-const-和-define-的区别">2.12 const 和 define 的区别</h3>
<p><strong>区别</strong></br></p>
<blockquote>
<p>(1)就<font color=red>起作用的阶段</font>而言：<code>#define</code>是在编译的预处理阶段起作用，而<code>const</code>是在 编译、运行的时候起作用。</br>
(2)就<font color=red>起作用的方式</font>而言：<code>#define</code>只是<u>简单的字符串替换，没有类型检查</u>。而<code>const</code>有对应的数据类型，是要进行判断的，可以避免一些低级的错误。</br>
(3)就<font color=red>存储方式</font>而言：<code>#define</code>只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。</br>
(4)从<font color=red>代码调试的方便程度</font>而言： <code>const</code>常量可以进行调试的，<code>define</code>是不能进行调试的，因为在预编译阶段就已经替换掉了。</br></p>
</blockquote>
<p><strong>const优点：</strong></p>
<blockquote>
<p>(1)const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</br>
(2)有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。</br>
(3)const可节省空间，避免不必要的内存分配，提高效率</br></p>
</blockquote>
<h3 id="213c中函数指针和指针函数的区别">2.13 C++中函数指针和指针函数的区别</h3>
<ol>
<li>定义不同</li>
</ol>
<blockquote>
<p>指针函数本质是一个函数，其返回值为指针。</br>
函数指针本质是一个指针，其指向一个函数。</br></p>
</blockquote>
<ol start="2">
<li>写法不同</li>
</ol>
<blockquote>
<p>指针函数：int *fun(int x, int y);</br>
函数指针：int (*fun)(int x, int y);</br></p>
</blockquote>
<ol start="3">
<li>用法不同</li>
</ol>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//指针函数示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_Data</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">Data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//指针函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Data</span><span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Data</span> <span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用指针函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Data</span> <span class="o">*</span> <span class="n">myData</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//Data * myData = static_cast&lt;Data*&gt;(f(4,5));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//函数指针示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//赋值, 函数指针指向函数add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fun</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(*fun)(1,2) = &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出结果
</span></span></span><span class="line"><span class="cl"><span class="c1">//(*fun)(1,2) =  3
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="214使用指针需要注意什么">2.14 使用指针需要注意什么？</h3>
<blockquote>
<p>①定义指针时，先初始化为NULL空指针。</br>
②用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。</br>
③不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</br>
④避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作。</br>
⑤动态内存的申请与释放必须配对，防止内存泄漏。</br>
⑥用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”。</br></p>
</blockquote>
<h3 id="215volatile有什么作用">2.15 volatile有什么作用</h3>
<blockquote>
<p>①volatile为状态寄存器一类的并行设备硬件寄存器。</br>
②一个中断服务子程序会访问到的非自动变量。</br>
③多线程间被几个任务共享的变量。</br>
注意：虽然volatile在嵌入式方面应用比较多，但是在PC软件的多线程中，volatile修饰的临界变量也是非常实用的。</p>
</blockquote>
<p>C++中volatile的作用:</br>
<font color=red>总结: 建议编译器不要对该变量进行优化，每次都从内存中读取该变量，而不是从缓存(寄存器)中读取变量。</font></p>
<blockquote>
<p>volatile是“易变/不稳定”的意思。volatile是C的一个较为少用的关键字，解决变量在“共享”环境下容易出现读取错误的问题。</br></p>
</blockquote>
<blockquote>
<p>定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，<font color=red>你希望这个值被正确地处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取</font>，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。</br></p>
</blockquote>
<blockquote>
<p>在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM(从RAM中读取变量的值到寄存器)，以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。</br></p>
</blockquote>
<blockquote>
<p>而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序(如中断程序、另外的线程等)所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。</br></p>
</blockquote>
<h3 id="216-一个参数可以既是const又是volatile吗">2.16 一个参数可以既是const又是volatile吗</h3>
<blockquote>
<p>可以。用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。</br>
注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并<font color=red>没有实际地禁止某段内存的读写特性</font><br></p>
</blockquote>
<h3 id="217a和a有什么区别">2.17 <code>a</code>和<code>&amp;a</code>有什么区别</h3>
<p>&lt;1&gt; <code>&amp;a</code>：其含义就是“变量a的地址”。</br>
&lt;2&gt; <code>*a</code>：用在不同的地方，含义也不一样。</br></p>
<ul>
<li>①在声明语句中，<code>*a</code>只说明a是一个指针变量，如<code>int *a</code>；</li>
<li>②在其他语句中，<code>*a</code>前面没有操作数且a是一个指针时，<code>*a</code>代表指针a指向的地址内存放的数据(解引用)，如<code>b=*a</code>；</li>
<li>③<code>*a</code>前面有操作数且a是一个普通变量时，a代表乘以a，如c=ba</li>
</ul>
<h3 id="218-用c-编写一个死循环程序">2.18 用C 编写一个死循环程序</h3>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：很多种途径都可实现同一种功能，但是不同的方法时间和空间占用度不同，特别是对于嵌入式软件，处理器速度比较慢，存储空间较小，所以时间和空间优势是选择各种方法的首要考虑条件。</p>
</blockquote>
<h3 id="219全局变量和局部变量有什么区别是怎么实现的操作系统和编译器是怎么知道的">2.19 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</h3>
<blockquote>
<p>①全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束(在程序结束时所占内存释放)；</br>
②而局部变量存在于模块(子程序，函数)中，只有所在模块可以访问，其他模块不可直接访问，模块结束(函数调用完毕)，局部变量消失，所占据的内存释放。</br>
③操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。</br></p>
</blockquote>
<h3 id="220-结构体内存对齐问题">2.20 结构体内存对齐问题</h3>
<p>请写出以下代码的输出结果：</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cm">/**************************************************************
</span></span></span><span class="line"><span class="cl"><span class="cm">*		结构体内存对⻬问题
</span></span></span><span class="line"><span class="cl"><span class="cm">*   从偏移为0的位置开始存储；
</span></span></span><span class="line"><span class="cl"><span class="cm">*	如果没有定义 #pragma pack(n)
</span></span></span><span class="line"><span class="cl"><span class="cm">*	sizeof 的最终结果必然是结构内部最⼤成员的整数倍，不够补⻬；
</span></span></span><span class="line"><span class="cl"><span class="cm">*	结构内部各个成员的⾸地址必然是⾃身⼤⼩的整数倍；
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">***************************************************************/</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S1</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span> <span class="p">;</span>  <span class="c1">//起始偏移0，sizeof(i)=4; 地址0、1、2、3分配给成员i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">char</span> <span class="n">j</span> <span class="p">;</span> <span class="c1">//起始偏移4，sizeof(j)=1;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">a</span> <span class="p">;</span>	 <span class="c1">//sizeof(a)=4,内存对齐到8个字节，从偏移量为8处存放a;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">double</span> <span class="n">b</span><span class="p">;</span><span class="c1">//sizeof(b)=8,内存对齐到16个字节，再存放b,结构体总大小24;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//结构体成员的首地址必须是自身大小的整数倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">S3</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">j</span><span class="p">;</span><span class="c1">//起始偏移0，sizeof(j)=1;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span> <span class="n">i</span><span class="p">;</span><span class="c1">//sizeof(i)=4，内存对齐到4，起始偏移量为4,再存放i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">double</span> <span class="n">b</span><span class="p">;</span><span class="c1">//当前地址为8，是b大小的整数倍，无需对齐，直接存放成员b 8个字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span><span class="c1">//sizeof(a)=4,内存对齐到20，再存放a,总大小24字节；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">S1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">S3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">24
</span></span><span class="line"><span class="cl">24</span></span></code></pre></td></tr></table>
</div>
</div><p>说明：</br></p>
<blockquote>
<p>①结构体作为一种复合数据类型，其构成元素既可以是基本数据类型的变量，也可以是一些复合型类型数据。对此，编译器会自动进行成员变量的对齐以提高运算效率。</br>
②默认情况下，按自然对齐条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同，向结构体成员中size最大的成员对齐。</br>
③许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k(通常它为4或8)的倍数，而这个k则被称为该数据类型的对齐模数。</br></p>
</blockquote>
<h2 id="3-基础知识三">3 基础知识(三)</h2>
<h3 id="31-简述cc程序编译的内存分配情况">3.1 简述C、C++程序编译的内存分配情况</h3>
<blockquote>
<p>①从静态存储区域分配：</br>
内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错， 因为有系统会善后。例如全局变量，static 变量，常量字符串等。</p>
</blockquote>
<blockquote>
<p>②在栈上分配：</br>
在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。大小为2M。</p>
</blockquote>
<blockquote>
<p>③从堆上分配：</br>
即动态内存分配。程序在运行的时候用 malloc 或new 申请任意大小的内存，程序员自己负责在何 时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生 堆内碎块。</p>
</blockquote>
<p><strong>一个C、C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区。</strong></p>
<h3 id="32简述strcpysprintf-与memcpy-的区别">3.2 简述strcpy、sprintf 与memcpy 的区别</h3>
<blockquote>
<p>①操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</br>
②执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。</br>
③实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。</br>
注意：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。</p>
</blockquote>
<h3 id="请解析void---0-的含义">请解析((void ()( ) )0)( )的含义</h3>
<blockquote>
<p><code>void (0)( )</code> ：是一个返回值为void，参数为空的函数指针0。</br>
<code>(void ()( ))0</code>：把0转变成一个返回值为void，参数为空的函数指针。</br>
<code>((void ()( ))0()</code>：在上句的基础上加表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。</br>
<code>((void (*)( ))0)( )</code>：这就是上句的函数名所对应的函数的调用。</br></p>
</blockquote>
<h3 id="34-typedef-和define-有什么区别">3.4 typedef 和define 有什么区别</h3>
<blockquote>
<p>①用法不同：</br>
typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。</br>
②执行时间不同：</br>
typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</br>
③作用域不同：</br>
typedef 有作用域限定：define 不受作用域约束，只要在define 声明后的引用都是正确的。</br>
④对指针的操作不同：</br>
typedef 和define 定义的指针时有很大的区别。</br>
注意：typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。</br></p>
</blockquote>
<h3 id="35指针常量与常量指针区别">3.5 指针常量与常量指针区别</h3>
<blockquote>
<p>指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。</br>
常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。</br></p>
<blockquote>
<p>指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。</br></p>
</blockquote>
</blockquote>
<blockquote>
<p>注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</p>
</blockquote>
<h3 id="36简述队列和栈的异同">3.6 简述队列和栈的异同</h3>
<blockquote>
<p>队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是 “后进先出”。
注意：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS 回收。分配方式类似于链表。 它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。</p>
</blockquote>
<h3 id="37设置地址为0x67a9-的整型变量的值为0xaa66">3.7 设置地址为0x67a9 的整型变量的值为0xaa66</h3>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x67a9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mh">0xaa66</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：这道题就是强制类型转换的典型例子，无论在什么平台，地址长度和整型数据的长度是一样的， 即一个整型数据可以强制转换成地址指针类型，只要有意义即可。</p>
</blockquote>
<h3 id="38编码实现字符串转化为数字">3.8 编码实现字符串转化为数字</h3>
<blockquote>
<p>编码实现函数atoi()，设计一个程序，把一个字符串转化为一个整型数值。例如数字：“5486321 ”， 转化成字符：5486321。</p>
</blockquote>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">myAtoi</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//保存转换后的数值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">isNegative</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//记录字符串中是否有负号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">//判断指针的合法性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="c1">//计算数字符串度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">n</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="c1">//判断数组是否有负号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">isNegative</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span><span class="p">(</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span> <span class="o">||</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="c1">//滤除非数字字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">!=</span><span class="mi">0</span> <span class="o">||</span> <span class="n">temp</span> <span class="o">!=</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="c1">//滤除字符串开始的0 字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">temp</span> <span class="o">-=</span> <span class="mh">0x30</span><span class="p">;</span> <span class="c1">//将数字字符转换为数值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">num</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">*</span><span class="kt">int</span><span class="p">(</span> <span class="n">pow</span><span class="p">(</span><span class="mi">10</span> <span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="n">isNegative</span><span class="p">)</span> <span class="c1">//如果字符串中有负号，将数值取反
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">num</span><span class="p">;</span> <span class="c1">//返回转换后的数值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="39c语言的结构体struct和c的类class有什么区别">3.9 C语言的结构体(struct)和C++的类(class)有什么区别</h3>
<blockquote>
<p>①C语言的结构体是不能有成员函数的，而C++的类可以有。</br>
②C语言的结构体中数据成员是没有private、public和protected访问限定的。而C++的类的成员有这些访问权限限定。</br>
③C语言的结构体是没有继承关系的，而C++的类却有丰富的继承关系。</br>
注意：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。</br></p>
</blockquote>
<h3 id="310-简述指针常量与常量指针的区别">3.10 简述指针常量与常量指针的区别</h3>
<blockquote>
<p>①指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。指针常量的值只能在定义时初始化，常量指针指向一个只读的对象</br>
②指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。</br>
注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</br></p>
</blockquote>
<h3 id="311-如何避免野指针">3.11 如何避免“野指针”</h3>
<blockquote>
<p>①指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。</br>
②指针p被free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。</br>
③指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。</br></p>
</blockquote>
<h3 id="312句柄和指针的区别和联系是什么">3.12 句柄和指针的区别和联系是什么？</h3>
<p>句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32bit的uint。指针则标记某个物理内存地址，两者是不同的概念。</p>
<h3 id="313newdelete与mallocfree的区别是什么">3.13 new/delete与malloc/free的区别是什么</h3>
<blockquote>
<p>new能自动计算需要分配的内存空间，而malloc需要手工计算字节数。</p>
</blockquote>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">2</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>①new与delete直接带具体类型的指针，malloc和free返回void类型的指针。</br>
②new类型是安全的，而malloc不是。例如int *p = new float[2];就会报错；而int p = malloc(2sizeof(int))编译时编译器就无法指出错误来。</br>
③new一般分为两步：new操作和构造。new操作对应与malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。</br>
④new调用构造函数，malloc不能；delete调用析构函数，而free不能。</br>
⑤malloc/free需要库文件stdlib.h的支持，new/delete则不需要！</br>
注意：delete和free被调用后，内存不会立即回收，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该讲该指针指向NULL。</br></p>
</blockquote>
<h3 id="314说一说externc">3.14 说一说extern“C”</h3>
<blockquote>
<p>extern &ldquo;C&quot;的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern &ldquo;C&quot;后，会指示编译器这部分代码按C语言(而不是C++)的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</br></p>
</blockquote>
<blockquote>
<p>这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern &ldquo;C&quot;就是其中的一个策略。</br></p>
</blockquote>
<blockquote>
<p>C++代码调用C语言代码在C++的头文件中使用在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到。</br></p>
</blockquote>
<h3 id="315请你来说一下c中struct和class的区别">3.15 请你来说一下C++中struct和class的区别</h3>
<p>在C++中，class和struct做类型定义是只有两点区别：</p>
<blockquote>
<p>①默认继承权限不同，class继承默认是private继承，而struct默认是public继承</br>
②class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数 </br>
③C++保留struct关键字，原因：保证与C语言的向下兼容性，C++必须提供一个struct</br>
④C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制</br>
⑤对struct定义的扩展使C语言的代码能够更容易的被移植到C++中</br></p>
</blockquote>
<h3 id="316c类内可以定义引用数据成员吗">3.16 C++类内可以定义引用数据成员吗？</h3>
<blockquote>
<p>可以，必须通过成员函数初始化列表初始化。</p>
</blockquote>
<h3 id="317c中类成员的访问权限">3.17 C++中类成员的访问权限</h3>
<blockquote>
<p>①C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</br>
②在类的内部(定义类的代码内部)，无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。</br>
③在类的外部(定义类的代码之外)，只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</br></p>
</blockquote>
<h3 id="318什么是右值引用跟左值又有什么区别">3.18 什么是右值引用，跟左值又有什么区别？</h3>
<p>左值和右值的概念：</p>
<blockquote>
<p>①左值：</br>
能取地址，或者具名对象，表达式结束后依然存在的持久对象；</br>
右值：不能取地址，匿名对象，表达式结束后就不再存在的临时对象；</br>
②区别：</br>
左值能寻址，右值不能；</br>
左值能赋值，右值不能；</br>
左值可变，右值不能(仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变)；</br></p>
</blockquote>
<h3 id="319面向对象的三大特征">3.19 面向对象的三大特征</h3>
<blockquote>
<p>封装性：将客观事物抽象成类，每个类对自身的数据和方法实行 protection (private ， protected ， public )。</br>
继承性：广义的继承有三种实现形式：实现继承(使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。</br>
多态性：是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</br></p>
</blockquote>
<h3 id="320c的空类有哪些成员函数">3.20 C++的空类有哪些成员函数</h3>
<p><a href="https://blog.csdn.net/weixin_45805339/article/details/128089198"target="_blank" rel="external nofollow noopener noreferrer">C++空类成员函数<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>：</p>
<blockquote>
<p>缺省构造函数。</br>
缺省拷贝构造函数。</br>
缺省析构函数。</br>
缺省赋值运算符。</br>
缺省取址运算符。</br>
缺省取址运算符 const 。</br>
注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些空类成员函数的时候，编译器才会去定义它们。</br></p>
</blockquote>
<h2 id="4-基础知识四">4. 基础知识(四)</h2>
<h3 id="41-说一说c中四种cast转换">4.1 说一说c++中四种cast转换</h3>
<p>C++中四种类型转换是：<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code></p>
<blockquote>
<p>1、const_cast</br>
用于将const变量转为非const</br>
2、static_cast</br>
用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</br>
3、dynamic_cast</br>
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</br></p>
<ul>
<li>向上转换：指的是子类向基类的转换</br></li>
<li>向下转换：指的是基类向子类的转换</br>
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</br></li>
</ul>
<p>4、reinterpret_cast</br>
几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</br>
5、为什么不使用C的强制转换？</br>
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</br></p>
</blockquote>
<h3 id="42-对c中的smart-pointer四个智能指针的理解shared_ptrunique_ptrweak_ptrauto_ptr">4.2 对c++中的smart pointer四个智能指针的理解：shared_ptr,unique_ptr,weak_ptr,auto_ptr</h3>
<blockquote>
<p>①C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被C++11弃用。</br>
②智能指针的作用是管理一个指针，因为存在以下这种情况：</br>
申请的空间在函数结束时忘记释放，造成<strong>内存泄漏</strong>。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</br>
③auto_ptr(c++98的方案，cpp11已经抛弃)</p>
</blockquote>
<p><font color=red>采用所有权模式。</font></p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">unique_ptr</span> <span class="nf">p3</span> <span class="p">(</span><span class="k">new</span> <span class="n">string</span> <span class="p">(</span><span class="err">“</span><span class="k">auto</span><span class="err">”</span><span class="p">));</span> <span class="c1">//#4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span> <span class="n">p4</span><span class="err">；</span> <span class="c1">//#5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p4</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span><span class="c1">//此时会报错！！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</br></p>
<p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">unique_ptr</span> <span class="nf">pu1</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span> <span class="p">(</span><span class="err">“</span><span class="n">hello</span> <span class="n">world</span><span class="err">”</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span> <span class="n">pu2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">pu2</span> <span class="o">=</span> <span class="n">pu1</span><span class="p">;</span> <span class="c1">// #1 not allowed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span> <span class="n">pu3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">pu3</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span> <span class="p">(</span><span class="err">“</span><span class="n">You</span><span class="err">”</span><span class="p">));</span> <span class="c1">// #2 allowed
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">unique_ptr</span> <span class="n">ps1</span><span class="p">,</span> <span class="n">ps2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ps1</span> <span class="o">=</span> <span class="n">demo</span><span class="p">(</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ps2</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">ps1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ps1</span> <span class="o">=</span> <span class="n">demo</span><span class="p">(</span><span class="err">“</span><span class="n">alexia</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ps2</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>shared_ptr实现共享式拥有概念。</strong><u>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。</u>从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p><strong>成员函数：</strong></p>
<blockquote>
<p>use_count 返回引用计数的个数</br>
unique 返回是否是独占所有权( use_count 为 1)</br>
swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</br>
reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</br>
get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptrsp(new int(1)); sp 与 sp.get()是等价的</br></p>
</blockquote>
<p><strong>weak_ptr:</strong></p>
<blockquote>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。</br></br>
weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</br></br>
weak_ptr是用来<strong>解决shared_ptr相互引用时的死锁问题</strong>,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</br></p>
</blockquote>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">pb_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">A</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;A delete&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pa_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">B</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;B delete&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">pb</span><span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pa</span><span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">pb</span><span class="o">-&gt;</span><span class="n">pa_</span> <span class="o">=</span> <span class="n">pa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pa</span><span class="o">-&gt;</span><span class="n">pb_</span> <span class="o">=</span> <span class="n">pb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pb</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pa</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放(A B的析构函数没有被调用)，如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</br></p>
<p>注意：不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</br></p>
<h3 id="43-说说强制类型转换运算符">4.3 说说强制类型转换运算符</h3>
<p><strong>①static_cast 用于非多态类型的转换</strong></p>
<blockquote>
<p>用于非多态类型的转换</br>
不执行运行时类型检查(转换安全性不如 dynamic_cast)</br>
通常用于转换数值数据类型(如 float -&gt; int)</br>
可以在整个类层次结构中移动指针，子类转化为父类安全(向上转换)，父类转化为子类不安全(因为子类可能有不在父类的字段或方法)</br></p>
</blockquote>
<p><strong>②dynamic_cast 用于多态类型的转换</strong></p>
<blockquote>
<p>用于多态类型的转换
执行行运行时类型检查
只适用于指针或引用
对不明确的指针的转换将失败(返回 nullptr)，但不引发异常
可以在整个类层次结构中移动指针，包括向上转换、向下转换</p>
</blockquote>
<p><strong>③const_cast</strong></p>
<blockquote>
<p>用于删除 const、volatile 和 __unaligned 特性(如将 const int 类型转换为 int 类型 )</p>
</blockquote>
<p><strong>④reinterpret_cast</strong></p>
<blockquote>
<ul>
<li>用于位的简单重新解释</br></li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</br></li>
<li>允许将任何指针转换为任何其他指针类型(如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全)
也允许将任何整数类型转换为任何指针类型以及反向转换。</br></li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</br></li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</br></li>
</ul>
</blockquote>
<p><strong>⑤bad_cast</strong></p>
<blockquote>
<p>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。
bad_cast 使用:</p>
</blockquote>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Circle</span><span class="o">&amp;</span> <span class="n">ref_circle</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">ref_shape</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">catch</span> <span class="p">(</span><span class="n">bad_cast</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Caught: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="44-谈谈你对拷贝构造函数和赋值运算符的认识">4.4 谈谈你对拷贝构造函数和赋值运算符的认识</h3>
<p>拷贝构造函数和赋值运算符重载有以下两个不同之处：</br></p>
<blockquote>
<p>①拷贝构造函数生成新的类对象，而赋值运算符不能。</br>
②由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对之前不用检验原对象是否和新建对象相同，而赋值运算符则需要这个操作，</br>
③另外，赋值运算中，如果原来的对象中有内存分配要先把内存释放掉。</br>
注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。</p>
</blockquote>
<h3 id="45-在c中使用malloc申请的内存能否通过delete释放使用new申请的内存能否用free">4.5 在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？</h3>
<blockquote>
<p>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。</br>
①malloc /free的操作对象都是必须明确大小的。<font color=red>而且不能用在动态类上</font>。</br>
②new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。</br></p>
</blockquote>
<p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p>
<h3 id="46-用c设计一个不能被继承的类">4.6 用C++设计一个不能被继承的类</h3>
<p>ref: <a href="https://blog.csdn.net/wei_cheng18/article/details/81043858"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/wei_cheng18/article/details/81043858<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">friend</span> <span class="n">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">     <span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">   <span class="o">~</span><span class="n">B</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">B</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">     <span class="n">C</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//C c;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意：<font color=red>构造函数是继承实现的关键</font>，每次子类对象构造时，首先调用的是父类的构造函数，然后才 是自己的。</p>
<h3 id="48-访问基类的私有虚函数">4.8 访问基类的私有虚函数</h3>
<p>写出以下程序的输出结果：</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A::g&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A::f&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;B::g&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">h</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;B::h&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span> <span class="o">*</span><span class="n">Fun</span> <span class="p">)(</span> <span class="kt">void</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Fun</span> <span class="n">pFun</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pFun</span> <span class="o">=</span> <span class="p">(</span> <span class="n">Fun</span> <span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span> <span class="kt">int</span><span class="o">*</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">int</span><span class="o">*</span> <span class="p">)(</span> <span class="o">&amp;</span><span class="n">b</span> <span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pFun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果:</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">B</span><span class="o">::</span><span class="n">g</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">::</span><span class="n">f</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">::</span><span class="n">h</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：考察了面试者对虚函数的理解程度。一个对虚函数不了解的人很难正确的做出本题。 在学习面向对象的多态性时一定要深刻理解虚函数表的工作原理。</p>
</blockquote>
<blockquote>
<p>虚函数：通过基类访问派生类定义的函数，多态时使用，使用虚函数加上virtual关键字。</br>
虚函数就是在基类定义一个未实现的函数名，为了提高程序的可读性</br>
<a href="https://blog.csdn.net/weixin_45138932/article/details/125667041"target="_blank" rel="external nofollow noopener noreferrer">虚函数详解<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
<a href="https://blog.csdn.net/qq_42048450/article/details/117282640?spm=1001.2014.3001.5502"target="_blank" rel="external nofollow noopener noreferrer">C++虚函数详解_疯狂的麦克斯_max的博客-CSDN博客_c++虚函数<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</blockquote>
<p><a href="https://blog.csdn.net/weixin_43700340/article/details/89471069"target="_blank" rel="external nofollow noopener noreferrer">菱形继承1<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
<a href="https://blog.csdn.net/Y673789476/article/details/128271855#t9"target="_blank" rel="external nofollow noopener noreferrer">菱形继承2<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="49-对虚函数和多态的理解">4.9 对虚函数和多态的理解</h3>
<blockquote>
<p>①多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。
举个例子: 一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</br>
②虚函数的实现: 在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</br></p>
</blockquote>
<h3 id="410-简述类成员函数的重写overwrite重载overload和隐藏的区别">4.10 简述类成员函数的重写(overwrite)、重载(overload)和隐藏的区别</h3>
<p>(1)重写和重载主要有以下几点不同。</p>
<blockquote>
<p>①范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。</br>
②参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。</br>
③virtual的区别：重写的基类中被重写的函数必须要有virtual修饰，而重载函数和被重载函数可以被virtual修饰，也可以没有。</br></p>
</blockquote>
<p>(2)隐藏和重写、重载有以下几点不同。</p>
<blockquote>
<p>与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。</br>
参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。 当参数不相同时，无论基类中的参数是否被virtual 修饰，基类的函数都是被隐藏，而不是被重写。</br>
注意：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。</p>
</blockquote>
<h3 id="411-链表和数组有什么区别">4.11 链表和数组有什么区别</h3>
<p><strong>存储形式:</strong></p>
<blockquote>
<p>数组是一块连续的空间，声明时就要确定长度。</br>
链表是一块可不连续的动态空间， 长度可变，每个结点要保存相邻结点指针。</br></p>
</blockquote>
<p><strong>数据查找:</strong></p>
<blockquote>
<p>数组的线性查找速度快，查找操作直接使用偏移地址。</br>
链表需要按顺序检索结点， 效率低。</br>
数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。</br></p>
</blockquote>
<p><strong>越界问题：</strong></p>
<blockquote>
<p>链表不存在越界问题，数组有越界问题。</p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。</p>
</blockquote>
<h3 id="412-用两个栈实现一个队列的功能">4.12 用两个栈实现一个队列的功能</h3>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">node</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">node</span><span class="p">,</span><span class="o">*</span><span class="n">LinkStack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//创建空栈：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LinkStack</span> <span class="nf">CreateNULLStack</span><span class="p">(</span> <span class="n">LinkStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkStack</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 申请新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span><span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">S</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Fail to malloc a new node.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="n">S</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//初始化新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//栈的插入函数：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LinkStack</span> <span class="nf">Push</span><span class="p">(</span> <span class="n">LinkStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span><span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">S</span><span class="p">)</span> <span class="c1">//检验栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;There no node in stack!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">LinkStack</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkStack</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// 申请新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span><span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Fail to malloc a new node.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span><span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">else</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span> <span class="c1">//初始化新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//插入新结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">return</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//出栈函数：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">node</span> <span class="nf">Pop</span><span class="p">(</span> <span class="n">LinkStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">node</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">temp</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">temp</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">if</span><span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">S</span><span class="p">)</span> <span class="c1">//检验栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;There no node in stack!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">if</span><span class="p">(</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The stack is NULL,can&#39;t pop!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="n">LinkStack</span> <span class="n">p</span> <span class="o">=</span> <span class="n">S</span> <span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">//节点出栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">free</span><span class="p">(</span> <span class="n">p</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//双栈实现队列的入队函数：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LinkStack</span> <span class="nf">StackToQueuPush</span><span class="p">(</span> <span class="n">LinkStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">node</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">LinkStack</span> <span class="n">S1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">CreateNULLStack</span><span class="p">(</span> <span class="n">S1</span> <span class="p">);</span> <span class="c1">//创建空栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="k">while</span><span class="p">(</span> <span class="nb">NULL</span> <span class="o">!=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">next</span> <span class="p">)</span> <span class="c1">//S 出栈入S1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">=</span> <span class="n">Pop</span><span class="p">(</span> <span class="n">S</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Push</span><span class="p">(</span> <span class="n">S1</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">data</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="n">Push</span><span class="p">(</span> <span class="n">S1</span><span class="p">,</span> <span class="n">data</span> <span class="p">);</span> <span class="c1">//新结点入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="k">while</span><span class="p">(</span> <span class="nb">NULL</span> <span class="o">!=</span> <span class="n">S1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="p">)</span> <span class="c1">//S1 出栈入S
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">=</span> <span class="n">Pop</span><span class="p">(</span> <span class="n">S1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Push</span><span class="p">(</span> <span class="n">S</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">data</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意：用两个栈能够实现一个队列的功能，那用两个队列能否实现一个队列的功能呢？结果是否定的，因为栈是先进后出，将两个栈连在一起，就是先进先出。而队列是现先进先出，无论多少个连在一起都是先进先出，而无法实现先进后出。</p>
<h3 id="413-共享数据的保护">4.13 共享数据的保护</h3>
<p>①常引用：使所引用的形参不能被更新</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>②常对象：在生存期内不能被更新，但必须被初始化</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">A</span> <span class="k">const</span> <span class="nf">a</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>③常成员函数：
不能修改对象中数据成员，也不能调用类中没有被const 修饰的成员函数(常对象唯一的对外接口).如果声明了一个常对象，则该对象只能调用他的常函数！-&gt;可以用于对重载函数的区分;</p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>④extern int a:使其他文件也能访问该变量
声明一个函数或定义函数时，冠以static的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数(每一个cpp 文件就是一个编译单元)。</p>
<h3 id="414-程序内存分配方式以及它们的区别">4.14 程序内存分配方式以及它们的区别</h3>
<p>内存分配大致上可以分成5块：</p>
<blockquote>
<p><strong>栈区(stack)</strong></br>
栈，就是那些由编译器在需要时分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是<u>局部变量</u>、<u>函数参数</u>等。(由编译器管理)</br>
<strong>堆区(heap)</strong></br>
一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。注意，它与数据结构中的堆是两回事，分配方式类似于链表。</br>
<strong>全局区(静态区)(static)</strong></br>
全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。</br>
<strong>常量存储区</strong></br>
常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。</br>
<strong>程序代码区</strong></br>
存放函数体的二进制代码。</br></p>
</blockquote>
<p>C++程序在执行时，将内存大方向划分为4个区域:</p>
<blockquote>
<p>程序运行前</p>
<blockquote>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</br></li>
<li>全局区：存放全局变量和静态变量以及常量</br></li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>程序运行后</p>
<blockquote>
<ul>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</br></li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</br></li>
</ul>
</blockquote>
</blockquote>
<p>内存四区意义：</p>
<blockquote>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
</blockquote>
<h3 id="415-explicit">4.15 explicit</h3>
<p>函数声明时加上explicit可以<u>阻止函数参数被隐式转换</u>。</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="n">Class</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">explicit</span> <span class="nf">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">A</span> <span class="n">a1</span><span class="o">=</span><span class="mi">12</span><span class="p">;</span>   <span class="c1">//不加explicit时会被隐式转换位 A a1=A(12);加了此时编译器会报错。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>被声明为explicit的构造函数通常比non-explicit 函数更受欢迎。</p>
<h3 id="416-mutable关键字">4.16 mutable关键字</h3>
<blockquote>
<p>mutable的中文意思是“可变的，易变的”，跟constant(既C++中的const)是反义词。在C++中，mutable也是为了突破const的限制而设置的。</br>
被mutable修饰的变量(mutable只能用于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。</br>
我们知道，假如类的成员函数不会改变对象的状态，那么这个成员函数一般会声明为const。但是，有些时候，我们<font color=purple>需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰</font>。(使用mutable修饰的数据成员可以被const成员函数修改)。</br></p>
</blockquote>
<h3 id="417-用const修饰函数的返回值">4.17 用const修饰函数的返回值</h3>
<p>如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值(即指针)的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。例如函数：</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">GetString</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如下语句将出现编译错误：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span><span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 正确的用法是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span><span class="n">GetString</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="418-宏const和enum">4.18 宏、const和enum</h3>
<blockquote>
<p>#define不被视为语言的一部分。对于单纯常量，最好用const对象或者enum替换#define。</br>
对于类似函数的宏，尽量使用内联函数inline替换掉#define</br>
enum枚举类型是被当做 int 或者 unsigned int 类型来处理的。</br></p>
</blockquote>
<h3 id="419-stack的生存期">4.19 stack的生存期</h3>
<blockquote>
<p>①C++中的static对象是指存储区不属于stack和heap、&ldquo;寿命&quot;从被构造出来直至程序结束为止的对象。</br>
②这些对象包括全局对象，定义于namespace作用域的对象，在class、function以及file作用域中被声明为static的对象。</br>
③其中，函数内的static对象称为local static对象，而其它static对象称为non-local static对象。</br></p>
</blockquote>
<p>这两者在何时被初始化(构造)这个问题上存在细微的差别：</p>
<blockquote>
<p>①对于local static对象，在其所属的函数被调用之前，该对象并不存在，即只有在第一次调用对应函数时，local static对象才被构造出来。</br>
②而对于non-local static对象，在main()函数开始前就已经被构造出来，并在main()函数结束后被析构。</br></p>
</blockquote>
<p>&lt;/font color=red&gt;建议：</font></p>
<blockquote>
<p>1.对内置对象进行手工初始化，因为C++不保证初始化它们。</br>
2.构造函数最好使用成员初值列，而不要在构造函数本体中使用赋值操作。初值列中列出的成员变量，其排序次序应该和它们在class中的声明次序相同(初始化顺序与声明变量顺序一致)。</br>
3.为免除“跨编译单元的初始化次序问题”，尽量以local static对象替换non-local static对象。</br></p>
</blockquote>
<h3 id="420-全局变量和static变量的区别">4.20 全局变量和static变量的区别</h3>
<blockquote>
<p>①全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。</br>
②这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。</br>
③而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。</br>
④由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</br></p>
</blockquote>
<h2 id="5-基础知识五">5 基础知识(五)</h2>
<h3 id="51-为什么栈要比堆速度要快">5.1 为什么栈要比堆速度要快</h3>
<blockquote>
<p>①首先, 栈是本着LIFO原则的存储机制, 对栈数据的定位相对比较快速, 而堆则是随机分配的空间, 处理的数据比较多, 无论如何, 至少要两次定位.
②其次, 栈是由CPU提供指令支持的, 在指令的处理速度上, 对栈数据进行处理的速度自然要优于由操作系统支持的堆数据.
③再者, 栈是在一级缓存中做缓存的, 而堆则是在二级缓存中, 两者在硬件性能上差异巨大.
最后, 各语言对栈的优化支持要优于对堆的支持, 比如swift语言中, 三个字及以内的struct结构, 可以在栈中内联, 从而达到更快的处理速度.</p>
</blockquote>
<h3 id="52-c-析构函数调用时间">5.2 c++ 析构函数调用时间</h3>
<blockquote>
<p>对象生命周期结束，被销毁时
delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时
对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用</p>
</blockquote>
<h3 id="53-静态绑定-动态绑定-也叫动态连编静态连编">5.3 静态绑定 动态绑定 (也叫动态连编，静态连编)</h3>
<blockquote>
<p>如果父类中存在有虚函数，那么编译器便会为之生成虚表(属于类)与虚指针(属于某个对象)，在程序运行时，根据虚指针的指向，来决定调用哪个虚函数，这称之与动态绑定，与之相对的是静态绑定，静态绑定在编译期就决定了。</p>
</blockquote>
<p>class和template都支持接口与多态；
①对classes而言，接口是显式的，以函数签名为中心。多态则是通过virtual函数(虚函数)发生于运行期；
②对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。
<strong>泛型</strong>
泛型是通过参数化类型来实现在同一份代码上操作多种数据类型。利用“参数化类型”将类型抽象化，从而实现灵活的复用。</p>
<h3 id="54-c语言的指针和c的引用有什么区别">5.4 C语言的指针和c++的引用有什么区别？</h3>
<blockquote>
<ul>
<li>指针有自己的一块空间，指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体。而引用只是一个别名；</br></li>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</br></li>
<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</br></li>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</br></li>
</ul>
</blockquote>
<h3 id="55-请你说说c语言是怎么进行函数调用的">5.5 请你说说C语言是怎么进行函数调用的</h3>
<blockquote>
<p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。(ESP(Extended Stack Pointer)为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针)</br></p>
</blockquote>
<p>C语言参数压栈顺序？：从右到左</p>
<h3 id="56-c中拷贝赋值函数的形参能否进行值传递">5.6 C++中拷贝赋值函数的形参能否进行值传递？</h3>
<p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数(aa = ex.aa; //此处调用拷贝构造函数)。如此循环，无法完成拷贝，栈也会满。</p>
<h3 id="57-include头文件的顺序以及双引号和尖括号的区别">5.7 include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h3>
<p>编译器预处理阶段查找头文件的路径不一样</p>
<blockquote>
<p>使用双引号包含的头文件，查找头文件路径的顺序为：
①当前头文件目录
②编译器设置的头文件路径(编译器可使用-I显式指定搜索路径)
③系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径
对于使用尖括号包含的头文件，查找头文件的路径顺序为：
①编译器设置的头文件路径(编译器可使用-I显式指定搜索路径)
②系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
</blockquote>
<h3 id="58-一个c源文件从文本到可执行文件经历的过程">5.8 一个C++源文件从文本到可执行文件经历的过程</h3>
<p>对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</br></p>
<ul>
<li>预编译，预编译的时候做一些简单的文本替换，比如宏替换，而不进行语法的检查；</li>
<li>编译，在编译阶段，编译器将检查一些语法错误，但是，如果使用的函数事先没有定义这种情况，不再这一阶段检查，编译后，得到.s文件</li>
<li>汇编，将C/C++代码变为汇编代码，得到.o或者.obj文件</li>
<li>链接，将所用到的外部文件链接在一起，在这一阶段，就会检查使用的函数有没有定义</li>
</ul>
<p>链接过后，形成可执行文件.exe
详细请参阅: <a href="https://blog.csdn.net/daaikuaichuan/article/details/89060957"target="_blank" rel="external nofollow noopener noreferrer">一个C++源文件从文本到可执行文件经历的过程<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="59-内存泄漏原因和判断方法">5.9 内存泄漏原因和判断方法</h3>
<p>内存泄漏通常是因为调用了malloc/new等内存申请操作，但是缺少了对应的free/delete。
为了判断内存是否泄漏，我们一方面可以使用Linux环境下的内存泄漏检查工具Valgrind，另一方面我们写代码的时候，可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否有泄漏。</p>
<p>内存泄漏分类：</p>
<ul>
<li>堆内存泄漏(heap leak)。堆内存值得是程序运行过程中根据需要分配通过malloc\realloc\new等从堆中分配的一块内存，再完成之后必须要通过调用对应的free或者delete删除。</li>
<li>如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</li>
<li>系统资源泄露(Resource Leak)。主要指程序使用系统分配的资源比如 Bitmap，handle，SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确的释放，从而造成内存泄漏。</li>
</ul>
<h3 id="510-段错误的产生原因">5.10 段错误的产生原因</h3>
<p><strong>段错误是什么?</strong></p>
<blockquote>
<p>一句话来说，段错误是指访问的内存超出了系统给这个程序所设定的内存空间，例如访问了不存在的内存地址、访问了系统保护的内存地址、访问了只读的内存地址等等情况。这里贴一个对于“段错误”的准确定义。</br></p>
</blockquote>
<p><strong>段错误产生的原因</strong></p>
<blockquote>
<p>访问不存在的内存地址</br>
访问系统保护的内存地址</br>
访问只读的内存地址</br>
栈溢出</br>
详细请参阅：<a href="https://www.cnblogs.com/lidabo/p/4545625.html"target="_blank" rel="external nofollow noopener noreferrer">Linux环境下段错误的产生原因及调试方法小结<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
</blockquote>
<h3 id="511-c-函数调用过程">5.11 C++ 函数调用过程</h3>
<p>总结起来整个过程就三步：</p>
<blockquote>
<p>1)根据调用的函数名找到函数入口；</br>
2)在栈中申请调用函数中的参数及函数体内定义的变量的内存空间</br>
3)函数执行完后，释放函数在栈中的申请的参数和变量的空间，最后返回值(如果有的话)</br></p>
</blockquote>
<p>详细请查阅：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html"target="_blank" rel="external nofollow noopener noreferrer">函数调用过程 / C/C++函数调用过程分析<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="512-如何调试c多线程程序">5.12 如何调试c++多线程程序？</h3>
<ol>
<li>打印日志，日志中加上线程ID；(简单粗暴)
gdb有thread相关命令，如infothread(简写infoth)显示线程消息，bxxthreadyy可以</br></li>
<li>对某个thread设置断点，threadxx(简写成thrxx)切换到某个thread。再配合frame(简写f)相关的命令(比如up，down在不同frame间跳转)，基本可以处理若干个不同的线程间的debug……</br>
详细请查阅：<a href="https://www.cnblogs.com/LuckCoder/p/10948242.html"target="_blank" rel="external nofollow noopener noreferrer">C++(vs)多线程调试 (转)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ol>
<h3 id="513面向对象和面向过程的区别">5.13 面向对象和面向过程的区别</h3>
<blockquote>
<p>①面向对象方法中，把数据和数据操作放在一起，组成对象；对同类的对象抽象出其共性组成类；类通过简单的接口与外界发生联系，对象和对象之间通过消息进行通信。</br>
②面向对象的三大特性是&quot;封装、“多态”、“继承”，五大原则是&quot;单一职责原则&rdquo;、“开放封闭原则”、“里氏替换原则”、“依赖倒置原则”、“接口分离原则”。</br>
③而面向过程方法是以过程为中心的开发方法，它自顶向下顺序进行， 程序结构按照功能划分成若干个基本模块，这些模块形成树状结构。</br></p>
</blockquote>
<p><strong>(过程)优点：</strong></p>
<p>性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗源;比如嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。缺点：没有面向对象易维护、易复用、易扩展。</p>
<p><strong>(对象)优点：</strong></p>
<p>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统。缺点：性能比面向过程低。</p>
<h3 id="514-关于引用赋值的多态">5.14 关于引用赋值的多态：</h3>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Class</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Class</span> <span class="nl">D</span> <span class="p">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">&amp;</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">d</span> <span class="p">;</span>  <span class="c1">//父类可以作为子类的引用，此时b1表现和指针形式一致(会调用B的非虚函数)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">D</span><span class="o">&amp;</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">b</span><span class="err">；</span> <span class="c1">//错误，不能将子类作为父类的引用
</span></span></span><span class="line"><span class="cl"><span class="c1">//父类可以作为子类的引用，此时b1表现和指针形式一致(会调用B的非虚函数) 
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="515-模板的声明和实现不能分开的原因">5.15 模板的声明和实现不能分开的原因</h3>
<blockquote>
<p>链接的时候，需要实例化模板，这时候就需要找模板的具体实现了。假设在main函数中调用了一个模板函数，这时候就需要去实例化该类型的模板。注意main函数里面只包含了.h文件，也就是只有模板的声明，没有具体实现。就会报错。
而模板的实现.cpp里面，虽然有模板的具体实现，但是没有谁在该.cpp里面使用一个模板函数，就不会生成一个具体化的实例
详细请参阅：<a href="https://www.cnblogs.com/callme/articles/6142129.html"target="_blank" rel="external nofollow noopener noreferrer">C++ 模板类的声明与实现分离问题<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> / ​​​​​<a href="https://blog.csdn.net/weixin_40539125/article/details/83375452?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param"target="_blank" rel="external nofollow noopener noreferrer">​C++ 模板类的声明与实现分离问题(模板实例化)​​​​​​<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</blockquote>
<h3 id="516-c类中引用成员和常量成员的初始化初始化列表">5.16 C++类中引用成员和常量成员的初始化(初始化列表)</h3>
<p>如果一个类是这样定义的：</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Class</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">pram1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pram2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pram3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="nl">privite</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假如在构造函数中对三个私有变量进行赋值则通常会这样写：</p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">pram1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pram2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pram3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">a</span><span class="o">=</span><span class="n">pram1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="n">b</span><span class="o">=</span><span class="n">pram2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="n">c</span><span class="o">=</span><span class="n">pram3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，这样是编译不过的。因为常量和引用初始化必须赋值。所以上面的构造函数的写法只是简单的赋值，并不是初始化。
正确写法应该是：</p>
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">pram1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pram2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pram3</span><span class="p">)</span><span class="o">:</span><span class="n">b</span><span class="p">(</span><span class="n">pram2</span><span class="p">),</span><span class="n">c</span><span class="p">(</span><span class="n">pram3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span><span class="o">=</span><span class="n">pram1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>采用初始化列表实现了对常量和引用的初始化。采用括号赋值的方法，括号赋值只能用在变量的初始化而不能用在定义之后的赋值。
凡是有引用类型的成员变量或者常量类型的变量的类，不能有缺省构造函数。默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。并且必须使用初始化列表进行初始化const对象、引用对象。</p>
</blockquote>
<h3 id="517-memset为int型数组初始化问题">5.17 memset为int型数组初始化问题：</h3>
<p>头文件：<code>#include &lt;string.h&gt;</code>
memset() 函数用来将指定内存的前n个字节设置为特定的值，其原型为：</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="nf">memset</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">num</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>参数说明：</br>
ptr 为要操作的内存的指针。</br>
value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。</br>
num 为 ptr 的前 num 个字节，size_t 就是unsigned int。</br></p>
</blockquote>
<p>【函数说明】memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后返回指向 ptr 的指针。</p>
<p>无法下面这样初始化，这样的结果是a被赋值成168430090，168430090&hellip;..</p>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是因为int由4个字节(说)表示，并且不能得到数组a中整数的期望值。
但我经常看到程序员使用memset将int数组元素设置为0或-1。其他值不行！</p>
<div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">//假设a为int型数组：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mh">0x7f</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">//a数组每个空间将被初始化为0x7f7f7f7f,原因是C函数传参过程中的指针降级，导致sizeof(a)，返回的是一个 something*指针类型大小的的字节数，如果是32位，就是4字节。所以memset按字节赋值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mh">0xaf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">//a数组每个空间将被初始化为0xafafafaf
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="518-编译器对-inline-函数的处理步骤">5.18 编译器对 inline 函数的处理步骤</h3>
<blockquote>
<p>将 inline 函数体复制到 inline 函数调用点处；</br>
为所用 inline 函数中的局部变量分配内存空间；</br>
将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</br>
如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支(使用 GOTO)</br></p>
</blockquote>
<p>优点:</p>
<blockquote>
<p>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</br>
内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换(同普通函数)，而宏定义则不会。</br>
在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</br>
内联函数在运行时可调试，而宏定义不可以。</br></p>
</blockquote>
<p>缺点:</p>
<blockquote>
<p>代码膨胀。内联是以代码膨胀(复制)为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</br>
inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</br>
是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</br></p>
</blockquote>
<h3 id="519-虚函数virtual可以是内联函数inline吗">5.19 虚函数(virtual)可以是内联函数(inline)吗？</h3>
<blockquote>
<p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</br>
内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时(运行期)不可以内联。</br>
inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类(如 Base::who())，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生;</br></p>
</blockquote>
<h3 id="520静态库和动态库比较">5.20 静态库和动态库比较</h3>
<p>静态库 (.a、.lib):</p>
<blockquote>
<p>将静态库的内容添加到程序中，此时程序的空间，变成了源程序空间大小+静态库空间大小。</p>
</blockquote>
<p>动态库(共享库)(.so、.dll):</p>
<blockquote>
<p>常驻内存，当程序需要调用相关函数时，会从内存调用。</p>
</blockquote>
<p>区别:</p>
<blockquote>
<p>静态库：对空间要求较低，而时间要求较高的核心程序中。(.a、.lib) </br>
动态库：对时间要求较低，对空间要求较高。(.so、.dll) </br></p>
</blockquote>
<p><a href="https://blog.csdn.net/m0_46245582/article/details/124027320"target="_blank" rel="external nofollow noopener noreferrer">hash<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="6-基础知识六">6 基础知识(六)</h2>
<h3 id="61-构造函数为什么不能定义为虚函数-析构函数般写成虚函数的原因-">6.1 构造函数为什么不能定义为虚函数？ ⽽析构函数⼀般写成虚函数的原因 ？</h3>
<p>构造函数不能声明为虚函数的原因是:</p>
<blockquote>
<p>1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。</br>
2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。</br></p>
</blockquote>
<p>虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。(动态绑定是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本就不存在，它怎么动态绑定？)
编译器在调用基类的构造函数的时候并不知道你要构造的是一个基类的对象还是一个派生类的对象。</p>
<blockquote>
<p>析构函数设为虚函数的作用:
解释：在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。(如果基类的析构函数不是虚函数，那么在delete 基类指针时，只调用基类的析构函数，不会调用派生类的析构函数，故派生类部分不会被析构。)</p>
</blockquote>
<p>ref:</br>
[1]. <a href="https://blog.csdn.net/Yangy_Jiaojiao/article/details/127588598"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Yangy_Jiaojiao/article/details/127588598<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://blog.csdn.net/Yangy_Jiaojiao/article/details/128145609"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Yangy_Jiaojiao/article/details/128145609<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
<p>参考(待补充):</br>
[1]. <a href="https://zhuanlan.zhihu.com/p/401341063"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/401341063<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://zhuanlan.zhihu.com/p/602866792"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/602866792<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
<p>ref: <a href="https://blog.csdn.net/m0_46245582/category_11569287.html"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/m0_46245582/category_11569287.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>]]></description></item><item><title>Effective STL [29] | 需要一个一个字符输入时考虑使用istreambuf_iterator</title><link>https://jianye0428.github.io/posts/clause_29/</link><pubDate>Fri, 18 Aug 2023 07:55:51 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_29/</guid><description><![CDATA[<h2 id="istream_iterator-拷贝文件">istream_iterator 拷贝文件</h2>
<p>假设要把一个文本文件拷贝到一个字符串对象中。似乎可以用一种很有道理的方法完成：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把inputFile读入fileData；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 关于为什么它不是很正确请看下文关于这个语法的警告参见条款6
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很快你就会发现这种方法无法把文件中的空格拷贝到字符串中。</p>
<p>那是因为<code>istream_iterators</code>使用<code>operator&gt;&gt;</code>函数来进行真的读取，而且<code>operator&gt;&gt;</code>函数在默认情况下忽略空格。</p>
<p>假如你想保留空格，你要的做就是覆盖默认情况。只要清除输入流的skipws标志就行了：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">inputFile</span><span class="p">.</span><span class="n">unset</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">skipws</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 关闭inputFile的忽略空格标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在inputFile中的所有字符都拷贝到fileData中了。</p>
<p><strong>拷贝速度</strong></p>
<p>你会发现它们的拷贝速度不像你想象的那么快。</p>
<p><code>istream_iterators</code>所依靠的<code>operator&gt;&gt;</code>函数进行的是格式化输入，这意味着每次你调用的时候它们都必须做大量工作：</p>
<ol>
<li>
<p>必须建立和销毁岗哨（sentry）对象（为每个<code>operator&gt;&gt;</code>调用进行建立和清除活动的特殊的<code>iostream</code>对象）；</p>
</li>
<li>
<p>必须检查可能影响它们行为的流标志（比如skipws）；</p>
</li>
<li>
<p>必须进行全面的读取错误检查；</p>
</li>
<li>
<p>如果它们遇到问题，它们必须检查流的异常掩码来决定是否该抛出一个异常。</p>
</li>
</ol>
<p>如果进行格式化输入，那些都是重要的活动，但如果你需要的只是从输入流中抓取下一个字符，那就过度了。</p>
<h2 id="istreambuf_iterators-拷贝文件">istreambuf_iterators 拷贝文件</h2>
<p>你可以像<code>istream_iterator</code>一样使用<code>istreambuf_iterator</code>，但<code>istream_iterator&lt;char&gt;</code>对象使用<code>operator&gt;&gt;</code>来从输入流中读取单个字符。 <code>istreambuf_iterator</code>对象进入流的缓冲区并直接读取下一个字符。（更明确地说，<code>istreambuf_iterator&lt;char&gt;</code> 对象从一个<code>istream s</code>中读取会调用<code>s.rdbuf()-&gt;sgetc()</code>来读<code>s</code>的下一个字符。）把我们的文件读取代码改为使用<code>istreambuf_iterator</code>相当简单，大多数Visual Basic程序员都可以在两次尝试内做对：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl"><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意这里不需要“<code>unset</code>” <code>skipws</code>标志，<code>istreambuf_iterator</code>不忽略任何字符。它们只抓取流缓冲区的下一个字符。</p>
<p>相对于<code>istream_iterator</code>，它们抓取得更快。</p>
<p>如果你需要一个一个地读取流中的字符，你不需要格式化输入的威力，你关心的是它们花多少时间来读取流，和明显的性能提高相比，为每个迭代器多键入三个字符的代价是微弱的。对于无格式的一个一个字符输入，你总是应该考虑使用<code>istreambuf_iterator</code>。</p>
<h2 id="结论">结论</h2>
<p>当你了解它之后，你也应该考虑把<code>ostreambuf_iterator</code>用于相应的无格式一个一个字符输出的作。</p>
<p>它们没有了<code>ostream_iterator</code>的开销（和灵活性），所以它们通常也做得更好。</p>
]]></description></item><item><title>Transformer | 如何理解attention中的Q,K,V？</title><link>https://jianye0428.github.io/posts/attentionaqkv/</link><pubDate>Sun, 20 Aug 2023 17:44:07 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/attentionaqkv/</guid><description><![CDATA[<h2 id="解答一">解答一</h2>
<p>我们直接用torch实现一个SelfAttention来说一说：</p>
<ol>
<li>首先定义三个线性变换矩阵，query, key, value：</li>
</ol>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，这里的query, key, value只是一种操作(线性变换)的名称，实际的Q/K/V是它们三个的输出
2. 假设三种操作的输入都是同一个矩阵(暂且先别管为什么输入是同一个矩阵)，这里暂且定为长度为L的句子，每个token的特征维度是768，那么输入就是(L, 768)，每一行就是一个字，像这样：

乘以上面三种操作就得到了Q/K/V，(L, 768)*(768,768) = (L,768)，维度其实没变，即此刻的Q/K/V分别为：

代码为:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden_states</span><span class="p">):</span> <span class="c1"># hidden_states 维度是(L, 768)</span>
</span></span><span class="line"><span class="cl">     <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>
<p>然后来实现这个操作:
$$Attention(Q,K_i,V_i)\color{red}{\boxed{=softmax(\frac{Q^TK_i}{\sqrt{d_k}})V_i}}$$
① 首先是Q和K矩阵乘，(L, 768)*(L, 768)的转置=(L,L)，看图：

首先用Q的第一行，即“我”字的768特征和K中“我”字的768为特征点乘求和，得到输出(0，0)位置的数值，这个数值就代表了“我想吃酸菜鱼”中“我”字对“我”字的注意力权重，然后显而易见输出的第一行就是“我”字对“我想吃酸菜鱼”里面每个字的注意力权重；整个结果自然就是“我想吃酸菜鱼”里面每个字对其它字(包括自己)的注意力权重(就是一个数值)了~</p>
<p>② 然后是除以根号dim，这个dim就是768，至于为什么要除以这个数值？主要是为了缩小点积范围，确保softmax梯度稳定性，具体推导可以看这里：<a href="https://zhuanlan.zhihu.com/p/149903065"target="_blank" rel="external nofollow noopener noreferrer">莲生三十二：Self-attention中dot-product操作为什么要被缩放<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，然后就是为什么要softmax，一种解释是为了保证注意力权重的非负性，同时增加非线性，还有一些工作对去掉softmax进行了实验，如<a href="https://zhuanlan.zhihu.com/p/157490738"target="_blank" rel="external nofollow noopener noreferrer">PaperWeekly：线性Attention的探索：Attention必须有个Softmax吗？<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>③ 然后就是刚才的注意力权重和V矩阵乘了，如图：
</p>
<p>注意力权重 x VALUE矩阵 = 最终结果 </br>
首先是“我”这个字对“我想吃酸菜鱼”这句话里面每个字的注意力权重，和V中“我想吃酸菜鱼”里面每个字的第一维特征进行相乘再求和，这个过程其实就相当于用每个字的权重对每个字的特征进行加权求和，然后再用“我”这个字对对“我想吃酸菜鱼”这句话里面每个字的注意力权重和V中“我想吃酸菜鱼”里面每个字的第二维特征进行相乘再求和，依次类推~最终也就得到了(L,768)的结果矩阵，和输入保持一致~</p>
<p>整个过程在草稿纸上画一画简单的矩阵乘就出来了，一目了然~最后上代码：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hidden_states</span><span class="p">):</span> <span class="c1"># hidden_states 维度是(L, 768)</span>
</span></span><span class="line"><span class="cl">     <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">     <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">attention_scores</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attention_head_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">attention_probs</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">attention_scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_probs</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">out</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>为什么叫<strong>自注意力网络</strong>？</br>
因为可以看到Q/K/V都是通过同一句话的输入算出来的，按照上面的流程也就是一句话内每个字对其它字(包括自己)的权重分配；那如果不是自注意力呢？简单来说，Q来自于句A，K、V来自于句B即可~</br></p>
</li>
<li>
<p>注意，K/V中，如果同时替换任意两个字的位置，对最终的结果是不会有影响的，至于为什么，可以自己在草稿纸上画一画矩阵乘；也就是说注意力机制是没有位置信息的，不像CNN/RNN/LSTM；这也是为什么要引入positional embeding的原因。</p>
</li>
</ol>
<h2 id="解答二">解答二</h2>
<p>其实直接用邱锡鹏老师PPT里的一张图就可以直观理解——假设D是输入序列的内容，完全忽略线性变换的话可以近似认为Q=K=V=D(所以叫做Self-Attention，因为这是输入的序列对它自己的注意力)，于是序列中的每一个元素经过Self-Attention之后的表示就可以这样展现：</p>
<p></p>
<p>也就是说，The这个词的表示，实际上是整个序列加权求和的结果——权重从哪来？点积之后Softmax得到——这里Softmax(QK)就是求权重的体现。我们知道，向量点积的值可以表征词与词之间的相似性，而此处的“整个序列”包括The这个词自己(再一次强调这是Self-Attention)，所以最后输出的词的表示，其“主要成分”就主要地包含它自身和跟它相似的词的表示，其他无关的词的表示对应的权重就会比较低。</p>
<h2 id="解答三">解答三</h2>
<p>首先附上链接：<a href="https://zhuanlan.zhihu.com/p/37601161"target="_blank" rel="external nofollow noopener noreferrer">张俊林：深度学习中的注意力模型(2017版)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 。这个几乎是我读到过的讲解Attention最为透彻的篇章之一了。</p>
<p>Q(Querry)代表查询值，对应Decoder的H(t-1)状态。这里要正确理解H(t-1)，想要解码出t时刻的输出，你送入Decoder的必然有前一时刻计算出的隐状态。好了，所谓查询，就是你要拿着这个Decoder中的H(t-1)去和Encoder中各个时刻的隐状态<a href="%e4%b9%9f%e5%b0%b1%e6%98%af%e5%90%84%e4%b8%aaKey">H(1), H(2), &hellip; , H(T)</a>去比，也就是二者计算相似度(对应于文献中的各种energy函数)。最后算出来的结果用Softmax归一化，这个算出来的权重就是带有注意力机制的权重，其实在翻译任务中，Key和Value是相等的。在Transformer的实现源码中，Key和Value的初始值也是相等的。有了这个权重之后，就可以用这个权重对Value进行加权求和，生成的这个新的向量就是带有注意力机制的语义向量 Context vector，而这个语义向量会权衡Target与Source的token与token的关系，从而实现解码输出时，与Source中“真正有决定意义”的token关联。</p>
<p>姑且画蛇添足的再说几句：
首先，Attention机制是由Encoder-Decoder架构而来，且最初是用于完成NLP领域中的翻译(Translation)任务。那么输入输出就是非常明显的 Source-Target的对应关系，经典的Seq2Seq结构是从Encoder生成出一个语义向量(Context vector)而不再变化，然后将这个语义向量送入Decoder配合解码输出。这种方法的最大问题就是这个语义向量，我们是希望它一成不变好呢？还是它最好能配合Decoder动态调整自己，来使Target中的某些token与Source中的真正“有决定意义”的token关联起来好呢？
这就是为什么会有Attention机制的原因。说到底，Attention机制就是想生成会动态变化的语义向量来配合解码输出。而新贵 Self-Attention则是为了解决Target与Source各自内部token与token的关系。在Transformer中，这两种注意力机制得到了有机的统一，释放出了异常惊人的潜力。</p>
<p>ref:</br>
[1]. <a href="https://mp.weixin.qq.com/s/v7N3lhMBSdoGCz4K3TmsmA"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/v7N3lhMBSdoGCz4K3TmsmA<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective C++ (第3版) 精读总结 [2]</title><link>https://jianye0428.github.io/posts/parttwo/</link><pubDate>Sun, 30 Jul 2023 17:08:51 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/parttwo/</guid><description><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-C++总结系列分为四部分，本文为第二部分，涉及原书第3~4章，内容范围Rule13~25。为方便书写，Rule13简写为R13。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<p>由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人<code>开发经验</code>新增一些个人感悟👉<code>By the way</code>环节。</p>
<h2 id="ch3资源管理">CH3.资源管理</h2>
<h3 id="r13-以对象管理资源">R13 以对象管理资源</h3>
<ul>
<li>
<p>为防止资源泄露，尽量使用<code>RAII</code>对象(资源获取即初始化，Resource Acquisition Is Initialization)
如果用老式的new-delete组合手动管理资源，可能会遇到这样的场景，处理代码中有多处return/break之类的分支语句，每处都手动添加delete回收资源难免会有遗漏风险。</p>
<ol>
<li>
<p>auto_ptr
本书提及的智能指针对象<code>std::auto_ptr</code>可以在资源A初始化化时接管对象A，对象脱离作用域，析构时释放接管的A。
为避免重复删除资源，<code>std::auto_ptr特性:</code> 通过copy构造函数或copy-assignment操作符，操作它们，它们自身会失去资源所有权，变成NULL ！</p>
</li>
<li>
<p>shared_ptr
为解决上述问题，后来推出了引用计数管理资源，即<code>RCSP(Reference-counting smart poiner)</code>，std::shared_ptr 。(书中当时还是tr1::shared_ptr)特点是shared_ptr在使用copy构造函数或copy-assignment操作符时，不会失去资源所有权，而是自身引用计数加1。
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>
<p>auto_ptr目前已经被弃用，转而使用 std::unique_ptr来指涉独占资源的智能指针，不可被复制和赋值。</p>
</li>
<li>
<p>shared_ptr存在的问题是环形循环应用，互相持有对方，则无法释放，针对这一问题，需要引入std::weak_ptr来破局。</p>
</li>
<li>
<p>这些智能指针的头文件支持：#include <memory></p>
</li>
</ul>
</div>
    </div>
  </div></p>
</li>
</ol>
</li>
<li>
<p>常用的RAII方式存在的问题
上述的shared_ptr是<strong>不支持数组资源的释放</strong>的，在析构时默认调用delete，而不是delete[] 。如果要能释放，需要手动传入析构函数。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="o">&gt;</span> <span class="n">instSpMan</span><span class="p">(</span><span class="k">new</span> <span class="n">Investment</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[](</span><span class="n">Investment</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// 使用lamda函数，还可以传入普通函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">instSp</span><span class="p">(</span><span class="k">new</span> <span class="n">Investment</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span><span class="c1">// shared_ptr重载了[]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">intUp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span> <span class="c1">// unique_ptr重载了[]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>PS: 通常情况下，如果能用vector代替的场景，就不需要这样使用对象数组。</p>
</li>
</ul>
<h3 id="r14-在资源管理类中小心coping行为">R14 在资源管理类中小心coping行为</h3>
<p>并非所有资源都是堆上管理(heap-based)，所以也有智能指针不适合的场景，这时需要自己实现一个资源管理类。</p>
<p>比如有个类CMutex ，只有2个函数lock和unlock，可以新建一个管理类CLock，来管理Mutex类，代码如下：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CMutex</span> <span class="p">{</span><span class="cm">/*省略类实现*/</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">CMutex</span> <span class="o">*</span><span class="n">mtx</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;has lock...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span><span class="cm">/*other operation...*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">CMutex</span> <span class="o">*</span><span class="n">mtx</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;release lock...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span><span class="cm">/*other operation...*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CLock</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">CLock</span><span class="p">(</span><span class="n">CMutex</span> <span class="o">*</span><span class="n">mtx</span><span class="p">)</span> <span class="o">:</span><span class="n">mtx_</span><span class="p">(</span><span class="n">mtx</span><span class="p">)</span> <span class="p">{</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">CLock</span><span class="p">()</span> <span class="p">{</span> <span class="n">unlock</span><span class="p">(</span><span class="n">mtx_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> <span class="n">CMutex</span> <span class="o">*</span><span class="n">mtx_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果涉及CLock的coping相关函数，那么有以下几种选择：</p>
<ul>
<li>禁止复制
参考本书Part1-Rule06，禁止coping函数的生成。</li>
<li>对底层资源使用“引用计数法”
以shared_ptr<CMutex>代替裸指针，并且传入unlock函数作为该指针的“删除器”。</li>
<li>复制底部资源
即“深度拷贝”，复制资源管理对象时，同时复制其包裹的资源。</li>
<li>转移底部资源所有权
即浅复制，不拷贝包裹的资源，而是转移所有权，和前文提到的auto_ptr非常契合。</li>
</ul>
<h3 id="r15-在资源管理类中提供对原始资源的访问">R15 在资源管理类中提供对原始资源的访问</h3>
<p>智能指针<code>auto_ptr</code>, <code>unique_ptr</code>, <code>shared_ptr</code>都提供了接口访问原始资源，方法名称为<code>get()</code>，对类A资源得到裸指针<code>A*</code>。</p>
<p>智能指针也重载了操作符<code>operator -&gt;</code> 和 <code>operator *</code> ，访问类成员函数都可以像普通指针那样使用。</p>
<p>如果自行设计资源管理类，也要像上述的智能指针那样，做到能够轻松访问原始资源。</p>
<p>某些情况，也可以不使用get成员函数<strong>显式转换</strong>，转而使用<strong>隐式类型转换</strong>，方便客户调用:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Font</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 隐式转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">operator</span> <span class="n">FontHandle</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 显式转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">FontHandle</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">FontHandle</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="r16-成对使用new和delete时要采取相同形式">R16 成对使用new和delete时要采取相同形式</h3>
<p>先看一段错误代码：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">stringArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">delete</span> <span class="n">stringArray</span><span class="p">;</span><span class="c1">// undefined behavior,未定义行为；有可能只删除了第一个元素
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>new 和 delete对应</li>
<li>new[] 和 delete[]对应
不可遗漏或者交叉错配！</li>
</ul>
</div>
    </div>
  </div>
<p>简单探究 <code>delete[]</code>的原理：实际上，在编译器的实现中，对象数组的起始内存会存放“数组长度”这一变量，以便告知<code>delete[]</code>应该调用多少次析构，删除多少资源。</p>
<p>👉 谨慎对数组使用typedef，容易产生new-delete的匹配误解，示例如下：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AddressLines</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">pal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AddressLines</span><span class="p">;</span><span class="c1">//注意：这里其实就是 new string[4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">delete</span> <span class="n">pal</span><span class="p">;</span>     <span class="c1">// 行为未定义！！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">delete</span> <span class="p">[]</span> <span class="n">pal</span><span class="p">;</span>  <span class="c1">// 正解！
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这里建议的替代方法：vector&lt;string&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="r17-以独立语句将newed对象置入智能指针">R17 以独立语句将newed对象置入智能指针</h3>
<p><strong>不要将申请资源的new语句直接当作函数入参</strong>，而是应该先以单独语句申请后传入。</p>
<p>考虑下述问题代码：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">priority</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw</span><span class="p">,</span><span class="kt">int</span> <span class="n">pri</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//函数调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span><span class="n">priority</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码第4行，在processWidget函数体执行之前，至少有3个步骤(并非严格次序)：</p>
<ol>
<li>执行&quot;new Widget&quot;</li>
<li>调用std::shared_ptr的构造函数</li>
<li>调用priority函数</li>
</ol>
<p>C++编译器能保证1-&gt;2的次序(2需要1做入参)，但是无法保证3的次序不在1，2之间，如果步骤3抛出异常，将会直接导致内存泄漏。正确示例如下：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span>  <span class="n">pw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">processWidget</span><span class="p">(</span><span class="n">pw</span><span class="p">,</span><span class="n">priority</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ch4设计与声明">CH4.设计与声明</h2>
<h3 id="r18-让接口容易被正确使用不易被误用">R18 让接口容易被正确使用，不易被误用</h3>
<p>要想设计一个不容易误用的接口，<strong>就要先考虑使用者可能犯什么错误</strong>。</p>
<ul>
<li><code>避免“接口误用”，可以导入新类型进行限制</code>
比如设计一个Date类，参数传递就可能出错，如下所示：
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Date</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">month</span><span class="p">,</span><span class="kt">int</span> <span class="n">day</span><span class="p">,</span><span class="kt">int</span> <span class="n">year</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>实际使用时，使用者可能写出<code>Date date(30,4,2021)</code>;这样的错误代码，如何防范呢？
方法之一：封装出Month,Day,Year这3个Struct/Class，作为参数入参，并<strong>添加月份限制</strong>，代码：
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Month</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Month</span> <span class="n">Jan</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Month</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span> <span class="c1">// ...省略其他11个月份
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">Month</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">m</span><span class="p">){}</span> <span class="c1">//可被class-static调用，不能被外部调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Day</span> <span class="p">{</span><span class="k">explicit</span> <span class="nf">Day</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span><span class="n">day</span><span class="p">(</span><span class="n">d</span><span class="p">){}</span>    <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>  <span class="c1">//省略 struct Year定义，和Day类似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Date</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Date</span><span class="p">(</span><span class="k">const</span> <span class="n">Month</span><span class="o">&amp;</span> <span class="n">month</span><span class="p">,</span><span class="k">const</span> <span class="n">Day</span><span class="o">&amp;</span> <span class="n">day</span><span class="p">,</span><span class="k">const</span> <span class="n">Year</span><span class="o">&amp;</span> <span class="n">year</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>最终客户代码使用的情况如下：
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Date</span> <span class="nf">date</span><span class="p">(</span><span class="n">Month</span><span class="o">::</span><span class="n">Jan</span><span class="p">(),</span><span class="n">Day</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span><span class="n">Year</span><span class="p">(</span><span class="mi">2022</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><pre><code>  C++11 支持对枚举的强化，即类型安全的`enum class`，它不能隐式地转换为整数；也无法与整数数值做比较。此处可以考虑定义一个MonthEm来代替Month：
  ```c++
  enum  class MonthEm {
  Jan = 1,
  Feb = 2, //... 省略其它的月份定义
  };
  // 修改Date的构造函数，MonthEm来代替Month
  Date(const MonthEm&amp; monthEm, const Day&amp; day, const Year&amp; year) {}
  // 构造对象
  Date date2(MonthEm::Feb, Day(23), Year(2021));
  ```
</code></pre>
</div>
    </div>
  </div></li>
<li><code>限制类型内什么事是可不可做的</code>
常见操作是加上const限制，比如“以const 修饰operator * 的返回类型”可以阻止这个错误：
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//本意是想做比较，写成了赋值，但是赋给const，报错！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>智能指针传入删除器可避免&quot;Cross-dll-problem&quot;</code>
std::shared_ptr管理资源时，传入删除器，可避免在A-Dll中new，结果在另一个B-Dll中delete的情况，这会导致Runtime-Error。</li>
</ul>
<h3 id="r19-设计class犹如设计type">R19 设计Class犹如设计Type</h3>
<p>设计一个优秀的Class并不容易，很多C++书籍都像本书一样提到“Check-Table”，设计Class/Type前，问自己一些重要问题：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？</li>
<li>对象的初始化和赋值该有什么差别？</li>
<li>新type的对象如果值传递(pass-by-value)，意味着什么？
copy构造函数用来定义一个type的值传递具体实现。</li>
<li>什么是新type的“合法值”？
想清楚约束条件，特别是构造函数、赋值操作符以及<strong>setter</strong>函数，涉及的错误检查与非法值拦截。</li>
<li>新type需要配合某个继承图谱吗？
如果继承自某Base类，那么就会收到virtual,non-virtual函数的约束；如果要做后续类的基类，则该type就要注意<strong>虚析构</strong>的设计。</li>
<li>新type涉及什么样的转换？
与其他type之间如有转换需求，则需要自行实现相关函数，可参考<code>Rule15</code>。</li>
<li>新type需要怎样的操作符和函数？
确定哪些是member函数，哪些不是。参考<code>Rule23</code>，<code>Rule24</code>，<code>Rule26</code>。</li>
<li>是否有需要立即驳回的标准函数？
比如<strong>是否禁止</strong>copy构造，copy-assignment操作符等函数，可以声明为private；或者使用C++新特性&quot;=delete&quot;。参考<code>Rule6</code>。</li>
<li>新type成员的访问属性控制？
成员变量都应为private，考虑其他member函数该为private/public/protected。以及启用友元friend的考虑。</li>
<li>什么是新type的“未声明接口”?
参考<code>Rule29</code>。</li>
<li>新type有多么一般化？
如果是一般化的问题处理，该考虑是否该定义Class-Template。</li>
<li>真的需要一个新type吗？</li>
</ul>
<h3 id="r20-以pass-by-reference-to-const代替pass-by-value">R20 以pass-by-reference-to-const代替pass-by-value</h3>
<ul>
<li>尽量以pass-by-reference-to-const代替pass-by-value
前者通常更<strong>高效</strong>，并可<strong>避免“对象切割”问题</strong>。
如果对象入参以值传递，就会在入参时创建临时对象，函数完成后临时对象析构，涉及构造函数和析构函数的调用，这些都可能是不小的开销！
<code>如果是以const reference形式，则不会有任何构造/析构的开销</code>。const的作用是让使用者放心，不会改变入参的值。
“对象切割&quot;问题：
如果是值传递，Derived-Obj传递给Base-Param，会丢失Derived独有的特性，只保留Base的那部分。</li>
<li>对于C++内置类型，值传递往往更高效
从C++编译器的底层实现角度来看，references引用往往是以指针的形式实现。所以如果是内置数据类型，比如int类型 ，直接值传递反而效率更高。
<blockquote>
<p>此规则还适用于STL迭代器和函数对象。</p>
</blockquote>
</li>
</ul>
<h3 id="r21-必须返回对象时不要随意返回reference">R21 必须返回对象时，不要随意返回reference</h3>
<p><strong>不要返回指针或引用指向以下对象</strong>:</p>
<ul>
<li>局部栈对象(local stack)
函数内部新建的栈变量对象，出了函数就面临消亡，仍持有它的引用/指针，是典型的未定义行为。</li>
<li>堆分配对象(heap allocated)
内部new，然后return出去使用，一来会增加外部delete的负担，二来可能delete的机会都没有。代码如下：
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Rational</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rational</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="n">lhs</span><span class="p">.</span><span class="n">d</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如下使用连乘，则没有delete的机会
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Rational</span> <span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">w</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// 内存泄漏！！！
</span></span></span></code></pre></td></tr></table>
</div>
</div>上述代码返回的是引用，返回指针也是一样的负作用。</li>
<li>局部static对象(local static)
函数内部的static对象，只初始化一次，且只有一份，有记忆功能，可以被更新。那么下述代码就会出现问题：
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">Rational</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">result</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="n">lhs</span><span class="p">.</span><span class="n">d</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="c1">//在调用者看来，因为是引用，永远只看到独一份的result的“最新值 ”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 下方的比较永远都是true，永远走if分支  ！！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Rational</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">((</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//乘积相等，走if分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//乘积不相等，走else分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><blockquote>
<p>那是不是永远不能以reference作为返回值呢 ？
当然不是，*this可以返回其引用，参考Rule10；或者类成员作为返回值时，可以返回其引用，但最好是const。</p>
</blockquote>
</div>
    </div>
  </div>
<h3 id="r22-将成员变量声明为private">R22 将成员变量声明为private</h3>
<ul>
<li>
<p>成员变量为private获得的好处</p>
<ol>
<li>客户访问数据的一致性。都是用getter函数（需要加括号），而不是混用函数获取和直接访问；</li>
<li>细化成员变量的访问权限。根据是否有getter、setter函数可以精准控制read/write/none这样的细化。</li>
<li>保持实现弹性。比如获取某系统指标，可以在getter函数中修改各种灵活的策略和算法，而调用者感知不到。</li>
<li>封装性。封装性是指☞ <code>越多函数可以访问该数据，封装性越低</code>。
客户调用端感知不到class内部的实现，这些确实也是不必暴露的。并且，如果是要修改某个变量，使用setter函数也更方便调试，不至于被随意修改。</li>
</ol>
</li>
<li>
<p>protected和public差不多，都不具备封装性
如果某个public/protected变量权限被取消（比如改为private），将会导致大面积的编译错误，能访问的变成unaccessible，需要对应修改许多代码。</p>
</li>
</ul>
<h3 id="r23-宁可用non-membernon-friend代替member函数">R23 宁可用non-member,non-friend代替member函数</h3>
<ul>
<li>实际上，non-member/non-friend函数具有更大的封装性
考虑下述一个类WebBrowser，member函数和non-member函数，实际上，<strong>member函数</strong>WebBrowser::clearEverything具有其他private数据的访问权限，<strong>封装性是更差的</strong>！
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">WebBrowser</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">clearCache</span><span class="p">()</span> <span class="p">{</span><span class="cm">/*to clear cache*/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">clearHistory</span><span class="p">()</span> <span class="p">{</span><span class="cm">/*to clear history*/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">removeCookies</span><span class="p">()</span> <span class="p">{</span><span class="cm">/*to clear cookies*/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">clearEverything</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">clearCache</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">clearHistory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">removeCookies</span><span class="p">();}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">clearBrowser</span><span class="p">(</span><span class="n">WebBrowser</span> <span class="o">&amp;</span><span class="n">wb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">wb</span><span class="p">.</span><span class="n">clearCache</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">wb</span><span class="p">.</span><span class="n">clearHistory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">wb</span><span class="p">.</span><span class="n">removeCookies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>工程结构安排
对于上述WebBrowser的例子，non-member函数放哪里呢，除了可以是其他class的member函数，更适用自然的答案是用<code>namespace包裹起来</code>。代码如下：
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">WebBrowserStuff</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">WebBrowser</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">clearBrowser</span><span class="p">(</span><span class="n">WebBrowser</span> <span class="o">&amp;</span><span class="n">wb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>注意：<code>namespace可以跨越多个源码文件，而class不能</code>。
<strong>通常的组织方式</strong>：多个.h头文件都使用同一个namespace，管理不同的功能模块。除了让模块更清晰，还能降低不必要的编译依赖关系。</li>
<li>对于private数据，member和friend函数具有相同的访问权限
基于此，这里讨论的封装性不在于member与否，而是member和non-member ，non-friend函数之间。</li>
</ul>
<h3 id="r24-若所有参数皆需类型转换请采用non-member">R24 若所有参数皆需类型转换，请采用non-member</h3>
<p>标题需明晰：所有参数，是指<strong>包含了被this指针所指向的那个隐含参数</strong>（non-explicit构造函数调用隐式类型转换时）。</p>
<p><strong>应对具体场景</strong>：构造函数允许隐式类型转换，且需要这个构造好的对象立即调用某member函数foo(比如operator函数)，此时这个foo函数应该改为non-member的foo函数。</p>
<p>考虑一个有理数类Rational，允许隐式类型转换构造（即non-explicit），如果<code>operator*</code>是member函数则会出现问题。Rational类实现代码示例如下：</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rational</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Rational</span><span class="p">(</span><span class="kt">int</span> <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span><span class="n">numerator_</span><span class="p">(</span><span class="n">numerator</span><span class="p">),</span> <span class="n">denominator_</span><span class="p">(</span><span class="n">denominator</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Rational</span> <span class="k">operator</span><span class="o">*</span> <span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">Rational</span><span class="p">(</span><span class="n">numerator_</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">numerator_</span><span class="p">,</span> <span class="n">denominator_</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">denominator_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">numerator</span><span class="p">()</span><span class="k">const</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">numerator_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">denominator</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">denominator_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">numerator_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">denominator_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码存在一个问题，就是不能混合运算，举例如下：</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Rational</span> <span class="nf">rat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Rational</span> <span class="n">rat3Tm</span> <span class="o">=</span> <span class="n">rat</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>   <span class="c1">//能成功调用member-operator*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Rational</span> <span class="n">rat3Tm2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">rat</span><span class="p">;</span>  <span class="c1">//编译报错！！！ 本节的场景就在于此.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果要让这种混合运算无障碍，把<code>operator*</code>函数改成non-member即可，注意要<strong>删掉原来member内的<code>operator*</code></strong>，不能同时存在这2个operator*。</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rational</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//... 注意，要删除类内的member函数operator*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Rational</span> <span class="k">operator</span><span class="o">*</span> <span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">Rational</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">()</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="n">lhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">()</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="r25-考虑写一个不抛异常的swap函数">R25 考虑写一个不抛异常的swap函数</h3>
<ul>
<li>当 std::swap对某个类型效率不高时，提供一个swap成员函数，且该swap不抛异常
先看一下效率不高的std::swap实现：
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">//std::swap的典型实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//置换 a 和 b 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">T</span> <span class="nf">temp</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">//若T是class，此处调用copy构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>       <span class="c1">//若T是class，此处调用copy assignment操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>考虑这样的使用场景：需要swap一个&quot;pimpl手法”(pointer to implementation)实现的类，这种传统的std::swap必然是效率不高(深复制impl类的数据耗时较长)。
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">WidgetSwImpl</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> <span class="c1">//很大的vector,意味着复制时间很长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">WidgetSw</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">WidgetSw</span><span class="p">(</span><span class="n">WidgetSwImpl</span><span class="o">*</span> <span class="n">pImpl</span><span class="p">)</span> <span class="o">:</span><span class="n">pImpl_</span><span class="p">(</span><span class="n">pImpl</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">WidgetSw</span><span class="p">(</span><span class="k">const</span> <span class="n">WidgetSw</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*其他copy&amp;initial操作*/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">WidgetSw</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">WidgetSw</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">pImpl_</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">WidgetSw</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//public-member函数swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>   <span class="c1">//令std::swap在此函数可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span><span class="n">pImpl_</span><span class="p">,</span><span class="n">other</span><span class="p">.</span><span class="n">pImpl_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">WidgetSwImpl</span><span class="o">*</span> <span class="n">pImpl_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>调用时代码如下：
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">WidgetSw</span> <span class="nf">wSw1</span><span class="p">(</span><span class="k">new</span> <span class="n">WidgetSwImpl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">WidgetSw</span> <span class="nf">wSw2</span><span class="p">(</span><span class="k">new</span> <span class="n">WidgetSwImpl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">wSw1</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">wSw2</span><span class="p">);</span> <span class="c1">//成功运行
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果提供了member swap，需提供一个non-member的swap调用前者
注意，其实上述swap成员函数使用起来不算直观和统一，可以全特化std::swap让使用更直观方便，代码如下：
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">swap</span><span class="o">&lt;</span><span class="n">WidgetSw</span><span class="o">&gt;</span><span class="p">(</span><span class="n">WidgetSw</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">WidgetSw</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 客户端应用代码可以如下调用
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意，不应该，也没必要加 std::，会限制编译器只使用std命名空间的swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">swap</span><span class="p">(</span><span class="n">wSw1</span><span class="p">,</span><span class="n">wSw2</span><span class="p">);</span><span class="c1">//编译器会优先挑中全特化版本的std::swap
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果是Class-Template，则不要特化std命名空间的swap，而是移到其它命名空间
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">WidgetStuff</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">WidgetSw</span><span class="p">{</span> <span class="cm">/*省略类定义*/</span><span class="p">}</span> <span class="c1">// 类内含有swap成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">WidgetSw</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">WidgetSw</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Notice<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>std命名空间的函数不要尝试重载，也不要增加任何新东西</li>
<li>C++只允许对<code>Class-Template</code>直接偏特化，不能对<code>Function-Template</code>偏特化(函数模板可以通过重载间接实现“偏特化”的作用)</li>
<li><strong>成员版swap绝对不要抛出异常</strong>，非成员swap可以(因为成员swap的一个最好应用就是提供异常安全性)</li>
</ul>
</div>
    </div>
  </div></li>
</ul>
<p>ref:</br>
[1]. <a href="https://blog.csdn.net/cltcj/category_12098441.html"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://kissingfire123.github.io/2022/01/11_effective-c-%e4%b9%8b%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93%e4%ba%8c/"target="_blank" rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2022/01/11_effective-c-%e4%b9%8b%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93%e4%ba%8c/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
]]></description></item><item><title>Effective STL [30] | 确保目标区间足够大</title><link>https://jianye0428.github.io/posts/clause_30/</link><pubDate>Sat, 19 Aug 2023 15:32:43 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_30/</guid><description><![CDATA[<p>STL容器在被添加时（通过insert、push_front、push_back等）自动扩展它们自己来容纳新对象。</p>
<h2 id="插入数据">插入数据</h2>
<p><strong>尾部插入 back_inserter</strong></p>
<p>当你想向容器中插入对象但并没有告诉STL他们所想的时，问题出现了:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">transmogrify</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 自定义的这个函数从x产生一些新值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把数据放入values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify应用于values中的每个对象
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把这个返回的values附加到results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这段代码有bug！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>transform被告知它的目的区间是从<code>results.end()</code>开始的，所以那就是开始写在values的每个元素上调用<code>transmogrify</code>的结果的地方。</p>
<p>就像所有使用目标区间的算法，<code>transform</code>通过对目标区间的元素赋值的方法写入结果，<code>transform</code>会把<code>transmogrify</code>应用于<code>values[0]</code>并把结果赋给<code>*results.end()</code>。</p>
<p>然后它会把<code>transmogrify</code>应用于<code>value[1]</code>并把结果赋给<code>*(results.end()+1)</code>。</p>
<p>那只能带来灾难，因为在<code>*results.end()</code>没有对象，<code>*(results.end()+1)</code>也没有！因为<code>transform</code>并没有在尾部创造新的对象。</p>
<p>调用<code>transform</code>是错误的，因为它会给不存在的对象赋值。</p>
<p><strong>正确做法</strong></p>
<p>把<code>transform</code>的结果放入<code>results</code>容器的结尾的方式是调用<code>back_inserter</code>来产生指定目标区间起点的迭代器:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify应用于values中的每个对象，在results的结尾插入返回的values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在内部，<code>back_inserter</code>返回的迭代器会调用<code>push_back</code>，所以你可以在任何提供<code>push_back</code>的容器上使用<code>back_inserter</code>(也就是任何标准序列容器: <code>vector</code>、<code>string</code>、<code>deque</code>和<code>list</code>)。</p>
<p><strong>前端插入 front_inserter</strong></p>
<p>如果你想让一个算法在容器的前端插入东西，你可以使用<code>front_inserter</code>。</p>
<p>在内部，<code>front_inserter</code>利用了<code>push_front</code>，所以<code>front_insert</code>只和提供那个成员函数的容器配合(也就是<code>deque</code>和<code>list</code>):</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// results现在是list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 在results前端   以反序   插入transform的结果
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为<code>front_inserter</code>用<code>push_front</code>把每个对象添加到<code>results</code>，<code>results</code>中的对象顺序会和<code>values</code>中对应的对象顺序相反。</p>
<p><code>vector</code>不提供<code>push_front</code>，所以<code>front_inserter</code>不能用于<code>vector</code>。</p>
<p><strong>同序插入</strong></p>
<p>如果你要<code>transform</code>把输出结果放在<code>results</code>前端，但你也要输出和<code>values</code>中对应的对象顺序相同，只要以相反的顺序迭代<code>values</code>:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在results前端 插入transform的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 保持相对的对象顺序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>任意位置插入 inserter</strong></p>
<p><code>front_inserter</code>让你强制算法在容器前端插入它们的结果，<code>back_inserter</code>让你告诉它们把结果放在容器后端，有点惊人的是<code>inserter</code>允许你强制算法把它们的结果插入容器中的任意位置:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同上，除了现在在调用transform前 results已经有一些数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify的结果插入results的中间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">inserter</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="插入效率">插入效率</h2>
<p>不管你是否使用了<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>，<code>transform</code>会对目的区间每次写入一个值，你无法改变。</p>
<p>当你要插入的容器是<code>vector</code>或<code>string</code>时，你可以最小化这个代价，<strong>预先调用<code>reserve</code></strong>。</p>
<p>你仍然要承受每次发生插入时移动元素的开销，但至少你避免了重新分配容器的内在内存:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 确定results至少还能装得下values.size()个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上，但results没有任何重新分配操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">inserter</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当使用<code>reserve</code>来提高一连串插入的效率时，总是应该记住<code>reserve</code><strong>只增加容器的容量：容器的大小仍然没有改变</strong>。</p>
<p>即使调用完<code>reserve</code>，当你想要让容器把新元素加入到<code>vector</code>或<code>string</code>时，你也必须对算法使用插入迭代器(比如，从<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>返回的迭代器之一)，因为赋值只在两个对象之间操作时有意义，而不是在一个对象和一块原始的比特之间。</p>
<p>第一个例子正确的写法:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify的结果写入results的结尾，处理时避免了重新分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="p">,</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="覆盖原始数据">覆盖原始数据</h2>
<p>有时候你要覆盖现有容器的元素而不是插入新的。</p>
<p><strong>当这种情况时，你不需要插入迭代器，但你仍然需要按照本条款的建议来确保你的目的区间足够大。</strong></p>
<p>假设你让<code>transform</code>覆盖<code>results</code>的元素。如果<code>results</code>至少有和<code>values</code>一样多的元素，那很简单。如果没有， 你也必须使用<code>resize</code>来确保它有。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 确保results至少和values一样大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl"> <span class="n">results</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 覆盖values.size()个 results的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者你可以清空results然后用通常的方式使用插入迭代器:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 销毁results中的所有元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">results</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 保留足够空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transform地返回值// 放入results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>无论何时你使用一个要求指定目的区间的算法，确保目的区间已经足够大或者在算法执行时可以增加大小。</p>
<p>如果你选择增加大小，就使用插入迭代器，比如<code>ostream_iterators</code>或从<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>返回的迭代器。</p>
]]></description></item><item><title>Effective STL [28] | 了解如何通过reverse_iterator的base得到iterator</title><link>https://jianye0428.github.io/posts/clause_28/</link><pubDate>Thu, 17 Aug 2023 20:04:40 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_28/</guid><description><![CDATA[<h2 id="example">Example</h2>
<p>通过reverse_iterator的base初始化一个iterator:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 参见条款14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="err">；</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 向vector插入1到5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">ri</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 使ri指向3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 使i和ri的base一样
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>执行上述代码后，可以想到产生的结果就像这样:</p>
<p></p>
<p>上图显示了<code>reverse_iterator</code>和它对应的<code>base iterator</code>之间特有的偏移量，就像<code>rbegin()</code>和<code>rend()</code>与相关的<code>begin()</code>和<code>end()</code>一样，但是它并没有解释怎样在<code>ri</code>上实现你在i上想要完成的操作。</p>
<p>正如条款26解释的，有些容器的成员函数只接受<code>iterator</code>类型的参数，所以如果你想要在<code>ri</code>所指的位置插入一个新元素，你不能直接这么做，因为<code>vector</code>的<code>insert</code>函数不接受<code>reverse_iterator</code>。</p>
<p>如果你想要删除ri所指位置上的元素也会有同样的问题。<code>erase</code>成员函数会拒绝<code>reverse_iterator</code>，坚持要求<code>iterator</code>。</p>
<h2 id="reverse_iterator转换成iterator">reverse_iterator转换成iterator</h2>
<p>为了完成删除和一些形式的插入操作，你必须先通过base函数将reverse_iterator转换成iterator，然后用iterator来完成工作。</p>
<p><strong>插入操作</strong></p>
<p>假设你要在ri指出的位置上把一个新元素插入v。假设你要插入的值是99。</p>
<p>**ri在上图中遍历的顺序是自右向左，而且插入操作会将新元素插入到ri位置，并且将原先ri位置的元素移到遍历过程的“下一个”位置，我们认为3应该出现在99的左侧。**插入操作之后，v看起来像这样:</p>
<p></p>
<p>我们不能用<code>ri</code>来指定插入的地方，因为它不是一个<code>iterator</code>。我们必须用<code>i</code>来代替。如上所述，当<code>ri</code>指向3时，<code>i</code>（就是<code>ri.base()</code>）指向4。</p>
<p>如果我们用<code>ri</code>来指定插入位置，那么用i指向插入位置，那个假设就是正确的。</p>
<p><strong>结论</strong></p>
<blockquote>
<p>要实现在一个reverse_iterator ri指出的位置上插入新元素，在ri.base()指向的位置插入就行了。
对于insert操作而言，ri和ri.base()是等价的，而且ri.base()真的是ri对应的iterator。</p>
</blockquote>
<p><strong>删除操作</strong></p>
<p>如果你要删除ri指向的元素，你不能直接使用i了，因为i与ri不是指向同一个元素。因此，你要删除的是i的前一个元素。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 向v插入1到5，同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vecot</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">ri</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 同上，ri指向3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="o">--</span><span class="n">ri</span><span class="p">.</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 尝试删除ri.base()前面的元素；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 对于vector，一般来说编译不通过
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>--ri.base()</code>确实能够指出我们需要删除的元素。而且，它们能够处理除了<code>vector</code>和<code>string</code>之外的其他所有容器。</p>
<p>它可能也能处理vector和string，但对于大多数vector和string的实现，它无法通过编译。</p>
<p>在这样的实现下，<code>iterator</code>(和<code>const_iterator</code>)会采用内建的指针来实现，所以<code>ri.base()</code>的结果是一个指针。</p>
<p><strong>原因剖析</strong></p>
<p>C和C++都规定了不能直接修改函数返回的指针，所以在string和vector的迭代器是指针的STL平台上，像<code>--ri.base()</code>这样的表达式无法通过编译。</p>
<p>要移植从一个由<code>reverse_iterator</code>指出的位置删除元素时，你应该尽量避免修改base的返回值。</p>
<p>所以，如果你不能减少调用<code>base</code>的返回值，只需要先增加<code>reverse_iterator</code>的值，然后再调用<code>base</code>！</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">((</span><span class="o">++</span><span class="n">ri</span><span class="p">).</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 删除ri指向的元素；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这下编译没问题了！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>这个方法适用于所有的标准容器，这是删除一个由reverse_iterator指出的元素时首选的技巧</strong></p>
<h2 id="结论">结论</h2>
<p><code>reverse_iterator</code>的<code>base</code>成员函数返回一个“对应的”<code>iterator</code>的说法并不准确：对于插入操作而言，的确如此; 但是对于删除操作，并非如此。</p>
<p>当需要把<code>reverse_iterator</code>转换成<code>iterator</code>的时候，有一点非常重要的是你必须知道你准备怎么处理返回的<code>iterator</code>，因为只有这样你才能决定你得到的<code>iterator</code>是否是你需要的。</p>
]]></description></item><item><title>Transformer 详解</title><link>https://jianye0428.github.io/posts/transformerdetailedexplanation/</link><pubDate>Mon, 24 Jul 2023 17:37:50 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/transformerdetailedexplanation/</guid><description><![CDATA[<h2 id="transformer-详解">Transformer 详解</h2>
<p>Transformer 是谷歌大脑在 2017 年底发表的论文 <a href="https://arxiv.org/pdf/1706.03762.pdf"target="_blank" rel="external nofollow noopener noreferrer">attention is all you need<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 中所提出的 seq2seq 模型。现在已经取得了大范围的应用和扩展，而 BERT 就是从 Transformer 中衍生出来的预训练语言模型</p>
<p>这篇文章分为以下几个部分</p>
<ul>
<li>Transformer 直观认识</br></li>
<li>Positional Encoding</br></li>
<li>Self Attention Mechanism</br></li>
<li>残差连接和 Layer Normalization</br></li>
<li>Transformer Encoder 整体结构</br></li>
<li>Transformer Decoder 整体结构</br></li>
<li>总结</br></li>
<li>参考文章</br></li>
</ul>
<h3 id="0-transformer-直观认识">0. Transformer 直观认识</h3>
<p>Transformer 和 LSTM 的最大区别，就是 <font color=green>LSTM 的训练是迭代的、串行的，必须要等当前字处理完，才可以处理下一个字</font>。而 Transformer 的训练时<strong>并行</strong>的，即所有字是同时训练的，这样就大大增加了计算效率。<font color=green>Transformer 使用了位置嵌入 (Positional Encoding) 来理解语言的顺序</font>，使用自注意力机制(Self Attention Mechanism)和全连接层进行计算，这些后面会讲到。</p>
<p>Transformer 模型主要分为两大部分，分别是 Encoder 和 Decoder。<font color=red>Encoder 负责把输入(语言序列)映射成隐藏层(下图中第 2 步用九宫格代表的部分)，然后解码器再把隐藏层映射为自然语言序列</font>。例如下图机器翻译的例子(Decoder 输出的时候，是通过 N 层 Decoder Layer 才输出一个 token，并不是通过一层 Decoder Layer 就输出一个 token)。</p>
<p></p>
<p>本篇文章大部分内容在于解释 Encoder 部分，即把自然语言序列映射为隐藏层的数学表达的过程。理解了 Encoder 的结构，再理解 Decoder 就很简单了</p>
<p></p>
<p>上图为 Transformer Encoder Block 结构图，注意：下面的内容标题编号分别对应着图中 1,2,3,4 个方框的序号</p>
<h3 id="1-positional-encoding">1. Positional Encoding</h3>
<p>由于 Transformer 模型没有循环神经网络的迭代操作，所以我们必须提供每个字的位置信息给 Transformer，这样它才能<font color=red>识别出语言中的顺序关系</font>。</p>
<p>现在定义一个<strong>位置嵌入</strong>的概念，也就是 Positional Encoding，位置嵌入的维度为 [max_sequence_length, embedding_dimension], 位置嵌入的维度与词向量的维度是相同的，都是 embedding_dimension。max_sequence_length 属于超参数，指的是限定每个句子最长由多少个词构成</p>
<p>注意，我们一般以字为单位训练 Transformer 模型。首先初始化字编码的大小为 [vocab_size, embedding_dimension]，vocab_size 为字库中所有字的数量，embedding_dimension 为字向量的维度，对应到 PyTorch 中，其实就是 nn.Embedding(vocab_size, embedding_dimension)</p>
<p>论文中使用了 sin 和 cos 函数的线性变换来提供给模型位置信息:</p>
<p>$$\left{\begin{aligned}
PE(pos, 2i) = \sin (pos/10000^{2i/d_{model}}) \cr
PE(pos, 2i + 1) = \cos (pos/10000^{2i/d_{model}}) \cr
\end{aligned}\right.$$</p>
<p>上式中 $pos$ 指的是一句话中某个字的位置，取值范围是 $[0, \text{max _ sequence_ length}]$ ， $i$ 指的是字向量的维度序号，取值范围是 $[0, \text{embedding_ dimension} / 2]$ ， $d_{model}$ 指的是 embedding_dimension​的值</p>
<p>上面有 sin 和 cos 一组公式，也就是对应着 embedding_dimension 维度的一组奇数和偶数的序号的维度，例如 0,1 一组，2,3 一组，分别用上面的 sin 和 cos 函数做处理，从而产生不同的周期性变化，而位置嵌入在 embedding_dimension​维度上随着维度序号增大，周期变化会越来越慢，最终产生一种包含位置信息的纹理，就像论文原文中第六页讲的，位置嵌入函数的周期从 $ 2\pi $ 到 $10000 * 2 \pi$ 变化，而每一个位置在 embedding_dimension ​维度上都会得到不同周期的 $ \sin $ 和 $ \cos $ 函数的取值组合，从而产生独一的纹理位置信息，最终使得模型学到<strong>位置之间的依赖关系和自然语言的时序特性</strong>。</p>
<p>如果不理解这里为何这么设计，可以看这篇文章 <a href="https://wmathor.com/index.php/archives/1453/"target="_blank" rel="external nofollow noopener noreferrer">Transformer 中的 Positional Encoding<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>下面画一下位置嵌入，纵向观察，可见随着 embedding_dimension​序号增大，位置嵌入函数的周期变化越来越平缓</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
</span></span><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">math</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">get_positional_encoding</span><span class="p">(</span><span class="n">max_seq_len</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 初始化一个positional encoding</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># embed_dim: 字嵌入的维度</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># max_seq_len: 最大的序列长度</span>
</span></span><span class="line"><span class="cl">        <span class="n">positional_encoding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">            <span class="p">[</span><span class="n">pos</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">embed_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_seq_len</span><span class="p">)])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">positional_encoding</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">positional_encoding</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># dim 2i 偶数</span>
</span></span><span class="line"><span class="cl">        <span class="n">positional_encoding</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">positional_encoding</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># dim 2i+1 奇数</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">positional_encoding</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">positional_encoding</span> <span class="o">=</span> <span class="n">get_positional_encoding</span><span class="p">(</span><span class="n">max_seq_len</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">embed_dim</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">positional_encoding</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&#34;Sinusoidal Function&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&#34;hidden dimension&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&#34;sequence length&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">positional_encoding</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&#34;dimension 1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">positional_encoding</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&#34;dimension 2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">positional_encoding</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&#34;dimension 3&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&#34;Sequence length&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&#34;Period of Positional Encoding&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<h3 id="2-self-attention-mechanism">2. Self Attention Mechanism</h3>
<p>对于输入的句子 $ X $，通过 WordEmbedding 得到该句子中每个字的字向量，同时通过 Positional Encoding 得到所有字的位置向量，将其相加(维度相同，可以直接相加)，得到该字真正的向量表示。第 $ t $ 个字的向量记作 $ x_t $。</p>
<p>接着我们定义三个矩阵 $ W_Q $, $ W_K $, $ W_V $，使用这三个矩阵分别对所有的字向量进行三次线性变换，于是所有的字向量又衍生出三个新的向量 $ q_t $, $ k_t $, $ v_t $。我们将所有的 $ q_t $ 向量拼成一个大矩阵，记作查询矩阵 $ Q $ ，将所有的 $ k_t $ 向量拼成一个大矩阵，记作键矩阵 $ K $  ，将所有的 $ v_t $ 向量拼成一个大矩阵，记作值矩阵 $ V $ (见下图)</p>
<p></p>
<p>为了获得第一个字的注意力权重，我们需要用第一个字的查询向量 $ q_1 $ 乘以键矩阵 $ K $(见下图)</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">                [0, 4, 2]
</span></span><span class="line"><span class="cl">    [1, 0, 2] x [1, 4, 3] = [2, 4, 4]
</span></span><span class="line"><span class="cl">                [1, 0, 1]</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>之后还需要将得到的值经过 softmax，使得它们的和为 1(见下图)</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> softmax([2, 4, 4]) = [0.0, 0.5, 0.5]</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>有了权重之后，将权重其分别乘以对应字的值向量 $ v_t $(见下图)</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    0.0 * [1, 2, 3] = [0.0, 0.0, 0.0]
</span></span><span class="line"><span class="cl">    0.5 * [2, 8, 0] = [1.0, 4.0, 0.0]
</span></span><span class="line"><span class="cl">    0.5 * [2, 6, 3] = [1.0, 3.0, 1.5]</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>最后将这些<strong>权重化后的值向量求和</strong>，得到第一个字的输出(见下图)</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">      [0.0, 0.0, 0.0]
</span></span><span class="line"><span class="cl">    + [1.0, 4.0, 0.0]
</span></span><span class="line"><span class="cl">    + [1.0, 3.0, 1.5]
</span></span><span class="line"><span class="cl">    -----------------
</span></span><span class="line"><span class="cl">    = [2.0, 7.0, 1.5]</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>对其它的输入向量也执行相同的操作，即可得到通过 self-attention 后的所有输出</p>
<p></p>
<p><strong>矩阵计算</strong></p>
<p>上面介绍的方法需要一个循环遍历所有的字$ x_t $，我们可以把上面的向量计算变成矩阵的形式，从而一次计算出所有时刻的输出</p>
<p>第一步就不是计算某个时刻的$ q_t $, $ k_t $, $ v_t $了，而是一次计算所有时刻的 $
Q $, $ K $, $ V $。计算过程如下图所示，这里的输入是一个矩阵 $ X $，矩阵第 $ t $ 行为第 $ t $ 个词的向量表示 $x_t$</p>
<p></p>
<p>接下来将 $ Q $ 和 $K_T$ 相乘，然后除以 $ \sqrt{d_k} $(这是论文中提到的一个 trick)，经过 softmax 以后再乘以 $ V $ 得到输出</p>
<p></p>
<p><strong>Multi-Head Attention</strong></p>
<p>这篇论文还提出了 Multi-Head Attention 的概念。其实很简单，前面定义的一组 $Q $, $ K $, $ V $, 可以让一个词 attend to 相关的词，我们可以定义多组 $Q $, $ K $, $ V $，让它们分别关注不同的上下文。计算 $Q $, $ K $, $ V $ 的过程还是一样，只不过线性变换的矩阵从一组 $ W^Q $, $ W^K $, $ W^V $ 变成了多组$ W^Q_0 $, $ W^K_0 $, $ W^V_0 $  ，$ W^Q_1 $, $ W^K_1 $, $ W^V_1 $ ，… 如下图所示:</p>
<p></p>
<p>对于输入矩阵 $ X $ ，每一组 $ Q $ 、$ K $ 和 $ V $ 都可以得到一个输出矩阵 $ Z $ 。如下图所示</p>
<p></p>
<p><strong>Padding Mask</strong>
</p>
<p>上面 Self Attention 的计算过程中，我们通常使用 mini-batch 来计算，也就是一次计算多句话，即 $ X $ 的维度是 <code>[batch_size, sequence_length]</code>，sequence_length​是句长，而一个 mini-batch 是由多个不等长的句子组成的，我们需要按照这个 mini-batch 中最大的句长对剩余的句子进行补齐，一般用 0 进行填充，这个过程叫做 padding</p>
<p>但这时在进行 softmax 就会产生问题。回顾 softmax 函数 $\sigma(z_i) = \frac{e^{z_i}}{\sum_K^{j=i} e^{z_j}}$，$e^0$ 是 1，是有值的，这样的话 softmax 中被 padding 的部分就参与了运算，相当于让无效的部分参与了运算，这可能会产生很大的隐患。因此需要做一个 mask 操作，让这些无效的区域不参与运算，一般是给无效区域加一个很大的负数偏置，即</p>
<p>$$
\begin{aligned}Z_{illegal}&amp;=Z_{illegal}+bias_{illegal}\cr
bias_{illegal}&amp;\to-\infty\end{aligned}
$$</p>
<h3 id="3-残差连接和-layer-normalization">3. 残差连接和 Layer Normalization</h3>
<p><strong>残差连接</strong></p>
<p>我们在上一步得到了经过 self-attention 加权之后输出，也就是$\text{Self-Attention(Q, K, V)}$，然后把他们加起来做残差连接</p>
<p>$$X_{\text{embedding}} + \text{Self-Attention(Q, K, V)}$$</p>
<p><strong>Layer Normalization</strong></p>
<p>Layer Normalization 的作用是<strong>把神经网络中隐藏层归一为标准正态分布</strong>，也就是 $i.i.d$ 独立同分布，以起到<strong>加快训练速度，加速收敛</strong>的作用</p>
<p>$$\mu_j=\frac1m\sum_{i=1}^mx_{ij}$$</p>
<p>上式以矩阵的列(column)为单位求均值；</p>
<p>$$\sigma^2_{j} = \frac{1}{m}\sum^m_{i=1}(x_{ij} - \mu_j)^2$$</p>
<p>上式以矩阵的列(column)为单位求方差</p>
<p>$$LayerNorm(x) = \frac{x_{ij} - \mu_{j}}{\sqrt{\sigma^2 + \epsilon}}$$</p>
<p>然后用每一列的每一个元素减去这列的均值，再除以这列的标准差，从而得到归一化后的数值，加 $\epsilon$ 是为了防止分母为 0。</p>
<p></p>
<p>下图展示了更多细节：输入 $x_1, x_2$ 经 self-attention 层之后变成 $z_1, z_2$，然后和输入 $x_1, x_2$ 进行残差连接，经过 LayerNorm 后输出给全连接层。全连接层也有一个残差连接和一个 LayerNorm，最后再输出给下一个 Encoder(每个 Encoder Block 中的 FeedForward 层权重都是共享的)</p>
<p></p>
<h3 id="4-transformer-encoder-整体结构">4. Transformer Encoder 整体结构</h3>
<p>经过上面 3 个步骤，我们已经基本了解了 Encoder 的主要构成部分，下面我们用公式把一个 Encoder block 的计算过程整理一下：</p>
<p>(1). 字向量与位置编码</p>
<p>$$X = \text{Embedding-Lookup(X)} + \text{Positional-Encoding}$$</p>
<p>(2). 自注意力机制</p>
<p>$$Q = Linear_{q}(X) = XW_{Q}$$
$$K = Linear_{k}(X) = XW_{K}$$
$$V = Linear_{v}(X) = XW_{V}$$
$$X_{attention} = \text{Self-Attention(Q, K, V)}$$</p>
<p>(3). self-attention 残差连接与 Layer Normalization</p>
<p>$$X_{attention} = X + X_{attention}$$
$$X_{attention} = LayerNorm(attention)$$</p>
<p>(4). 下面进行 Encoder block 结构图中的第 4 部分，也就是 FeedForward，其实就是两层线性映射并用激活函数激活，比如说 $ReLU$</p>
<p>$$X_{hidden} = Linear(ReLU(Linear(X_{attention})))$$</p>
<p>(5). FeedForward 残差连接与 Layer Normalization</p>
<p>$$X_{hidden} = X_{attention} + X_{hidden}$$
$$X_{hidden} = LayerNorm(X_{hidden})$$</p>
<p>其中
$$X_{hidden} \in \mathbb{R}^{batch_size * seq_len * embed_dim}$$</p>
<h3 id="5-transformer-decoder-整体结构">5. Transformer Decoder 整体结构</h3>
<p>我们先从 HighLevel 的角度观察一下 Decoder 结构，从下到上依次是：</p>
<ul>
<li>Masked Multi-Head Self-Attention</li>
<li>Multi-Head Encoder-Decoder Attention</li>
<li>FeedForward Network</li>
</ul>
<p>和 Encoder 一样，上面三个部分的每一个部分，都有一个残差连接，后接一个 Layer Normalization。Decoder 的中间部件并不复杂，大部分在前面 Encoder 里我们已经介绍过了，但是 Decoder 由于其特殊的功能，因此在训练时会涉及到一些细节</p>
<p></p>
<p><strong>Masked Self-Attention</strong></p>
<p>具体来说，传统 Seq2Seq 中 Decoder 使用的是 RNN 模型，因此在训练过程中输入 $t$ 时刻的词，模型无论如何也看不到未来时刻的词，因为循环神经网络是时间驱动的，只有当 $t$ 时刻运算结束了，才能看到 $t + 1$ 时刻的词。而 Transformer Decoder 抛弃了 RNN，改为 Self-Attention，由此就产生了一个问题，<font color=red>在训练过程中，整个 ground truth 都暴露在 Decoder 中</font>，这显然是不对的，我们需要对 Decoder 的输入进行一些处理，该处理被称为 Mask
</br>
举个例子，Decoder 的 ground truth 为 &ldquo;<start> I am fine&rdquo;，我们将这个句子输入到 Decoder 中，经过 WordEmbedding 和 Positional Encoding 之后，将得到的矩阵做三次线性变换 $(W_Q, W_K, W_V)$。然后进行 self-attention 操作，首先通过得到 Scaled Scores，接下来非常关键，我们要<strong>对 Scaled Scores 进行 Mask</strong>，举个例子，当我们输入 &ldquo;I&rdquo; 时，模型目前仅知道包括 &ldquo;I&rdquo; 在内之前所有字的信息，即 &ldquo;<start>&rdquo; 和 &ldquo;I&rdquo; 的信息，不应该让其知道 &ldquo;I&rdquo; 之后词的信息。道理很简单，我们做预测的时候是按照顺序一个字一个字的预测，怎么能这个字都没预测完，就已经知道后面字的信息了呢？Mask 非常简单，首先生成一个下三角全 0，上三角全为负无穷的矩阵，然后将其与 Scaled Scores 相加即可</p>
<p></p>
<p>之后再做 softmax，就能将 - inf 变为 0，得到的这个矩阵即为每个字之间的权重</p>
<p></p>
<p>Multi-Head Self-Attention 无非就是并行的对上述步骤多做几次，前面 Encoder 也介绍了，这里就不多赘述了</p>
<p><strong>Masked Encoder-Decoder Attention</strong></p>
<p>其实这一部分的计算流程和前面 Masked Self-Attention 很相似，结构一模一样，唯一不同的是这里的 K, V为 Encoder 的输出，Q 为 Decoder 中 Masked Self-Attention 的输出</p>
<p></p>
<h3 id="6-总结">6. 总结</h3>
<p>到此为止，Transformer 中 95% 的内容已经介绍完了，我们用一张图展示其完整结构。不得不说，Transformer 设计的十分巧夺天工。</p>
<p></p>
<p>下面有几个问题，是我从网上找的，感觉看完之后能对 Transformer 有一个更深的理解</p>
<p><font color=red>Transformer 为什么需要进行 Multi-head Attention？</font></p>
<ul>
<li>原论文中说到进行 Multi-head Attention 的原因是将模型分为多个头，形成多个子空间，可以让模型去关注不同方面的信息，最后再将各个方面的信息综合起来。其实直观上也可以想到，如果自己设计这样的一个模型，必然也不会只做一次 attention，多次 attention 综合的结果至少能够起到增强模型的作用，也可以类比 CNN 中同时使用多个卷积核的作用，直观上讲，多头的注意力有助于网络捕捉到更丰富的特征 / 信息</li>
</ul>
<p><font color=red>Transformer 相比于 RNN/LSTM，有什么优势？为什么？</font></p>
<ul>
<li>RNN 系列的模型，无法并行计算，因为 T 时刻的计算依赖 T-1 时刻的隐层计算结果，而 T-1 时刻的计算依赖 T-2 时刻的隐层计算结果</li>
<li>Transformer 的特征抽取能力比 RNN 系列的模型要好</li>
</ul>
<p><font color=red>为什么说 Transformer 可以代替 seq2seq？</font></p>
<ul>
<li>这里用代替这个词略显不妥当，seq2seq 虽已老，但始终还是有其用武之地，seq2seq 最大的问题在于<strong>将Encoder端的所有信息压缩到一个固定长度的向量中</strong>，并将其作为 Decoder 端首个隐藏状态的输入，来预测 Decoder 端第一个单词 (token) 的隐藏状态。在输入序列比较长的时候，这样做显然会损失 Encoder 端的很多信息，而且这样一股脑的把该固定向量送入 Decoder 端，Decoder 端不能够关注到其想要关注的信息。</li>
<li>Transformer 不但对 seq2seq 模型这两点缺点有了实质性的改进 (多头交互式 attention 模块)，而且还引入了 self-attention 模块，让源序列和目标序列首先 “自关联” 起来，这样的话，源序列和目标序列自身的 embedding 表示所蕴含的信息更加丰富，而且后续的 FFN 层也增强了模型的表达能力，并且 Transformer 并行计算的能力远远超过了 seq2seq 系列模型</li>
</ul>
<h3 id="7-参考文章">7. 参考文章</h3>
<ul>
<li><a href="http://mantchs.com/2019/09/26/NLP/Transformer/"target="_blank" rel="external nofollow noopener noreferrer">Transformer<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="http://jalammar.github.io/illustrated-transformer/"target="_blank" rel="external nofollow noopener noreferrer">The Illustrated Transformer<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="http://www.peterbloem.nl/blog/transformers"target="_blank" rel="external nofollow noopener noreferrer">TRANSFORMERS FROM SCRATCH<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://medium.com/@bgg/seq2seq-pay-attention-to-self-attention-part-2-%E4%B8%AD%E6%96%87%E7%89%88-ef2ddf8597a4"target="_blank" rel="external nofollow noopener noreferrer">Seq2seq pay Attention to Self Attention: Part 2<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<p>ref:</br>
[1]. <a href="https://www.bilibili.com/video/BV1mk4y1q7eK?p=1"target="_blank" rel="external nofollow noopener noreferrer">B站讲解视频<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://wmathor.com/index.php/archives/1438/"target="_blank" rel="external nofollow noopener noreferrer">https://wmathor.com/index.php/archives/1438/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://wmathor.com/index.php/archives/1455/"target="_blank" rel="external nofollow noopener noreferrer">Transformer的pytorch实现<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
]]></description></item><item><title>Effective STL [26] | 尽量用iterator代替const_iterator，reverse_iterator和const_reverse_iterator</title><link>https://jianye0428.github.io/posts/clause_26/</link><pubDate>Wed, 16 Aug 2023 19:06:25 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_26/</guid><description><![CDATA[<h2 id="4种迭代器">4种迭代器</h2>
<p>每个标准容器类都提供4种迭代器类型:<code>iterator</code>,<code>const_iterator</code>，<code>reverse_iterator</code>和<code>const_reverse_iterator</code></p>
<p>对于<code>container&lt;T&gt;</code>而言，<code>iterator</code>的作用相当于<code>T*</code>，而<code>const_iterator</code>则相当于<code>const T*</code>。</p>
<p>增加一个<code>iterator</code>或者<code>const_iterator</code>可以在一个从容器开头趋向尾部的遍历中让你移动到容器的下一个元素。</p>
<p><code>reverse_iterator</code>与<code>const_reverse_iterator</code>同样相当于对应的<code>T</code>和<code>const T</code>，所不同的是，增加<code>reverse_iterator</code>或者<code>const_reverse_iterator</code>会在从尾到头的遍历中让你移动到容器的下一个元素。</p>
<h2 id="vectort的insert和erase的样式">vector<T>的insert和erase的样式</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">rangeBegin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">rangeEnd</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些方法只接受<code>iterator</code>类型的参数，而不是<code>const_iterator</code>、<code>reverse_iterator</code>或<code>const_reverse_iterator</code>。总是<code>iterator</code>。</p>
<h2 id="迭代器之间存在的转换关系">迭代器之间存在的转换关系</h2>
<p></p>
<p>图中显示了从<code>iterator</code>到<code>const_iterator</code>、从<code>iterator</code>到<code>reverse_iterator</code>和从<code>reverse_iterator</code>到<code>const_reverse_iterator</code>可以进行隐式转换。</p>
<p>并且，<code>reverse_iterator</code>可以通过调用其<code>base成员函数</code>转换为<code>iterator</code>。<code>const_reverse_iterator</code>也可以类似地通过<code>base</code>转换成为<code>const_iterator</code>。</p>
<p>通过base得到的也许并非你所期待的iterator。</p>
<p>而且，<strong>没有办法从一个const_iterator转换得到一个iterator，也无法从const_reverse_iterator得到reverse_iterator</strong>。</p>
<p>所以，当你需要指出插入位置或删除的元素时，const迭代器几乎没有用。</p>
<h2 id="尽量使用iterator取代const或者reverse类型的迭代器">尽量使用iterator取代const或者reverse类型的迭代器</h2>
<ol>
<li>
<p><code>insert</code>和<code>erase</code>的一些版本要求<code>iterator</code>。如果你需要调用这些函数，你就必须产生<code>iterator</code>，而不能用<code>const</code>或<code>reverse iterators</code>。</p>
</li>
<li>
<p>不可能把<code>const_iterator</code>隐式转换成<code>iterator</code>。从一个<code>const_iterator</code>产生一个<code>iterator</code>的技术并不普遍适用，而且不保证高效。</p>
</li>
<li>
<p>从<code>reverse_iterator</code>转换而来的<code>iterator</code>在转换之后可能需要相应的调整。</p>
</li>
</ol>
<p><code>iterator</code>与<code>reverse_iterator</code>之间的选择显而易见——依赖于从前到后或从后到前的遍历。</p>
<p><strong>迭代器比较</strong></p>
<p>当在<code>iterator</code>和<code>const_iterator</code>之间作选择的时候，你有更充分的理由选择<code>iterator</code>，即使<code>const_iterator</code>同样可行而且即使你并不需要调用容器类的任何成员函数。其中的令人讨厌的原因包括<code>iterator</code>与<code>const_iterator</code>之间的比较：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// typedef可以极大地简化STL容器类和iterator的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 同一个容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ci</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 比较iterator和const_iterator
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>唯一的变化是等号的一边的类型是<code>iterator</code>，而另一边的类型是<code>const_iterator</code>。</p>
<p><strong>因为<code>iterator</code>应该在比较之前隐式的转换成<code>const_iterator</code>，真正的比较应该在两个<code>const_iterator</code>之间进行。</strong></p>
<p><strong>如果一些实现将<code>const_iterator</code>的<code>operator==</code>作为<code>const_iterator</code>的一个成员函数而不是非成员函数。</strong></p>
<p>而问题的解决之道显得非常有趣：只要像这样交换两个<code>iterator</code>的位置：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ci</span> <span class="o">==</span> <span class="n">i</span><span class="p">)...</span> <span class="c1">// 当上面比较无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>迭代器混用</strong></p>
<p>不仅是比较是否相等，只要你在同一个表达式中混用<code>iterator</code>和<code>const_iterator</code>（或者<code>reverse_iterator</code>和<code>const_reverse_iterator</code>），这样的问题就可能会出现:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 如果i与ci之间至少有三个元素...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果迭代器的类型不同，你的正确的代码可能会被错误地拒绝。</p>
<p>本例中最简单的解决方法是<strong>通过一个（安全的）映射把iterator转换为const_iterator</strong>:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 当上面的代码无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>避免这类问题的最简单的方法是减少混用不同类型的迭代器的机会。</strong></p>
]]></description></item><item><title>Effective STL [27] | 用distance和advance把const_iterator转化成iterator</title><link>https://jianye0428.github.io/posts/clause_27/</link><pubDate>Thu, 17 Aug 2023 07:54:00 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_27/</guid><description><![CDATA[<h2 id="把const_iterator转化为iterator">把const_iterator转化为iterator</h2>
<p>有些容器成员函数只接受iterator作为参数，而不是const_iterator。如果你只有一个const_iterator，要在它所指向的容器位置上插入新元素呢？</p>
<p>上一条款说并不存在从const_iterator到iterator之间的隐式转换，那该怎么办？</p>
<p>看看当你把一个const_iterator映射为iterator时会发生什么:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 方便的typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// ci是const_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// 错误！没有从const_iterator 到iterator隐式转换的途径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="nf">i</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Iter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ci</span><span class="p">));</span> <span class="c1">// 仍是个错误！不能从const_iterator 映射为iterator！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里只是以deque为例，但是用其它容器类——list、set、multiset、map、multimap甚至条款25描述的散列表容器——的结果一样。使用映射的行也许在vector或string的代码时能够编译，但这是我们马上要讨论的非常特殊的情形。</p>
<p>上述代码不能通过编译的原因在于，对于这些容器而言，<font color=red>iterator和const_iterator是完全不同的类。</font></p>
<p>在两个毫无关联的类之间进行<code>const_cast</code>映射是荒谬的，所以<code>reinterpret_cast</code>、<code>static_cast</code>甚至C风格的映射也会导致同样的结果。</p>
<p><strong>不能编译的代码对于vector和string容器来说也许能够通过编译</strong></p>
<p>那是因为通常情况下大多数实现都会采用真实的指针作为那些容器的迭代器。</p>
<p>就这种实现而言，<code>vector&lt;T&gt;::iterator</code>是<code>T*</code>的<code>typedef</code>，而<code>vector&lt;T&gt;::const_iterator</code>是<code>const T*</code>的<code>typedef</code>，<code>string::iterator</code>是<code>char</code>的<code>typedef</code>，而<code>string::const_iterator</code>是<code>const char*</code>的<code>typedef</code>。</p>
<p>在这种实现的情况下，用<code>const_cast</code>把<code>const_iterator</code>映射成<code>iterator</code>当然可以编译而且没有问题，因为<code>const_iterator</code>与<code>iterator</code>之间的<code>const_cast</code>映射被最终解释成<code>const T*</code>到<code>T*</code>的映射。但是，即使是在这种实现中，<code>reverse_iterator</code>和<code>const_reverse_iterator</code>也是真正的类，所以你仍然不能直接用<code>const_cast</code>把<code>const_reverse_iterator</code>映射成<code>reverse_iterator</code>。</p>
<p>而且这些实现通常只会在Release模式时才使用指针表示vector和string的迭代器。</p>
<p>所有这些事实表明，把const迭代器映射为迭代器是病态的，即使是对vector和string来说也时，因为移植性很值得怀疑。</p>
<h2 id="const_iterator转换为iterator">const_iterator转换为iterator</h2>
<p>有一种安全的、可移植的方法获取它所对应的iterator，而且，用不着陷入类型系统的转换。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 和以前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">IntDeque</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 让ci指向d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// 初始化i为d.begin()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 把i移到指向ci位置（但请留意下面关于为什么在它编译前要调整的原因）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要得到与const_iterator指向同一位置的iterator:</p>
<ol>
<li>将iterator指向容器的起始位置，</li>
<li>把它向前移到和const_iterator距离容器起始位置的偏移量一样的位置即可</li>
</ol>
<p>这个任务得到了两个函数模板advance和distance的帮助，它们都在<iterator>中声明:</p>
<ul>
<li>distance返回两个指向同一个容器的iterator之间的距离；</li>
<li>advance则用于将一个iterator移动指定的距离。</li>
</ul>
<p>如果<code>i</code>和<code>ci</code>指向同一个容器，那么表达式<code>advance(i, distance(i, ci))</code>会将<code>i</code>移动到与<code>ci</code>相同的位置上。</p>
<p>上述代码编译存在问题。</p>
<p>先来看看distance的定义：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_InputIterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="n">_GLIBCXX17_CONSTEXPR</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_InputIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span>
</span></span><span class="line"><span class="cl">  <span class="n">distance</span><span class="p">(</span><span class="n">_InputIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_InputIterator</span> <span class="n">__last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// concept requirements -- taken care of in __distance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">__distance</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">__iterator_category</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当遇到<code>distance</code>调用时，你的编译器需要根据使用的实参类型推断出<code>InputIterator</code>的类型。</p>
<p>再来看看我所说的不太正确的<code>distance</code>调用:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 调整i，指向ci位置
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有两个参数传递给distance，i和ci。i的类型是Iter，即<code>deque&lt;int&gt;::iterator</code>的typedef。</p>
<p>对编译器来说，这表明调用<code>distance</code>的<code>InputIterator</code>是<code>deque::iterator</code>。但<code>ci</code>是<code>ConstIter</code>，即<code>deque::const_iterator</code>的<code>typedef</code>。</p>
<p>表明那个<code>InputIterator</code>是<code>deque&lt;int&gt;::const_iterator</code>。</p>
<p><code>InputIterator</code>不可能同时有两种不同的类型，所以调用<code>distance</code>失败。</p>
<p>一般会造成一些冗长的出错信息，可能会也可能不会说明是编译器无法得出<code>InputIterator</code>是什么类型。</p>
<p>要顺利地调用<code>distance</code>，你需要排除歧义。</p>
<p>最简单的办法就是显式的指明<code>distance</code>调用的模板参数类型，从而避免编译器自己得出它们的类型:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们现在知道了怎么通过<code>advance</code>和<code>distance</code>获取<code>const_iterator</code>相应的<code>iterator</code>了。</p>
<p><strong>效率如何？</strong></p>
<p>答案很简单。<strong>取决于你所转换的究竟是什么样的迭代器。</strong></p>
<p>对于<strong>随机访问的迭代器</strong>（比如<code>vector</code>、<code>string</code>和<code>deque</code>的）而言，这是<strong>常数时间</strong>的操作。</p>
<p>对于<strong>双向迭代器</strong>（也就是，所有其它容器和包括散列容器的一些实现）而言，这是<strong>线性时间</strong>的操作。</p>
<p>因为它可能花费线性时间的代价来产生一个和<code>const_iterator</code>等价的<code>iterator</code>，并且因为如果不能访问<code>const_iterator</code>所属的容器这个操作就无法完成。</p>
<p>从这个角度出发，也许你需要重新审视你从<code>const_iterator</code>产生<code>iterator</code>的设计。</p>
<p>当处理容器时尽量用<code>iterator</code>代替<code>const</code>和<code>reverse</code>迭代器。</p>
]]></description></item><item><title>Effective STL [25] | 熟悉非标准散列容器</title><link>https://jianye0428.github.io/posts/clause_25/</link><pubDate>Wed, 16 Aug 2023 08:21:08 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_25/</guid><description><![CDATA[<p><strong>STL没有散列表。</strong></p>
<p>兼容STL的散列关联容器可以从多个来源获得，而且它们甚至有事实上的标准名字：<code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>和<code>hash_multimap</code>。在C++标准委员会的议案中，散列容器的名字是<code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>和<code>unordered_multimap</code>。</p>
<p><strong>它们在接口、能力、内在数据结构和支持操作的相关效率方面不同。</strong></p>
<p>最常见的两个来自<code>SGI</code>和<code>Dinkumware</code>，<code>STLport</code>也提供散列容器，但是<code>STLport</code>的散列容器是基于来自<code>SGI</code>的。</p>
<p>散列容器是关联容器，它们需要知道储存在容器中的对象类型，用于这些对象的比较函数，以及用于这些对象的分配器。</p>
<h2 id="散列容器声明">散列容器声明</h2>
<p>散列容器需要散列函数的说明。下面是散列容器声明：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_container</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这非常接近于散列容器的SGI声明，主要差别是SGI为HashFunction和CompareFunction提供了默认类型。</p>
<p><strong>SGI 设计举例</strong></p>
<p><code>hash_set</code>的SGI声明看起来基本上像这样：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">equa_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>SGI</code>设计的一个值得注意的方面是使用<code>equal_to</code>作为默认比较函数。<strong>这违背标准关联容器的约定——默认比较函数是less。</strong></p>
<p><code>SGI</code>的散列容器确定在一个散列容器中的两个对象是否有相同的值是通过相等测试，而不是等价。</p>
<p>因为散列关联容器，不像它们在标准中的（通常基于树）兄弟，不需要保持有序。</p>
<p><strong>Dinkumware 设计举例</strong></p>
<p>Dinkumware设计的散列容器采取一些不同的策略。它仍然允许你指定对象类型、散列函数类型、比较函数类型和分配器类型，但是<strong>它把默认的散列和比较函数移进一个单独的类似特性的叫做hash_compare的类</strong>，而且它把<code>hash_compare</code>作为容器模板的<code>HashingInfo</code>实参的默认值。</p>
<p>这是<code>Dinkumware</code>的hash_set声明（再次为演示而调整过）:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">HashingInfo</span> <span class="o">=</span> <span class="n">hash_compare</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种接口设计有趣的地方是<code>HashingInfo</code>的使用。</p>
<p><strong>容器的散列和比较函数储存在<code>HashingInfo</code>中，但HashingInfo类型也容纳了控制表中桶（bucket）最小数量，以及容器元素对桶的最大允许比率的枚举。</strong></p>
<p>当这比率被超过时，表中桶的数量就增加，而表中的一些元素需要重新散列。（SGI提供具有类似控制表中桶和表中元素对桶比率的成员函数。）</p>
<p><strong>hash_compare</strong></p>
<p><code>hash_compare</code>（HashingInfo的默认值）看起来或多或少像这样:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bucket_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// 元素对桶的最大比率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">min_buckets</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1">// 桶的最小数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 散列函数比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// 忽略一些东西，包括 CompareFunction的使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>重载<code>operator()</code>（在这里是实现散列和比较函数）是比你可以想象的更经常出现的一个策略。</p>
<p><code>Dinkumware</code>设计允许你写你自己的类似hash_compare的类（也许通过从<code>hash_compare</code>本身派生而来），而且只要你的类定义了<code>bucket_size</code>、<code>min_buckets</code>、两个<code>operator()</code>函数（一个带有一个实参，一个带有两个），加上已经省去的一些东西，就能使用它来控制Dinkumware的<code>hash_set</code>或<code>hash_multiset</code>的配置和行为。</p>
<p><code>hash_map</code>和<code>hash_multimap</code>的配置控制也相似。</p>
<h2 id="决策留给实现">决策留给实现</h2>
<p>注意不管是SGI还是Dinkumware的设计，你都能把全部决策留给实现:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 建立一个int的散列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">hash_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intTable</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要让这个可以编译，散列表必须容纳一个整数类型（例如int），因为<strong>默认散列函数一般局限于整数类型。</strong></p>
<p><strong>实现方法不同</strong></p>
<p>在后端，SGI和Dinkumware的实现方法非常不同。</p>
<ol>
<li>SGI利用常用的一个元素的单链表的指针数组（桶）组成的开放散列法。</li>
<li>Dinkumware也利用了开放散列法，但是它的设计是基于一种新颖的数据结构——由迭代器（本质是桶）的数组组成的元素双向链表，迭代器的相邻对表示在每个桶里元素的范围。</li>
</ol>
<p><strong>链表不同</strong></p>
<ol>
<li>SGI实现在<strong>单链表</strong>中储存表的元素</li>
<li>Dinkumware实现使用一个双向链表</li>
</ol>
<p><strong>迭代器种类不同</strong></p>
<ol>
<li>SGI的散列容器提供了前向迭代器，因此你得放弃进行反向迭代的能力：在SGI的散列容器中没有rbegin或者rend成员函数。</li>
<li>用于Dinkumware散列容器的迭代器是双向的，所以它们可以提供前向和反向遍历。</li>
</ol>
<p><strong>内存使用量方面不同</strong></p>
<p>SGI的设计比Dinkumware的节俭一点点。</p>
<h2 id="结论">结论</h2>
<p>虽然STL本身缺乏散列容器，兼容STL的散列容器（有不同的接口、能力和行为权衡）不难得到。就SGI和STLport的实现而言，你甚至可以免费下载得到它们。</p>
]]></description></item><item><title>Effective STL [24] | 当关乎效率时应该在map::operator[]和map-insert之间仔细选择</title><link>https://jianye0428.github.io/posts/clause_24/</link><pubDate>Tue, 15 Aug 2023 08:10:23 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_24/</guid><description><![CDATA[<h2 id="example-map插入">Example map插入</h2>
<p>假设有一个支持默认构造函数以及从一个double构造和赋值的Widget类:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设我们想建立一个从int到Widget的map，而且我们想有初始化有特定值的映射:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.67</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">45.8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0003</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>map operator[] 工作原理</strong></p>
<p>map的<code>operator[]</code>函数是个奇怪的东西。它与vector、deque和string的<code>operator[]</code>函数无关，也和内建的数组operator[]无关。</p>
<p><code>map::operator[]</code>被设计为简化“添加或更新”功能。即，给定<code>map&lt;K, V&gt; m</code>;这个表达式</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>检查键k是否已经在map里。如果不，就添加上，以v作为它的对应值。如果k已经在map里，它的关联值被更新成v。</strong></p>
<p>这项工作的原理是<code>operator[]</code>返回一个与k关联的值对象的引用。然后v赋值给所引用（<code>从operator[]</code>返回的）的对象。</p>
<p>当要更新一个已存在的键的关联值时很直接，因为已经有<code>operator[]</code>可以用来返回引用的值对象。</p>
<p>但是如果k还不在map里，<code>operator[]</code>就没有可以引用的值对象。那样的话，它使用值类型的默认构造函数从头开始建立一个，然后<code>operator[]</code>返回这个新建立对象的引用。</p>
<p>让我们再次地看看原先例子的第一部分：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>m[1]</code>是<code>m.operator[](1)</code>的简化，所以这是一个<code>map::operator[]</code>的调用。</p>
<p>这个函数必须返回一个Widget的引用，因为m 的映射类型是Widget。</p>
<p>在这里，m里面还没有任何东西，所以键1在map里没有入口。因此<code>operator[]</code>默认构造一个Widget来作为关联到1的值，然后返回到那个Widget的引用。</p>
<p>最后，Widget成为赋值目标：被赋值的值是1.50。</p>
<p>所以，下面这个语句</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>功能上等价于这个:</strong></p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 方便的 typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">IntWidgetMap</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 用键1建立新映射入口和一个默认构造的值对象；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Widget</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 赋值给值类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>现在已经很清楚为什么这种方法可能降低性能了：先默认构造一个Widget，然后我们立即赋给它新值。</strong></p>
<p><strong><code>map insert</code>更高效</strong></p>
<p>如果<strong>用想要的值构造Widget比默认构造Widget然后进行赋值显然更高效</strong>，就应该用直截了当的insert调用来替换operator[]的使用（包括它的构造加赋值）:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.50</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这与上面的那些代码有相同的最终效果，除了它<strong>通常节省了3次函数调用</strong>：</p>
<ol>
<li>一个建立临时的默认构造Widget对象</li>
<li>一个销毁那个临时的对象</li>
<li>一个对Widget的赋值操作。</li>
</ol>
<p>这些函数调用越昂贵，你通过使用map-insert代替<code>map::operator[]</code>就能节省越多。</p>
<p>上面的代码利用了每个标准容器都提供的value_type typedef。这typedef没有什么特别重要的，但对于map和multimap（以及非标准容器的hash_map和hash_multimap——参见条款25），记住它是很重要的，容器元素的类型总是某种pair。</p>
<p>之前谈及的<code>operator[]</code>被设计为简化“添加或更新”功能，而且现在我们理解了当“增加”被执行时，<code>insert</code>比<code>operator[]</code>更高效。当做更新时，情形正好相反，也就是，当一个等价的键这已经在map里时。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 使用operator[]来把k的值更新为v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 来把k的值更新为v使用insert
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)).</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="operator-与-insert-权衡">operator[] 与 insert 权衡</h2>
<p>insert的调用需要<code>IntWidgetMap::value_type</code>类型的实参（即<code>pair&lt;int, Widget&gt;</code>），所以当调用insert时，我们必须构造和析构一个那种类型的对象。那耗费了一对构造函数和析构函数，也会造成一个Widget的构造和析构，因为<code>pair&lt;int, Widget&gt;</code>本身包含了一个Widget对象，<strong>operator[]没有使用pair对象，所以没有构造和析构pair和Widget。</strong></p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>情形选择:</p>
<ol>
<li>因此出于对效率的考虑，当给<code>map</code>添加一个元素时，我们断定<code>insert</code>比<code>operator[]</code>好；</li>
<li>从效率和美学考虑，当更新已经在<code>map</code>里的元素值时<code>operator[]</code>更好。</li>
</ol>
</div>
    </div>
  </div>
<p>如果STL提供一个两全其美的函数，即，在句法上吸引人的包中的高效的“添加或更新”功能:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 如果键k不再map m中；高效地把pair(k, v)添加到m中；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 否则高效地把和k关联的值更新为v。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 返回一个指向添加或修改的pair的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">iterator</span> <span class="n">affectedPair</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，在STL内没有像这样的函数，正如下面的代码所演示的，自己写一个并不难。那些注释总结了正在做什么，而且随后的段落也提供了一些附加的解释。</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// map的类型KeyArgType和ValueArgtype是类型参数的原因请看下面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MapType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">KeyArgType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ValueArgtype</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">MapType</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">KeyArgType</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValueArgtype</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 找到k在或应该在哪里；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Ib</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果Ib指向一个pair, 它的键等价于k...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span><span class="p">(</span><span class="n">Ib</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">k</span><span class="p">,</span> <span class="n">Ib</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 更新这个pair的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Ib</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 并返回指向pair的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">Ib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">value_type</span> <span class="n">MVT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 把pair(k, v)添加到m并// 返回指向新map元素的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Ib</span><span class="p">,</span> <span class="n">MVT</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>执行一个高效的增加或更新，我们需要能<strong>找出k的值是否在map中; 如果是这样，那它在哪里; 如果不是，它该被插入哪里。</strong></p>
<p>这个工作是为<code>low_bound</code>量身定做的，所以在这里我们调用那个函数。确定lower_bound是否用我们要寻找的键找到了一个元素，我们对后半部分进行一个等价测试，一定要对map使用正确的比较函数: 通过<code>map::key_comp</code>提供的比较函数。等价测试的结果告诉我们应该进行增加还是更新。</p>
<p>如果是更新，代码很直截了当。插入分支更有趣，因为它使用了insert的“提示”形式。结构<code>m.insert(Ib，MVT(k，v))</code>“提示”了**<code>Ib</code>鉴别出了键等价于k的新元素正确的插入位置，而且保证如果提示正确，那么插入将在分摊的常数时间内发生，而不是对数时间**。在<code>efficientAddOrUpdate</code>里，我们知道Ib鉴别出了适当的插入位置，因此insert的调用被保证为是一次常数时间操作。</p>
<p><strong>KeyArgType和ValueArgType</strong></p>
<p>这个实现的一个有趣方面是<code>KeyArgType</code>和<code>ValueArgType</code>不必是储存在map里的类型。它们只需要可以转换到储存在map里的类型。</p>
<p>一个可选的方法是去掉类型参数<code>KeyArgType</code>和<code>ValueArgType</code>，改为使用<code>MapType::key_type</code>和<code>MapType::mapped_type</code>。</p>
<p>但是，如果我们那么做，<strong>在调用时我们可能强迫发生不必要的类型转换</strong>:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 别忘了Widget接受从一个double赋值：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在考虑<code>efficientAddOrUpdate</code>的调用:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设是一次更新操作，即，m已经包含键是10的元素。那样的话，上面的模板推断出<code>ValueArgType</code>是<code>double</code>，<strong>函数体直接把1.5作为double赋给与10相关的那个Widget</strong>。那是通过调用<code>Widget::operator(double)</code>完成的。</p>
<p>如果我们用了<code>MapType::mapped_type</code>作为<code>efficientAddOrUpdate</code>的第3个参数的类型，在调用时我们得把1.5转化成一个Widget，那样的话我们就得<strong>花费本来不需要的一次Widget构造（以及随后的析构）</strong>。</p>
<h2 id="结论">结论</h2>
<p>当关乎效率时应该在map::operator[]和map-insert之间仔细选择。</p>
<p><font color=red>如果你要更新已存在的map元素，operator[]更好，但如果你要增加一个新元素，insert则有优势。</font></p>
]]></description></item><item><title>Effective STL [17] | 使用“交换技巧”来修整过剩容量(仅适用于vector和string)</title><link>https://jianye0428.github.io/posts/clause_17/</link><pubDate>Tue, 08 Aug 2023 08:48:22 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_17/</guid><description><![CDATA[<blockquote>
<p>注意: 这里的容量指的是capacity</p>
</blockquote>
<p>假如有一个海选，需要从申请者中挑选一些人进入到下一轮比赛当中，我们可能会建立一个vector用来存储申请者：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Contestant</span> <span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">contestants</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>vector</code>会很快获得很多元素，你可能会将能够进入到下一轮的申请者放到 vector 的前端（可能通过 <code>partial_sort</code>或<code>partition</code>），如果没有参与到下一轮的申请者就会从vector 中删除（典型的方法就是调用 erase 的区间形式，具体见条款5）。</p>
<p>这样很好地减少了 vector 的大小，<strong>但是没有减少它的容量</strong>。</p>
<p>当然可以通过resize方法去改变，但是如果我不知道大概要多少，我只知道有一些符合我的要求，如果直接用resize可能大了很多，或者抛弃了原本符合要求的元素。所以最好有一种shrink_to_fit的方式。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">contestants</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contestants</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">contestants</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=Aqua><strong>具体工作原理：</strong></font></p>
<ol>
<li>表达式<code>vector&lt;Contestant&gt;(contestants)</code>建立一个临时<code>vector</code>，它是<code>contestants</code>的一份拷贝：<code>vector</code>的拷贝构造函数做了这个工作。<strong>vector的拷贝构造函数只分配拷贝的元素需要的内存</strong>，就是说<code>contestants</code>真实包含多少元素，就分配多少内存空间，按照<code>size()</code>的个数，而不是capicatiy个数，所以这个临时vector没有多余的容量。</li>
<li>让临时<code>vector</code>和<code>contestants</code>交换数据，这时contestants只有临时变量的修整过的容量(size)，而这个临时变量则持有了曾经在contestants中的发胀的容量(capacity)。在这里（这个语句结尾），临时vector被销毁，因此释放了以前contestants使用的内存。  收缩到合适。</li>
<li>完成收缩内存的同时，也拷贝了实际<code>size()</code>个内存，也有性能消耗。</li>
</ol>
<p><strong>TEST</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r1</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// r1 包含100个1，即100个申请者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">r1</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span> <span class="c1">// 只保留前50名申请者进入下一轮
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r1</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span> <span class="c1">// shrink to fit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>结果:</strong></p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">r1 size: <span class="m">100</span> capacity: <span class="m">100</span>
</span></span><span class="line"><span class="cl">r1 size: <span class="m">50</span> capacity: <span class="m">100</span>
</span></span><span class="line"><span class="cl">r1 size: <span class="m">50</span> capacity: <span class="m">50</span>
</span></span><span class="line"><span class="cl">r1 size: <span class="m">0</span> capacity: <span class="m">0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>string也同样适用：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contest</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>	<span class="c1">//清楚v并把它的容量变为最小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>			<span class="c1">//清楚s并把它的容量变为最小
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>另外，在swap的时候，不仅仅容器内容被交换，其迭代器、指针和引用也被交换(string除外)。因此，在发生交换后，原来的迭代器、指针和引用依然有效，并指向同样的元素——但这些元素已经在另外一个容器中。</p>
<h2 id="清空容器并减少容量到最小">清空容器并减少容量到最小</h2>
<p><strong>交换技巧的变体可以用于清除容器和减少它的容量到你的实现提供的最小值。</strong></p>
<p>可以简单地和一个默认构造的临时vector或string做个交换：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 使用v和s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 清除v而且最小化它的容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// 清除s而且最小化它的容量
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试代码：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r1</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// r1 包含100个1，即100个申请者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span> <span class="c1">// 清空 r1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">r1</span> <span class="nl">size</span><span class="p">:</span> <span class="mi">100</span> <span class="nl">capacity</span><span class="p">:</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">r1</span> <span class="nl">size</span><span class="p">:</span> <span class="mi">0</span> <span class="nl">capacity</span><span class="p">:</span> <span class="mi">0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>ref:</br>
[1]. <a href="https://blog.csdn.net/u011058765/article/details/51205757?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=3"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/u011058765/article/details/51205757?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=3<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [18] | 避免使用vector&lt;bool></title><link>https://jianye0428.github.io/posts/clause_18/</link><pubDate>Wed, 09 Aug 2023 14:39:18 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_18/</guid><description><![CDATA[<h2 id="vectorbool-问题">vector<bool> 问题</h2>
<p>作为一个STL容器，vector<bool>确实只有1个问题:</p>
<ul>
<li>它不是一个STL容器；</li>
<li>它并不容纳bool。</li>
</ul>
<h2 id="剖析">剖析</h2>
<p>一个东西要成为STL容器就必须满足所有在C++标准23.1节中列出的容器必要条件。</p>
<p>如果c是一个T类型对象的容器，且c支持operator[]，那么以下代码必须能够编译:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">T</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 无论operator[]返回什么，都可以用这个地址初始化一个T*
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>换句话说，如果你使用<code>operator[]</code>来得到Container中的一个T对象，你可以通过取它的地址而获得指向那个对象的指针。(假设T没有倔强地重载一些操作符。) 然而如果vector是一个容器，这段代码必须能够编译：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 用vector&lt;bool&gt;::operator[]返回的东西的地址初始化一个bool*
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但它不能编译。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">test_vector.cpp:154:19: error: taking address of rvalue <span class="o">[</span>-fpermissive<span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="m">154</span> <span class="p">|</span>   bool *pb <span class="o">=</span> <span class="p">&amp;</span>r2<span class="o">[</span>0<span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>                   ^
</span></span><span class="line"><span class="cl">test_vector.cpp:154:14: error: cannot convert ‘std::vector&lt;bool&gt;::reference*’ <span class="o">{</span>aka ‘std::_Bit_reference*’<span class="o">}</span> to ‘bool*’ in initialization
</span></span><span class="line"><span class="cl">  <span class="m">154</span> <span class="p">|</span>   bool *pb <span class="o">=</span> <span class="p">&amp;</span>r2<span class="o">[</span>0<span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              ^~~~~~
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              <span class="p">|</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              std::vector&lt;bool&gt;::reference* <span class="o">{</span>aka std::_Bit_reference*<span class="o">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为<code>vector&lt;bool&gt;</code>是一个伪容器，并不保存真正的bool，而是打包bool以节省空间。在一个典型的实现中，每个保存在“vector”中的“bool”占用一个单独的比特，而一个8比特的字节将容纳8个“bool”。</p>
<p>在内部，<code>vector&lt;bool&gt;</code>使用了与位域（bitfield）等价的思想来表示它假装容纳的bool。</p>
<p><font color=blue>位域也只表现为两种可能的值，但真的bool和化装成bool的位域之间有一个重要的不同：你可以创建指向真的bool的指针，但却禁止有指向单个比特的指针。</font></p>
<h2 id="实际实现">实际实现</h2>
<p>vector::operator[]返回一个对象，其行为类似于比特的引用，也称为代理对象。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">_Bvector_base</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bvector_base</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;</span>   <span class="n">_Base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_Bit_pointer</span>  <span class="n">_Bit_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_Bit_alloc_traits</span>  <span class="n">_Bit_alloc_traits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if __cplusplus &gt;= 201103L
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="k">friend</span> <span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="kt">bool</span>     <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">size_t</span>     <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">ptrdiff_t</span>     <span class="n">difference_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_reference</span>    <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="kt">bool</span>     <span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_reference</span><span class="o">*</span>    <span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">const</span> <span class="kt">bool</span><span class="o">*</span>    <span class="n">const_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_iterator</span>    <span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_const_iterator</span>   <span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">const_reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span>  <span class="n">reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Alloc</span>     <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">allocator_type</span>
</span></span><span class="line"><span class="cl">      <span class="nf">get_allocator</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="k">return</span> <span class="n">_Base</span><span class="o">::</span><span class="n">get_allocator</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_allocate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_deallocate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_S_nword</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_get_Bit_allocator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="n">reference</span>
</span></span><span class="line"><span class="cl">      <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">__n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="nf">iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_p</span>
</span></span><span class="line"><span class="cl">    <span class="o">+</span> <span class="n">__n</span> <span class="o">/</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">),</span> <span class="n">__n</span> <span class="o">%</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">const_reference</span>
</span></span><span class="line"><span class="cl">      <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">__n</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="nf">const_iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_p</span>
</span></span><span class="line"><span class="cl">        <span class="o">+</span> <span class="n">__n</span> <span class="o">/</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">),</span> <span class="n">__n</span> <span class="o">%</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码不能编译的原因很明显：<code>bool *pb = &amp;v[0]</code>右边的表达式是<code>vector&lt;bool&gt;::reference*</code>类型，不是<code>bool*</code>。</p>
<h2 id="替代品">替代品</h2>
<h3 id="1-dequebool">1. deque<bool></h3>
<p><code>deque</code>提供了几乎所有<code>vector</code>所提供的（唯一值得注意的是<code>reserve</code>和<code>capacity</code>），而<code>deque&lt;bool&gt;</code>是一个STL容器，它保存真正的<code>bool</code>值。</p>
<p><code>deque</code>内部内存不是连续的。所以不能传递<code>deque&lt;bool&gt;</code>中的数据给一个希望得到<code>bool</code>数组的<code>C API</code>。</p>
<p>条款16中用于<code>vector</code>的技术不能在<code>vector&lt;bool&gt;</code>上通过编译，因为它们依赖于能够取得指向容器中包含的元素类型的指针。</p>
<h3 id="2-bitset">2. bitset</h3>
<p><code>bitset</code>不是一个STL容器，但它是C++标准库的一部分。与STL容器不同，<strong>它的大小（元素数量）在编译期固定</strong>，因此它不支持插入和删除元素。</p>
<p>因为它不是一个STL容器，它也不支持iterator。但就像<code>vector&lt;bool&gt;</code>，<strong>它使用一个压缩的表示法，使得它包含的每个值只占用一比特。</strong></p>
<p>它提供<code>vector&lt;bool&gt;</code>特有的<code>flip</code>成员函数，还有一系列其他操作位集<code>(collection of bits)</code>所特有的成员函数。</p>
<h2 id="总结">总结</h2>
<p><code>vector&lt;bool&gt;</code>不满足STL容器的必要条件，你最好不要使用它；</p>
<p>而<code>deque&lt;bool&gt;</code>和<code>bitset</code>是基本能满足你对<code>vector&lt;bool&gt;</code>提供的性能的需要的替代数据结构。</p>
]]></description></item><item><title>Effective STL [23] | 考虑用有序vector代替关联容器</title><link>https://jianye0428.github.io/posts/clause_23/</link><pubDate>Mon, 14 Aug 2023 19:13:32 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_23/</guid><description><![CDATA[<p>当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>。</p>
<p>如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。</p>
<p>对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的<code>set</code>、<code>map</code>和它们的<code>multi</code>同事。</p>
<p>即使你需要的就只是==对数时间==查找的保证，标准关联容器仍然可能不是你的最佳选择。和直觉相反，对于标准关联容器，所提供的性能也经常劣于本该比较次的<code>vector</code>。</p>
<h2 id="关联容器数据结构">关联容器数据结构</h2>
<p>标准关联容器的典型实现是<strong>平衡二叉查找树</strong>。</p>
<p>一个平衡二叉查找树是一个对<strong>插入</strong>、<strong>删除</strong>和<strong>查找</strong>的混合操作优化的数据结构。</p>
<p>换句话说，它被设计为应用于进行一些插入，然后一些查找，然后可能再进行一些插入，然后也许一些删除，然后再来一些查找，然后更多的插入或删除，然后更多的查找等。这个事件序列的关键特征是插入、删除和查找都是混合在一起的。</p>
<p>一般来说，没有办法预测对树的下一个操作是什么。</p>
<p><strong>使用数据结构的3阶段</strong></p>
<ol>
<li><strong>建立</strong>。通过插入很多元素建立一个新的数据结构。在这个阶段，几乎所有的操作都是插入和删除。几乎没有或根本没有查找。</li>
<li><strong>查找</strong>。在数据结构中查找指定的信息片。在这个阶段，几乎所有的操作都是查找。几乎没有或根本没有插入和删除。</li>
<li><strong>重组</strong>。修改数据结构的内容，通过删除所有现有数据和在原地插入新数据。从动作上说，这个阶段等价于阶段1。一旦这个阶段完成，应用程序返回阶段2。</li>
</ol>
<h2 id="有序vector更高效">有序vector更高效</h2>
<p>一个vector可能比一个关联容器能提供更高的性能（时间和空间上都是）。</p>
<p>但不是任意的<code>vector</code>都会，只有有序vector。因为只有有序容器才能正确地使用查找算法——<code>binary_search</code>、<code>lower_bound</code>、<code>equal_range</code>等。</p>
<p>Q: 为什么一个（有序的）vector的二分法查找比一个二叉树的二分法查找提供了更好的性能？</p>
<p>A: 其中的一个是<strong>大小问题</strong>，其中的一个是<strong>引用局部性问题</strong>。</p>
<p><strong>大小问题</strong></p>
<p>假设我们需要一个容器来容纳Widget对象，而且，因为查找速度对我们很重要，我们考虑一个Widget的关联容器和一个有序<code>vector&lt;Widget&gt;</code>。</p>
<p><strong>关联容器数据结构</strong></p>
<p>如果选择一个关联容器，我们几乎确定了要使用平衡二叉树。这样的树是由树节点组成，每个都不仅容纳了一个Widget，而且保存了一个该节点到左孩子的指针，一个到它右孩子的指针，和（典型的）一个到它父节点的指针。</p>
<p>这意味着<strong>在关联容器中用于存储一个Widget的空间开销至少会是三个指针</strong>。</p>
<p><strong>vector数据结构</strong></p>
<p>与之相对的是，当在vector中存储Widget并没有开销：简单地存储一个Widget。</p>
<p>当然，<strong>vector本身有开销</strong>，在vector结尾也可能有空的（保留）空间，但是每个vector开销是可以忽略的（通常是三个机器字，比如，三个指针或两个指针和一个int），而且如果必要的话，末尾空的空间可以通过“交换技巧”去掉。即使这个附加的空间没有去掉，也并不影响下面的分析，因为当查找时不会引用那段内存。</p>
<p><strong>内存大小</strong></p>
<p>假设我们的数据结构足够大，它们可以分成多个内存页面，但是vector比关联容器需要的页面要少。</p>
<p>因为vector不需要每个Widget的开销，而关联容器给每个Widget上附加了三个指针。</p>
<p>假设在你使用的系统上一个Widget的大小是12个字节，指针是4个字节，一个内存页面是4096（4K）字节。</p>
<p>忽略每个容器的开销，当用vector保存时，你可以在一页面上放置341个Widget $(4096\div12\approx341)$，但使用关联容器时你最多只能放170个 $4096\div(12+4\times3)\approx170)$。</p>
<p><strong>因此关联容器和vector比起来，你将会使用大约两倍的内存。</strong></p>
<p>如果你使用的环境可以用<strong>虚拟内存</strong>，就很可以容易地看出那会<strong>造成大量的页面错误，因此一个系统会因为大数据量而明显慢下来</strong>。</p>
<p><strong>引用局部性问题</strong></p>
<p>假设在二叉树中的节点都群集在一个相关的小内存页面集中，实际情况下关联容器很乐观的。</p>
<p><strong>大部分STL实现使用自定义内存管理器来达到这样的群集，但是如果你的STL实现没有改进树节点中的引用局部性，这些节点会分散在所有你的内存空间。那会导致更多的页面错误。</strong></p>
<p>即使使用了自定义群集内存管理器，关联容器也会导致很多页面错误，因为，不像连续内存容器，比如vector，<strong>基于节点的容器更难保证在容器的遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个。</strong></p>
<p><strong>当进行二分查找时那种内存组织方式（译注：遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个）正好是页面错误最少的。</strong></p>
<h2 id="vector的缺点">vector的缺点</h2>
<p><font color=red>有序vector的大缺点是必须保持有序！</font></p>
<p>因为vector中所有的元素都必须拷贝，所以：</p>
<ol>
<li>
<p>当一个新元素插入时，大于这个新元素的所有东西都必须向上移一位，非常昂贵；</p>
</li>
<li>
<p>如果vector必须重新分配它的内在内存，则会更昂贵；</p>
</li>
<li>
<p>如果一个元素从vector中被删除，所有大于它的元素都要向下移动。</p>
</li>
</ol>
<p>vector的插入和删除都很昂贵，但是关联容器的插入和删除则很轻量。</p>
<p>这就是为什么只有当你知道你的数据结构使用的时候查找几乎不和插入和删除混合时，使用有序vector代替关联容器才有意义。</p>
<p><strong>概要</strong></p>
<ol>
<li>
<p>在有序vector中存储数据很有可能比在标准关联容器中保存相同的数据消耗更少的内存；</p>
</li>
<li>
<p>当页面错误值得重视的时候，在有序vector中通过二分法查找可能比在一个标准关联容器中查找更快。</p>
</li>
</ol>
<h2 id="example">Example</h2>
<blockquote>
<p>vector代替set</p>
</blockquote>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="c1">// 代替set&lt;Widget&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">vw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结束建立阶段。（当模拟一个multiset时，你可能更喜欢用stable_sort 来代替；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于查找的值的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span><span class="c1">// 开始查找阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过binary_search查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过lower_bound查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 条款19解释了“!(w &lt; *i)”测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">i</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过equal_range查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                       <span class="n">equal_range</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">)...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 结束查找阶段，开始重组阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 开始新的查找阶段...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>里面最难的东西就是<strong>怎么在搜索算法中做出选择</strong>（比如，<code>binary_search</code>、<code>lower_bound</code>等）</p>
<blockquote>
<p>vector代替map或multimap</p>
</blockquote>
<p>当你决定用vector代替map或multimap时，事情会变得更有趣，因为<strong>vector必须容纳pair对象</strong>。</p>
<p>但是要注意，如果你声明一个map&lt;K, V&gt;的对象（或者等价的multimap），保存在map中的元素类型是<code>pair&lt;const K, V&gt;</code>。</p>
<p>如果要用vector模拟<code>map</code>或者<code>multimap</code>，<strong>必须去掉const</strong>，因为当你对vector排序时，元素的值将会通过赋值移动，那意味着pair的两个组件都必须是可赋值的。</p>
<p>当使用vector来模拟map&lt;K, V&gt;时，<strong>保存在vector中数据的类型将是<code>pair&lt;K, V&gt;</code></strong>，而不是<code>pair&lt;const K, V&gt;</code>。</p>
<p>map和multimap以顺序的方式保存他们的元素，但<strong>用于排序目的时它们只作用于元素的key部分</strong>（pair的第一个组件），所以当排序vector时你必须做一样的事情。</p>
<p>你需要为你的pair写一个自定义比较函数，因为<code>pair</code>的<code>operator&lt;</code>作用于pair的两个组件。</p>
<p><strong>2个比较函数来进行查找</strong></p>
<p>用来排序的比较函数将作用于两个pair对象，但是查找只用到key值。</p>
<p>必须传给用于查找的比较函数一个key类型的对象（要查找的值）和一个pair（存储在vector中的一个pair）——两个不同的类型。</p>
<p>还有一个附加的麻烦，你不会知道key还是pair是作为第一个实参传递的，所以你真的需要两个用于查找的比较函数：<strong>一个key值先传递，一个pair先传递</strong></p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">Data</span><span class="p">;</span> <span class="c1">// 在这个例子里&#34;map&#34;容纳的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DataCompare</span> <span class="p">{</span> <span class="c1">// 用于比较的类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于排序的比较函数keyLess在下面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">keyLess</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于查找的比较函数（形式1）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">Ihs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">keyLess</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于查找的比较函数（形式2）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span>  <span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">keyLessfk</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// “真的”比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">keyLess</span><span class="p">(</span><span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">k1</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们假设有序vector将模拟<code>map&lt;string, int&gt;</code>。</p>
<p>这段代码几乎是上面讨论的字面转换，除了存在成员函数<code>keyLess</code>。</p>
<p>那个函数的存在是用来<strong>保证几个不同的<code>operator()</code>函数之间的一致性</strong>。</p>
<p>每个这样的函数只是简单地比较两个key的值，所以我们把这个测试放在keyLess中并让operator()函数返回keyLess所做的事情，这比复制那个逻辑要好。</p>
<p>这个软件工程中绝妙的动作增强了<code>DataCompare</code>的可维护性，但<strong>有一个小缺点，它提供了有不同参数类型的operator()函数，这将导致函数对象无法适配。</strong></p>
<p>把有序vector用作map本质上和用作set一样。</p>
<p><strong>唯一大的区别是必须把DataCompare对象用作比较函数:</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 代替map&lt;string, int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;</span> <span class="n">vd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结束建立阶段。（当模拟multimap时，你可能更喜欢用stable_sort来代替）；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于查找的值的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 开始查找阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过binary_search查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">()))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 再次通过lower_bound查找，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 条款45解释了“!DataCompare()(s, *i)”测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">DataCompare</span><span class="p">()(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">i</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过equal_range查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">equal_range</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">)...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 结束查找阶段，开始重组阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 开始新的查找阶段...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DataCompare</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如你所见，一旦你写了DataCompare，东西都很好地依序排列了。</p>
<p>而一旦位置合适了，它们往往比相应的使用真的map的设计运行得更快而且使用更少内存。</p>
<p>如果你的程序不是按照阶段的方式操作数据结构，那么使用有序vector代替标准关联容器几乎可以确定是在浪费时间。</p>
]]></description></item><item><title>Effective STL [21] | 永远让比较函数对相等的值返回false</title><link>https://jianye0428.github.io/posts/clause_21/</link><pubDate>Fri, 11 Aug 2023 17:11:35 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_21/</guid><description><![CDATA[<h2 id="example-set">Example set</h2>
<p>建立一个set，比较类型用<code>less_equal</code>，然后插入整型数字33(称为 $33_{A}$):</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// s以“&lt;=”排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span> <span class="c1">// 插入33
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在尝试再插入一次33(称为 $33_{B}$):</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于这个insert的调用，set必须先要判断出 $33_{A}$ 是否已经位于其中了，查找哪儿适合插入 $33_{B}$。最终，它总要检查 $33_{B}$是否与 $33_{A}$ 相同。</p>
<p>关联容器对“相同”的定义是等价，因此set测试 $33_{B}$是否等价于 $33_{A}$。</p>
<p>当执行这个测试时，它自然是使用set的比较函数。在这一例子里，是<code>operator&lt;=</code>，因为我们指定<code>set</code>的比较函数为<code>less_equal</code>，而<code>less_equal</code>意思就是<code>operator&lt;=</code>。</p>
<p>可以看看<code>less_equal</code>的源码实现：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// One of the @link comparison_functors comparison functors@endlink.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">less_equal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_GLIBCXX14_CONSTEXPR</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__y</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span> <span class="o">&lt;=</span> <span class="n">__y</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 此处是 &lt;=
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>于是，set将计算这个表达式是否为真:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="mi">33</span><span class="n">A</span> <span class="o">&lt;=</span> <span class="mi">33</span><span class="n">B</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="mi">33</span><span class="n">B</span> <span class="o">&lt;=</span> <span class="mi">33</span><span class="n">A</span><span class="p">)</span> <span class="c1">// 测试33A和33B是否等价
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>$33_{A}$ 和 $33_{B}$ 都是33，因此， $33_{A}$&lt;=$33_{B}$ 肯定为真。同样清楚的是，$33_{B}$ &lt;= $33_{A}$。于是上述的表达式简化为:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再简化就是</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果当然是false。</p>
<p>也就是说，set得出的结论是 $33_{B}$ 与 $33_{B}$ 不等价，因此不一样，于是它将 $33_{B}$ 插入容器中的旁边。</p>
<p>在技术上而言，这个做法导致未定义的行为，但是通常的结果是set以拥有了两个为33的值的拷贝而告终，也就是说它不再是一个set了。通过使用less_equal作为我们的比较类型，我们破坏了容器！</p>
<p><strong>测试</strong></p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">snumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">snumber</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">snumber</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">for_each</span><span class="p">(</span><span class="n">snumber</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">snumber</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">33</span>
</span></span><span class="line"><span class="cl"><span class="mi">33</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="example-string">Example string*</h2>
<p><code>条款20</code>描述了该如何写一个比较函数以使得容纳<code>string*</code>指针的容器根据string的值排序，而不是对指针的值排序。那个比较函数是按升序排序的，但现在假设你需要<code>string*</code>指针的容器的降序排序的比较函数。</p>
<p>自然是抓现成的代码来修改了。如果不细心，可能会这么干:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrGreater</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 这代码是有瑕疵的！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">);</span> <span class="c1">// 只是相反了旧的测试；这是不对的！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的想法是通过将比较函数内部结果取反来达到反序的结果。很不幸，取反“&lt;”不会给你（你所期望的）“&gt;”，它给你的是 “&gt;=”。</p>
<p>而你现在知道，因为它将对相等的值返回true，对关联容器来说，它是一个无效的比较函数。</p>
<p>你真正需要的比较类型是这个:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrGreater</span><span class="o">:</span> <span class="c1">// 对关联容器来说这是有效的比较类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="n">ps2</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps1</span><span class="p">;</span> <span class="c1">// 返回*ps2是否大于*ps1（也就是交换操作数的顺序）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要避免掉入这个陷阱，你所要记住的就是比较函数的返回值表明的是在此函数定义的排序方式下，一个值是否大于另一个。</p>
<p><strong>相等的值绝不该一个大于另一个，所以比较函数总应该对相等的值返回<code>false</code></strong></p>
<h2 id="example-multiset">Example multiset</h2>
<p>multiset和multimap那些容器可以容纳复本可能包含副本，如果容器认为两个值相等的对象不等价，它将会把两个都存储进去的，这正是multi系列容器的所要支持的事情。</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">msnum</span><span class="p">;</span> <span class="c1">// 仍然以“&lt;=”排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">msnum</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// 插入22A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">msnum</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// 插入22B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">22</span>
</span></span><span class="line"><span class="cl"><span class="mi">22</span></span></span></code></pre></td></tr></table>
</div>
</div><p>s里有两个22的拷贝，<strong>因此我们期望如果我们在它上面做一个<code>equal_range</code>，我们将会得到一对指出包含这两个拷贝的范围的迭代器。但那是不可能的。</strong></p>
<p><code>equal_range</code>，虽然叫这个名字，但不是指示出相等的值的范围，而是等价的值的范围。在这个例子中，s的比较函数说22A和22B是不等价的，所以不可能让它们同时出现在equal_range所指示的范围内。</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//在 myvector 容器中找到所有的元素 22
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">range2</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">22</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">my multiset：&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">range2</span><span class="p">.</span><span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">range2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果没有得到期望结果:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">my multiset:</span></span></code></pre></td></tr></table>
</div>
</div><p>如果改为<code>less</code>比较:</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">range2</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">22</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">my</span> <span class="n">multiset</span><span class="err">：</span><span class="mi">22</span> <span class="mi">22</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red><strong>除非你的比较函数总是为相等的值返回false，你将会打破所有的标准关联型容器，不管它们是否允许存储复本。</strong></font></p>
<h2 id="总结">总结</h2>
<p>从技术上说，用于排序关联容器的比较函数必须在它们所比较的对象上定义一个“<strong>严格的弱序化(strict weakordering)</strong>”。（传给sort等算法（参见条款31）的比较函数也有同样的限制）。</p>
<p><strong>任何一个定义了严格的弱序化的函数都必须在传入相同的值的两个拷贝时返回false。</strong></p>
]]></description></item><item><title>Effective STL [22] | 避免原地修改set和multiset的键</title><link>https://jianye0428.github.io/posts/clause_22/</link><pubDate>Mon, 14 Aug 2023 08:13:21 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_22/</guid><description><![CDATA[<p><strong>所有标准关联容器，set和multiset保持它们的元素有序，这些容器的正确行为依赖于它们保持有序。</strong></p>
<p>如果你改了关联容器里的一个元素的值（例如，把10变为1000），新值可能不在正确的位置，而且那将破坏容器的有序性。</p>
<h2 id="修改map和multimap值">修改map和multimap值</h2>
<p>试图改变这些容器里的一个键值的程序将不能编译:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 错误！map键不能改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">mm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">mm</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 错误！multimap键也不能改变
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition tip open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-lightbulb fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">因为<code>map&lt;K, V&gt;</code>或<code>multimap&lt;K, V&gt;</code>类型的对象中元素的类型是<code>pair&lt;const K, V&gt;</code>。因为键的类型const K，它不能改变。</div>
    </div>
  </div>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">map</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">key_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Tp</span>     <span class="n">mapped_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&gt;</span>  <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span>     <span class="n">key_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Alloc</span>     <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你使用一个<code>const_cast</code>，或许能改变它，后面会讨论到。</p>
<h2 id="修改set和multiset值">修改set和multiset值</h2>
<p>对于<code>set&lt;T&gt;</code>或<code>multiset&lt;T&gt;</code>类型的对象来说，储存在容器里的元素类型只不过是<code>T</code>，并非<code>const T</code>。因此，<code>set</code>或<code>multiset</code>里的元素可能在你想要的任何时候改变。不需要映射。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">set</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// typedefs:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///@{
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Public typedefs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">key_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span> <span class="n">key_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span> <span class="n">value_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Alloc</span>   <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">///@}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>为什么set或multiset里的元素不是常数？</strong></p>
<p>假设我们有一个雇员的类:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Employee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>       <span class="c1">// 获取雇员名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span> <span class="c1">// 设置雇员名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">getTitle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>   <span class="c1">// 获取雇员头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setTitle</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">);</span>     <span class="c1">// 设置雇员头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">idNumber</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>             <span class="c1">// 获取雇员ID号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们做合理的假设，每个雇员有唯一的ID号，就是<code>idNumber</code>函数返回的数字。然后，建立一个雇员的<code>set</code>，很显然应该只以<code>ID</code>号来排序<code>set</code>:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">IDNumberLess</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">Employee</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 参见条款40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Employees</span> <span class="n">lhs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">idNumber</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">idNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">IDNumberLess</span><span class="o">&gt;</span> <span class="n">EmpIDSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EmpIDSet</span> <span class="n">se</span><span class="p">;</span> <span class="c1">// se是雇员的set， 按照ID号排序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，雇员的<code>ID</code>号是<code>set</code>中元素的键。<strong>其余的雇员数据只是虚有其表</strong>。在这里，没有理由不能把一个特定雇员的头衔改成某个有趣的东西:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Employee</span> <span class="n">selectedID</span><span class="p">;</span> <span class="c1">// 容纳被选择的雇员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span> <span class="c1">// ID号的变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">-&gt;</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 给雇员新头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为在这里我们只是改变雇员的一个与set排序的方式无关的方面（一个雇员的非键部分），所以这段代码不会破坏set。那是它合法的原因。但它的合法排除了<code>set/multiset</code>的元素是<code>const</code>的可能。而且那是它们为什么不是的原因。</p>
<p>因为<code>set</code>或<code>multiset</code>里的值不是<code>const</code>，所以试图改变它们可以编译。</p>
<p><font color=red>如果你改变<code>set</code>或<code>multiset</code>里的元素， 你必须<strong>确保不改变一个键部分——影响容器有序性的元素部分</strong>。如果你做了，你会破坏容器，再使用那个容器将产生未定义的结果， 而且那是你的错误。另一方面，这个限制只应用于被包含对象的键部分。对被包含元素的所有其他部分来说，是开放的: 随便改变！</font></p>
<h2 id="阻止修改set和multiset值">阻止修改set和multiset值</h2>
<p>即使<code>set</code>和<code>multiset</code>的元素不是<code>const</code>，实现仍然有很多方式可以阻止它们被修改。</p>
<p>例如，实现可以让用于<code>set&lt;T&gt;::iterator的operator*</code>返回一个常数<code>T&amp;</code>。即，它可以让<code>set</code>的迭代器解引用的结果是<code>set</code>元素的常量引用。</p>
<p>在这样的实现下，将没有办法修改<code>set</code>或<code>multiset</code>的元素，因为所有访问那些元素的方法都将在让你访问之前加一个<code>const</code>。</p>
<h2 id="要不要修改set和multiset值">要不要修改set和multiset值</h2>
<ol>
<li>如果<strong>不关心移植性</strong>，你想要改变set或multiset中元素的值，而且你的STL实现让你侥幸成功，继续做。只是要确定不要改变元素的键部分，即，会影响容器有序性的元素部分。</li>
<li>如果<strong>在乎移植性</strong>，就认为set和multiset中的元素不能被修改，至少不能在没有映射的情况下</li>
</ol>
<p><strong>Solution: 映射到一个引用</strong></p>
<p>有时候完全有理由改变<code>set</code>或<code>multiset</code>元素的非键部分。例如刚看的不能在一些实现下编译的<code>setTitle</code>调用:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">-&gt;</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 有些STL实现会拒绝这样，因为*i是const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了让它可以编译并且行为正确，我们必须映射掉*i的常量性。这是那么做的正确方法:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 映射掉*i的常量性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>这可以得到i指向的对象，告诉你的编译器把映射的结果当作一个（非常数）Employee的引用，然后在那个引用上调用setTitle。</strong></p>
<p><strong>错误版本的映射</strong></p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">  <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 把*i映射到一个Employee
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>它也等价于如下内容:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">((</span><span class="n">Employee</span><span class="p">)(</span><span class="o">*</span><span class="n">i</span><span class="p">)).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 使用C映射语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这两个都能编译，而且因为它们等价，所以它们错的原因也相同。</p>
<p><strong>在运行期，它们不能修改<code>*i</code>！</strong></p>
<p><strong>在这两个情况里，映射的结果是一个<code>*i</code>副本的临时匿名对象，而setTitle是在匿名的物体上调用，不在<code>*i</code>上<code>！*i</code>没被修改，因为setTitle从未在那个对象上调用，它在那个对象的副本上调用。</strong></p>
<p>两个句法形式等价于这个:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Employee</span> <span class="nf">tempCopy</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 把*i拷贝到tempCopy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tempCopy</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 修改tempCopy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过映射到引用，我们避免了建立一个新对象。</p>
<p>取而代之的是，映射的结果是一个现有对象的引用，<code>i</code>指向的对象。</p>
<p>当我们在有这个引用指定的对象上调用setTitle时，我们是在<code>*i</code>上调用setTitle，而且那正是我们想要的。</p>
<p><strong>为什么不能去掉map和multimap的常量性</strong></p>
<p>注意<code>map&lt;K, V&gt;</code>或<code>multimap&lt;K, V&gt;</code>包含<code>pair&lt;const K, V&gt;</code>类型的元素。</p>
<p>那个<code>const</code>表明<code>pair</code>的第一个组件被定义为常量，而那意味着试图修改它是未定义的行为（即使映射掉它的常量性）。</p>
<p>理论上，一个STL实现可能把这样的值写到一个只读的内存位置（比如，一旦写了就通过系统调用进行写保护的虚拟内存页），而且试图映射掉它的常量性，最多，没有效果。</p>
<p>如果你是一个坚持遵循标准拟定的规则的人，你绝不会试图映射掉<code>map</code>或<code>multimap</code>键的常量性。</p>
<h2 id="安全修改元素步骤">安全修改元素步骤</h2>
<p>想要总是可以工作而且总是安全地改变set、multiset、map或multimap里的元素，按5个简单的步骤去做：</p>
<ol>
<li>定位你想要改变的容器元素。如果你不确定最好的方法， 条款45提供了关于怎样进行适当搜寻的指导。</li>
<li>拷贝一份要被修改的元素。对map或multimap而言，确定不要把副本的第一个元素声明为const。毕竟，你想要改变它！</li>
<li>修改副本，使它有你想要在容器里的值。</li>
<li>从容器里删除元素，通常通过调用erase（参见条款9）。</li>
<li>把新值插入容器。如果新元素在容器的排序顺序中的位置正好相同或相邻于删除的元素，使用insert的“提示”形式把插入的效率从对数时间改进到分摊的常数时间。使用你从第一步获得的迭代器作为提示。</li>
</ol>
<p><strong>一句话概括就是：先删除，再插入新的。</strong></p>
<p><strong>Example:</strong></p>
<p>这是同一个累人的雇员例子，这次以安全、可移植的方式写:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EmpIDSet</span> <span class="n">se</span><span class="p">;</span> <span class="c1">// 同前，se是一个以ID号排序的雇员set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Employee</span> <span class="n">selectedID</span><span class="p">;</span> <span class="c1">// 同前，selectedID是一个带有需要ID号的雇员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span> <span class="c1">// 第一步：找到要改变的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Employee</span> <span class="nf">e</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 第二步：拷贝这个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">se</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>  <span class="c1">// 第三步：删除这个元素；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// 自增这个迭代器以
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// 保持它有效（参见条款9）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">e</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 第四步：修改这个副本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">se</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>               <span class="c1">// 第五步：插入新值；提示它的位置和原先元素的一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Effective STL [19] | 了解相等和等价的区别</title><link>https://jianye0428.github.io/posts/clause_19/</link><pubDate>Thu, 10 Aug 2023 08:30:55 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_19/</guid><description><![CDATA[<h2 id="比较对象">比较对象</h2>
<p>STL充满了比较对象是否有同样的值。比如，当你用<code>find</code>来定位区间中第一个有特定值的对象的位置，<code>find</code>必须可以比较两个对象，看看一个的值是否与另一个相等。同样，当你尝试向<code>set</code>中插入一个新元素时，<code>set::insert</code>必须可以判断那个元素的值是否已经在<code>set</code>中了。</p>
<p><code>find</code>算法和<code>set</code>的<code>insert</code>成员函数是很多必须判断两个值是否相同的函数的代表。但它们实现方式不同，find对“相同”的定义是相等，基于<code>operator==</code>。<code>set::insert</code>对“相同”的定义是等价，通常基于<code>operator&lt;</code>。因为有定义不同，所以有可能一个定义规定了两个对象有相同的值而另一个定义判定它们没有。结果，如果你想有效使用STL，那么你必须明白相等和等价的区别。</p>
<p><strong>相等</strong></p>
<p>操作上来说，相等的概念是基于<code>operator</code>的。如果表达式“<code>x == y</code>”返回true，<code>x</code>和<code>y</code>有相等的值，否则它们没有。</p>
<p><strong><font color=red>x和y有相等的值并不意味着所有它们的成员有相等的值</font></strong>。比如，我们可能有一个内部记录了最后一次访问的Widget类。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="n">TimeStamp</span> <span class="n">lastAccessed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以有一个用于Widget的忽略这个域的operator:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 忽略lastAccessed域的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，两个<code>Widget</code>即使它们的<code>lastAccessed</code>域不同也可以有相等的值。</p>
<p>一般而言，相等意味着两个变量的值相同，但是如果比较2个对象，因为比较函数可以自定义，因此有时候对象的某些成员变量值不同也会设定2个对象相等。</p>
<p><strong>等价</strong></p>
<p>==等价是基于在一个有序区间中对象值的相对位置==。</p>
<p>等价一般在每种标准关联容器（比如，set、multiset、map和multimap）的一部分——排序顺序方面有意义。注意这里的应用场景是==排序==。</p>
<p>两个对象x和y如果在关联容器c的排序顺序中没有哪个排在另一个之前，那么它们关于c使用的排序顺序有等价的值。</p>
<p>举一个例子，一个set<Widget> s。两个Widget w1和w2，如果在s的排序顺序中没有哪个在另一个之前，那么关于s它们有等价的值。set<Widget>的默认比较函数是less<Widget>，而默认的less<Widget>简单地对Widget调用operator&lt;，所以w1和w2关于operator&lt;有等价的值如果下面表达式为真：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="n">w1</span> <span class="o">&lt;</span> <span class="n">w2</span><span class="p">)</span> <span class="c1">// w1 &lt; w2时它非真
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&amp;&amp;</span> <span class="c1">// 而且
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">!</span><span class="p">(</span><span class="n">w2</span><span class="o">&lt;</span><span class="n">w1</span><span class="p">)</span> <span class="c1">// w2 &lt; w1时它非真
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个有意义：<font color=red>两个值如果没有哪个在另一个之前（关于某个排序标准），那么它们等价（按照那个标准）。</font>在一般情况下，用于关联容器的比较函数不是<code>operator&lt;</code>或甚至<code>less</code>，它是用户定义的判断式。每个标准关联容器通过它的<code>key_comp</code>成员函数来访问排序判断式，所以如果下式求值为真，两个对象x和y关于一个关联容器c的排序标准有等价的值：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// 在c的排序顺序中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果x在y之前它非真，同时在c的排序顺序中,如果y在x之前它非真
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要完全领会==相等==和==等价==的含义，考虑一个忽略大小写的<code>set&lt;string&gt;</code>，也就是set的比较函数忽略字符串中字符大小写的<code>set&lt;string&gt;</code>。这样的比较函数会认为“STL”和“stL”是等价的。条款35演示了怎么实现一个函数，<code>ciStringCompare</code>，它进行了忽略大小写比较，但set要一个比较函数的类型，不是真的函数。要填平这个鸿沟，我们写一个operator()调用了ciStringCompare的仿函数类:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CIStringCompare</span><span class="o">:</span> <span class="c1">// 用于忽略大小写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span> <span class="c1">// 字符串比较的类；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">ciStringCompare</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// 关于ciStringCompare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>具体实现为:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">ciCharCompare</span><span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">)</span> <span class="c1">// 忽略大小写比较字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>   <span class="c1">// c1和c2，如果c1 &lt; c2返回-1，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果c1==c2返回0，如果c1 &gt; c2返回1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Ic1</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c1</span><span class="p">));</span><span class="c1">// 转成小写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Ic2</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Ic1</span> <span class="o">&lt;</span> <span class="n">Ic2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">lc1</span> <span class="o">&gt;</span> <span class="n">Ic2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>给定<code>CIStringCompare</code>，要建立一个忽略大小写的set<string>就很简单了:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">CIStringCompare</span><span class="o">&gt;</span> <span class="n">ciss</span><span class="p">;</span> <span class="c1">// ciss = “case-insensitive
</span></span></span><span class="line"><span class="cl"><span class="c1">// string set”
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们向这个set中插入“<code>Persephone</code>”和“<code>persephone</code>”，只有第一个字符串加入了，因为第二个等价于第一个：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ciss</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">);</span> <span class="c1">// 一个新元素添加到set中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ciss</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">);</span> <span class="c1">// 没有新元素添加到set中
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们现在使用set的find成员函数搜索字符串“persephone”，搜索会成功，</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ciss</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试会成功
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但如果我们用非成员的find算法，搜索会失败：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">ciss</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试会失败
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那是因为“<code>persephone</code>”等价于“<code>Persephone</code>”（关于比较仿函数CIStringCompare），但不等于它（因为string(&ldquo;persephone&rdquo;) != string(&ldquo;Persephone&rdquo;)）。你可能会奇怪为什么标准关联容器是基于等价而不是相等。毕竟，大多数程序员对相等有感觉而缺乏等价的感觉。</p>
<p><font color=red>标准关联容器保持有序，所以每个容器必须有一个定义了怎么保持东西有序的比较函数（默认是less）。等价是根据这个比较函数定义的，所以标准关联容器的用户只需要为他们要使用的任意容器指定一个比较函数（决定排序顺序的那个）。</p>
<p>如果关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器就需要，除了用于排序的比较函数，还需要一个用于判断两个值是否相等的比较函数。（默认的，这个比较函数大概应该是equal_to，但有趣的是equal_to从没有在STL中用做默认比较函数。当在STL中需要相等时，习惯是简单地直接调用operator==。比如，这是非成员find算法所作的。）</font></p>
<p><strong><font color=blue>说白了，就是等价是为容器排序服务的，如果容器想要插入多个转化为小写后相等的单词，容器会判定这些单词等价，虽然它们本身不相等，这样就能够很好地保持容器内单词的唯一性和单词的有序性。否则通过查找或插入该单词的时候，容器内部就会发生歧义，造成不符合使用者逻辑。</font></strong></p>
<p>让我们假设我们有一个类似set的STL容器叫做<code>set2CF</code>，“set with two comparison functions”。<strong><font color=red>第一个比较函数用来决定set的排序顺序，第二个用来决定是否两个对象有相同的值。</font></strong> 现在考虑这set2CF：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set2CF</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">CIStringCompare</span><span class="p">,</span> <span class="n">equal_to</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，s内部排序它的字符串时不考虑大小写，等价标准直觉上是这样：如果两个字符串中一个等于另一个，那么它们有相同的值。让我们向s中插入哈迪斯强娶的新娘（Persephone）的两个拼写:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如果我们说<code>&quot;Persephone&quot; != &quot;persephone&quot;</code>然后两个都插入s，它们应该是什么顺序？</p>
</blockquote>
<p>记住排序函数不能分别告诉它们。我们可以以任意顺序插入，因此放弃以确定的顺序遍历set内容的能力吗？（不能以确定的顺序遍历关联容器元素已经折磨着<code>multiset</code>和<code>multimap</code>了，因为标准没有规定等价的值（对于multiset）或键（对于multimap）的相对顺序。）或者我们坚持s的内容的一个确定顺序并忽略第二次插入的尝试（“persephone”的那个）? 如果我们那么做，这里会发生什么？</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试成功或失败？
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>大概**<font color=red>find使用了等价检查</font>**，但如果我们为了维护s中元素的一个确定顺序而忽略了第二个insert的调用，这个find会失败，即使“persephone”的插入由于它是一个重复的值的原则而被忽略！</p>
<h2 id="总结">总结</h2>
<p>通过只使用一个比较函数并使用等价作为两个值“相等”的意义的仲裁者，标准关联容器避开了很多会由允许两个比较函数而引发的困难。</p>
<p>一开始行为可能看起来有些奇怪（特别是当你发现成员和非成员find可能返回不同结果），但最后，它避免了会由在标准关联容器中混用相等和等价造成的混乱。</p>
]]></description></item><item><title>Effective STL [20] | 为指针的关联容器指定比较类型</title><link>https://jianye0428.github.io/posts/clause_20/</link><pubDate>Fri, 11 Aug 2023 16:10:59 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_20/</guid><description><![CDATA[<h2 id="example">Example</h2>
<p>假定你有一个string*指针的set，你把一些动物的名字插入进set:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Anteater&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Wombat&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Lemur&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Penguin&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ssp = “set of string ptrs”
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后你写了下列代码打印set的内容，希望字符串按字母顺序出现。毕竟，确定set保持它们的内容有序。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你期望看到</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Anteater
</span></span><span class="line"><span class="cl">Wombat
</span></span><span class="line"><span class="cl">Lemur
</span></span><span class="line"><span class="cl">Penguin</span></span></code></pre></td></tr></table>
</div>
</div><p>实际运行结果:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mh">0x5566364b5eb0</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5f10</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5f70</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5fd0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果是4个十六进制的数，代表指针的值。 因为set容纳指针，<code>*i</code>不是一个<code>string</code>，是一个<code>string</code>的指针。</p>
<p>如果你已经改为调用copy算法，</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">copy</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span><span class="c1">// 把ssp中的字符串拷贝到cout（但这不能编译）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个copy的调用将不能编译，因为<code>ostream_iterator</code>需要知道被打印的对象的类型，所以当你告诉它是一个string时（通过作为模板参数传递），编译器检测到那和ssp中储存的对象类型(是<code>string*</code>)之间不匹配，它们会拒绝编译代码。</p>
<p>把显式循环中的<code>*i</code>改为<code>**i</code>，你可能可以得到你想要的输出，但也可能不。动物名字将被打印，但它们按字母顺序出现的机会只是24份之1。ssp保持它的内容有序，但是它容纳的是指针，所以它以指针的值排序，而不以string值。对于四个指针值可能有24种排列（），所以指针被储存时有24种可能的顺序。因此你看见字符串按字母排序有24份之1的几率。</p>
<p>或者打印 <code>*string</code>的<code>char*</code>数组</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="solution">Solution</h2>
<p>当我们写下<code>set&lt;string*&gt; ssp</code>;，其实省略了一个默认参数<code>set&lt;string*, less&lt;string*&gt; &gt; ssp</code>;，实际上还有个默认参数:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">,</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="自定义仿函数">自定义仿函数</h2>
<p>如果想要<code>string*</code>指针以字符串值确定顺序被储存在<code>set</code>中，不能使用默认比较仿函数类<code>less&lt;string*&gt;</code>。</p>
<p><strong>必须改为写自己的比较仿函数类，它的对象带有string*指针并按照指向的字符串值来进行排序:</strong></p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrLess</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后可以使用<code>StringPtrLess</code>作为<code>ssp</code>的比较类型:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">StringPtrLess</span><span class="o">&gt;</span> <span class="n">StringPtrSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">StringPtrSet</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立字符串的集合，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 按照StringPtrLess定义的顺序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 和前面一样插入
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同样四个字符串
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在循环最后将做想要它做的（也就是前面你使用*i代替**i所修正的问题）:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">StringPtrSet</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>指针之前对它们解引用的函数，然后和<code>for_each</code>联用那个函数:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ps</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="p">);</span><span class="c1">// 在ssp中的每个元素上调用print
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者你想象并写出了泛型的解引用仿函数类，然后让它和transform与ostream_iterator连用:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 当本类型的仿函数被传入一个T*时，它们返回一个const T&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Dereference</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过解引用“转换” ssp中的每个元素，把结果写入cout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">Dereference</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要点是无论何时你建立一个指针的标准关联容器，你必须记住容器会以指针的值排序。这基本上不是你想要的，所以你几乎总是需要建立自己的仿函数类作为比较类型。</p>
<p><strong>比较类型 vs 比较函数</strong></p>
<p>注意到这里写的是“比较类型”。</p>
<p>你可能奇怪为什么必须特意创造一个仿函数类而不是简单地为set写一个比较函数:</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">stringPtrLess</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">ps2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 将成为用于按字符串值排序的string*指针的比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">return</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">stringPtrLess</span><span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span><span class="c1">// 假设使用stringPtrLess 作为ssp的比较函数；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这不能编译
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的问题是每个set模板的第三个参数都是一种类型，而<code>stringPtrLess</code>不是一种类型，它是一个函数。这就是为什么尝试使用<code>stringPtrLess</code>作为set的比较函数不能编译的原因，set不要一个函数，它要的是能在内部用实例化建立函数的一种类型。</p>
<p><strong>无论何时你建立指针的关联容器，注意你也得指定容器的比较类型。</strong></p>
<p>大多数时候，你的比较类型只是解引用指针并比较所指向的对象（就像上面的<code>StringPtrLess</code>做的那样）。</p>
<p>鉴于这种情况，你手头最好也能有一个用于那种比较的仿函数模板。像这样:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DereferenceLess</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PtrType</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">PtrType</span> <span class="n">pT1</span><span class="p">,</span> <span class="n">PtrType</span> <span class="n">pT2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="c1">// 参数是值传递的因为我们希望它们是（或行为像）指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">pT1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pT2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的模板消除了写像<code>StringPtrLess</code>那样的类的需要，因为我们可以改为使用<code>DereferenceLess</code>:</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">DereferenceLess</span><span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 行为就像 set&lt;string*, StringPtrLess&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>本条款是关于指针的关联容器，但它也可以应用于表现为指针的对象的容器，例如，智能指针和迭代器。</p>
<p>如果你有一个智能指针或迭代器的关联容器，那也得为它指定比较类型。幸运的是，指针的这个解决方案也可以用于类似指针的对象。正如DereferenceLess适合作为T*的关联容器的比较类型一样，它也 可以作为T对象的迭代器和智能指针容器的比较类型。</p>
<p>实际上，这24种排列很可能不是平等的，所以“24份之1”的陈述有点使人误解。确实，有24个不同的顺序，而且你可能得到它们中的任何一个。</p>
]]></description></item><item><title>Diffusion 扩散模型（DDPM）</title><link>https://jianye0428.github.io/posts/ddpm/</link><pubDate>Mon, 31 Jul 2023 15:57:07 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/ddpm/</guid><description><![CDATA[<h2 id="一引入">一、引入</h2>
<p></p>
<p>近年AIGC的爆火离不开人工智能在图像生成、文本生成以及多模态等领域的不断累积，其中<strong>生成模型</strong>的发展占据了很大功劳，如：<mark>生成对抗网络 GAN</mark> 及其一系列变体、<mark>变分自编码器 VAE</mark> 及其一系列变体、<mark>自回归模型 AR</mark>、<mark>流模型 flow</mark> ，以及近年大火的<strong>扩散模型 Diffusion Model</strong> 等。</p>
<p>扩散模型的大火并非横空出世，早在2015年就有人提出了类似的想法，直到2020年才提出了经典的 <strong>Denoising Diffusion Probabilistic Models（DDPM）</strong>，像OpenAI、NovelAI、NVIDIA和Google成功的训练了大规模模型之后，它们吸引了很多人注意，后续有了很多基于扩散模型的变体，比如有：GLIDE、DALLE-2、Imagen和年底爆火的完全开源的稳定扩散模型（Stable Diffusion）。</p>
<p>扩散模型与之前所有的生成方法有着本质的区别：</p>
<p></p>
<p>直观的说它是<mark>将图像生成过程（采样）分解为许多小的去噪步骤</mark>，其实 Diffusion 的含义本质上就是一个迭代过程，实线箭头用于扩散步骤中添加随机噪声，虚线箭头代表的是通过学习逆向扩散过程<mark>从噪声中重构所需的数据样本</mark>。<strong>引入噪声导致了信息的衰减，再通过噪声尝试还原原始数据，多次迭代最小化损失后，能够使模型在给定噪声输入的情况下学习生成新图像。</strong></p>
<p>所以Diffusion模型和其它生成模型的区别是，它不是直接的<strong>图像-&gt;潜变量、潜变量-&gt;图像</strong>的一步到位，它是一步一步的<mark><font color=red><strong>逐渐分解、逐渐去噪</strong></font></mark>的过程。</p>
<p>当然有关Diffusion的理解和变体有很多，但是扩散模型从本质上讲就是DDPM，所以本文主要对DDPM的原理进行讲解，并给出DDPM的扩散过程、去噪过程、训练损失的详细推导，对于掌握Diffusion算法原理只需要抓住以下四点即可：</p>
<ul>
<li>前向过程（扩散）；</li>
<li>反向过程（去噪、采样）；</li>
<li>如何训练；</li>
<li>如何推断。</li>
</ul>
<h2 id="二扩散原理阐述">二、扩散原理阐述</h2>
<p>扩散模型包括 <strong>前向扩散过程</strong> 和 <strong>反向去噪过程(采样)</strong>，前向阶段对图像逐步施加噪声，直至图像被破坏变成完全的高斯噪声，然后在反向阶段学习从高斯噪声还原为原始图像的过程。</p>
<h3 id="21直观理解">2.1、直观理解</h3>
<ul>
<li>扩散模型的目的是什么？
<ul>
<li>学习从纯噪声生成图片的方法。</li>
</ul>
</li>
<li>扩散模型是怎么做的？
<ul>
<li>训练一个UNet，接受一系列加了噪声的图片，学习预测所加的噪声。</li>
</ul>
</li>
<li>前向过程在干什么？
<ul>
<li>逐步向真实图片添加噪声最终得到一个纯噪声；</li>
<li>对于训练集中的每张图片，都能生成一系列的噪声程度不同的加噪图片；</li>
<li>在训练时，这些 【不同程度的噪声图片 + 生成它们所用的噪声】 是实际的训练样本。</li>
</ul>
</li>
<li>反向过程在干什么？
<ul>
<li>训练好模型后，采样、生成图片。</li>
</ul>
</li>
</ul>
<h3 id="22前向过程扩散">2.2、前向过程（扩散）</h3>
<p></p>
<p>前向过程在原始输入图像$x_0$上逐步添加随机噪声，这个噪声服从高斯分布$N(0, 1)$，每一步得到的图像$x_t$只和上一步的加噪结果$x_{t-1}$相关，逐步添加噪声至$T$步，可以得到趋向于纯粹噪声的图像，如下图所示：
</p>
<blockquote>
<p>后面有详细的推导，公式比较多，这里先提前把主要的列一下方便阐述。</p>
</blockquote>
<p>对于将一张图片，从$x_{t-1}\rightarrow x_{t}$的逐步加噪破坏的公式为：</p>
<p>$$x_t=\sqrt{\alpha_t}\left.x_{t-1}+\sqrt{1-\alpha_t}\right.\varepsilon_t\quad\quad\quad\quad\quad\quad(1)$$</p>
<p>其中:</p>
<ul>
<li>$x_t$表示第$t$步的图像；</li>
<li>$\varepsilon$ 是一个满足正态分布的随机噪声，$\varepsilon \sim N(0, 1)$；</li>
<li>$\sqrt{\alpha_{t}}$ 是图片的权重，$\sqrt{1 - \alpha_{t}}$ 是噪声的权重；</li>
</ul>
<p>定义：</p>
<ul>
<li>$\alpha_t=1-\beta_t$</li>
<li>$\overline{\alpha}=\prod_{s=1}^t\alpha_s$</li>
</ul>
<p>随着$t$的增加，<strong>噪声的占比会越来越大</strong>，所以添加的<strong>噪声强度也会越来越大</strong>，也就是说图片的权重要越来越小，噪声的权重要越来越大。因为随着扩散过程的增加，图像中噪声的占比也会越来越大，我们想要进一步破坏它的结构，就需要添加更多的噪声。</p>
<blockquote>
<p>换句话说，一开始图像比较清晰，这个时候添加的噪声小一些，随着图像的噪声越来越多，这个时候再加一点噪声的话，对原来的图像就没什么影响了，因为它本身就有好多噪声了，所以随着图像的噪声越来越多，后面的步骤就要加更多的噪声。</p>
</blockquote>
<p>实际训练过程中会比较大（DDPM原文中为1000），所以会有从$x_0$递推到$x_t$的公式：</p>
<p>$$x_t=\sqrt{\overline{\alpha}_t}\left.x_0+\sqrt{1-\overline{\alpha}_t}\right.\varepsilon\quad\quad\quad\quad(2)$$</p>
<p>其中：</p>
<ul>
<li>$\alpha_t$、$\beta_t$ 有一个固定的已知函数，是可以直接进行计算的；</li>
<li>$\varepsilon$ 为随机产生的噪声；</li>
</ul>
<p>所以整个式子是已知的，式 $(1)$、$(2)$ 就可以描述前向过程了，$(1)$ 用于将一张图片的逐步破坏，$(2)$ 用于一步到位的破坏。</p>
<h3 id="23反向过程去噪">2.3、反向过程（去噪）</h3>
<p>反向过程则是不断去除噪声的过程，给定一个噪声图片 $x_T$，对它一步步的去噪还原，直至最终将原始图像 $x_0$ 给恢复出来，如下图所示：</p>
<p></p>
<p>去噪的过程，$x_t$、$\alpha_t$、$\beta_t$ 都是已知的，只有公式 $(2)$ 中的真实噪声是未知的，因为它是随机采样的。所以需要一个神经网络把 $\varepsilon$ 给学出来，也就是说训练一个由 $x_t$ 和 $t$ 估测噪声的模型:</p>
<p>$$x_{t-1}=\frac{1}{\sqrt{\alpha_t}}(x_t-\frac{\beta_t}{\sqrt{1-\overline{\alpha}<em>t}}\varepsilon</em>\theta(x_t,t))$$</p>
<p>其中 $\theta$ 就是模型的参数，通常使用UNet作为预估噪声的模型。</p>
<h3 id="24模型训练">2.4、模型训练</h3>
<p>所以说反向过程其实就是<strong>训练网络去学习分解过程每一步的噪声</strong>，当网络训练好之后，输入一张噪声图片，通过网络就能把加的噪声给求出来，噪声有了代入公式，就能把 $x_{t-1}$ 步的比较清晰的图给求出来了，一步步往前迭代就行了。</p>
<p>采用L2距离刻画相近程度就可以，DDPM的关键是训练 $\varepsilon_{\theta}(x_t, t)$，目的就是使预测的噪声与真实用于破坏的噪声相近：</p>
<p>$$Loss=\mid\mid\varepsilon-\varepsilon_\theta(x_t,t)\mid\mid^2=\mid\mid\varepsilon-\varepsilon_\theta(\sqrt{\overline{\alpha}_t}~x_0+\sqrt{1-\overline{\alpha}_t}~\varepsilon_t,t)\mid\mid^2$$</p>
<p></p>
<p>模型训练完后，只要给定随机高斯噪声，就可以生成一张从未见过的图像。</p>
<p>UNet本文不做介绍，结构图为：</p>
<p></p>
<blockquote>
<p>额外强调的是：Unet里有一个位置编码，是关于时间步的，每个时间步是有一个线性调度器的，每个时间添加的噪声的方差是不一样的，所以将时间步作为编码嵌入的话，可以将模型预测的噪声更加的准确。</p>
</blockquote>
<h2 id="三算法流程概述">三、算法流程概述</h2>
<p></p>
<p>再次总结，扩散模型两个步骤如下：</p>
<ul>
<li>一个固定的（预先定义好的）前向扩散过程 $q(x_t | x_{t-1})$：逐步向图片增加噪声直到最终得到一张纯粹的噪声图；</li>
<li>一个学习得到的去噪过程 $p_{\theta}(x_{t-1} | x_t)$：训练一个神经网络去逐渐的从一张纯噪声中消除噪声，直到得到一张真正的图片。</li>
</ul>
<p></p>
<p>算法1 为训练流程：</p>
<ul>
<li>line2：从数据中采样 $x_0$，$q(x_0)$ 的意思是给 $x_0$ 加上噪声；</li>
<li>line3：随机选取 time step $t$；
<ul>
<li>真实训练过程中我们不可能一步步的从 $t$ 到 $T$，因为会很大，这就意味着每输入一张图片 $x$，就会产生张噪声图像，也就是一张图像的网络要训练 $T$ 个噪声样本，非常耗时。</li>
<li>所以对 $T$ 进行了采样，$t$ 就是从 $T$ 里采集若干个的意思。</li>
<li>举个例子：假设采集 $t$ 的分别为100、20、3，对应的 $x$ 为 $x_{100}$、$x_{20}$、$x_{3}$，对应噪声为 $\varepsilon_{100}$、$\varepsilon_{20}$、$\varepsilon_{3}$，对于的预测噪声为 $\hat{\varepsilon}<em>{100}$、$\hat{\varepsilon}</em>{20}$、$\hat{\varepsilon}_{3}$, 只需要将 $\varepsilon$ 和 $\hat{\varepsilon}$ 代入MSE公式即可（相减、平方、最小化）。</li>
</ul>
</li>
<li>line 4：生成随机高斯噪声；</li>
<li>line 5：调用模型估计 $\varepsilon_{\theta}(\sqrt{\overline{\alpha}_t}~x_0+\sqrt{1-\overline{\alpha}_t}~\varepsilon_t,t)$ ，计算真实噪声与估计噪声之间的MSE Loss，反向传播更新模型。
<ul>
<li>网络的作用是预测噪声，随着的增加，噪声强度会越来越大，因此预测的噪声是和迭代是直接相关的，所以要把作为参数送入到网络当中。</li>
</ul>
</li>
<li>直到收敛。</li>
</ul>
<p>算法2 为采样流程：</p>
<ul>
<li>line 1：从高斯分布采样 $x_T$；</li>
<li>line 2：按照 $T, &hellip;, 1$ 的顺序进行迭代；</li>
<li>line 3：如果 $t = 1$ 令 $z = 0$；如果 $t &gt; 1$ ，从高斯分布中采样；</li>
<li>line 4：利用公式求出均值和方差，进而求得 $x_{t-1}$；</li>
<li>经过上述迭代，恢复 $x_0$。</li>
</ul>
<h2 id="四数学描述">四、数学描述</h2>
<p>我们来推导如何从原始图像直接到第t时刻的图像 $(X_0 - X_t)$。</p>
<p>首先回顾 2.1小节 的两个定义：</p>
<ul>
<li>$\alpha_t = 1 - \beta_{t}$, $\beta_t$ 要越大越好，论文中从0.0001到0.02;</li>
<li>$\overline{\alpha}=\prod_{s=1}^t\alpha_s$累乘，下面会用到；</li>
<li>$x_t=\sqrt{\alpha_t}x_{t-1}+\sqrt{1-\alpha_t}\varepsilon_t\text{,}\varepsilon_t\sim N(0,1)$ 每一时刻添加的噪声均独立；</li>
</ul>
<p>我们要求$x_t$时刻的图像，它需要一步步的加噪迭代，这样太慢了。因为每一步添加的噪声独立且服从正太分布，我们可以做如下推导：</p>
<blockquote>
<p>为了不混淆，只需要记住：<strong>下标越小，噪声越小</strong>，即 $x_{t-1}$ 的噪声是小于 $x_t$ 的。</p>
</blockquote>
<p>$$
\begin{aligned}
q(x_{t}\mid x_{t-1})&amp; =N(x_t;\sqrt{\alpha_t}x_{t-1},(1-\alpha_t)I)  \cr
&amp;=\underbrace{\sqrt{\alpha_t}x_{t-1}}<em>{x</em>{t-2}\text{来表示}x_{t-1}}+\sqrt{1-\alpha_t}\varepsilon_t \cr
&amp;=\sqrt{\alpha_t}\left(\sqrt{\alpha_{t-1}}\right.x_{t-2}+\sqrt{1-\alpha_{t-1}}\left.\varepsilon_{t-1}\right)+\sqrt{1-\alpha_t}\left.\varepsilon_t\right. \cr
&amp;=\sqrt{\alpha_t\alpha_{t-1}}x_{t-2}+\underbrace{\sqrt{\alpha_t-\alpha_t\alpha_{t-1}}\varepsilon_{t-1}+\sqrt{1-\alpha_t}\varepsilon_t}<em>{\text{两个独立正太分布相加}} \cr
&amp;=\sqrt{\alpha_t\alpha</em>{t-1}}\left.x_{t-2}+\sqrt{1-\alpha_t\alpha_{t-1}}\right.\varepsilon  \cr
&amp;\text{&hellip;} \
&amp;=\sqrt{\overline{\alpha}_t}\left.x_0+\sqrt{1-\overline{\alpha}_t}\right.\varepsilon  \cr
&amp;\therefore q(x_t\mid x_0)=N(x_t;\sqrt{\overline{\alpha}_t}x_0,\sqrt{1-\overline{\alpha}_t}I)
\end{aligned}
$$</p>
<blockquote>
<p>上述用的就是重参数化技巧。</p>
</blockquote>
<p>方差参数 $\beta_{t}$ 可以固定为一个常数，也可以选择作为 $T$ 时间段的一个时间表。事实上，人们可以定义一个方差表，它可以是线性的、二次的、余弦的等等。最初的DDPM作者利用了一个从 $\beta_1 = 10^{-4}$ 到$\beta_T = 0.02$增加的线性时间表。Nichol等人2021年的研究表明，采用余弦时间表效果更好。</p>
<p></p>
<h3 id="42反向过程去噪">4.2、反向过程（去噪）</h3>
<p>接下来是反向过程的推导：
$$p(x_{t-1}\mid x_t)=N(x_{t-1};\underbrace{\mu_\theta(x_t,t)}<em>\text{要反预测这个},\overbrace{\Sigma</em>\theta(x_t,t)}^{fixed})$$</p>
<p>给定$x_t$要预测 $x_{t-1}$，它是一个高斯分布，$x_t$和$t$的方差是固定的，论文作者使用原始的噪声调度器作为方差，也就是说噪声调度器一旦确立，方差的大小也就固定了。所以我们只需要预测这个均值就好了，下面给出具体的推导过程：</p>
<p>我们先看整个损失函数，是个<strong>负对数似然</strong>：</p>
<p>$$-\log{p_{\theta}(x_0)}$$</p>
<p>希望神经网络的参数 $\theta$，可以使得生成 $x_0$的概率越大越好。</p>
<p>但问题在于 $x_0$ 的概率不好计算，因为它依赖于 $x_0$ 之前的所有步长，从 $x_T$ 开始。作为一种解决方案，我们可以计算这个目标的<strong>变分下界</strong>，并得到一个更易于计算的公式：</p>
<p>$$-log(p_\theta(x_0))\leq-log(p_\theta(x_0))+D_{KL}(q(x_{1:T}\mid x_0)\parallel p_\theta(x_{1:T}\mid x_0))$$</p>
<p>其中：</p>
<ul>
<li>$x_{1:T}$ 指的是 $x_1, &hellip;, x_T$ 整个序列。</li>
</ul>
<p>现在依然无法计算，我们继续推导：</p>
<p>$$
\begin{gathered}
-log(p_\theta(x_0)) \leq-log(p_\theta(x_0))+D_{KL}(q(x_{1:T}\mid x_0)\mid\mid p_\theta(x_{1:T}\mid x_0)) \cr
\leq-log(p_\theta(x_0))+log(\frac{q(x_{1:T}\mid x_0)}{p_\theta(x_{1:T}\mid x_0)})
\end{gathered}
$$</p>
<p>我们将 KL divergence 改写后，再利用贝叶斯公式进行变形，即分母可以改写为：</p>
<p>$$
\begin{aligned}
p_\theta(x_{1:T}\mid x_0) &amp;=\frac{p_\theta(x_0\mid x_{1:T})\mathrm{~}p_\theta(x_{1:T})}{p_\theta(x_0)} \cr
&amp;=\frac{p_\theta(x_0,x_{1:T})}{p_\theta(x_0)} \cr
&amp;=\frac{p_\theta(x_{0:T})}{p_\theta(x_0)}
\end{aligned}
$$</p>
<p>将其代回原式：</p>
<p>$$
\begin{aligned}
log(\frac{q(x_{1:T}\mid x_0)}{p_\theta(x_{1:T}\mid x_0)})&amp; =log(\frac{q(x_{1:T}\mid x_0)}{\frac{p_\theta(x_{0:T})}{p_\theta(x_0)}})  \cr
&amp;=log(\frac{q(x_{1:T}\mid x_0)}{p_\theta(x_{0:T})})+log(p_\theta(x_0))
\end{aligned}
$$</p>
<p>所以原式可简化为：</p>
<p>$$-log(p_\theta(x_0))\leq\underbrace{log(\frac{q(x_{1:T}\mid x_0)}{p_\theta(x_{0:T})})}_{\text{变分下界,可以优化它}}$$</p>
<ul>
<li>
<p>分子，就是前向过程，它是固定的，从 $x_0$ 到 $x_{1:T}$ 的采样，换句话说就是从我们数据中的一些图像开始；</p>
</li>
<li>
<p>分母，$p_\theta(x_{0:T})=p(x_T)\prod_{t=1}^Tp_\theta(x_{t-1}\mid x_t)$；</p>
<ul>
<li>将 $p(x_T)$ 提出来，是因为 $p(x_T)$ 是指当前图像，它是不依赖于网络参数 $\theta$ 的.</li>
</ul>
<p>$$
\begin{aligned}
log(\frac{q(x_{1:T}\mid x_0)}{p_{\theta}(x_{0:T})})&amp; =log(\frac{\prod_{t=1}^Tq(x_t\mid x_{t-1})}{p(x_T)\prod_{t=1}^Tp_\theta(x_{t-1}\mid x_t)})  \cr
&amp;=-log(p(x_T))+log(\frac{\prod_{t=1}^Tq(x_t\mid x_{t-1})}{\prod_{t=1}^Tp_\theta(x_{t-1}\mid x_t)}) \cr
&amp;=-log(p(x_T))+\sum_{t=1}^Tlog(\frac{q(x_t\mid x_{t-1})}{p_\theta(x_{t-1}\mid x_t)}) \cr
&amp;=-log(p(x_T))+\sum_{t=2}^Tlog(\frac{q(x_t\mid x_{t-1})}{p_\theta(x_{t-1}\mid x_t)})+\underbrace{log(\frac{q(x_1\mid x_0)}{p_\theta(x_0\mid x_1)})}_{t=1}
\end{aligned}
$$</p>
</li>
</ul>
<p></p>
<p>$q(x_t|x_{t-1})$ 根据贝叶斯公式可以变换如下：</p>
<p>$$q(x_t\mid x_{t-1})=\frac{q(x_{t-1}\mid x_t)q(x_t)}{q(x_{t-1})}$$</p>
<p>$q(x_{t-1}|x_{t})$具有比较高的方差，因为根据这张照片，我们无法确定它来自哪里，但是引入 $x_0$，我们就可以容易的预测出 $x_{t-1}$，</p>
<p></p>
<p>因此我们使用：</p>
<p>$$\frac{q(x_{t-1}\mid x_t,x_0)\mathrm{~}q(x_t\mid x_0)}{q(x_{t-1}\mid x_0)}$$</p>
<p>替换贝叶斯重写后的式子，我们得到：</p>
<p>$$
\begin{aligned}
log(\frac{q(x_{1:T}\mid x_0)}{p_{\theta}(x_{0:T})})&amp; =-log(p(x_T))+\sum_{t=2}^Tlog(\frac{q(x_{t-1}\mid x_t,x_0)q(x_t\mid x_0)}{p_\theta(x_{t-1}\mid x_t)q(x_{t-1}\mid x_0)})+log(\frac{q(x_1\mid x_0)}{p_\theta(x_0\mid x_1)})  \cr
&amp;=-log(p(x_T))+\sum_{t=2}^Tlog(\frac{q(x_{t-1}\mid x_t,x_0)}{p_\theta(x_{t-1}\mid x_t)})+\underbrace{\sum_{t=2}^Tlog(\frac{q(x_t\mid x_0)}{q(x_{t-1}\mid x_0)})}+log(\frac{q(x_1\mid x_0)}{p_\theta(x_0\mid x_1)})
\end{aligned}
$$</p>
<p>上述标记的式子，也可以简化，我们假设 $t=4$：</p>
<p>$$
\begin{gathered}
\begin{aligned}\sum_{t=2}^{T=4}log(\frac{q(x_t\mid x_0)}{q(x_{t-1}\mid x_0)})\end{aligned} =log(\frac{q(x_2\mid x_0)}{q(x_1\mid x_0)}\cdot\frac{q(x_3\mid x_0)}{q(x_2\mid x_0)}\cdot\frac{q(x_4\mid x_0)}{q(x_3\mid x_0)}) \
=log(\frac{q(x_4\mid x_0)}{q(x_1\mid x_0)})
\end{gathered}
$$</p>
<p>因此我们可以简化为：</p>
<p>$$
\begin{aligned}
&amp;=-log(p(x_T))+\sum_{t=2}^Tlog(\frac{q(x_{t-1}\mid x_t,x_0)}{p_\theta(x_{t-1}\mid x_t)})+log(\frac{q(x_t\mid x_0)}{q(x_1\mid x_0)})+log(\frac{q(x_1\mid x_0)}{p_\theta(x_0\mid x_1)}) \cr
&amp;=-log(p(x_T))+\sum_{t=2}^Tlog(\frac{q(x_{t-1}\mid x_t,x_0)}{p_\theta(x_{t-1}\mid x_t)})+log(q(x_t\mid x_0))-log(p_\theta(x_0\mid x_1)) \cr
&amp;=log(\frac{q(x_t\mid x_0)}{p(x_T)})+\sum_{t=2}^Tlog(\frac{q(x_{t-1}\mid x_t,x_0)}{p_\theta(x_{t-1}\mid x_t)})-log(p_\theta(x_0\mid x_1))\cr
&amp;=\overbrace{\underbrace{D_{KL}(q(x_t\mid x_0)\mid\mid p(x_T))}<em>{q\text{只是个正向过程没有可学习参数}}}^{\text{可以忽略}} + \sum</em>{t=2}^TD_{KL}(q(x_{t-1}\mid x_t,x_0)\mid\mid p_\theta(x_{t-1}\mid x_t))-log(p_\theta(x_0\mid x_1))
\end{aligned}
$$</p>
<ul>
<li>第一项KL散度可以忽略，因为$q$只是个正向过程，没有可学习参数，换句话说就是它是固定的。</li>
<li>第二项KL散度，左边和右边都是正太分布，分别服从 $N(x_{t-1};\tilde{\mu_t}(x_t,x_0),\tilde{\mathsf{\beta}<em>t}I)$ 、$N(x</em>{t-1};\mu_\theta(x_t,t),\text{β}I)$：</li>
</ul>
<p>$$
\sum_{t=2}^TD_{KL}(\underbrace{q(x_{t-1}\mid x_t,x_0)}<em>{N(x</em>{t-1};\tilde{\mu}<em>t(x_t,x_0),\tilde{\mathsf{\beta}}<em>tI)}\mid\mid\overbrace{p</em>\theta(x</em>{t-1}\mid x_t)}^{N(x_{t-1};\mu_\theta(x_t,t),\mathsf{\beta}I})
$$</p>
<p>第一项的 $\tilde{\mu_{t}}(x_{t},x_{0})$、$\tilde{\beta_{t}}$ 就是我们要求的值，这里省略了这部分的推导，不影响算法的理解，</p>
<p>$$
\begin{gathered}\tilde{\mu}<em>t(x_t,x_0)=\frac{\sqrt{\alpha_t}(1-\overline{\alpha}</em>{t-1})}{1-\overline{\alpha}<em>t}x_t+\frac{\sqrt{\alpha}</em>{t-1}\beta_t}{1-\overline{\alpha}_t}x_0\\tilde{\mathsf{\beta}}<em>t=\frac{1-\overline{\alpha}</em>{t-1}}{1-\overline{\alpha}_t}\beta_t\end{gathered}
$$</p>
<blockquote>
<p>凡是涉及到 $\alpha_t$ 的，就是学习调度器的，我们不需要关注它</p>
</blockquote>
<p>我们可以化简 $\tilde{\mu}_{t}$，我们知道 $x_t=\sqrt{\overline{\alpha}_t}x_0+\sqrt{1-\overline{\alpha}_t}\varepsilon $, 即:</p>
<p>$$
x_0=\frac1{\sqrt{\overline{\alpha}_t}}(x_t-\sqrt{1-\overline{\alpha}_t}\left.\varepsilon\right)
$$</p>
<p>还知道: $\overline{\alpha}=\prod_{s=1}^t\alpha_s$、$\alpha_t=1-\beta_t$:</p>
<p>代入 $\tilde{\mu}_{t}$ 得到：</p>
<p>$$
\begin{aligned}
\underbrace{\tilde{\mu}<em>t(x_t,x_0)}</em>{\text{不再依赖}x_0}&amp; =\frac{\sqrt{\alpha_{t}}(1-\overline{\alpha}<em>{t-1})}{1-\overline{\alpha}</em>{t}}x_{t}+\frac{\sqrt{\overline{\alpha}<em>{t-1}}\beta</em>{t}}{1-\overline{\alpha}<em>{t}}\frac{1}{\sqrt{\overline{\alpha}</em>{t}}}(x_{t}-\sqrt{1-\overline{\alpha}<em>{t}}\varepsilon)  \cr
&amp;=\frac{\alpha_t(1-\overline{\alpha}</em>{t-1})x_t}{\sqrt{\alpha_t}(1-\overline{\alpha}_t)}+\frac{\beta_t}{\sqrt{\alpha_t}(1-\overline{\alpha}_t)}(x_t-\sqrt{1-\overline{\alpha}_t}\left.\varepsilon\right) \cr
&amp;=\frac{\alpha_tx_t-\overline{\alpha}_tx_t+(1-\alpha_t)x_t-(1-\alpha_t)\sqrt{1-\overline{\alpha}_t}\varepsilon}{\sqrt{\alpha_t}(1-\overline{\alpha}_t)} \cr
&amp;=\frac{x_t(1-\overline{\alpha}_t)-(1-\alpha_t)\sqrt{1-\overline{\alpha}_t}\varepsilon}{\sqrt{\alpha_t}(1-\overline{\alpha}_t)} \cr
&amp;=\frac{x_t}{\sqrt{\alpha_t}}-\frac{(1-\alpha_t)\varepsilon}{\sqrt{\alpha_t}\sqrt{(1-\overline{\alpha}_t)}} \cr
&amp;=\frac1{\sqrt{\alpha_t}}(x_t-\frac{\beta_t}{\sqrt{1-\overline{\alpha}_t}}\left.\varepsilon\right)
\end{aligned}
$$</p>
<p>代入之后我们发现它就不再依赖于 $x_0$ 了，它就是和 $x_t$ 的一个关系式，式中的 $\alpha_t$、$\beta_t$、$\varepsilon$都是已知的，最后的本质就是我们只是从中减去缩放的随机噪声。</p>
<p>$$\therefore x_{t-1}=N(x_{t-1};\frac1{\sqrt{\alpha_t}}(x_t-\frac{\beta_t}{\sqrt{1-\overline{\alpha}<em>t}}\left.\varepsilon</em>\theta(x_t,t)\right),\Sigma_\theta(x_t,t))$$</p>
<p>这样一来，DDPM的每一步推断可以总结为：</p>
<ul>
<li>每个时间步通过 $x_t$ 和 $t$ 来预测高斯噪声，图中用 $z$ 表示，根据上述公式计算得到均值 $\mu$；</li>
<li>得到方差 $\Sigma_\theta(x_t,t)$</li>
<li>入公式得到 $q(x_{t-1}\mid x_t)$ ，利用重参数化得到 $x_{t-1}$ 。</li>
</ul>
<p></p>
<h3 id="43训练损">4.3、训练损</h3>
<p>下面我们来看损失的推导，我们来回顾第二项：</p>
<p></p>
<p>我们需要减小KL散度，由于<mark>方差是固定的，我们无法优化，所以需要将它们的均值之差减小</mark>，原论文中使用的是简单的均方误差：</p>
<p>将$\mu$表达式代入：</p>
<p>$$
\begin{aligned}
L_{t}&amp; =\frac1{2\sigma_t^2}\mid|\tilde{\mu}<em>t(x_t,x_0)-\mu</em>\theta(x_t,t)||^2  \cr
&amp;=\frac1{2\sigma_t^2}\mid\mid\frac1{\sqrt{\alpha_t}}(x_t-\frac{\beta_t}{\sqrt{1-\overline{\alpha}<em>t}}\left.\varepsilon\right)-\frac1{\sqrt{\alpha_t}}(x_t-\frac{\beta_t}{\sqrt{1-\overline{\alpha}<em>t}}\left.\varepsilon</em>\theta(x_t,t)\right)\mid\mid^2 \cr
&amp;=\frac{\beta_t^2}{2\sigma_t^2\alpha_t(1-\overline{\alpha}<em>t)}\underbrace{\mid\mid\varepsilon-\varepsilon</em>\theta(x_t,t)\mid\mid^2}</em>{mse} \cr
&amp;-&gt;\mid\mid\varepsilon-\varepsilon_\theta(x_t,t)\mid\mid^2=\mid\mid\varepsilon-\varepsilon_\theta(\sqrt{\overline{\alpha}_t}\left.x_0+\sqrt{1-\overline{\alpha}_t}\left.\varepsilon_t,t\right)\mid\mid^2\right.
\end{aligned}
$$</p>
<p>研究人员发现，忽略前面的系数项会变得更简单，采样质量也会得到提高，所以前面这个系数项我们直接忽略，它是和噪声调度器有关的，我们加噪的话也会使计算复杂。</p>
<p>我们最小化 $\mid\mid\varepsilon-\varepsilon_\theta(x_t, t)\mid\mid^2$ 也就是<strong>最小化了KL散度</strong>，KL散度变小了也就是变分上限优化到最小，所以那个负对数似然也会变小。</p>
<p>上面还剩了最后一项 $-log(p_\theta(x_0\mid x_1))$ ，这个作者决定去掉它，即在 $t=1$ 时，我们不添加噪声。也就是下面横线的地方，只有 $t&gt;1$ 的时候才服从高斯分布，如果 $t\leq {1}$，直接让 $z=0$，即噪声设置为0。</p>
<p></p>
<p>回顾上面整个推导过程：我们从<strong>负对数似然 -&gt; 优化下界 -&gt; 简化下界 -&gt; 预测噪声</strong>。</p>
<h2 id="五torch复现">五、torch复现</h2>
<p><a href="https://wangguisen.blog.csdn.net/article/details/128821008"target="_blank" rel="external nofollow noopener noreferrer">https://wangguisen.blog.csdn.net/article/details/128821008<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>ref:
[1]. <a href="https://arxiv.org/abs/2006.11239"target="_blank" rel="external nofollow noopener noreferrer">https://arxiv.org/abs/2006.11239<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://kexue.fm/archives/9119"target="_blank" rel="external nofollow noopener noreferrer">https://kexue.fm/archives/9119<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://zhuanlan.zhihu.com/p/576475987"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/576475987<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[4]. <a href="https://zhuanlan.zhihu.com/p/525106459"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/525106459<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[5]. <a href="https://www.bilibili.com/video/BV1b541197HX"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/BV1b541197HX<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[6]. <a href="https://www.bilibili.com/video/BV1WD4y1E7X5"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/BV1WD4y1E7X5<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[7]. <a href="https://huggingface.co/blog/annotated-diffusion"target="_blank" rel="external nofollow noopener noreferrer">https://huggingface.co/blog/annotated-diffusion<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[8]. <a href="https://www.datalearner.com/blog/1051664857725795"target="_blank" rel="external nofollow noopener noreferrer">https://www.datalearner.com/blog/1051664857725795<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[9]. <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models"target="_blank" rel="external nofollow noopener noreferrer">https://lilianweng.github.io/posts/2021-07-11-diffusion-models<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[10]. <a href="https://mp.weixin.qq.com/s?__biz=Mzk0MzIzODM5MA==&amp;mid=2247486128&amp;idx=1&amp;sn=7ffef5d8c1bbf24565d0597eb5eaeb16&amp;chksm=c337b729f4403e3f4ca4fcc1bc04704f72c1dc02876a2bf83c330e7857eba567864da6a64e18&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s?__biz=Mzk0MzIzODM5MA==&mid=2247486128&idx=1&sn=7ffef5d8c1bbf24565d0597eb5eaeb16&chksm=c337b729f4403e3f4ca4fcc1bc04704f72c1dc02876a2bf83c330e7857eba567864da6a64e18&scene=21#wechat_redirect<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[11]. <a href="https://arxiv.org/pdf/2006.11239.pdf"target="_blank" rel="external nofollow noopener noreferrer">paper link<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [16] | 如何将vector和string的数据传给遗留的API</title><link>https://jianye0428.github.io/posts/clause_16/</link><pubDate>Mon, 07 Aug 2023 08:35:57 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_16/</guid><description><![CDATA[<h2 id="string-和-vector-传递给c-api">string 和 vector 传递给C API</h2>
<h3 id="vector传递指针">vector传递指针</h3>
<p>C风格API接受的是<strong>数组</strong>和<code>char*</code>指针，这样的API还会存在很长时间，如果有1个vector对象randy， 则使用<code>&amp;v[0]</code>就可以得到一个指向randy中数据的指针。对于string对象sesame，则传递<code>sesame.c_str()</code>即可。</p>
<p>表达式<code>randy[0]</code>生产一个指向vector中第一个元素的引用，所以，<code>&amp;randy[0]</code>是指向那个首元素的指针。</p>
<p>vector中的元素被C++标准限定为存储在连续内存中，就像是一个数组。</p>
<p>所以我们可能会这么传递</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// C API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pInts</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">numInts</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">doSomething</span><span class="p">(</span><span class="o">&amp;</span><span class="n">randy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">randy</span><span class="p">.</span><span class="n">size</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>唯一的问题就是，如果randy是空的，<code>randysize()</code>是0，而<code>&amp;randy[0]</code>试图产生一个指向根本就不存在的东西的指针。</p>
<p>可以提前判断一下randy的大小：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">randy</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">doSomething</span><span class="p">(</span><span class="o">&amp;</span><span class="n">randy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">randy</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>randy.begin()代替&amp;randy[0]?</strong></p>
</blockquote>
<p>对于vector，其迭代器实际上是指针。</p>
<p><code>begin</code>的返回类型是<code>iterator</code>，而不是一个指针，当你需要一个指向vector内部数据的指针时绝不该使用begin。如果你基于某些原因决定键入<code>randy.begin()</code>，就应该键入<code>&amp;*randy.begin()</code>，因为这将会产生和<code>&amp;v[0]</code>相同的指针。</p>
<h3 id="string-传递指针">string 传递指针</h3>
<p>类似从vector上获取指向内部数据的指针的方法，<strong>对string不是可靠的</strong>:</p>
<ol>
<li>string中的数据并没有保证被存储在独立的一块连续内存中</li>
<li>string的内部表示形式并没承诺以一个null字符结束。这解释了string的成员函数c_str存在的原因</li>
</ol>
<p>即使是字符串的长度为0，<code>c_str</code>将返回一个指向<code>null</code>字符的指针。</p>
<p><strong>在两种形式下，指针都被传递为指向const的指针。vector和string的数据只能传给只读取而不修改它的API。</strong></p>
<p>如果你将<code>randy</code>传给一个修改其元素的C风格API的话，典型情况都是没问题，但<strong>被调用的函数绝不能试图改变vector中元素的个数</strong>。否则，randy的内部状态将会变得不一致，<code>v.size()</code>将会得到一个不正确的结果。</p>
<p><strong>把一个vector传递给需要修改vector数据的API，一定要确保这些额外限制继续被满足</strong>，比如是否需要保持原来vector中元素的顺序。</p>
<h2 id="c风格api返回的元素初始化stl容器">C风格API返回的元素初始化STL容器</h2>
<h3 id="初始化vector">初始化vector</h3>
<p><strong>利用vector和数组潜在的内存分布兼容性将存储vecotr的元素的空间传给API函数：</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// C API：此函数需要一个指向数组的指针，数组最多有arraySize个double
</span></span></span><span class="line"><span class="cl"><span class="c1">// 而且会对数组写入数据。它返回写入的double数，不会大于arraySize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">size_t</span> <span class="nf">fillArray</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">pArray</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">arraySize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd</span><span class="p">(</span><span class="n">maxNumDoubles</span><span class="p">);</span> <span class="c1">// 建立一个vector，它的大小是maxNumDoubles
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vd</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">fillArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vd</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span> <span class="c1">// 让fillArray把数据写入vd，然后调整vd的大小为fillArray写入的元素个数
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>这个技巧只能工作于vector，因为只有vector承诺了与数组具有相同的潜在内存分布。</strong></p>
<h3 id="初始化string">初始化string</h3>
<p>只要让API将数据放入一个<code>vector&lt;char&gt;</code>，然后从vector中将数据拷到string：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// C API：此函数需要一个指向数组的指针，数组最多有arraySize个char
</span></span></span><span class="line"><span class="cl"><span class="c1">// 而且会对数组写入数据。它返回写入的char数，不会大于arraySize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">size_t</span> <span class="nf">fillString</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pArray</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">arraySize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vc</span><span class="p">(</span><span class="n">maxNumChars</span><span class="p">);</span> <span class="c1">// 建立一个vector，它的大小是maxNumChars
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">size_t</span> <span class="n">charsWritten</span> <span class="o">=</span> <span class="n">fillString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vc</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// 让fillString把数据写入vc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="n">vc</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vc</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">charsWritten</span><span class="p">);</span> <span class="c1">// 从vc通过范围构造函数拷贝数据到s
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化其他stl容器">初始化其他STL容器</h3>
<p><strong>通用方法：C风格API把数据放入一个vector，然后拷到实际想要的STL容器</strong></p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">size_t</span> <span class="nf">fillArray</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">pArray</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">arraySize</span><span class="p">);</span> <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd</span><span class="p">(</span><span class="n">maxNumDoubles</span><span class="p">);</span> <span class="c1">// 一样同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vd</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">fillArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vd</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl"><span class="n">deque</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 拷贝数据到deque
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 拷贝数据到list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 拷贝数据到set
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="stl容器传递给c-api">STL容器传递给C API</h3>
<p>STL容器将它们的数据传给C风格API，只要将容器的每个数据拷到vector，然后将vector传给API:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="n">pints</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">numInts</span><span class="p">);</span> <span class="c1">// C API (同上)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intSet</span><span class="p">;</span> <span class="c1">// 保存要传递给API数据的set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">intSet</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">intSet</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 拷贝set数据到vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">doSomething</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// 传递数据到API
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>如果在编译期就知道容器的大小</strong>，可以将数据拷进一个<strong>数组</strong>，然后将数组传给C风格的API，否则不得不分配动态数组。</p>
]]></description></item><item><title>Effective C++ (第3版) 精读总结 [1]</title><link>https://jianye0428.github.io/posts/partone/</link><pubDate>Sat, 29 Jul 2023 18:51:19 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partone/</guid><description><![CDATA[<h1 id="序言">序言</h1>
<p>这本C++的经典之作，作者是大佬<code>Scott Meyers</code>👉<a href="https://www.aristeia.com/books.html"target="_blank" rel="external nofollow noopener noreferrer">大佬主页<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，还写过其他几本影响深远的C++经典，例如<code>《Effective STL》</code>,<code>《More Effective C++》</code>,<code>《Effective Mordern C++》</code>,<code>《Overview of the New C++(C++11/14)》</code>等等。本人看的是中文版，侯捷老师翻译的，精读分析并实践推敲后，整理成博客记录下来。</p>
<blockquote>
<p>(Effective-C++总结系列分为四部分，本文为第一部分，涉及原书第1~2章，内容范围Rule01~12。为方便书写，Rule01简写为R01)。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<h2 id="ch1让自己习惯c">CH1.让自己习惯C++</h2>
<h3 id="r01-视c为一个语言联邦">R01 视C++为一个语言联邦</h3>
<p>如今的C++已经是个多重范式(multiparadigm)语言，同时支持面向过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 要理解这么多特性，可以简单的归结为<code>四种次语言</code>(sublanguage)组成：</p>
<ul>
<li><strong>C语言:</strong> <code>C++仍以C为基础</code>。C++是C的超集, 仍然以 C 为基础。<font color=green>区块</font>、<font color=green>语句</font>、<font color=green>预处理器</font>、<font color=green>内置数据类型</font> 、<font color=green>数组</font>、<font color=green>指针</font>等统统来自C，许多时候C++对问题的解决其实不过就是较高级的 C 解法，但当你C++内的 C 成分工作时，高效编程守则映照出 C 语言的<font color=red>局限</font>：没有模板(template) ，没有异常(exceptions)，没有重载(overloading)……</li>
<li><strong>Object-Oriented C++:</strong> 面向对象特性。这部分也就是 C with classes 所诉求的: <strong>classes</strong>(包括构造函数和析构函数)，<strong>封装</strong>(encapsulation)、<strong>继承</strong>(inheritance)、<strong>多态</strong>(polymorhpism)、<strong>virtual函数</strong>(动态绑定)……等等，这一部分是面向对象设计之古典守则在C++ 上的直接实施。</li>
<li><strong>Template C++:</strong> C++的泛型(generic)编程的部分，也带来了黑魔法-模板元编程(TMP,Metaprogramming)；</li>
<li><strong>STL：</strong> STL(Standard Temlate Library)即标准模板库，它是template程序库。封装了各类容器(container)、配置器(allocator)、迭代器(iterator)、算法以及常用对象。</li>
</ul>
<p><strong>总结:</strong>
C++高效编程守则视状况而变化，取决于你使用C++的哪一部分</p>
<h3 id="r02-尽量以constenuminline替换define">R02 尽量以<code>const</code>,<code>enum</code>,<code>inline</code>替换<code>#define</code></h3>
<ul>
<li><strong>对于宏定义的常量，建议用const常量或者枚举enum替换</strong>
这样做的好处是方便调试，因为宏报错就是个常数值，没有符号表；并且宏不具有封装性(宏的作用域是在编译时是其定义之事)。
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 举例：MAX_DATA_COUNT在预处理阶段就会被替换，编译器不会见到它，所以一旦有相关报错，给的是100这个值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MAX_DATA_COUNT   100
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_DATA_COUNT</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">;</span><span class="c1">// 常量只有一份，宏会导致多份常量值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Buffer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span><span class="c1">//...类其他部分省略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">factor_</span> <span class="p">;</span><span class="c1">// static常量,类内声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span>  <span class="n">times_</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="c1">// int类型允许类内初始化,规范上还是建议拿到类外
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ArrLength</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">ArrLength</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">double</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">factor_</span>  <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span><span class="c1">// 类外初始化,一般写在实现文件*.cpp,*.cc中
</span></span></span></code></pre></td></tr></table>
</div>
</div>如果编译器不允许声明时&quot;in-class初值设定&quot;,如果是整形常量，可以让枚举值来替代，而且<font color=red><code>枚举值不能被取地址</code></font>。</li>
<li><strong>对于宏定义的函数，建议用内联inline函数替换</strong>
宏函数没办法单行debug调试，而内联函数可以；
宏的写法即使小心翼翼的加好了括号，也可能造成意想不到的<font color=red><code>宏函数重复计算</code></font>的问题。
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#define  GET_MAX(a,b)   ((a)&gt;(b) ? (a) :(b))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">GET_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>    <span class="c1">// a累加二次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">GET_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// a累加一次
</span></span></span><span class="line"><span class="cl"><span class="c1">// 定义个inline函数就不会有这个问题,(a,b)作为函数入参就只会计算一次
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>上述情况，从纯C语言角度，想避免“宏函数重复计算”，其实还有个方法，就是使用GNU C 扩展的 typeof 或 GCC 的 <code>__auto_type</code> 关键字，详细可参考GCC官方文档页面。2者都适用于GCC和Clang，都不适用MSVC），示例如下：</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define  GET_MAX_ONCE(a,b) \
</span></span></span><span class="line"><span class="cl"><span class="cp">      ( {typeof(a) _a = (a);   \
</span></span></span><span class="line"><span class="cl"><span class="cp">         typeof(b) _b = (b);   \
</span></span></span><span class="line"><span class="cl"><span class="cp">         (_a) &gt; (_b) ? (_a) : (_b); } )</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试代码如下：</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">GET_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;a = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, b = &#34;</span><span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, c = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="nf">GET_MAX_ONCE</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;a = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, b = &#34;</span><span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, c = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试代码输出：</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">a</span> <span class="o">=</span> 11, <span class="nv">b</span> <span class="o">=</span> 22, <span class="nv">c</span> <span class="o">=</span> <span class="m">21</span>
</span></span><span class="line"><span class="cl"><span class="nv">a</span> <span class="o">=</span> 11, <span class="nv">b</span> <span class="o">=</span> 21, <span class="nv">c</span> <span class="o">=</span> <span class="m">20</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>🤔 <code>使用 __auto_type</code> 来取代时要赋初值，关键的 typeof 那行用法改为<code>__auto_type _a = (a);</code> 。
__auto_type 比 typeof 的优势之处在于面对变长数组(VLA)，只解析1次；以及面对嵌套宏定义时也是只严格解析一次。</p>
</blockquote>
</div>
    </div>
  </div></li>
</ul>
<h3 id="r03-尽可能用const">R03 尽可能用const</h3>
<p>说起const，先复习个面试高频题😁</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//类型char在哪里没关系，关键看const和*的相对位置：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//const在*左边，指针所指物为常量;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//const在*右边，指针为常量；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 指针p所指的字符串为常量，但是p可以修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 指针p是常量，指向的字符串可修改
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>const修饰函数返回值时的防御性
const修饰函数的返回值，可以避免一些错误，如下：
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Rational</span> <span class="k">operator</span><span class="o">*</span> <span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//存在Rational a,b,c;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="c1">//例如手误 &#34;==&#34;打成了&#34;=&#34;，编译器会直接报错
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>const成员函数的限制
const成员函数有2个好处：(1). 明确理解函数是否修改对象内容；(2). 使“操作const对象”成为可能。
可以通过const特性让对象自动调用正确的版本：
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TextBlock</span><span class="p">{</span><span class="c1">//...类其他部分省略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">index</span><span class="p">];}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">index</span><span class="p">];}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;</span> <span class="n">ctb</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span><span class="c1">//根据const特性，调用 const TextBlock::operator[]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>思考：const成员函数不修改成员对象，那么，如果成员对象为指针<code>char *p</code>，仅修改<code>p</code>指向的内容，那它还是<code>const</code>成员函数吗？
实测：const成员函数是允许<code>p[2]= 'x'</code>这一操作的，但是不允许p++；
<ul>
<li><code>bitwise-constness</code>(又称为physical constness)理念认为不是，不能更改任何对象内的任何一个bit。这种说法也有纰漏，const函数返回一个引用就失控了,外部可改；</li>
<li><code>logical-constness</code>理念则允许const成员函数修改成员变量的bits，但只有在客户端侦测不出的情况下;</li>
<li><code>const成员函数</code>如果一定要修改成员变量，成员变量使用 <code>mutable</code> 修饰即可.</li>
</ul>
</li>
<li>const与non-const的成员函数实现完全相同时
这种情况，如何去除代码冗余是个问题。不要封装出一个private函数然后一起调用，多了层调用。
正确做法👉 <code>使用转型,让non-const调用const成员函数</code>，如下为示例：</li>
</ul>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rawdata</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Rawdata</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span><span class="o">:</span><span class="n">p_</span><span class="p">(</span><span class="n">src</span><span class="p">),</span><span class="n">length_</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">GetLength</span><span class="p">()</span><span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">p_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="c1">//为求简便,不作检查了。p_内容修改编译器是允许的.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">length_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">GetLength</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Rawdata</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)).</span><span class="n">GetLength</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">p_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">length_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="r04-确定对象使用前先初始化">R04 确定对象使用前先初始化</h3>
<p>分清&quot;赋值&quot;和&quot;初始化&quot;，在类的构造函数体内使用等号&quot;=&ldquo;赋值并非&quot;初始化”。成员变量的初始化是在构造函数的<u>成员初始化列表</u>实现，效率更高。</p>
<p><code>C++初始化的次序:</code></p>
<ol>
<li>Base class总是早于Derived Class被初始化；</li>
<li>Class内的成员变量总是以声明次序被初始化；
举例: 下图中的代码初始化顺序为声明顺序&quot;age_$\rightarrow$name_$\rightarrow$gender_ $\rightarrow$isVip_&rdquo;
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">class</span> <span class="nc">Customer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> <span class="c1">//这里只是为了验证，如果是实际工程代码，建议初值列表尽量和声明顺序保持一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">Customer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">gender</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">age</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="o">:</span><span class="n">isVip_</span><span class="p">(</span><span class="n">isVip</span><span class="p">),</span> <span class="n">gender_</span><span class="p">(</span><span class="n">gender</span><span class="p">),</span> <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">age_</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">     <span class="kt">uint8_t</span> <span class="n">age_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">gender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="kt">bool</span> <span class="n">isVip_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><pre><code>💡：任何一个成员变量a的初始化流程：类内声明赋初值(C++11)-&gt;构造函数初始化列表-&gt;构造函数体内赋值.
</code></pre>
</div>
    </div>
  </div></li>
<li>函数体外static变量称为<code>non-local static</code>变量，这种变量可以在各自的编译单元正常工作，但C++无法保证初始化次序，当编译单元之间需要共享变量时，而该变量依赖non-local static，就可能会出问题。
<strong>解决办法</strong>是将这样的变量放回函数体内，成为local static，因为C++确保在函数被调用时一定会初始化这个static变量。</li>
</ol>
<h2 id="ch2构造析构赋值运算">CH2.构造/析构/赋值运算</h2>
<h3 id="r05-了解c默认编写并调用哪些函数">R05 了解C++默认编写并调用哪些函数</h3>
<p>编译器可以暗自为Class创建<code>default构造函数</code>，<code>copy构造函数(复制构造)</code>，<code>copy assigment(赋值构造)操作符</code>，以及<code>default析构函数</code>。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">EmptyClass</span><span class="p">{};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>等价于:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">EmptyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">EmptyClass</span><span class="p">()</span> <span class="p">{}</span>        <span class="c1">// default构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">EmptyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">EmptyClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span><span class="c1">//copy构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">~</span><span class="n">EmptyClass</span><span class="p">()</span> <span class="p">{}</span><span class="c1">//default析构函数，注意是non-virtual
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">EmptyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">EmptyClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span><span class="c1">//copy assignment操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>如果一个非空Class自行声明了构造函数，编译器就不再为它创建default构造函数;</p>
</li>
<li>
<p>如果一个Class内有引用变量或const变量，编译器不会为其生成copy-assignment函数，需要自己实现.</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">NameObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">NameObject</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span><span class="n">nameValue_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">objectVal_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nameValue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">objectVal_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span><span class="c1">//考虑以下应用代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">(</span><span class="s">&#34;Mike&#34;</span><span class="p">),</span> <span class="n">name2</span><span class="p">(</span><span class="s">&#34;Nicky&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">NameObject</span> <span class="nf">nObj</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="mi">22</span><span class="p">),</span> <span class="n">nObj2</span><span class="p">(</span><span class="n">name2</span><span class="p">,</span><span class="mi">33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">nObj2</span> <span class="o">=</span> <span class="n">nObj</span><span class="p">;</span><span class="c1">//这一句会导致编译失败，因为引用不能指向2个对象，且const不可改
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="r06-不想编译器的自动生成的函数明确拒绝">R06 不想编译器的自动生成的函数,明确拒绝</h3>
<p>某些场景，类对象本身是认为独一无二的，比如描述人物性格的类Personality(可能不恰当)，不同的人性格不同，肯定是不希望能复制/赋值的。
如果不想编译器自动生成那几个函数，比如不想要复制构造或赋值构造，就明确在代码中禁止，也防止外部用户使用。</p>
<ul>
<li>技巧1：可以声明为private函数但是不给出实现，让编译器报错；</li>
<li>技巧2：可以设立基类Base，让复制构造和赋值构造都为private函数，让目标类继承于Base类。</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>C++11针对此类情况，给予了delete关键字一个新功能，在成员函数后面新增&quot;=delete&quot;，即可显式地拒绝这个函数的生成和调用.举例如下:</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 拷贝赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></div>
    </div>
  </div>
<h3 id="r07-为多态基类声明virtual析构函数">R07 为多态基类声明<code>virtual</code>析构函数</h3>
<ul>
<li>针对<code>Base* pBase= new DerivedObj()</code>，释放pBase时，如果Base基类的析构函数<code>None-Virtual</code>，则会导致Derived的析构函数不会被调用，造成<code>内存不完全释放</code>，即内存泄漏；</li>
<li>Non-Virtual的Class不要做基类；</li>
<li>如果不做基类，就不要声明析构函数为virtual函数，避免虚表为其分配vptr造成浪费；</li>
<li>如果想要抽象类，又暂时没有合适接口，可以让先虚析构成为纯虚函数，例如
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RawData</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">RawData</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这里特殊的是，需要为这个纯虚函数提供定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">~</span><span class="n">RawData</span><span class="o">::</span><span class="n">RawData</span><span class="p">(){}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="r08-别让异常逃离析构函数">R08 别让异常逃离析构函数</h3>
<ul>
<li>
<p>析构函数最好不要吐出异常</br>
对于某个Widget类，如果析构函数抛出异常，那么<code>vector&lt;widget&gt;</code>析构时可能连续抛出多个异常以至于无法处理，直接导致提前程序结束或者未定义行为。</p>
</li>
<li>
<p>如果有某个函数可能会抛出异常，并需要对异常做出反应，应该提供一个非析构的函数来处理</br>
注意，在析构中抛异常并吞下(catch后go-on-execute)，会掩盖错误，也不是个好办法;抛异常后catch住并std::abort()反而可以提前终结『未定义行为』。</p>
</li>
</ul>
<h3 id="r09-绝不在构造和析构过程中调用virtual函数">R09 绝不在构造和析构过程中调用<code>virtual</code>函数</h3>
<ul>
<li>在Derived-Class的Base-Class构造期间，对象的类型是Base-Class，而非Derived，即使<code>dynamic_cast</code>也是这样认为的，因为此时virtual函数不会下降到Derived-Class的阶层；换句话说==&gt; “<code>在Base-Class构造期间，virtual函数不是virtual函数</code>”；</li>
<li>在析构的时候也是类似道理，也不要在析构函数中调用virtual函数，间接调用也不行(比如non-Virtual-&gt;virtual)；</li>
<li>那么替代方案是？</br>
如果有这样一种情况，希望在子类构造时能调用父类的foo函数(下方logTransaction函数)，那么将foo改为non-Virtual函数，并且子类构造时调用父类构造函数，有参数时一并传过去；</li>
</ul>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Transaction</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">explict</span> <span class="n">Transaction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span><span class="o">:</span><span class="n">id_</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="n">logTransaction</span><span class="p">(</span><span class="n">info</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">logTransaction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span> <span class="p">}</span><span class="c1">//non-Virtual函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BuyTransaction</span> <span class="o">:</span><span class="k">public</span> <span class="n">Transaction</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>  <span class="c1">//将log信息传递给 基类Transaction构造函数； 并初始化了基类成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">BuyTransaction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span><span class="n">Transaction</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>上述代码中，如果有几个Base构造函数，就得写几个Derived构造函数传参。为了简化这一步骤， 在现代C++11，推出了继承构造函数(Inheriting Constructor)，子类可以一个都不用写，直接写一句using声明即可，使用<code>using BaseClass::BaseClass</code>的形式，如下👇</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BuyTransaction</span> <span class="o">:</span><span class="k">public</span> <span class="n">Transaction</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">Transaction</span><span class="o">::</span><span class="n">Transaction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//其他
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></div>
    </div>
  </div>
<h3 id="r10-令operator返回一个reference-to-this">R10 令<code>operator=</code>返回一个reference to *this</h3>
<ul>
<li>关于赋值操作符<code>operator=</code>，主流做法是:
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//... do some thing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>上述做法不局限于operator=，还有<code>operator += ,-=,*=,/=</code>等其他赋值运算符。</br>
该主流协议/做法不是强制性的，只是个建议，因为这样可以允许<strong>连续赋值</strong>($x=y=z$的形式)。</br>
该协议被内置类型，以及STL的类型(如string,vector,complex,shared_ptr)共同遵守。</br></li>
</ul>
<h3 id="r11-在operator中处理自我赋值">R11 在<code>operator=</code>中处理&quot;自我赋值&quot;</h3>
<p>一个对象赋值给自己，这种看起来有点傻的做法，有时候会比较难以发觉。比如：<code>a[i] = a[j]</code>，如果 $i$ 和 $j$ 相等，就是“自我赋值”的经典场景了。
所以，我们需要一个尽量完备的赋值操作符函数🤔。
考虑如下类<code>MapWidget</code>，内有数据裸指针<code>BitMap *pb_</code>，在赋值时同时考虑<strong>异常安全</strong>和 <strong>“自我赋值”</strong> 安全(认同测试保障自我赋值安全)，是一个相对不错的实现。但是，认同测试会降低运行效率，根据实际工程实践情况(自我赋值概率极低 )可以酌情去掉。</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BitMap</span> <span class="p">{</span><span class="cm">/*省略类声明&amp;实现*/</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MapWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">BitMap</span> <span class="o">*</span> <span class="n">pb_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">MapWidget</span><span class="p">(</span><span class="n">BitMap</span> <span class="o">*</span><span class="n">pb</span><span class="p">)</span> <span class="o">:</span><span class="n">pb_</span><span class="p">(</span><span class="n">pb</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">MapWidget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MapWidget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">//这一句为认同测试(identity test)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">BitMap</span> <span class="o">*</span><span class="n">pOrig</span> <span class="o">=</span> <span class="n">pb_</span><span class="p">;</span><span class="c1">//不要一上来就delete，而是保存this-&gt;pb_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pb_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BitMap</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pb_</span><span class="p">);</span><span class="c1">//因为这一句可能抛异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">delete</span> <span class="n">pOrig</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Copy and Swap技术 上文中保障<strong>异常安全</strong>和 **“自我赋值”**安全的技术手段，另外一个办法，就是Copy and Swap技术。这个技术的关键在于“修改对象数据的副本，然后在一个不抛异常的函数中将修改的数据和原件置换 ”。
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">MapWidget</span><span class="o">::</span><span class="n">Swap</span><span class="p">(</span><span class="n">MapWidget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">pb_</span><span class="p">,</span><span class="n">pb_</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="n">MapWidget</span><span class="o">&amp;</span> <span class="n">MapWidget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MapWidget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MapWidget</span> <span class="nf">temp</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Swap</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="r12-复制对象时别忘记其每一个成分">R12 复制对象时别忘记其每一个成分</h3>
<ul>
<li>
<p>编写类的Copying函数时需要做到2点
这里的Copying函数是指有copy属性的特殊函数==&gt; copy构造函数和copy赋值操作符。</p>
<ol>
<li>复制所有Local成员变量
如果成员复制的时候有遗漏，编译器并不会有怨言，这就埋下了隐患。如果新增了成员，要对应修改Copying函数。</li>
<li>调用所有Base-Class内部的适当的Copy函数
具体代码的推荐实现 如下👇：</li>
</ol>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Customer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Customer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">float</span> <span class="n">money</span><span class="p">)</span><span class="o">:</span><span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">money_</span><span class="p">(</span><span class="n">money</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">money_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">VipCustomer</span> <span class="o">:</span><span class="k">public</span> <span class="n">Customer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>  <span class="c1">//注意：派生类要复制基类那部分的成员变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">Customer</span><span class="o">::</span><span class="n">Customer</span><span class="p">;</span> <span class="c1">//参考R09
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">VipCustomer</span><span class="p">(</span><span class="k">const</span> <span class="n">VipCustomer</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span><span class="n">priority_</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">priority_</span><span class="p">),</span><span class="n">Customer</span><span class="p">(</span><span class="n">rhs</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="n">VipCustomer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">VipCustomer</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">Customer</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">priority_</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">priority_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">setPriority</span><span class="p">(</span><span class="kt">int</span> <span class="n">priority</span><span class="p">)</span> <span class="p">{</span> <span class="n">priority_</span> <span class="o">=</span> <span class="n">priority</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">priority_</span><span class="p">;</span><span class="c1">//子类独有成员可以单独set函数赋值，或者构造函数初始化列表赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>不要用一个Copying函数去实现另一个
令copy-assignment操作符调用copy构造函数是不合理的；反之，后者调用前者也是无意义的。 如果2者有大量的代码是相同的，可以剥离一个类内private类型的<code>init</code>函数出来，提供给上述2者调用。</p>
</li>
</ul>
<h2 id="refbr">ref:</br></h2>
<p>[1]. <a href="https://blog.csdn.net/cltcj/category_12098441.html"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://kissingfire123.github.io/2021/12/06_effective-c-%e4%b9%8b%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93%e4%b8%80/"target="_blank" rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2021/12/06_effective-c-%e4%b9%8b%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93%e4%b8%80/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>]]></description></item><item><title>Effective STL [15] | 小心string实现的多样性</title><link>https://jianye0428.github.io/posts/clause_15/</link><pubDate>Fri, 04 Aug 2023 08:25:48 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_15/</guid><description><![CDATA[<h2 id="sizeofstring的值">sizeof(string)的值</h2>
<p>如果想知道<code>sizeof(string)</code>的值是多少，答案不一定。</p>
<p><code>string</code>和<code>char*</code>指针一样大的实现很常见，也很容易找到<code>string</code>是<code>char</code>*7 倍大小的<code>string</code>实现。</p>
<p>所以得了解一下<code>string</code>的实现</p>
<h2 id="string的实现">string的实现</h2>
<p><strong>基本实现</strong></p>
<ul>
<li>字符串的大小，也就是包含的字符的数目。</li>
<li>容纳字符串字符的内存容量。</li>
<li>字符串的值，也就是，构成这个字符串的字符。
<strong>可能实现</strong></li>
<li>配置器的拷贝
<strong>依赖引用计数的string实现</strong>s</li>
<li>包含这个值的引用计数</li>
</ul>
<h2 id="4种不同的string实现数据结构">4种不同的string实现数据结构</h2>
<p>以下是原作者看到的4个源码的string的实现</p>
<p><strong>A</strong>
每个string对象包含一个<strong>配置器的拷贝</strong>，<strong>字符串的大小(size)</strong>，<strong>容量(capacity)</strong>，<strong>一个指向包含引用计数（“RefCnt”）<strong>和</strong>字符串值的动态分配的缓冲区的指针</strong>。</p>
<p>在这个实现中，一个使用默认配置器的字符串对象是指针大小的4倍。对于一个自定义的配置器，string对象会随配置器对象的增大而变大：</p>
<p></p>
<p><strong>B</strong>
B的<strong>string对象和指针一样大</strong>，因为在结构体中只包含一个指针。再次，这里假设使用默认配置器。正如实现A，如果使用自定义配置器，这个string对象的大小会增加大约配置器对象的大小。</p>
<p>在这个实现中，<strong>使用默认配置器不占用空间，这归功于这里用了一个在实现A中没有的使用优化</strong>。</p>
<p>B的string指向的对象包含<strong>字符串的大小</strong>、<strong>容量</strong>和<strong>引用计数</strong>，以及<strong>容纳字符串值的动态分配缓冲区的指</strong>针及&quot;<strong>其他</strong>&quot;。“其他”指对象包含在多线程系统中与并发控制有关的一些附加数据。</p>
<p>
在实现B中，<strong>用于并发控制的数据是一个指针大小的6倍</strong>。</p>
<p><strong>C</strong>
<strong>C的string对象总是等于指针的大小</strong>，但是<strong>这个指针指向一个包含所有与string相关的东西的动态分配缓冲器</strong>：大小、容量、引用计数和值。没有每物体配置器（per-object allocator）的支持。缓冲区也容纳一些关于值可共享性的数据，标记为“<strong>X</strong>”。
</p>
<p><strong>D</strong>
D的<strong>string对象是一个指针大小的7倍</strong>（仍然假设使用了默认配置器）。这个实现<strong>没有使用引用计数</strong>，但每个string包含了一个足以<strong>表现最多15个字符的字符串值的内部缓冲区</strong>。</p>
<p>因此小的字符串可以被整个保存在string对象中，一个有时被称为“<strong>小字符串优化</strong>”的特性。</p>
<p>当一个string的容量超过15时，<strong>缓冲器的第一部分被用作指向动态分配内存的一个指针，而字符串的值存放在那块内存</strong>中：</p>
<p></p>
<p><strong>g++ 9.4.0中的实现</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_CharT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Traits</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">basic_string</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__alloc_traits</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;::</span><span class="k">template</span>
</span></span><span class="line"><span class="cl"> <span class="n">rebind</span><span class="o">&lt;</span><span class="n">_CharT</span><span class="o">&gt;::</span><span class="n">other</span> <span class="n">_Char_alloc_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__alloc_traits</span><span class="o">&lt;</span><span class="n">_Char_alloc_type</span><span class="o">&gt;</span> <span class="n">_Alloc_traits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Types:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Traits</span>     <span class="n">traits_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Traits</span><span class="o">::</span><span class="n">char_type</span>  <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Char_alloc_type</span>    <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">size_type</span>  <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">difference_type</span> <span class="n">difference_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">reference</span>  <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">const_reference</span> <span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">pointer</span>  <span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__normal_iterator</span><span class="o">&lt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">basic_string</span><span class="o">&gt;</span>  <span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__normal_iterator</span><span class="o">&lt;</span><span class="n">const_pointer</span><span class="p">,</span> <span class="n">basic_string</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">       <span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">const_reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span>  <span class="n">reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">///  Value returned by various member functions when they fail.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">static</span> <span class="k">const</span> <span class="n">size_type</span> <span class="n">npos</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>sizeof(string)</strong></p>
<p>举例：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;Randy&#34;</span><span class="p">);</span> <span class="c1">// 5个字符
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p>实现A有32个字符的最小分配大小，所以虽然s的大小是5，在实现A下容量是31。（第32个字符大概被保留作<strong>尾部的null</strong>，因此可以容易地实现c_str成员函数。）</p>
</li>
<li>
<p>实现C最小量16，而且没有为尾部null保留空间。所以在实现C下，s的容量是16。</p>
</li>
<li>
<p>实现D的最小缓冲区大小也是16，包括尾部null的空间。当然，在这里区别出实现D是因为容量小于16的字符串使用的内存包含在本身字符串对象中。</p>
</li>
<li>
<p>实现B没有最小分配，在实现B下，s的容量是7。</p>
</li>
</ol>
<p><strong>动态分配</strong></p>
<p>在实现D下<strong>将会没有动态分配</strong>，在<strong>实现A和C 1次</strong>，而在<strong>实现B 2次</strong>（一次是string对象指向的对象，一次是那个对象指向的字符缓冲区）。</p>
<p>如果关心动态分配和回收内存的次数，或如果关心经常伴随这样分配的内存开销，你可能想要避开实现B。</p>
<p>另一方面， 实<strong>现B的数据结构包括了对多线程系统并发控制的特殊支持的事实意味着它比实现A或C更能满足你的需要，尽管动态分配次数较多</strong>。</p>
<p>实现D不需要对多线程的特殊支持，因为它不使用引用计数。</p>
<p>在基于<strong>引用计数的设计</strong>中，<strong>字符串对象之外的每个东西都可以被多个字符串共享</strong>（如果它们有相同的值），所以我们可以从图中观察到的其他东西是<strong>实现A比B或C提供更少的共享性</strong>。</p>
<p>特别是，<strong>实现B和C能共享一个字符串的大小和容量，因此潜在地减少了每物体分摊的的储存数据的开销</strong>。</p>
<p>有趣的是，<strong>实现C不能支持每对象配置器的事实意味着它是唯一可以共享配置器的实现：所有字符串必须使用同一个</strong>！</p>
<p><strong>实现D在字符串对象间没有共享数据。</strong></p>
<h2 id="总结">总结</h2>
<p>不同的实现以不同的方式从它们的设计灵活性中得到好处：</p>
<ol>
<li>
<p><strong>字符串值可能是或可能不是引用计数的</strong>。默认情况下，很多实现的确是用了引用计数，但它们通常提供了关闭的方法，一般是通过预处理器宏。比如，<strong>引用计数只对频繁拷贝的字符串有帮助，而有些程序不经常拷贝字符串，所以没有那个开销</strong></p>
</li>
<li>
<p>string对象的大小可能从1到至少7倍char*指针的大小</p>
</li>
<li>
<p><strong>新字符串值的建立可能需要0、1或2次动态分配</strong></p>
</li>
<li>
<p><strong>string对象可能是或可能不共享字符串的大小和容量信息</strong></p>
</li>
<li>
<p><strong>string可能是或可能不支持每对象配置器</strong></p>
</li>
<li>
<p><strong>不同实现对于最小化字符缓冲区的配置器有不同策略</strong></p>
</li>
</ol>
<p>string是标准库中的最重要的组件之一，鼓励应该要多用。</p>
<p>如果要<strong>有效使用STL</strong>，<strong>需要小心string实现的多样性</strong>，特别是如果你正在写必须在不同STL平台上运行的代码并且你面临严格的性能需求。</p>
]]></description></item><item><title>Effective STL [14] | 使用reserve来避免不必要的重新分配</title><link>https://jianye0428.github.io/posts/clause_14/</link><pubDate>Thu, 03 Aug 2023 13:06:29 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_14/</guid><description><![CDATA[<h2 id="自动扩容">自动扩容</h2>
<p>STL 容器只要存储的对象不超过「<strong>最大大小</strong>」，就可以自动增长到足以容纳放进去的数据。这个最大值，只要调用名叫max_size的成员函数就可以查询到。</p>
<p>对于vector和string，只要需要更多空间，就以<code>realloc</code>等价的思想来增长。</p>
<p>realloc的操作有4个部分：</p>
<ol>
<li>「<strong>分配新的内存块</strong>」。在大部分实现中，vector和string的容量每次以「<strong>2</strong>」为因数增长，即容量每次翻倍。</li>
<li>「<strong>把所有元素从容器的旧内存拷贝到新内存</strong>」。</li>
<li>「<strong>销毁旧内存中的对象</strong>」。</li>
<li>「<strong>回收旧内存</strong>」。
这就是分配，回收，拷贝和析构4个步骤，这些步骤代价都很昂贵。</li>
</ol>
<p>即便是简单地把一个元素插入vector或string的动作也可能因为需要更新其他使用了指向vector或string中的迭代器、指针或引用的数据结构而膨胀。</p>
<h2 id="4个成员函数">4个成员函数</h2>
<p>这4个STL容器成员函数，只有vector和string提供了所有这些函数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">size()</td>
<td style="text-align:left">「容器中有多少元素」。</br>没有说明容器为容纳的元素分配了多少内存。</td>
</tr>
<tr>
<td style="text-align:left">capacity()</td>
<td style="text-align:left">「容器已经分配的内存中可以容纳多少元素」。</br>那是容器在那块内存中总共可以容纳多少元素，而不是还可以容纳多少元素。如果想知道一个vector或string中有多少没有被占用的内存，必须从capacity()中减去size()。如果size和capacity返回同样的值，容器中就没有剩余空间了，而下一次插入（通过insert或push_back等）会引发上面的重新分配步骤。</td>
</tr>
<tr>
<td style="text-align:left">resize(Container::size_type n)</td>
<td style="text-align:left"></br>「强制把容器改为容纳n个元素」。调用resize之后，size将会返回n。如果n小于当前大小，容器尾部的元素会被销毁。如果n大于当前大小，新默认构造的元素会添加到容器尾部。如果n大于当前容量，在元素加入之前会发生重新分配。</td>
</tr>
<tr>
<td style="text-align:left">reserve(Container::size_type n)</td>
<td style="text-align:left">「强制容器把它的容量改为至少n，提供的n不小于当前大小」。</br>这一般强迫进行一次重新分配，因为容量需要增加。</td>
</tr>
</tbody>
</table>
<p><strong>reserve</strong>成员函数允许你最小化必须进行的重新分配的次数，因而可以避免真分配的开销和迭代器/指针/引用失效。</p>
<p>「<strong>调用reserve不改变容器中对象的个数。</strong>」</p>
<h2 id="提前-reserve">提前 reserve</h2>
<p>「<strong>只要有元素需要插入而且容器的容量不足时就会发生重新分配</strong>」（包括它们维护的「原始内存分配和回收」，「对象的拷贝和析构」和「迭代器、指针和引用的失效」）。</p>
<p>「避免重新分配的关键」是使用reserve尽快把容器的容量设置为足够大，最好在容器被构造之后立刻进行。</p>
<p><strong>Example</strong></p>
<p>假定你想建立一个容纳1-1000值的<code>vector&lt;int&gt;</code>。没有使用<code>reserve</code>：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在大多数STL实现中，这段代码在循环过程中「<strong>将会导致2到10次重新分配</strong>」。（「vector在重新分配时一般把容量翻倍」，$1000 \approx 2^{10}$。） 把代码改为使用<code>reserve</code>：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>「<strong>这在循环中不会发生重新分配。</strong>」</p>
<h2 id="结论">结论</h2>
<p>通常有2种情况使用<code>reserve</code>来避免不必要的重新分配:</p>
<ol>
<li>可用的情况是「<strong>当你确切或者大约知道有多少元素将最后出现在容器中</strong>」。可以提前reserve适当数量的空间。</li>
</ol>
<p>2.「<strong>保留可能需要的最大的空间</strong>」，然后，一旦添加完全部数据「<strong>修整掉任何多余的容量</strong>」。</p>
]]></description></item><item><title>Effective STL [13] | 尽量使用vector和string来代替动态分配的数组</title><link>https://jianye0428.github.io/posts/clause_13/</link><pubDate>Thu, 03 Aug 2023 09:11:16 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_13/</guid><description><![CDATA[<h2 id="使用new动态分配内存时的注意事项">使用new动态分配内存时的注意事项</h2>
<ol>
<li>
<p>必须确保以后会delete这个分配。如果后面没有delete，「<strong>new就会产生一个资源泄漏</strong>」。</p>
</li>
<li>
<p>你须确保使用了<strong>delete</strong>的正确形式:
如果使用了delete的错误形式，结果会未定义。在一些平台上，程序在运行期会当掉。另一方面，有时候会造成资源泄漏，一些内存也随之而去。</p>
<ul>
<li>对于分配一个单独的对象，必须使用“delete”。</li>
<li>对于分配一个数组，必须使用“delete []”。</li>
</ul>
</li>
<li>
<p>必须确保只<strong>delete</strong>一次。如果一个分配被删除了不止一次，结果也会未定义。</p>
</li>
</ol>
<h2 id="vector和string">vector和string</h2>
<ol>
<li>
<p>vector和string消除了上面的负担，因为它们管理自己的内存。
当元素添加到那些容器中时它们的内存会增长，而且当一个vector或string销毁时，它的析构函数会自动销毁容器中的元素，回收存放那些元素的内存。</p>
</li>
<li>
<p>vector和string是羽翼丰满的序列容器。
虽然数组也可以用于STL算法，但没有提供像<code>begin</code>、<code>end</code>和<code>size</code>这样的成员函数，也没有内嵌像<code>iterator</code>、<code>reverse_iterator</code>或<code>value_type</code>那样的<code>typedef</code>。而且<code>char*</code>指针当然不能和提供了专用成员函数的<code>string</code>竞争。STL用的越多，越会歧视内建的数组。</p>
</li>
</ol>
<h2 id="string-计数问题">string 计数问题</h2>
<p>很多<code>string</code>实现在后台使用了引用计数，「一个消除了不必要的内存分配和字符拷贝的策略，而且在很多应用中可以提高性能」。</p>
<p>事实上，一般认为<strong>通过引用计数优化字符串很重要</strong>，所以C++标准委员会特别设法保证了那是一个合法的实现。</p>
<p><strong>多线程使用</strong></p>
<p>如果你在多线程环境中使用了引用计数的字符串，你可能发现<font color=red>「避免分配和拷贝所节省下的时间都花费在后台并发控制上」</font>了，会因为线程安全性导致的性能下降。</p>
<p>如果用到的string实现是引用计数的，而且已经确定string的引用计数在多线程环境中运行，那么至少有3个合理的选择，而且没有一个放弃了STL：</p>
<ol>
<li>「<strong>看看库实现是否可以关闭引用计数，通常是通过改变预处理变量的值</strong>」；</li>
<li>寻找或开发一个不使用引用计数的string实现（或部分实现）替代品；</li>
<li>「<strong>考虑使用vector<char>来代替string，vector实现不允许使用引用计数，所以隐藏的多线程性能问题不会出现了</strong>」。</li>
</ol>
<p>当然，使用了vector<char>，就相当于放弃了string的专用成员函数，但大部分功能仍然可以通过STL算法得到，所以从一种语法切换到另一种不会失去很多功能。</p>
<h2 id="结论">结论</h2>
<p>如果你在使用动态分配数组，你可能比需要的做更多的工作。
要减轻你的负担，就使用vector或string来代替。</p>
]]></description></item><item><title>变分自编码器 VAE 详解</title><link>https://jianye0428.github.io/posts/vae_1/</link><pubDate>Thu, 27 Jul 2023 10:53:41 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/vae_1/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="引入">引入</h2>
<p></p>
<div class="details admonition Notes open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Notes<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本文也是为写 Stable Diffusion 相关文章做的铺垫，主要参考了李宏毅老师的视频课以及B站的白板推导系列。有关GMM、蒙特卡洛、ELBO、变分推断、重参数化的细节本文不做详细介绍，主要围绕VAE的结构以及loss优化推导做讲解。</div>
    </div>
  </div>
<p>我们先来简单的引入一下：</p>
<ul>
<li>V：变分推断，它的意思来自于概率图模型，本文会给出变分下界的详细推导；</li>
<li>AE：Auto-Encoder，自编码器；</li>
<li>VAE：Variational Auto-Encoder，<strong>变分自编码器</strong>，将概率图模型和神经网络相结合的模型；</li>
</ul>
<h2 id="一ae">一、AE</h2>
<p></p>
<p>先来介绍一下自编码器（Auto-Encoder），它是一种无监督学习方法，如上图所示，原理可概述为：</p>
<ul>
<li>将高维原始数据（如图片）送入 Encoder，利用 Encoder 将高维数据映射到一个低维空间，将n维压缩到m维($m&laquo;n$)，我们用隐变量来表示；</li>
<li>然后将低维空间的特征送入 Decoder 进行解码，以此来重建原始输入数据。</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">Encoder、Decoder网络可以为普通的全连接、也可以为CNN、或者类似于Unet都可以，没有固定的要求。</div>
    </div>
  </div>
<p>这里为和后文的推导联系起来，我们将 Encoder 网络的映射函数定义为 $q_{\phi}$ 、Decoder 网络定义为 $p_{\theta}$，其中 $\phi$、$\theta$ 皆为网络参数。</br>
那么对于输入 $x$，我们可以通过Encoder得到 <code>Latent Variable</code>：$z = q_{\phi}(x)$，然后Decoder可以从隐变量z中对原始数据进行重建：$x&rsquo; = p_{\theta}(z) = p_{\theta}(q_{\phi}(x))$。</p>
<p>我们希望重建的数据和原来的数据近似一致，即最小化输入和输出之间的重构误差，那么AE的训练损失可以采用简单的MSE：</p>
<p>$$L_{\text{AE}}(\theta, \phi) = \frac{1}{n}\sum_{i=1}^{n} (x^{(i)} - x&rsquo;^{(i)})^2 =\frac{1}{n}\sum_{i=1}^{n} (x^{(i)} - p_{\theta}(q_{\phi}(x^{(i)})))^2$$</p>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">可以理解为比较输入和重构输入的像素点的误差。</div>
    </div>
  </div>
<h2 id="二ae-存在的问题">二、AE 存在的问题</h2>
<p>上面我们通过AE可以<font color=lightseablue><strong>构建一个重构图像的模型</strong></font>，但是这个模型并不能满足要求，或者说它并不是真正意义上的生成模型。对于一个生成模型而言，它满足：</p>
<ul>
<li><strong>Encoder 和 Decoder 可以独立拆分（类比 GAN 的 Generator 和 Discriminator）；</strong></li>
<li><strong>固定维度下<font color=red>任意采样</font>出来的编码，都应该能通过 Decoder 产生一张清晰且逼真的图片。</strong></li>
</ul>
<p>当然对于第一点它是满足的，我们主要分析第二点，也就是AE存在的问题，从而引出VAE。</p>
<p></p>
<p>如上图所示，用一张全月图和一张半月图去训练一个AE，经过训练模型是能够很好的还原出这两张图片。</p>
<p>接下来，我们在 latent code 中任取一点，将其交给 Decoder 进行解码，直觉上我们会得到一张介于全月和半月之前的图片（比如阴影面积覆盖的样子）。然而<font color=red>实际上的输出图片不仅模糊而且还是乱码的</font>。</p>
<p>对于这个现象，一个直观的解释就是AE的 Encoder 和 Decoder 都用了DNN，那么NN只会干一件事情：学习、记住、用记住的东西预测，我们<u>从 latent space 中采样的点，编码器都没有学习过</u>，怎么能够指望它生成希望的值呢?</p>
<p>换句话说，<font color=red><strong>NN只记住了左边全月图片的隐向量和右边半月图片的隐向量，并不能泛化到中间就是$\frac{3}{4}$月亮的图片</strong></font>。</p>
<p>为了解决这个问题，一个最直接的思想就是<strong>引入噪声</strong>，扩大图片的编码区域，从而能够覆盖到失真的空白编码区，如下图所示：</p>
<p></p>
<p>其实说白了就是<strong>通过增加输入的多样性从而增强输出的鲁棒性</strong>。</p>
<p>当我们给输入图片进行编码之前引入一点噪声，使得每张图片的编码点出现在绿色箭头范围内，这样一来所得到的 latent space 就能覆盖到更多的编码点。此时我们再从中间点抽取还原便可以得到一个比较希望的输出。</p>
<p>虽然我们给输入的图片增加了一些噪声，使得 latent space 能够覆盖到比较多的区域，但是还有不少地方没有覆盖到，比如上图的黄色点位置。</p>
<p>因此，我们是不是可以尝试利用更多的噪声，使得对于每一个输入样本，它的编码都能够覆盖到整个编码空间？只不过我们这里需要保证的是：<font color=red>对于编码附近的我们应该给定一个高的概率值，对于距离原编码点远的应该给定一个低的概率值</font>。</p>
<p>这样总体来说，我们就是要将原先的一个单点拉伸到整个编码空间，即将离散的编码点拉伸为一条连续的接近正太分布的编码曲线，如下图所示：</p>
<p></p>
<p>这个其实就是VAE的思想，熟悉GMM的同学应该知道，它是K个高斯分布（Gaussian Distribution）的混合，其实**<font color=green>VAE可以说是无限个高斯分布的混合</font>**。</p>
<h2 id="三vae-结构预览">三、VAE 结构预览</h2>
<p></p>
<p>如上图所示VAE的结构，我们可以看到VAE里的编码器不是输出隐向量$z$，而是一个概率分布，分布的均值为$m$、方差为$\sigma$，$e$ 即为给编码添加的噪声，来自于正态分布。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">VAE的Encoder的输出不是隐向量，而是均值为$m$, 方差为$\sigma$的正态分布。</div>
    </div>
  </div>
<p>公式怎么得到的后面会给出推导，我们先来描述一下这个过程：</p>
<p>$$z_{i} = c_{i} = \exp(\sigma_i) * e_i + m_i$$</p>
<ul>
<li>Encoder会计算出两组编码，一组为均值m、一组为控制噪声干扰程度的方差$\sigma$；</li>
<li>方差$\sigma$主要用来为噪声编码 $e$ 分配权重；</li>
<li>取指数主要是为了保证分配到的权重是正值；</li>
<li>也就是说数据分布会在 $\exp(\sigma_i) * e$ 方差范围内采样一个值，得到一个偏移量，就是相当于把原始的样本加上了一个噪声。从结构图中我们可以看到，损失除了AE的 重构损失（reconstruction error）外，还多出了下面这一项：
$$c = (c_1, c_2, c_3) = \sum_{i=1}^{3} (e^{\sigma_i} - (1 + \sigma_i) + (m_i)^2)$$</li>
</ul>
<p>这个辅助loss可以认为是一个约束，也就是说生成的 $\sigma$ 要满足这个约束。</p>
<p><strong>为什么要加这个辅助loss？</strong></p>
<ul>
<li>我们最小化了 reconstruction error，如果不加这个辅助loss的话，Encoder肯定希望噪声对自身生成的图片干扰越小越好，为了保证生成图片的质量，于是分配给噪声的权重也就是越低。如果不加这个约束的话，网络只需要将方差设置为接近负无穷大的值 $\exp ^ {-\infty} = 0$，即可消除噪声带来的影响，这样必然会过拟合导致鲁棒性不佳。</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">添加辅助loss是为了防止过拟合，提高模型的鲁棒性。</div>
    </div>
  </div>
<p><strong>为什么加这个辅助loss有用？</strong></p>
<ul>
<li>我们对 $\sigma$ 求导可得 $c = e^{\sigma} - 1$，令其等于0可求出 $\sigma = 0$ 时取得极小值，这样一来便可以约束方差不会一路走向负无穷，从而起到正则化约束的作用；</li>
<li>如下图所示，$e^{\sigma}$ 是蓝色曲线，$1 + \sigma$ 是红色线条，那么 $e^{\sigma} - (1 + \sigma)$就是蓝色曲线减去红色直线，得到绿色曲线，显而易见的可以发现它的最小值为0。</li>
</ul>
<p></p>
<h2 id="四数学描述">四、数学描述</h2>
<h3 id="41作者的-intuition">4.1、作者的 Intuition</h3>
<p>
</p>
<p>借用作者原文的表述，我们来引入定义。如上图所示，首先我们会有一个高维的随机变量，与之相关联的我们叫它隐变量 $z$，$z$ 的维度一般要比 $x$ 低很多，用来描述 $x$ 中所包含的信息。</p>
<p>我们假设 $z$ 满足分布 $p_{\theta}(z)$，$x$ 也是一个条件概率，也就是说：</p>
<ul>
<li>在已知 $z$ 的情况下，$p_{\theta}(z)$能生成一个sample $x$ ；</li>
<li>给定一个sample $x$，$q_{\phi}(x)$ 就可以尝试推测出这个来。</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>因为假设$z$满足一定分布，所以也有从$\theta$到$z$的箭头；</p>
<p>之后提到的$z$都是Decoder里的参数。</p>
</div>
    </div>
  </div>
<p>这么说可能有点抽象，我们举个例子：</p>
<p></p>
<p>如上图所示，假设有一个图像，里面有3个颜色不一致的形状，这个就是我们的输入$x$。通过右图的参数，可以控制$x$，这就是隐变量$z$。</p>
<p>那么回到实际的应用场景，我们想要通过$x$获得$z$，又想通过$z$得到相应的$x$，也就是图中的双箭头就是我们想要做的事情。</p>
<p>那么对于生成模型而言，VAE的数据产生包括两个过程：</p>
<ul>
<li>从一个先验分布 $p_{\theta}(z)$ 中采样一个 $z^{(i)}$；</li>
<li>根据条件分布 $p_{\theta}(x|z)$，用 $z^{(i)}$ 生成 $x^{(i)}$。</li>
</ul>
<p>我们希望找到一个参数 $\theta^*$ 来<strong>最大化生成真实数据的概率</strong>：</p>
<p>$$\theta^*=\argmax_{\theta} \prod_{i=1}^{n}p_{\theta}(x^{(i)})$$</p>
<p>这里 $p_{\theta}(x^{(i)})$ 可以通过对 $z$ 积分得到：</p>
<p>$$p_{\theta}(x^{(i)}) = \int_{z} p_{\theta}(x, z) \mathrm{d}{z} = \int_{z} p_{\theta}(z) p_{\theta}(x^{(i)}|z)\mathrm{d}{z}$$</p>
<p>实际上我们要根据上述积分是不可能实现的，先验分布 $p_{\theta}(z)$ 是未知的，而且如果分布比较复杂且高维，对其穷举计算也是不现实的。</p>
<p><strong>变分推断引入后验概率来联合建模</strong>，即given $x$ 想要得到它的 $z$，根据贝叶斯公式表示为：</p>
<p>$$p_{\theta}(z | x) = \frac{p_{\theta}(x|z) p_{\theta}(z)}{p_{\theta}(x)}$$</p>
<p>我们又回到最上面的图：</p>
<p></p>
<ul>
<li>实线箭头就是我们要得到的生成模型 $p_{\theta}(z) p_{\theta}(x|z)$，这里 $p_{\theta} (z)$ 往往是事先定义好的，比如标准正态分布，而 $p_{\theta}(x|z)$ 可以用一个网络来学习，它就可以看成是 <strong>Probabilistic Decoder</strong>。</li>
<li>虚线箭头代表对后验分布 $p_{\theta}(z|x)$ 的变分估计，它也可以用一个网络去近似，我们记为 $q_{\phi}(z|x)$，则这个网络称为 <strong>Probabilistic Encoder</strong>。</li>
</ul>
<p>所以VAE的优化目标就有了，为了<strong>达到从x估计z的过程</strong>，对于估计的后验 $q_{\phi}(z|x)$，我们希望它<strong>接近</strong>真实的后验分布 $p_{\theta}(z|x)$ ，即：</p>
<p>$$p_{\theta}(z|x) \cong q_{\phi}(z|x)$$</p>
<p>说白了就是使用另一个模型，参数由 $\phi$ 表示，在参数 $\phi$ 的帮助下，有了一个分布 $q$ ，现在希望分布 $q$ 能够尽量接近 $p$，从而达到从 $x$ 估计 $z$ 的过程。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>可以看到VAE和AE架构上还是相似的，VAE的最终目标是得到生成模型即Decoder，Encoder只是辅助建模。</p>
<p>而AE常常是为了得到Encoder来进行特征提取或压缩。</p>
</div>
    </div>
  </div>
<h3 id="42变分下界">4.2、变分下界</h3>
<p>为了衡量两个 distribution 的相似程度，我们应该很自然的想到了KL divergence，因为我们实际上计算的是分布 $q$ ，所以我们从 $q$ 的视角来计算它到 $p$ 的KL散度：</p>
<p>$$q_{\phi}(z|x) \cong p_{\theta}(z|x) \rightarrow D_{\text{KL}}(q_{\phi}(z|x) || p_{\theta}(z|x))$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>需要再次强调的是：</p>
<p>$\theta$ 为 decoder 的参数；</p>
<p>$\phi$ 为 encoder 的参数。</p>
</div>
    </div>
  </div>
<p>根据定义我们将KL divergence展开，对 $z$ 求和，表示如下：</p>
<p>$$
\begin{align}
D_{\text{KL}}(q_{\phi}(z|x) || p_{\theta}(z|x)) &amp;= \sum_{z} q_{\phi}(z | x) \log (\frac{q_{\phi}(z | x)}{p_{\theta}(z | x)}) \cr
&amp;= - \sum_{z} q_{\phi}(z | x) \log (\frac{p_{\theta}(z | x)}{q_{\phi}(z | x)})\cr
&amp;= - \sum_{z} q_{\phi}(z | x) \log (\frac{\frac{p_{\theta}(z,x)}{p_{\theta}(x)}}{q_{\phi}(z | x)})\cr
&amp;= - \sum_{z} q_{\phi}(z | x) [\log({\frac{p_{\theta}(x, z)}{p_{\theta}(x)}}) - \log({q_{\phi}(z | x)})]\cr
&amp;= - \sum_{z} q_{\phi}(z | x) [\log({\frac{p_{\theta}(x, z)}{q_{\phi}(z|x)}}) - \log({p_{\theta}(x)})]\cr
\end{align}
$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">$p_{\theta}(z | x)$ 是根据条件概率公式拆开的。</div>
    </div>
  </div>
<p>这个时候我们注意到 $\log(p_{\theta}(x))$ 是和 $z$ 没有关系的，并且log项是常数，所以在乘求和的时候直接提到 $\sum$ 外面去就可以了，并且 $q_{\phi} (z | x)$ 对 $z$ 求和的结果是1，那所以 $-\sum_{z}(q_{\phi}(z|x))(-\log(p_{\theta}(x)))$ 的结果就是 $\log(p_{\theta}(x))$，它是个const。</p>
<p>我们将它移到等式的左边，表示如下：</p>
<p>$$
\begin{align}
\log(p_{\theta}(x)) &amp;= D_{KL}(q_{\phi}(z|x) || p_{\theta}(z|x)) + \sum_{z}q_{\phi}(z|x)\log(\frac{p_{\theta}(x, z)}{q_{\phi}(z|x)}) \cr
&amp;= D_{KL}(q_{\phi}(z|x) || p_{\theta}(z|x)) + L(\theta, \phi; x)
\end{align}
$$</p>
<p>我们将 $\sum_{z}q_{\phi}(z|x)\log(\frac{p_{\theta}(x, z)}{q_{\phi}(z|x)})$ 写成 $L(\theta, \phi; x)$ ，等式左边是一个const，也就是说不管 $x$ 的分布是什么样，它对 $\theta$ 来说没什么影响。等式右边，KL divergence是一个非负的，所以我们只要把 $L(\theta, \phi; x)$ 的值尽可能的拉大，那么KL divergence的值就会随之缩小。</p>
<p><strong>想要最大化的$L(\theta, \phi; x)$，就被称为变分下界（Variational lower bound）。</strong></p>
<h3 id="43loss-function">4.3、Loss Function</h3>
<p>现在我们只要想办法将这个 lower bound 提升就可以了，那么这个 lower bound 就可以作为我们的 loss function：</p>
<p>$$
\begin{aligned}
L(\theta, \phi; x) &amp;= \sum_{z}q_{\phi}(z|x)\log(\frac{p_{\theta}(x, z)}{q_{\phi}(z|x)}) \cr
&amp;= \sum_{z}q_{\phi}(z|x)\log(\frac{p_{\theta}(x|z) p_{\theta}(z)}{q_{\phi}(z|x)}) \cr
&amp;= \sum_{z}q_{\phi}(z|x)[\log(p_{\theta}(x|z)) + \log(\frac{p_{\theta}(z)}{q_{\phi}(z | x)})] \cr
&amp;= {E}<em>{q</em>{\phi}(z|x)}[\log(p_{\theta}(x|z))] - D_{KL}(q_{\theta}(z | x) || p_{\theta}(z))
\end{aligned}
$$</p>
<p>上述等式，我们将 lower bound 再展开，将 $p_{\theta}(x, z)$ 展成条件概率，然后再将log拆分。</p>
<p>第三行中括号内，左边的可以写成期望的形式，右边的因为都有 $q_{\phi}$ 和 $p_{\theta}$ 所以符合KL divergence的公式。</p>
<ul>
<li>我们将 ${E}<em>{q</em>{\phi}(z|x)}[\log(p_{\theta}(x|z))]$ 称为<strong>Reconstruction Loss</strong>，</li>
<li>将 $-D_{KL}(q_{\theta}(z | x) || p_{\theta}(z))$ 称为 <strong>Regularization Loss</strong>。</li>
</ul>
<p>所以我们只需要估计出这两项的梯度来，就可以对 lower bound 进行优化了。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">我们的目的是想让 Probabilistic Encoder 接近于 $p_{\theta}(z)$，因为两个损失，这样KL divergence就越大越好，实际-KL才是训练用的loss。</div>
    </div>
  </div>
<h3 id="44蒙特卡洛法求梯度">4.4、蒙特卡洛法求梯度</h3>
<p>接下来讲如何求出这两项的导数，来优化提升 lower bound。我们看到想要优化的这个loss，其实是可以写成期望的形式的，假定期望里的这一项是 $f(z)$，对于估计这种期望它的导数，最直接的我们就想到了蒙特卡洛的方法。</p>
<p></p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">虽然这里有个 $\phi$，但我们假定这个 $f(z)$ 和 $\phi$ 是没有关系的。(假设！！！！)</div>
    </div>
  </div>
<p>使用蒙特卡洛方法，对 $f(z)$ 在 $q_{\phi}$ 上的期望，对 $\phi$ 求导数，表示如下：</p>
<p>$$
\begin{aligned}
\eta &amp;= \triangle_{\phi} E_{q_{\phi}(z)}[f(z)]\cr
&amp;= \triangle_{\phi} \int {q_{\phi}(z)}f(z) \mathrm{d}z\cr
&amp;= \int \triangle_{\phi}{q_{\phi}(z)}f(z) \mathrm{d}z\cr
&amp;= \int {q_{\phi}(z)}f(z)\triangle_{\phi} \log {q_{\phi}(z)}\mathrm{d}z\cr
&amp;= E_{q_{\phi}(z)}[f(z)\triangle_{\phi} \log {q_{\phi}(z)}]
\end{aligned}
$$</p>
<ul>
<li>$line 1 \sim 2:$ 根据期望的定义展开，因为我们假设 $f(z)$ 和 $\phi$ 没有关系，所以可以将导数符号拿进来；</li>
<li>$line 3: $ 根据变换 $\triangle_{\phi} \log q_{\phi}(z) = \frac{\triangle_{\phi}q_{\phi}(z)}{q_{\phi}(z)}$ 带入可得;</li>
</ul>
<p>套用蒙特卡洛公式，最终表示如下：</p>
<p>$$
\begin{aligned}
\triangle_{\phi}E_{q_{\phi}(z)}[f(z)] &amp;= E_{q_{\phi}(z)}[f(z) \triangle_{q_{\phi}(z)} \log{q_{\phi}(z)}] \cr
&amp;\cong \frac{1}{L}\sum_{l=1}^{L} f(z) \triangle_{q_{\phi}(z^{(l)})} \log{q_{\phi}(z^{(l)})}, where z^{(l)} \sim q_{\phi}(z|x^{(i)})
\end{aligned}
$$</p>
<p>但是作者实验发现使用这个 estimator 是有很高的 variance 的，就是直观上来说会导致训练很不稳定。</p>
<p>在此基础上作者提出了 Generic Stochastic Gradient Variational Bayes (<strong>SGVB</strong>) estimator，并使用**重参数化(Reparameterization)**trick，我们先来说下重参数化。</p>
<h3 id="45重参数化-trick">4.5、重参数化 Trick</h3>
<p>上面我们用蒙特卡洛的时候，有一个非常强的假设，那就是假设 $f(z)$ 和 $\phi$ 是没有关系的，但实际表达式中：
</p>
<p>我们可以看到它还是有关系的，所以我们得考虑它们之间存在的关系、这个关系会带来什么样的问题。</p>
<p>我们把它打开来看：</p>
<p>$$
\begin{aligned}
\triangle_{\phi}E_{q_{\phi}}[f(z)] &amp;= \triangle_{\phi}\int q_{\phi}(z)f(z) \mathrm{d}z \cr
&amp;= \int \triangle_{\phi}[q_{\phi}(z)f(z)] \mathrm{d}z\cr
&amp;= \int f(z) \triangle_{\phi}q_{\phi}(z) \mathrm{d}z + \int q_{\phi}(z)\triangle_{\phi}f(z) \mathrm{d}z\cr
&amp;= \underbrace{\int f(z) \triangle_{\phi}q_{\phi}(z) \mathrm{d}z}<em>{what \ about \ this \ ?} + E</em>{q_{\phi}(z)}[\triangle_{\phi}f(z)]
\end{aligned}
$$</p>
<p>分别求导之后，后面一项可以写成期望的形式，但是前面这一项就无法处理了，为了解决这个问题，作者使用了<strong>重参数化技巧（Reparameterization Trick）</strong>。</p>
<p>核心思想就是引入一个辅助的随机变量 $\epsilon$，$\epsilon \in p(\epsilon)$，这个随机变量和其它变量没有关系，它是一个独立的随机变量，用来表示产生 $z$ 的过程中所有的随机性。也就是说抽样产生 $z$ 的过程中，所有的随机性都是由这个 $\epsilon \in p(\epsilon)$ 产生的。</p>
<p>这样我们就可以把 $z$ 写成这种形式： $z = g_{\phi}(\epsilon, x)$，从而可以把 $q_{\phi}(z)$ 这个概率分布转移到 $p_{\epsilon}$ 上，而 $\epsilon$ 有一个非常好的特性，那就是和 $\phi$ 是没有关系的。</p>
<p>这种 trick 就是重参数化，得到新的变形后重新对 $\phi$ 求导：</p>
<p>$$
\begin{aligned}
E_{q_{\phi(z)}}[f(z^{(i)})] &amp;= E_{p(\epsilon)}[f(g_{\phi}(\epsilon, x^i))] \cr
\triangle_{\phi}E_{q_{\phi(z)}}[f(z^{(i)})] &amp;= \triangle_{\phi}E_{p(\epsilon)}[f(g_{\phi}(\epsilon, x^i)]\cr
&amp;=E_{p(\epsilon)}[\triangle_{\phi}f(g_{\phi}(\epsilon, x^i)]\cr
&amp;\approx \frac{1}{L} \sum_{l=1}^{L} \triangle_{\phi}f(g_{\phi}(\epsilon^{(l)}, x^{(i)}))
\end{aligned}
$$</p>
<p>估计这个期望也是采样然后求平均得到最后的式子，这样就可以把loss的梯度给估计出来了。</p>
<p>以上是从数学角度来分析的重参数化技巧，这里作者给出了一个更加直观的表达：</p>
<p></p>
<ul>
<li>左图为原来的形式，我们使用 $\phi$ 和 $x$ 产生一个distribution，然后在这个distribution中抽样产生一个z，然后再得到最终的 $f$ 。但是在传递梯度的时候，怎么把梯度通过抽样这个过程传递回来呢？这个是没法传递梯度的。
在使用了重参数化trick后，随机性移动到了 $\epsilon$ 上，之前所有抽样的过程包括的随机性，都让 $\epsilon$ 包括了，这样就可以顺利地将梯度通过 $z$ 传递到 $\phi$，这是一个非常巧妙的方法.</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">可以理解成用多余参数逼近抽样的过程。</div>
    </div>
  </div>
<h3 id="46-generic-sgvb">4.6 Generic SGVB</h3>
<p>简单说完重参数化，我们回到SGVB:
</p>
<p>这里是想求这一串期望，它就是我们的 $f(z)$ ，根据之前的 Reparameterization Trick，我们把 $z$ 写成这样的形式：</p>
<p>$$z^{(i, l)} = g_{\phi} (\epsilon^{(i,l)}, x^{(i)}) \ and \ \epsilon^{(l)} \sim p(\epsilon)$$</p>
<p>让 $\epsilon$ 从这个 distribution 中抽样产生，$\epsilon$ 是一个与 $\phi$ 、$\theta$ 都没有关系的随机变量，然后 loss 就变成：</p>
<p>$$L(\theta, \phi, x^{(i)}) = \frac{1}{L} \sum_{l=1}^{L} \log p_{\theta}(x^{(i)}, z^{(i,l)}) - \log q_{\phi}(z^{(i,l)} | x^{(i)})$$</p>
<p>想要求它对 $\phi$ 的导数，只需要两边同时求导即可。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">因为期望这个积分已经被替换成了 $\epsilon$ 的distribution，它跟 $\phi$ 是没有关系的，所以我们在估计整个loss的导数的时候，我们直接对 $\phi$ 求导就可以了。</div>
    </div>
  </div>
<p>这个就是作者提出的第一种估计梯度的方法。</p>
<h3 id="47another-sgvb">4.7、Another SGVB</h3>
<p>在此基础上作者还发现，有一些好的性质可以直接拿来利用，比如期望的一些性质。</p>
<p>在 4.3 节中我们讲到原来的 loss 可以写成 KL散度 + 期望 的形式：</p>
<p>$$L(\theta, \phi, x^{(i)}) = -D_{KL}(q_{\phi}(z|x^{(i)})||p_{\theta}(z)) + E_{q_{\phi}(z|x)}[\log(p_{\theta}(x^{(i)}|z))]$$</p>
<p>这里我们假设这两个distribution：$q_{\phi}$ 、$p_{\theta}$ 都是 Gaussian distribution，说白了就是0均值1方差，根据定义：</p>
<p>$$
\begin{cases}
D_{KL}(P||Q) = E_{x \sim P}[\log(\frac{P(x)}{Q(x)})]\cr
E_{x\sim P(x)} = \int P(x)Q(x)\mathrm{d}x
\end{cases}
$$</p>
<p>我们根据上述定义打开这个KL divergence：</p>
<p>$$-D_{KL}(q_{\phi}(z|x)||p_{\theta}(z)) = \int q_{\phi}(z|x)(\log p_{\theta}(z)) - \log q_{\phi}(z|x) \mathrm{d}z$$</p>
<p>我们先来看 $\int q_{\phi}(z|x)\log p_{\theta}(z) \mathrm{d}z$:</p>
<p>$$
\begin{align}
\int q_{\phi}(z|x)\log p_{\theta}(z) \mathrm{d}z &amp;= \int N(z; \mu, \sigma^2) \log N(z; 0, 1)\mathrm{d}z\cr
&amp;= \int N(z; \mu, \sigma^2) (-\frac{1}{2}z^2 - \frac{1}{2}\log(2\pi))\mathrm{d}z\cr
&amp;= -\frac{1}{2} \int N(z; \mu, \sigma^2) z^2\mathrm{d}z - \frac{J}{2}\log(2\pi) \cr
&amp;= -\frac{J}{2} \log (2\pi) - \frac{1}{2}(E_{z \sim N(z;\mu, \sigma^2)}[z]^2 + Var(z))\cr
&amp;= -\frac{J}{2} \log (2\pi) - \frac{1}{2}\sum_{J}^{j=1}(\mu^2 + \sigma_j^2)
\end{align}
$$</p>
<ul>
<li>$line 1\sim 2:$ 我们让左面分布 $N(z; \mu, \sigma^2)$ 保持不动，将 normal distribution 的PDF带进去；
<ul>
<li>normal distribution 的PDF为:
</li>
<li>将常数项直接拿出来，指数的部分也通过log直接拿下来了；</li>
</ul>
</li>
<li>$line 3:$ 因为 $\frac{1}{2}\log(2\pi)$ 是个常数、$N(z; \mu, \sigma^2)$ 这个分布积分之后是1，所以可以直接把常数项拿到积分外面；但是因为 $z$ 是一个向量，我们假设 $z$ 有 $J$ 个元素element，那么每个元素都会积出一个值来，所以要乘上 $J$，即 $\frac{J}{2}\log(2\pi)$;</li>
<li>$line 4:$ 对于积分 $\int N(z;\mu,\sigma^2) z^2\mathrm{d}z$ 我们可以换个角度理解它：这里我们把它就当成一个概率分布，所以整个这个积分其实也是一个期望的形式，不过它是对 $z^2$ 的期望，经过变形可以写成 $-\frac{1}{2} E_{z \sim N(z; \mu, \sigma^2)}[z]^2$
。在这个基础上我们使用期望的性质 $E[z^2] = E[z]^2 + variance(z)$，即 $z^2$ 的期望等于期望的平方加上 $z$ 的方差；</li>
<li>那么对于一个 normal distribution 来说它的期望和方差是显而易见的：$\mu$ 和 $\sigma$，对于 $z$ 里的每个元素（脚标是 $j$）都加起来就好了，这样最开始的积分就可以简化成最后的形式。</li>
</ul>
<p>我们再来看 $\int q_{\phi}(z|x)\log q_{\phi}(z|x)\mathrm{d}z$:</p>
<p>$$
\begin{aligned}
\int q_{\phi}(z|x)\log q_{\phi}(z|x)\mathrm{d}z &amp;=\int N(z; \mu, \sigma^2)\log N(z;\mu,\sigma^2)\mathrm{d}z\cr
&amp;= \int N(z; \mu, \sigma^2)(-\frac{1}{2}(\frac{z - \mu}{\sigma})^2- \frac{1}{2}\log (2 \pi) - \frac{1}{2}\log(\sigma^2))\mathrm{d}z\cr
&amp;=-\frac{1}{2}\int N(z;\mu,\sigma^{2})(\frac{z-\mu}{\sigma})^{2}\mathrm{d}z-\frac{J}{2}log(2\pi)-\frac{1}{2}\sum_{j=1}^{J}log(\sigma_{j}^{2}) \cr
&amp;=-\frac J2log(2\pi)-\frac12\sum_{j=1}^{J}log(\sigma_{j}^{2})-\frac12E_{z\sim N(z;\mu,\sigma^{2})}[(\frac{z-\mu}\sigma)^{2}] \cr
&amp;=-\frac{J}{2}log(2\pi)-\frac{1}{2}\sum_{j=1}^{J}log(\sigma_{j}^{2})-\frac{1}{2}(E_{z\sim N(z;\mu,\sigma^{2})}[\frac{z-\mu}{\sigma}]^{2}+Var(\frac{z-\mu}{\sigma})) \cr
&amp;=-\frac{J}{2}log(2\pi)-\frac{1}{2}\sum_{j=1}^{J}(1+log(\sigma_j^2))
\end{aligned}
$$</p>
<p>同样的还是把它的PDF带进来，展成上面相似的形式，但是这个地方的常数项和变量要显得复杂一点，相似的是我们一样可以把常数部分拿到积分外面去，然后对于前面这项积分也把它理解成期望的形式，同样利用期望的性质将平方化简，就可以得到最后的结果。</p>
<p>随后我们把 KL散度 这两项给合并起来：
$$
\begin{aligned}
-D_{KL}(q_{\phi}(z\mid x)\mid\mid p_{\theta}(z))&amp; =\int q_\phi(z\mid x)(logp_\theta(z))-logq_\phi(z\mid x))\mathrm{d}z  \cr
&amp;=\frac12\sum_{j=1}^J(1+log((\sigma_j)^2)-(\mu_j)^2-(\sigma_j)^2)
\end{aligned}
$$</p>
<p>把刚刚上面的结果带进来做减法即可得到这个等式，也就是说可以通过这个式子来估计出KL散度。</p>
<p>对于另一部分的loss $E_{q_{\phi}(z|x)}[\log(p_{\theta}(x^{(i)} | z))]$，就像我们上面说的，这部分的概率我们希望given $z$ 产生的 $x$ 尽量的接近输入 $x$，为了实现这个逼近，我们使用MSE来让$f(z)$逼近这个x，就可以最大化这个loss：</p>
<p></p>
<p>以上就是最终使用的SGVB，作者通过 KL散度 的性质和 Regularization Loss 的近似，给我们提供了一种相对稳定的估计loss和梯度的方法。</p>
<h2 id="五vae-结构回顾">五、VAE 结构回顾</h2>
<p></p>
<p>总的来看 Variational Auto-Encoder 的model就是：</p>
<ul>
<li>输入一个 $x$，进了Encoder，这个 Encoder 是由参数来决定的，Encoder 会产生 $μ$和 $σ$；</li>
<li>$μ$和 $σ$首先被我们用来计算 KL divergence，作为<strong>辅助损失</strong>；</li>
<li>同时在 $μ$ 和 $σ$之后我们对它抽样产生一个 $z$，加上 $\epsilon$ 帮我们产生随机的项；</li>
<li>得到隐变量 $z$后，放到 Decoder 里，它是由参数 $\theta$ 来决定的；</li>
<li>经过这个 Decoder 之后，我们重建出了一个 $x$；</li>
<li>对比重建后的 $x$ 和输入 $x$ 之间的 MSE 就构成了loss的另一部分，</li>
<li>两个loss加起来就是最终的loss。</li>
</ul>
<p>这个就是最经典的 Variational Auto-Encoder。</p>
<p>对比第一大节AE的图，可以画成一下形式：</p>
<p></p>
<h2 id="六原文实验">六、原文实验</h2>
<p>作者基于MNIST 和 Frey Face做了实验验证，看下原文的结果图：</p>
<p></p>
<p>首先作者说了使用不同的学习方法能把这个 lower bound 提升多少，lower bound 的提升越大，说明 Encoder 和我们想要逼近的这个Distruction，它的KL散度是越来越小。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">由图中可以看出AEVB与wake-sleep算法的比较，可以看出AEVB训练效果更好。且随着隐变量维度增大，并未出现过拟合现象。</div>
    </div>
  </div>
<p>
</p>
<p>图4是限定2个维度的隐变量 $z$，并调节两个维度的值，生成的图片。</p>
<p>图5是不同维度的隐变量随机采样的图片。</p>
<h2 id="七torch复现-aevae">七、torch复现 AE、VAE</h2>
<p><a href="https://wangguisen.blog.csdn.net/article/details/128476638"target="_blank" rel="external nofollow noopener noreferrer">https://wangguisen.blog.csdn.net/article/details/128476638<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="references">References</h2>
<p>[1]. <a href="https://arxiv.org/abs/1312.6114"target="_blank" rel="external nofollow noopener noreferrer">https://arxiv.org/abs/1312.6114<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="http://www.gwylab.com/note-vae.html"target="_blank" rel="external nofollow noopener noreferrer">http://www.gwylab.com/note-vae.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://zhuanlan.zhihu.com/p/452743042"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/452743042<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[4]. <a href="https://www.bilibili.com/video/BV1q64y1y7J2/"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/BV1q64y1y7J2/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[5]. <a href="https://www.bilibili.com/video/av15889450/?p=33"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/av15889450/?p=33<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[6]. <a href="https://gregorygundersen.com/blog/2018/04/29/reparameterization/"target="_blank" rel="external nofollow noopener noreferrer">https://gregorygundersen.com/blog/2018/04/29/reparameterization/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
</br>
[7]. <a href="https://mp.weixin.qq.com/s?__biz=Mzk0MzIzODM5MA==&amp;mid=2247486014&amp;idx=1&amp;sn=2ff34f72c869907408ed1b08bec1a238&amp;chksm=c337b7a7f4403eb14a1b5cdc3e1a1b11dca6f957591957cc29a4c270f0ace0a4674a7ae33214&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s?__biz=Mzk0MzIzODM5MA==&mid=2247486014&idx=1&sn=2ff34f72c869907408ed1b08bec1a238&chksm=c337b7a7f4403eb14a1b5cdc3e1a1b11dca6f957591957cc29a4c270f0ace0a4674a7ae33214&scene=21#wechat_redirect<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>]]></description></item><item><title>Effective STL [12] | 理解自定义分配器的正确用法</title><link>https://jianye0428.github.io/posts/clause_12/</link><pubDate>Wed, 02 Aug 2023 08:03:42 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_12/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="多线程维护的规则">多线程维护的规则</h2>
<p>多线程程序是很普遍的，所以大部分STL厂商努力使他们的实现在线程环境中可以正常工作。</p>
<p>但是，即使他们做得很好，「<strong>大部分负担仍在你肩上，而理解为什么会这样是很重要的</strong>」。</p>
<p>在STL容器（和大多数厂商的愿望）里对多线程支持的黄金规则已经由SGI定义，并且在它们的STL网站上发布：</p>
<ul>
<li>「<strong>多个读取者是安全的</strong>」。多线程可能同时读取一个容器的内容，在读取时「不能有任何写入者操作这个容器」。</li>
<li>「<strong>对不同容器的多个写入者是安全的</strong>」。多线程可以同时写不同的容器。对同一个容器同时多线程写入是不安全的。</li>
</ul>
<h2 id="完全线程安全">完全线程安全？</h2>
<p>很多程序员希望STL实现是完全线程安全，这非常难以实现。</p>
<p>一个库可能试图以下列方式实现这样完全线程安全的容器：</p>
<ul>
<li>每次调用容器的成员函数期间都要锁定该容器」</li>
<li>在「<strong>每个容器返回的迭代器(例如通过调用begin或end)的生存期之内都要锁定该容器</strong>」</li>
<li>在「<strong>每个在容器上调用的算法执行期间锁定该容器</strong>」。（这事实上没有意义，因为算法没有办法识别出它们正在操作的容器）</li>
</ul>
<h2 id="example-多线程修改">Example 多线程修改</h2>
<p>搜寻一个vector<int>中第一次出现3这个值的地方，如果它找到了，就把这个值改为2。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first3</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// line 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">first3</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span> <span class="c1">// line 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">first3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// line 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>多线程访问时，会有很多「问题」:</p>
<ol>
<li>在多线程环境里，另一个线程可能在行1完成之后立刻修改v中的数据。如果是那样，行2对first3和v.end的检测将是无意义的，因为v的值可能和它们在行1结束时的值不同。</li>
<li>这样的检测会产生未定义的结果，因为另一线程可能插在行1和行2之间，使first3失效，或许通过进行一次插入操作造成vector重新分配它的内在内存。（那将使vector全部的迭代器失效）</li>
<li>行3中对<code>*first3</code>的赋值是不安全的，因为另一个线程可能在行2和行3之间执行，并以某种方式使<code>first3</code>失效，可能通过删除它指向（或至少曾经指向）的元素。</li>
</ol>
<p><strong>解决办法：加锁</strong></p>
<p>要让上面的代码成为线程安全的，「<strong>v必须从行1到行3保持锁定</strong>」，让最多一个线程在1-3行的过程中能访问v。很难想象STL实现怎么能自动推断出这个。</p>
<p>而「<strong>同步原语（例如，信号灯，互斥量，等等）通常开销很大</strong>」，更难想象怎么实现在程序没有明显性能损失的情况下做到前面所说的。</p>
<p>因此你必须「<strong>手工对付</strong>」这些情况中的同步控制</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">getMutexFor</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first3</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">first3</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 这里现在安全了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">first3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 这里也是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">releaseMutexFor</span><span class="p">(</span><span class="n">v</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>「<strong>改进</strong>：」一个更面向对象的解决方案是「<strong>创建一个Lock类</strong>」，在它的「<strong>构造函数里获得互斥量并在它的析构函数里释放它</strong>」，这样使<strong>getMutexFor</strong>和<strong>releaseMutexFor</strong>的「<strong>调用不匹配的机会减到最小</strong>」:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">&gt;</span> <span class="c1">// 获取和释放容器的互斥量的类的模板核心；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span> <span class="o">/</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> <span class="c1">// 忽略了很多细节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Lock</span><span class="p">(</span><span class="k">const</span> <span class="n">Containers</span> <span class="n">container</span><span class="p">)</span><span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">getMutexFor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// 在构造函数获取互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">releaseMutexFor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// 在析构函数里释放它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用一个类（像Lock）来管理资源的生存期（例如互斥量）的办法通常称为<strong>资源获得即初始化</strong>。</p>
<p>应用到上述例子：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="c1">// 建立新块；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Lock</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 获取互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first3</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">first3</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">first3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 关闭块，自动
</span></span></span><span class="line"><span class="cl"><span class="c1">// 释放互斥量
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>基于Lock的方法在有异常的情况下是稳健的</strong></p>
<p>因为Lock对象在Lock的析构函数里释放容器的的互斥量，所以在互斥量需要释放是就销毁Lock是很重要的。为了让这件事发生，我们建立一个里面定义了Lock的新块，而且当我们不再需要互斥量时就关闭那个块。</p>
<p>C++保证如果抛出了异常，局部对象就会被销毁，所以即使当我们正在使用Lock对象时有异常抛出，Lock也将释放它的互斥量。如果我们依赖手工调用<code>getMutexFor</code>和<code>releaseMutexFor</code>，那么在调用<code>getMutexFor</code>之后<code>releaseMutexFor</code>之前如果有异常抛出，我们将不会释放互斥量。</p>
<h2 id="结论">结论</h2>
<ul>
<li>
<p>当涉及到线程安全和STL容器时，你可以确定库实现允许在一个容器上的多读取者和不同容器上的多写入者。</p>
</li>
<li>
<p>「你不能希望库消除对手工并行控制的需要，而且你完全不能依赖于任何线程支持」</p>
</li>
</ul>]]></description></item><item><title>Effective STL [11] | 理解自定义分配器的正确用法</title><link>https://jianye0428.github.io/posts/clause_11/</link><pubDate>Sun, 30 Jul 2023 09:21:58 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_11/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="自定义分配器">自定义分配器</h2>
<p>很多时候，你会有建立自定义分配器的想法：</p>
<ul>
<li><code>allocator&lt;T&gt;</code>对线程安全采取了措拖，但是你只对单线程的程序感兴趣，你不想花费不需要的同步开销</li>
<li>在某些容器里的对象通常一同被使用，所以你想在一个特别的堆里把它们放得很近使引用的区域性最大化</li>
<li>你想建立一个相当共享内存的唯一的堆，然后把一个或多个容器放在那块内存里，因为这样它们可以被其他进程共享。</li>
</ul>
<h3 id="管理共享内存">管理共享内存</h3>
<p>假定你有仿效<code>malloc</code>和<code>free</code>的特别程序，用于管理共享内存的堆</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">mallocShared</span><span class="p">(</span><span class="n">size_t</span> <span class="n">bytesNeeded</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">freeShared</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>并且你希望能把STL容器的内容放在共享内存中:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SharedMemoryAllocator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">pointer</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size_type</span> <span class="n">numObiects</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">localityHint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mallocShared</span><span class="p">(</span><span class="n">numObiects</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="n">pointer</span> <span class="n">ptrToMemory</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">numObjects</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">freeShared</span><span class="p">(</span><span class="n">ptrToMiemory</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>SharedMemoryAllocator</code>：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 方便的typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">SharedMemoryAllocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">SharedDoubleVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="c1">// 开始一个块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SharedDoubleVec</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 建立一个元素在
</span></span></span><span class="line"><span class="cl"><span class="c1">// 共享内存中的vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span> <span class="c1">// 结束这个块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>「问题：」<strong>v</strong>使用<code>SharedMemoryAllocator</code>，所以<strong>v</strong>分配来容纳它元素的内存将来自共享内存，但<strong>v本身——包括它的全部数据成员——几乎将肯定不被放在共享内存里，v只是一个普通的基于堆的对象，所以它将被放在运行时系统为所有普通的基于堆的对象使用的任何内存</strong>。那几乎不会是共享内存。</br></p>
<p>为了把v的内容和v本身放进共享内存，必须这么做:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">pVectorMemory</span> <span class="o">=</span> <span class="n">mallocShared</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SharedDoubleVec</span><span class="p">));</span><span class="c1">// 分配足够的共享内存来容纳一个SharedDoubleVec对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SharedDoubleVec</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">pVectorMemory</span><span class="p">)</span> <span class="n">SharedDoubleVec</span><span class="p">;</span> <span class="c1">// 使用“placement new”来 在那块内存中建立 一个SharedDoubleVec对象；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 参见下面这个对象的使用（通过pv）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">pv</span><span class="o">-&gt;~</span><span class="n">SharedDoubleVec</span><span class="p">();</span> <span class="c1">// 销毁共享内存中的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">freeShared</span><span class="p">(</span><span class="n">pVectorMemory</span><span class="p">);</span> <span class="c1">// 销毁原来的共享内存块
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这就是<code>「手工的四步分配/建造/销毁/回收的过程」</code>：获得一些共享内存 <code>——&gt;</code> 在里面建立一个用共享内存为自己内部分配的vector <code>——&gt;</code> 用完这个vector时，调用它的析构函数 <code>——&gt;</code> 释放vector占用的内存。</p>
<p>这段代码有2点需要注意：</p>
<ul>
<li>
<p>忽略了<code>mallocShared</code>可能返回一个null指针。</p>
</li>
<li>
<p>共享内存中的vector的建立由“placement new”完成。</p>
</li>
</ul>
<h3 id="管理分配和回收的堆">管理分配和回收的堆</h3>
<p>假设有2个堆，类<code>Heap1</code>和<code>Heap2</code>。</p>
<p>每个堆类有用于进行「分配」和「回收」的「静态成员函数」：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Heap1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">alloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numBytes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">memoryBlockToBeNear</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="nf">dealloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Heap2</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">// 有相同的alloc/dealloc接口
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你想在不同的堆里联合定位一些STL容器的内容。</p>
<p>首先，设计一个分配器，使用像Heap1和Heap2那样用于真实内存管理的类：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">typenameT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Heap</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecificHeapAllocator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">pointer</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size_type</span> <span class="n">numObjects</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">localityHint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Heap</span><span class="o">::</span><span class="n">alloc</span><span class="p">(</span><span class="n">numObjects</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">localityHint</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="n">pointer</span> <span class="n">ptrToMemory</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">numObjects</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Heap</span><span class="o">::</span><span class="n">dealloc</span><span class="p">(</span><span class="n">ptrToMemory</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后，使用<code>SpecificHeapAllocator</code>来把容器的元素集合在一起：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Heap1</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 把v和s的元素放进Heap1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Heap1</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">Heap2</span><span class="o">&gt;&gt;</span> <span class="n">L</span><span class="p">;</span> <span class="c1">// 把L和m的元素 放进Heap2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Heap2</span><span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子里，很重要的一点是「<strong>Heap1和Heap2是类型而不是对象</strong>」。</p>
<p>STL为用不同的分配器对象初始化相同类型的不同STL容器提供了语法。那是「<strong>因为如果Heap1和Heap2是对象而不是类型，那么它们将是不等价的分配器，那就违反了分配器的等价约束</strong>」。</p>
<p>只要遵循「<strong>相同类型的所有分配器都一定等价的限制条件</strong>」，你将毫不费力地使用自定义分配器来「<strong>控制一般内存管理策略，群集关系和使用共享内存以及其他特殊的堆</strong>」。</p>]]></description></item><item><title>Effective C++ (第3版) 精读总结 [4]</title><link>https://jianye0428.github.io/posts/partfour/</link><pubDate>Mon, 31 Jul 2023 07:26:06 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partfour/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-C++总结系列分为四部分，本文为第二部分，涉及原书第3~4章，内容范围Rule13~25。为方便书写，Rule13简写为R13。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<p>由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人<code>开发经验</code>新增一些个人感悟👉<code>By the way</code>环节。</p>
<h2 id="ch7-模板与泛型编程">CH7 模板与泛型编程</h2>
<h3 id="r41-了解隐式接口和编译期多态">R41 了解隐式接口和编译期多态</h3>
<p>面向对象编程的通常做法：</p>
<ul>
<li><strong>显式</strong>定义接口（参数和返回值类型都是确定的，函数签名 就是确定的）</li>
<li>虚函数实现<strong>运行时多态</strong></li>
</ul>
<p>那么编译期多态呢？在面向对象编程中，我们的答案通常是函数重载。</p>
<p>在Templates 及泛型编程中，更为注重的是<strong>隐式接口</strong>和<strong>编译期多态</strong>：</p>
<ul>
<li><code>隐式接口</code>:
Template的接口属于隐式接口，因为它类型不确定，所以是基于有效表达式来区分。再加上运算符重载等特性，隐式接口的自由度非常大。</li>
<li><code>编译期多态</code>:
Template的多态是通过Template具现化和函数重载决议发生于编译期。</li>
</ul>
<p>上述描述看起来有点抽象，分析下方Template函数代码：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doProcessing</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">someNastyWidget</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>doProcessing属于隐式接口，类型不定，传入不同类型T，就得到不同的函数。</p>
<p>由于 <code>操作符重载(operator overloading)</code> 的存在，隐式接口对传入的 T 类型的要求比较宽松，列举如下：</p>
<ol>
<li>T类型或其父类型具有 size() 接口，size() 接口返回类型S为整型或者S类型有 <code>bool operator&gt;(int)</code> 接口；</li>
<li>T类型有 <code>bool operator != (const T&amp;)</code>接口；或T类型可以隐式转换为某S类型，S可以与someNastyWidget进行 != 比较，或者干脆someNastyWidget就是T类型；</li>
<li>上述1 、 2 点的描述没有将 <code>operator &amp;&amp;</code> 考虑进来，否则情况会更为复杂，这里不赘述了。</li>
</ol>
<h3 id="r42-了解typename的双重意义">R42 了解typename的双重意义</h3>
<ul>
<li><code>typename</code> 和 <code>class</code> 关键字在声明 Template 参数的时候，没有任何区别
如下示例，效果是一致的：</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Widget</span> <span class="p">;</span> <span class="c1">//早期C++使用这个声明Template参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Widget</span><span class="p">;</span> <span class="c1">//现在更推荐用这个，暗示参数不一定是个class类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>使用关键字 <code>typename</code> 标识 <strong>嵌套从属类型名称</strong>
模板内的从属类型，是指在模板函数/模板类中，需要<strong>依赖传入的 template 参数间接表示</strong>的类型，如果呈嵌套状，就叫嵌套从属名称/类型。 如下示例的 <code>C::const_iterator</code> 就是嵌套从属类型。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">printContainer2ndVal</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">iter</span><span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;this container&#39;s second value is: &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*++</span><span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此时，typename 的作用就是告诉编译器 C::const_iterator 是个类型，否则会编译报错。此时可以用 class 关键字替代，但是不建议。</p>
<p>typename 使用范围不只是 template 函数内部，也包括了函数入参 ：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span>    <span class="c1">// 不允许使用 &#34;typename&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">);</span> <span class="c1">// 必须使用 &#34;typename&#34;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>⚠️ 其他特殊情况：不要在 基类列表base class list 或 成员初始化列member initialization list 使用 typename</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Nested</span><span class="p">{</span> <span class="c1">//基类列表不允许使用typename
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Nested</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="c1">// 成员初值列也不允许typename
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Nested</span> <span class="n">NestedType</span><span class="p">;</span><span class="c1">//结合typedef定义，常规用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">NestedType</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span><span class="c1">// 其他操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="r43-学习处理模板化基类内的名称">R43 学习处理模板化基类内的名称</h3>
<p><strong>模板化基类</strong>：指定义 template 模板类时，继承于某基类 Base<T>，这个 Base<T> 类就是模板化基类。</p>
<p>🤔 那么 Base<T> 类有关的函数等名称该如何处理，在子类中直接使用吗？还是有注意事项？这，就是本节要讨论的问题。示例如下：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Company</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MsgSender</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">SendPlain</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;send plain</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">SendEncrypted</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;send encrypted</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>  <span class="c1">// 基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Company</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LoggingMsgSender</span><span class="o">:</span> <span class="k">public</span> <span class="n">MsgSender</span><span class="o">&lt;</span><span class="n">Company</span><span class="o">&gt;</span><span class="p">{</span><span class="c1">//子类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">SendPlainMsg</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">SendPlain</span><span class="p">();</span><span class="c1">//  ==&gt; 这样直接调用是不行的，想想为什么？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述注释中问题的原因：因为当全特化时可随意去除 MsgSender 内的函数，那么编译器无法确定基类是否仍有 SendPlain 这个方法。所以，编译器干脆<strong>拒绝在编译时</strong>去模板化基类中<strong>主动寻找</strong>继承而来的名称。</p>
<p>解决方法有三个：</p>
<ol>
<li>使用 <code>this-&gt;</code> 调用SendPlain()，即可转化为运行时的问题，推荐这个方法；</li>
<li>使用 <code>using MsgSender::SendPlain;</code> 这样的 using 声明式，我们在 Rule 33: 避免遮掩由继承得来的名称 中用过这种方法，显式地告诉编译器扩大名称搜索范围，尝试去基类找找；</li>
<li>使用显式调用，即 <code>MsgSender::SendPlain();</code> ，但这样做的坏处是直接断绝了 virtual 函数的灵活性和可能，不太推荐</li>
</ol>
<h3 id="r44-将与参数无关的代码抽离templates">R44 将与参数无关的代码抽离templates</h3>
<p>通常，在非模板代码中，我们很容易看出重复的代码或者类，一般采用抽取公共部分为单独函数，或者采用类的继承/聚合等面向对象设计方式。</p>
<p>但是， template 有关的代码，有时代码重复是隐晦的。 这一节是为了解决 template 的 <code>代码膨胀(code bloat)</code> 问题，主要原则为 <code>共性与差异性分析(commonality and variability analysis)</code> 。</p>
<p>**某些不恰当的设计，会导致无畏的代码膨胀。**先看下方这个反面教材：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SquareMatrix</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">invert</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;size is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应用代码如下：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//下面这2句，模板类实例化 1 次。 invert函数有 1 份实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SquareMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">mat5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">SquareMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">mat5New</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//换成下面这2句，模板类实例化 2 次。invert函数有 2 份实现(问题暴露)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SquareMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">mat5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">SquareMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">mat10</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>膨胀原因</strong>：在编译器看来，SquareMatrix&lt;int, 5&gt; 和 SquareMatrix&lt;int, 10&gt; 是2个<strong>完全不同的 C++ 类</strong>，实例化了2次，生成了这2个类。试想，如果代码中还需要其他 size 的SquareMatrix ，都会再生成一个新类，那么最后二进制文件就多了许多重复的目标代码，也就是膨胀。</p>
<p>如果能<strong>抽离参数相关代码</strong>，做到尺寸无关，便可解决这个问题。</p>
<p><strong>解决思路</strong>：新建一个基类 BaseMatrix ，将尺寸参数传入给到基类作为成员变量保管，具体的数据可以用数组指针形式托管。不论有多少个与尺寸有关的派生类，一个 T 类型就<strong>只有一个基类</strong>，所以基类 <code>baseInvert</code> <strong>函数实现只有一份</strong>。</p>
<p><mark>基类实现</mark>代码如下：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BaseSqaureMatrix</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">BaseSqaureMatrix</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">,</span><span class="n">T</span><span class="o">*</span> <span class="n">dataPtr</span><span class="p">)</span> <span class="o">:</span><span class="n">n_</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dataPtr_</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">baseInvert</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;invert: pData = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dataPtr_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; , size = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n_</span>  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">SetDataPtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">dataPtr</span><span class="p">)</span> <span class="p">{</span> <span class="n">dataPtr_</span> <span class="o">=</span> <span class="n">dataPtr</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">*</span> <span class="n">dataPtr_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p><mark>目标派生类</mark>实现如下：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SquareMatrix</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseSqaureMatrix</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">SquareMatrix</span><span class="p">()</span> <span class="o">:</span><span class="n">BaseSqaureMatrix</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">data_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">SetDataPtr</span><span class="p">(</span><span class="n">data_</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">invert</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">baseInvert</span><span class="p">();</span> <span class="p">}</span><span class="c1">// 参考Rule43
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data_</span> <span class="p">;</span><span class="c1">// RAII管理资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最终效果：相同 T 类型的template实例类(比如SquareMatrix&lt;float,5&gt;和SquareMatrix&lt;float,6&gt;)，<mark>共享实现码</mark>，祛除代码膨胀。</p>
<h3 id="r45-运用模板成员函数接受所有兼容类型">R45 运用模板成员函数接受所有兼容类型</h3>
<p>众所周知，<code>Base *pBase = pDerived</code>; 这样普通类型裸指针的隐式转换是被 C++ 所认可的。</p>
<p>那么如果换成智能指针模板类 SmartPtr<Base> 和 SmartPtr <Derived> 呢，还能这样<strong>不需额外配置</strong>就随意转换吗，答案显然<strong>是不行</strong>的（纵然 Base 和 Derived 是兼容类型也不行）。</p>
<p>本节，就采用<mark>模板成员函数</mark>来解决这一问题。</p>
<ul>
<li><strong>使用模板成员函数，接受所有兼容类型的“泛化构造”/“泛化赋值”</strong>
<code>泛化(generalized)Copy构造</code>，是指接受其他兼容类型进行模板函数的Copy构造。举例一个粗糙的 RAII 智能指针实现，代码如下👇:
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SmartPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">SmartPtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">origPtr</span><span class="p">)</span> <span class="o">:</span><span class="n">originPtr_</span><span class="p">(</span><span class="n">origPtr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="n">SmartPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartPtr</span><span class="o">&amp;</span> <span class="n">smt</span><span class="p">)</span> <span class="o">:</span><span class="n">originPtr_</span><span class="p">(</span><span class="n">smt</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{}</span><span class="c1">// 正常Copy构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//正常copy操作符函数: 简单演示，就浅复制吧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SmartPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartPtr</span><span class="o">&amp;</span> <span class="n">smt</span><span class="p">)</span> <span class="p">{</span> <span class="n">originPtr_</span> <span class="o">=</span> <span class="n">smt</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="c1">//泛化构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SmartPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span><span class="o">:</span><span class="n">originPtr_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">//为了隐式转换不加 explict
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="c1">//泛化赋值操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SmartPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">originPtr_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="c1">//简单演示，浅复制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">*</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">originPtr_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">SmartPtr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">originPtr_</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">*</span> <span class="n">originPtr_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>有上述的代码支持，我们就能写出如下的应用代码：
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BaseObj</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DerivedObj</span><span class="o">:</span><span class="k">public</span> <span class="n">BaseObj</span> <span class="p">{};</span><span class="c1">//DerivedObj是BaseObj兼容类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">DerivedObj</span><span class="o">&gt;</span> <span class="n">smDerived</span><span class="p">(</span><span class="k">new</span> <span class="n">DerivedObj</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">BaseObj</span><span class="o">&gt;</span> <span class="n">smBase</span><span class="p">(</span><span class="n">smDerived</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">SmartPtr</span><span class="o">&lt;</span><span class="n">BaseObj</span><span class="o">&gt;</span> <span class="n">smBase2</span> <span class="o">=</span> <span class="n">smDerived</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>即使有 “泛化构造/ 赋值”，也需要正常的 Copy构造/赋值</strong>
注意，模板成员函数不会改变语言规则，也就是说“泛化构造”不能代替正常的 copy 构造函数。所以，需要同时声明正常的 Copy 构造函数和 Copy 赋值操作符函数。</li>
</ul>
<h3 id="r46-需要类型转换时请为模板定义非成员函数">R46 需要类型转换时请为模板定义非成员函数</h3>
<p>有时我们希望 class 支持类型转换，类似本书的另外一节👉 <a href="https://jianye0428.github.io/posts/parttwo/#r24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%B7%E9%87%87%E7%94%A8non-member"target="_blank" rel="external nofollow noopener noreferrer">Rule24:若所有参数皆需类型转换，请采用non-member<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 。</p>
<p>如果 Rule24 中的 Rational 类是 template 模板类，直接仿照 Rule24 利用 non-member 函数做混合运算是行不通的，原因是 <strong>template 实参推导</strong>是不采纳 “通过构造函数而发生的”隐式类型转换。</p>
<p>解决办法如下:</p>
<ul>
<li>
<p><strong>使用 “template class 内部的friend函数” 完成参数隐式转换</strong>
将 Rule24 的 non-member 的 <strong>operator *函数</strong>改为 <code>inline-friend</code> 函数，因为 template 实例化的时候需要找到该 friend 函数的定义实现，类外定义实现是会链接错误的，所以需要 inline 。
参考代码实现如下：</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RationalNew</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">RationalNew</span><span class="p">(</span><span class="n">T</span> <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span> <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span><span class="n">numerator_</span><span class="p">(</span><span class="n">numerator</span><span class="p">),</span> <span class="n">denominator_</span><span class="p">(</span><span class="n">denominator</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="nf">numerator</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">numerator_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="nf">denominator</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">denominator_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">()</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">(),</span><span class="n">lhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">numerator_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">denominator_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么，对如下的应用代码，就使用自如了：</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">RationalNew</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">oneHalf</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">RationalNew</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">oneHalf</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">RationalNew</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">oneHalf</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>若inline-friend函数体太大，可以抽离出类外辅助函数供inline调用</strong>
上述的 operator* 函数体只有一行，实现简单，但如果实现过程复杂代码量大，考虑 inline 带来的冲击以及代码可读性，可以抽取个函数出来供 inline-friend 调用。</p>
<p>修改方式如下：</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RationalNew</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="c1">//  其他部分略。注意 operator* 函数体实现，改为调用doMultiply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">friend</span> <span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">doMultiply</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 类外函数  doMultiply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">doMultiply</span><span class="p">(</span><span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">RationalNew</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">()</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="n">lhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="r47-请使用traits-classes表现类型信息">R47 请使用traits classes表现类型信息</h3>
<p>C++ 中通常把 Traits 称为<strong>类型萃取</strong>技术，即：在 template 编程中，获取模板参数的类型信息，并在编译阶段针对不同的类型响应不同的处理。同时，这个技术要求对C++<strong>内置类型built-in</strong> 和 <strong>用户自定义user-defined</strong> 类型的表现必须一样好。</p>
<p>本节讨论此议题，并且以一个 C++ 标准的模板函数作为切入口进行讨论(std::advance，作用是兼容不同类型迭代器，用于后续取用指定偏移量的元素 )。</p>
<p>下方 “By the way” 环节简单展示了 std::advance 标准C++的声明式和基本用法： 👇（单击展开）</p>
<p><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>std::advance 需要的头文件包含为 <code>#include&lt;iterator&gt;</code> ，再看下它的函数原型声明：</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Distance</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">advance</span><span class="p">(</span> <span class="n">InputIt</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">,</span> <span class="n">Distance</span> <span class="n">n</span> <span class="p">);</span>       <span class="c1">// C++17 之前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Distance</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">void</span> <span class="n">advance</span><span class="p">(</span> <span class="n">InputIt</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">,</span> <span class="n">Distance</span> <span class="n">n</span> <span class="p">);</span> <span class="c1">// 自C++17 开始
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再看下示例应用代码：</p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">vIter</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">vIter</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;after advance  3 offset: *vIter = &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">vIter</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">fNums</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">dIter</span> <span class="o">=</span> <span class="n">fNums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">dIter</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;after advance -2 offset: *dIter = &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">dIter</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">chList</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">cIter</span> <span class="o">=</span> <span class="n">chList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">cIter</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;after advance  2 offset: *cIter = &#34;</span> <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">cIter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最终输出信息如下：</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">after advance  <span class="m">3</span> offset: *vIter <span class="o">=</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl">after advance -2 offset: *dIter <span class="o">=</span> 0.5
</span></span><span class="line"><span class="cl">after advance  <span class="m">2</span> offset: *cIter <span class="o">=</span> <span class="m">30</span></span></span></code></pre></td></tr></table>
</div>
</div></div>
    </div>
  </div>
背景知识 👉 STL 迭代器按照功能分为 5 类，如下方表格所述：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>特点</th>
<th>应用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>input 迭代器</td>
<td>只向前移动，一次一步，只读</td>
<td>istream_iterators</td>
<td></td>
</tr>
<tr>
<td>output迭代器</td>
<td>只向前移动，一次一步，只写</td>
<td>ostream_iterators</td>
<td></td>
</tr>
<tr>
<td>forward迭代器</td>
<td>只向前移动，一次一步，可读写</td>
<td>single-list iterator</td>
<td></td>
</tr>
<tr>
<td>Bidirectional迭代器</td>
<td>双向移动，一次一步，可读写</td>
<td>set/multiset/map/multimap</td>
<td></td>
</tr>
<tr>
<td>random-access迭代器</td>
<td>双向移动，一次多步，可读写</td>
<td>vetor/deque/string</td>
<td></td>
</tr>
</tbody>
</table>
<p><mark>如何设计一个 trait_class 并运用起来呢？</mark></p>
<ul>
<li><strong>Step1： 确认若干个希望获取的类型信息</strong> (本例只有一个 iterator 类别信息)
针对5 种迭代器分类，C++ 提供了专属的 <strong>卷标结构tag struct</strong> 加以区分(可以理解为编译期的枚举作用)，继承关系如下：
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">input_iterator_tag</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">output_iterato_tag</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">forward_iterator_tag</span><span class="o">:</span><span class="k">public</span> <span class="n">input_iterator_tag</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">bidirectional_iterator_tag</span><span class="o">:</span> <span class="k">public</span> <span class="n">forward_iterator_tag</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">random_access_iterator_tag</span><span class="o">:</span> <span class="k">public</span> <span class="n">bidirectional_iterator_tag</span><span class="p">{};</span><span class="err">`</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>Step2：为该信息选一个名称</strong> (例如 iterator_category)
那么 vector，set之类的<strong>目标容器类</strong>，如何与上述 iterator_tag <strong>联系起来</strong>呢，需要一个名称传递出去：
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="c1">//省略template 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">iterator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>   <span class="c1">// ps: C++11 之后使用的都是 using 定义式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">random_access_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>Step3：提供一个 template 类和一组特化版本</strong>（特化版本支持某些特殊情况）
<code>Traits 技术</code>针对于迭代器的关键模板类 iterator_traits 定义如下：
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="o">&gt;</span>  <span class="c1">//  注意：使用的是 struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">iterator_traits</span> <span class="p">{</span> <span class="c1">//这里的 IterT 就可以传入vector等容器类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">IterT</span><span class="o">::</span><span class="n">iterator_category</span>  <span class="n">iterator_category</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>注意，这里的 IterT 类型不能是指针类型，因为 pointer 不能后续嵌套。那么就需要一个特化版本了，代码如下：
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">*&gt;</span><span class="p">{</span> <span class="c1">// 指针类型和 random 迭代器类似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="n">random_access_iterator_tag</span> <span class="n">iterator_category</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>至此，iterator_traits 的基本实现就完成了，也就是说 <code>iterator_traits&lt;IterT&gt;::iterator_category</code> 可以在编译期确定，接下来看看advance 函数如何使用它。</p>
<p>💗 正确做法：利用 <strong>函数重载overloading</strong> 技术，使得 <strong>trait classes 在编译期对类型执行 if … else 测试</strong>。</p>
<p>回顾我们的 advance 函数，只有迭代器类型 IterT 和 偏移量 DistT 。可以重载其子函数 doAdvance ，完成类型萃取后的自适应：</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator_tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bidirectional_iterator_tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">while</span> <span class="p">(</span><span class="n">d</span><span class="o">--</span><span class="p">)</span> <span class="o">++</span><span class="n">iter</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span> <span class="k">while</span> <span class="p">(</span><span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="o">--</span><span class="n">iter</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">input_iterator_tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Negative distance&#34;</span><span class="p">);}</span><span class="c1">//ps: msvc中的C++实现是采用编译期间的asset判定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">d</span><span class="o">--</span><span class="p">)</span> <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>自然地，advance 函数的实现如下所示：</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span>  <span class="n">advance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">doAdvance</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="n">d</span><span class="p">,</span> <span class="cm">/*不论 category 的tag类型是什么，重载能找到匹配函数。即编译期的 if...else 测试*/</span>
</span></span><span class="line"><span class="cl">              <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>至此，一个完整的 (以 iterator_traits 为例)Traits 技术实现与运用的过程就完成了。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>
<p>关于 iterator_traits ，不止有 iterator_category，还有 difference_type, value_type, pointer, reference 等4个成员，<a href="https://zh.cppreference.com/w/cpp/iterator/iterator_traits"target="_blank" rel="external nofollow noopener noreferrer">详细可参考 cpp参考手册：iterator_traits<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 。</p>
</li>
<li>
<p>C++ 标准库中类似 iterator_traits 应用了 Traits 技术的模板有十几个。</p>
<p>举例常用的数值类型萃取 <code>numeric_limits</code> ，需要注意2个细节：</p>
<ol>
<li>头文件是 #include<limits>;</li>
<li>成员函数 lowest/min/max 按照顺序，分别代表给定类型的 最低有限值、最小非负值、最大有限值。尤其是 float/double，取最小值是 lowest() ，不是 min().</li>
</ol>
</li>
</ul>
</div>
    </div>
  </div>
<h3 id="r48-认识template模板元编程">R48 认识Template模板元编程</h3>
<p><strong>TMP，模板元编程template metaprogramming</strong> ，是编写 template-based C++ 程序并执行于编译期的过程。TMP 过程结束后，若干 C++ 源码会被 templates 具现化出来，便会一如往常地被编译。</p>
<p>TMP 有 2 个强大的作用：</p>
<ol>
<li>可以完成非 TMP 的常规编程做不到的事情
比如代码生成，类型适配等。</li>
<li>可以将某些工作从运行期转移到编译期
可以将运行期的错误提前暴露在编译期，可以获得更小的可执行文件，更快地运行，更少地内存需求，缺点是明显增加编译时间。</li>
</ol>
<p>TMP 已被证明是个“<strong>图灵完备</strong>”的机器，意思是它强大到可以计算任何事物。使用 TMP 可以声明变量、执行循环、编写及调用函数…等等。</p>
<p>比较特别的是，TMP 实现上述各类功能的方式不同于常规 C++ 程序。比如上一节 Rule47 中使用重载完成了编译期的 if…else 条件分支。TMP 循环功能也通常会使用 “<strong>递归具现化</strong>” 来完成的。</p>
<p>下方代码示范如何使用 TMP 的方式来计算阶乘：</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">n</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Factorial</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>   <span class="c1">// 递归的形式体现: f(n) = n * f(n -1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">enum</span> <span class="p">{</span><span class="n">value</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>  <span class="c1">// 模板全特化: 实际是初始化 f(0) = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">enum</span> <span class="p">{</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么阶乘计算在编译期就完成了，运行时就是直接取用了：</p>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Factorial(&#34;</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;) = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Factorial(&#34;</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;) = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ch8-定制new和delete">CH8 定制new和delete</h2>
<h3 id="r49-了解new-handler的行为">R49 了解new-handler的行为</h3>
<p>当 <code>operator new</code> 无法满足某个内存分配需求时，一般会抛出 <code>std::bad_alloc</code> 异常。</p>
<blockquote>
<p>如果用 std::nothrow 修饰 new 操作符，使得内存分配阶段不会抛异常，失败了就返回 null 指针。举例 :</p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">pArr</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">[</span><span class="mh">0x1fffffff</span><span class="p">];</span> <span class="c1">//即使分配失败，也不抛异常，而是得到null指针.
</span></span></span><span class="line"><span class="cl"><span class="c1">//  nothroow-new 不能保证 class 后续的构造函数不抛异常
</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<p>new-hanlder 的使用示例如下：</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//先定义一个函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">OutOfMemTip</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;new memory fail,out of memory!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">abort</span><span class="p">();</span><span class="c1">//终止程序，若调试模式会弹窗提示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 故意制造new失败的情形，程序会调用 OutOfMemTip，触发std::abort()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">set_new_handler</span><span class="p">(</span><span class="n">OutOfMemTip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">pArr</span> <span class="o">=</span>  <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mh">0x1fffffff</span><span class="p">];</span><span class="c1">//约2GB,如果扛的住，调大这个数
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出这样的函数指针给了使用者非常大的设计弹性，可以做到以下事情：</p>
<ul>
<li>提前申请内存，让 new_handler 触发下一次分配使用；</li>
<li>安装另一个 new_handler ，或许新的 handler 可以申请到内存；</li>
<li>卸载 new_handler ，只要传 null 指针即可；</li>
<li>手动抛 std::bad_alloc 的异常；</li>
<li>不返回，通常调用 std::abort() 或 std::exit() ;</li>
</ul>
<p>🤔 我们思考另外一个问题：是否可以 让不同的 <strong>C++ 类拥有自己的 new-handler</strong> 呢？ C++ 标准机制是不支持的，我们可以自己实现。有两个实现途径，列举如下：</p>
<ol>
<li><strong>针对某个特定类 ，类内重载 static 类型的 <code>operator new</code> 以及 <code>set_new_handler</code>方法</strong>
具体实现略，只想指出这样做法有个明显弊端，就是每个类都得这么做，比较麻烦，也容易代码冗余。</li>
<li><strong>使用 CRTP 方法（即 <code>怪异的循环模板模式curiously recurring template pattern</code> ）将上述方法 1 塞进 template 类</strong>
这样做的好处是使用模板类赋予上述 operator new 和 set_new_hanler 的操作，使用起来方便。
CRTP 方法中的基类 NewHandlerSupport 实现如下 👇(点击打开折叠) ：</li>
</ol>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">NewHandlerSupport</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">set_new_handler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">p</span><span class="p">)</span><span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">oldHandler</span> <span class="o">=</span> <span class="n">currentHandler_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">currentHandler_</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">oldHandler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">oldHandle</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">set_new_handler</span><span class="p">(</span><span class="n">currentHandler_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">//new完后复原global-new-handler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">set_new_handler</span><span class="p">(</span><span class="n">oldHandle</span><span class="p">);</span><span class="c1">//原书使用RAII手法在还原这个handler，这里作用类似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">currentHandler_</span><span class="p">;</span><span class="c1">//初始化动作放到类外cpp文件里去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么目标类 <code>TestNewHandler</code> 只要基于 <code>CRTP</code> 方法继承于基类就可以了，实现如下：</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TestNewHandler</span> <span class="o">:</span> <span class="k">public</span> <span class="n">NewHandlerSupport</span><span class="o">&lt;</span><span class="n">TestNewHandler</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//不必声明 set_new_handler 或 operator new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//最终应用时也非常简单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TestNewHandler</span><span class="o">::</span><span class="n">set_new_handler</span><span class="p">(</span><span class="n">OutOfMemTip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">TestNewHandler</span><span class="o">*</span> <span class="n">pTestHandle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestNewHandler</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="r50-了解new和delete的合理替换时机">R50 了解new和delete的合理替换时机</h3>
<p>替换编译器提供的 <code>operator new</code> 和 <code>operator delete</code> 的 常见理由 如下：</p>
<ol>
<li>
<p><strong>检测运用上的错误</strong>
自定义的new/delete可以很方便地校验实际控制的区段内存，比如可以在目标区块前后额外空间添加内存签名(比如写入特定 int 值)，监测越界的问题。
越界分2种：underruns (区块内存起点之前) 和 overruns (区块内存末尾之后)。</p>
</li>
<li>
<p><strong>时间或内存使用的优化</strong>
通用的 new/delete 需要适用各种分配形态和场景，对于内存碎片或时间性能都是中庸水平。
对特定的需求和场景，定制化地内存管理会有很好的优化效果。</p>
</li>
<li>
<p><strong>收集内存使用的统计数据</strong>
对内存分配细节的把控，例如分配区块的大小分布、存续周期、FIFO/LIFO次序分配回收、内存峰值等情况。</p>
</li>
<li>
<p><strong>弥补默认内存分配器的 非最佳对齐位suboptimal alignment</strong>
例如x86体系结构CPU上访问double都是8bytes对齐，如果能在内存分配时就做好内存对齐，可提升访问效率。</p>
</li>
<li>
<p><strong>将相关对象成簇集中</strong>
比如已知某个数据结构往往一起使用，那么分配的时候应该尽量让所有数据的内存集中一些，避免频繁触发 换页中断page faults ，提升访问效率。</p>
</li>
<li>
<p><strong>其他的非传统行为</strong>
想完成一些系统编译器办不到的事情。比如希望分配释放共享内存的区块，但是只有 C-API 能做到，那就需要定制版的 new/delete 去包裹封装这样的API。</p>
</li>
</ol>
<h3 id="r51-编写new和delete时需固守常规">R51 编写new和delete时需固守常规</h3>
<p>上一个条款讲了重写 new/delete 的原因，这一节将讲述具体需要遵守的几个规则。</p>
<ol>
<li>
<p><strong>正确处理 new 失败的情况</strong>
如果分配正常，直接返回区块对应的指针即可。可如果失败，就必须得正确调用 new-handler 函数，参考 R49 了解new-handler的行为。</p>
</li>
<li>
<p><strong>如果要求分配 0 byte 空间</strong>
C++规定，如果客户要求分配 0 byte 内存申请，就返回 1byte 空间申请，并返回该有效地址。</p>
</li>
<li>
<p><strong>理解 operator new 内部的无穷循环</strong>
operator new 有个 while(true) 循环，分配成功可以return，或由 new-handler 为 nullptr 时抛出 std::bad_alloc 异常。伪代码pseudocode 如下：</p>
</li>
</ol>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="err">尝试分配</span> <span class="n">size</span> <span class="n">bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="err">分配成功</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>  <span class="n">target_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_handler</span> <span class="n">globalHandler</span> <span class="o">=</span> <span class="n">set_new_handler</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">set_new_handler</span><span class="p">(</span><span class="n">globalHandler</span><span class="p">);</span><span class="c1">//分配失败了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">globalHandler</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">globalHanler</span><span class="p">)();</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li><strong>当基类的 operator new 被子类继承时</strong>
当基类被继承时，成员 operator new 也一起被继承了，要注意的是基类和子类的 size 通常是不一样的。推荐实现如下：</li>
</ol>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span><span class="k">throw</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Base</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="c1">//子类走这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是，<strong>operator new[] 不能这样在基类中区分</strong>。因为即使在Base类，也无法假定每个元素是 sizeof(Base)，通常还有额外内存空间来保存元素个数。</p>
<ol start="5">
<li>operator delete 的注意事项
C++ 需要保证 “<code>删除NULL指针永远安全</code>”，所以必须兑现这个规则。针对null指针，就什么也不做，直接return。</li>
</ol>
<h3 id="r52-写了placement-new-也要写placement-delete">R52 写了placement-new 也要写placement-delete</h3>
<p>placement-new，是指“<code>除size参数以外，接受一个额外参数参与构造</code>”的 特定 operator-new。</p>
<p>其中，“<code>接受一个指针指向对象该被构造之处</code>”是<strong>最常使用</strong>的 placement-new，即“<code>一个特定位置上的new</code>”，形式如下为：</p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//这个特殊的也是最常涉及的 placement-new 已被纳入C++标准程序库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">pMemory</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>先暂时考虑一个调用了placement-new的正常构造过程：</p>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 有这样一个placement-new,接收一个ostream来log分配时的相关信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">logStream</span><span class="p">)</span> <span class="k">throw</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">*</span> <span class="n">pw</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">)</span> <span class="n">Widget</span><span class="p">;</span><span class="c1">//传入ostream
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于任何的new对象构造过程，至少可分为下述2个过程：</p>
<ol>
<li>operator new 分配对象需要的内存空间；</li>
<li>执行对应的构造函数
如果上述过程 1 成功了，过程 2 抛异常，已经申请的内存就需要及时回收避免memory-leak，运行期系统就会尝试寻找并调用“<strong>额外参数个数和类型都与operator new 一致的operator delete</strong>”，完成内存回收。</li>
</ol>
<p>那么上述事实，就是 placement-new 和 placement-delete 需要<strong>成对实现的理由</strong>。</p>
<p>针对上例额外参数是 std::ostream 的operator new，operator delete，类声明形式如下:</p>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">logStream</span><span class="p">)</span> <span class="k">throw</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//不抛异常时，最后对象析构时正常调用这个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pMemory</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//new抛异常时，调用这个 额外参数个数和类型都一致的 placement-delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pMemory</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">logStream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>⚠️ <strong>One More Thing</strong> : C++ 在global 作用域提供以下形式的 operator new:</p>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">throw</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span><span class="c1">//见条款49 new-Handler的行为
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>😎 所以，如果在class 内声明了上述 operator new， 则global作用域的 operator new 会被<code>名称遮掩</code>。</p>
<p>🤔 <code>解决办法</code>：在基类对global作用域的 ::operator new 进行封装调用，然后在子类中使用using 声明式破除名称遮掩。</p>
<h2 id="ch9-杂项讨论">CH9 杂项讨论</h2>
<h3 id="r53-不要轻易忽略编译器的警告">R53 不要轻易忽略编译器的警告</h3>
<ul>
<li>
<p><strong>严肃对待编译器发出的警告信息</strong>
编译器发出的警告信息，经常会被忽略。No-Warning是值得追崇的，除非你对编译 warning 信息是充分了解并确信是无关紧要的。</p>
<p>下面举一个较为常见的例子：</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BaseWarn</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetWarnInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="s">&#34;Base&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DerivedWarn</span> <span class="o">:</span><span class="k">public</span> <span class="n">BaseWarn</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetWarnInfo</span><span class="p">()</span>  <span class="p">{</span><span class="c1">//缺了const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="s">&#34;Derived&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如上代码所示，没有成功实现虚函数重写，而是造成了“<strong>名称遮掩</strong>”。
这样的错误较为隐蔽，有些编译器会给出警告信息，有些甚至连警告信息都没有（Ps：我自行测试了VS2017，没有warning信息）。
<code>如果编译器给出了警告信息，请认真对待</code>。</p>
</li>
<li>
<p><strong>不要过度依赖编译器的报警能力</strong>
还是上面的例子，不同编译器处理态度不同，警告信息甚至可能换个编译器就消失了。</p>
</li>
</ul>
<h3 id="r54-熟悉包括tr1在内的标准程序库">R54 熟悉包括TR1在内的标准程序库</h3>
<p><strong>C++ Technical Report 1 (TR1)</strong> 并非标准，而是一份草稿文件，对C++标准库的第一次扩展，它提出了对C++标准函式库的追加项目。</p>
<p>这份文件的目标在于「为扩充的C++标准函式库建立更为广泛的现实作品」。</p>
<blockquote>
<p><code>我的理解</code>：200x 年发布的 C++ 称为 “C++0x”，持续修改中，所有修改将合并于 TR1，最终绝大部分都定版、收录发布于 <strong>C++11</strong>。</p>
</blockquote>
<p>TR1详细叙述了许多新特性，都放在 <code>std::tr1</code> 命名空间内（以下简称 <code>tr1::</code> ），列举如下</p>
<ol>
<li><code>智能指针</code>：tr1::shared_ptr 和 tr1::weak_ptr ，RAII 基础，不赘述；</li>
<li><code>tr1::function</code>：表示 可调用物callable entity，即任何函数或函数对象，只要签名一致即可；</li>
<li><code>tr1::bind</code>：对函数调用的封装，将函数和其参数绑定一起；</li>
<li><code>Hash tables</code>：采哈希表形式参与构成，名称以 unordered_ 开头的 set/multiset/map/multimap；</li>
<li><code>正则表达式</code>：头文件在 <regrex> ；</li>
<li><code>Tuple 元组(或叫变量组)</code>：不定长变量组，是 std::pair 的一种泛化；</li>
<li><code>tr1::array</code>: 和 C 语言数组一样，是个定长数组，包裹了 STL 用法；</li>
<li><code>tr1::mem_fn</code>: 传入一个函数指针（支持对成员函数取址）作为入参，构造一个函数对象，进而调用，类似地还有 mem_fn_ref;</li>
<li><code>tr1::reference_wrapper</code>：“封装引用为一个对象”，通常用于对引用进行封装然后装入标准容器(直接往容器塞引用是不行的)；</li>
<li><code>随机数生成工具</code>：random_device，可以直接生成或者使用不同的 随机数引擎 和 随机分布算法进行生成，头文件是 <random>；</li>
<li><code>数学特殊函数</code>：包括Laguerre多项式、Bessel 函数、完全椭圆积分等特殊数学函数，注意，这些 在 C++17 才引入C++标准，可参考cppreference: special math ，头文件在 <cmath>；</li>
<li><code>C99兼容扩充</code> ：C99标准是C语言的官方标准第二版，1999年发布，TR1对其进行了兼容；</li>
<li><code>Type traits 类型萃取</code>：template编程的精华之一，参考 Rule47:使用trait表现类型信息，头文件为 &lt;type_traits&gt;，功能十分丰富，可参考cppreference: type_traits；</li>
<li><code>tr1::result_of</code> ：可以对函数返回值做推断，得到返回值类型，头文件为 &lt;type_traits&gt; ，示例用法如下：
<code>c++ // 假设有个函数 double calcDaySale(int); std::tr1::result_of&lt;calcDaySale(int)&gt;::type x = 3.14;//x就是double类型. C++11中直接 std::result_of </code>
更详细的定版TR1信息可以参考<a href="https://aristeia.com/EC3E/TR1_info.html"target="_blank" rel="external nofollow noopener noreferrer">Effective-C++：TR1 information<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</li>
</ol>
<h3 id="r55-让自己熟悉boost">R55 让自己熟悉Boost</h3>
<p>Boost是一个C++开发者集结的社群，也是个可自由下载的程序库集，网址是 <code>http://boost.org</code>。</p>
<p><strong>其特殊性</strong>：和C++标准委员会有着独一无二的密切关系，且具有很深影响力；接纳程序库非常严谨，需要一次以上的同行专家评审。</p>
<p>Boost 程序库集可处理的场景有许多（且<strong>囊括了TR1</strong>的实现），可区分出数十个类别，并且还在持续增加，<strong>列举一小部分</strong>如下：</p>
<ul>
<li><strong>字符串与文本处理</strong></li>
<li><strong>容器</strong></li>
<li><strong>函数对象与高级编程</strong></li>
<li><strong>泛型编程</strong>：覆盖一大组 traits classes</li>
<li><strong>模板元编程</strong>：覆盖一个针对编译器 assertions 而写的程序库，以及 Boost MPL程序库</li>
<li><strong>数学和数值</strong>:包括有理数、八元数、四元数、公约数、多重运算、随机数等等</li>
<li><strong>正确性与测试性</strong></li>
<li><strong>数据结构</strong></li>
<li><strong>语言间的支持</strong>：允许 C++ 和 Python 之间的无缝互联</li>
<li><strong>内存</strong>：覆盖Pool程序库和智能指针等</li>
<li><strong>杂项</strong>：包括 CRC 校验、日期和时间的处理、文件系统等内容</li>
</ul>
<p>总的来说，Boost 是一个社群，也是个网站。致力于免费、源码开放、同行复审的 C++ 程序库开发，非常值得经常访问与学习。</p>
<p>ref:</br>
[1]. <a href="https://blog.csdn.net/cltcj/category_12098441.html"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://kissingfire123.github.io/2022/05/17_effective-c-%e4%b9%8b%e9%98%85%e8%af%bb%e6%80%bb%e7%bb%93%e5%9b%9b/"target="_blank" rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2022/05/17_effective-c-%e4%b9%8b%e9%98%85%e8%af%bb%e6%80%bb%e7%bb%93%e5%9b%9b/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>]]></description></item><item><title>Effective C++ (第3版) 精读总结 [3]</title><link>https://jianye0428.github.io/posts/partthree/</link><pubDate>Mon, 31 Jul 2023 07:26:00 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partthree/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-C++总结系列分为四部分，本文为第二部分，涉及原书第3~4章，内容范围Rule13~25。为方便书写，Rule13简写为R13。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<p>由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人<code>开发经验</code>新增一些个人感悟👉<code>By the way</code>环节。</p>
<h2 id="ch5-实现">CH5. 实现</h2>
<h3 id="r26-尽可能延后变量定义式的出现时间">R26 尽可能延后变量定义式的出现时间</h3>
<ul>
<li>尽可能延后变量定义式的出现，可增加程序清晰度和效率
<ol>
<li>定义后，在使用前就遭遇抛异常
这种情况，如果是定义了对象<code>ObjectA a</code>，便白白地浪费了对象a的构造和析构成本。</li>
<li>不只是延后变量定义到使用时，而是尽量延后到能给它初值时</li>
</ol>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">encryptPassword</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">password</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&#34;Password is too short&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="c1">// 考虑1：在异常之后定义变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">encrypted</span><span class="p">(</span><span class="n">password</span><span class="p">);</span><span class="c1">//考虑2：定义延后至变量能赋初值的时机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">encrypt</span><span class="p">(</span><span class="n">encrypted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">encrypted</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>思考变量定义<strong>是否</strong>该在循环内</li>
</ol>
<ul>
<li>方法A：定义于循环外
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">w</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// other...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>方法B：定义于循环内
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="nf">w</span><span class="p">(</span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// other...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p><strong>究竟是A还是B方法好</strong>，取决于 <code>一个赋值成本</code>和<code>一组构造+析构</code>成本，这2者之间，如果是赋值成本低，那么A更好，否则B更好。</p>
<h3 id="r27-尽量少做转型动作">R27 尽量少做转型动作</h3>
<p>通常的转型是可能会这样写：函数风格的<code>int(expression)</code>或者C风格的(int)<code>expression</code>，这都被成为“旧式转型”。</p>
<ul>
<li>
<p>在C++中，有4种新式转型操作符：</p>
<ol>
<li><strong>const_cast (expression)</strong>
作用是移除变量的常量性(cast away the constness)，是唯一有此能力的操作符。</li>
<li><strong>dynamic_cast(expression)</strong>
作用是“安全向下转型”(safe downcasting)，决定某个对象是否属于某继承体系。耗费重大运行成本（原因：需要查询RTTI信息，而且不同编译器实现的方法和效率有所不同）。</li>
<li><strong>reinterpret_cast(expression)</strong>
执行低级转型，实际结果取决于编译器，移植性差。（比如int* 转为int）要清楚自己在做什么，慎用。</li>
<li><strong>static_cast(expression)</strong>
强迫隐式类型转换，代替C风格的&quot;旧式转换&quot;。也可以给变量加上const特性。</li>
</ol>
<p>新式转换的好处：很容易在代码找到“类型系统在何处转变或破坏”；对const特性的严控，让类型系统更健壮。</p>
</li>
<li>
<p>派生类里直接调用基类成员函数时，不要用转型</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecialWindow</span><span class="o">:</span><span class="k">public</span> <span class="n">Window</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onResize</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Window</span><span class="o">::</span><span class="n">onResize</span><span class="p">();</span><span class="c1">//不要使用 static_cast&lt;Window&gt;(*this).onResize();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>关于dynamic_cast需要注意的</p>
<ol>
<li>如何替代和避免
一般是持有一个<code>Base *pBase</code>，但是指向的是DerivedObj，于是转型为pDerived</li>
</ol>
<ul>
<li>可以这样修改：
修改设计，窄化类型，持有一个pDerived即可；或者将想做的事放到虚函数中，利用多态去完成。</li>
</ul>
<ol start="2">
<li>避免串联
避免下方这样的代码，一连串的dynamic_cast：</li>
</ol>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Window</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义子类 SpecialWindow1,SpecalWindow2,SpecialWindow3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Window</span><span class="o">*</span> <span class="n">winPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 省略winPtr的其他操作 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">SpecialWindow1</span> <span class="o">*</span><span class="n">psw1</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SpecialWindow1</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">winPtr</span><span class="p">)){</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>  <span class="nf">if</span><span class="p">(</span><span class="n">SpecialWindow2</span> <span class="o">*</span><span class="n">psw2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SpecialWindow2</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">winPtr</span><span class="p">)){</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>  <span class="nf">if</span><span class="p">(</span><span class="n">SpecialWindow3</span> <span class="o">*</span><span class="n">psw3</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SpecialWindow3</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">winPtr</span><span class="p">)){</span> <span class="p">...</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的代码又大又慢，每次继承体系有所改变，代码就需要重新检阅判断。这样的代码应该用“基于virtual函数调用”取代它。</p>
</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>自 <strong>C++11</strong> 起，针对智能指针 shared_ptr 的转型，推出了另外 4 个模版函数：</p>
<ul>
<li><code>std::static_pointer_cast</code>
函数的原型声明为：
<div class="highlight" id="id-47"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">static_pointer_cast</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>含义以及应用场景与 <code>static_cast</code> 类似，比如子类型指针转为父类型：
<div class="highlight" id="id-48"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">derivedPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">basePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="n">derivedPtr</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>或许我们会有疑问，是否有必要用这个函数进行转型呢，如下实现不是一样的吗?
<div class="highlight" id="id-49"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">basePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">derivedPtr</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span></span></span></code></pre></td></tr></table>
</div>
</div>🤔 当然不一样，static_cast&lt;T*&gt;((U*)nullptr)是未定义行为，而且就语法描述上来看，哪个更简洁不言自明。
另外，自 C++20 起支持右值引用，也就是如下形式：
<div class="highlight" id="id-50"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">static_pointer_cast</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>std::dynamic_pointer_cast</code>
含义以及应用场景与 dynamic_cast 类似，用法传参与 std::static_pointer_cast 类似，且自 C++20 起支持右值引用，不赘述。</li>
<li><code>std::const_pointer_cast：</code>与前 2 者类似，不赘述。</li>
<li><code>std::reinterpret_pointer_cast：</code>与前 3 者类似，不赘述。</li>
</ul>
</div>
    </div>
  </div>
<h3 id="r28-避免返回handles指向对象内部成分">R28 避免返回handles指向对象内部成分</h3>
<p>这里的<strong>handles（号码牌）包括</strong>指向对象内部的<strong>指针</strong>、<strong>迭代器</strong>、<strong>引用</strong>。</p>
<p>以下讲述当返回对象内部的handles时，存在的2个问题：</p>
<ul>
<li>可能会破坏封装性
考虑一个场景：public函数返回一个private成员的非const引用，就让外界有了修改private的机会，破坏了封装性。
此时，需要将非const引用改为const引用，只读属性。
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Pixel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Image</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>  <span class="c1">//注意：后面这const只保证成员变量vPixPtrs_不改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Pixel</span><span class="o">&amp;</span> <span class="n">GetThePixel</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>  <span class="n">vPixPtrs_</span><span class="p">[</span><span class="n">i</span><span class="p">];}</span><span class="c1">//隐患：其实外部调用者仍能直接修改Pixel的rgb值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 上一句的返回值应该改为 &#34;const Pixel&amp;&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;&gt;</span> <span class="n">vPixPtrs_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可能会引起“空悬handles”
即使用const解决了封装性的问题，因为很容易出现**“handles比其所指对象更长寿”**，可能存在对象已析构，但handles还留存的问题。尤其是临时变量的析构，不太容易察觉。
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SceneGraph</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Image</span> <span class="nf">CaptureImage</span><span class="p">(</span><span class="k">const</span> <span class="n">SceneGraph</span><span class="o">&amp;</span> <span class="n">graph</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//那么调用方可能会这样使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SceneGraph</span> <span class="n">Grap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//下面这句之后，Image临时对象被销毁，pPix指向一个不存在的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">Pixel</span> <span class="o">*</span><span class="n">pPix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">CaptureImage</span><span class="p">(</span><span class="n">Grap</span><span class="p">).</span><span class="n">GetThePixel</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div>注意，CaptureImage的确能返回一个临时Image对象，能成功调用GetThePixel，但这句结束后，临时对象立马会被销毁，造成空悬现象，或叫虚吊(dangling) ！</li>
</ul>
<h3 id="r29-为异常安全而努力是值得的">R29 为“异常安全”而努力是值得的</h3>
<p>“<strong>异常安全</strong>”是指，当异常抛出时，代码依然能做到如下2点：</p>
<ol>
<li>不泄露任何资源
包括内存资源，锁资源。</li>
<li>不允许数据败坏
不会因为异常而导致空悬指针等未定义行为。</li>
</ol>
<p>考虑下方的示例代码，（如果<code>new Image</code>抛<code>std::bad_alloc</code>异常）则会同时违背了上述2条：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PrettyMenu</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Mutex</span> <span class="n">mutex_</span><span class="p">;</span> <span class="c1">//互斥器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Image</span><span class="o">*</span> <span class="n">bgImage_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">imageChangeCnt_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">PrettyMenu</span><span class="o">::</span><span class="n">changeBackground</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">&amp;</span> <span class="n">imgSrc</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span><span class="c1">// 这个可以改为RAII的锁，来保证异常安全
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">delete</span> <span class="n">bgImage_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">imageChangeCnt_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//这里new Image抛异常，导致无法解锁；且bgImage_指向资源已经释放，空悬指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">bgImage_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Image</span><span class="p">(</span><span class="n">imageSrc_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="异常安全的3个等级">异常安全的3个等级</h4>
<p>异常安全的函数，有<strong>3个等级</strong>的异常安全保证，会满足<strong>三者之一</strong>：</p>
<ul>
<li>
<p><strong>基本承诺</strong>
如果异常被抛出，程序内的任何事务仍然保持在有效状态下，也没有任何数据败坏。比如上例中如果抛异常，会另外添加实现，使bgImage_持有某个默认图像，或保持原值，让程序继续有效运行。</p>
</li>
<li>
<p><strong>强烈保证</strong>
如果异常被抛出，程序状态不改变。这样的函数要么成功，要么退回到执行前的状态。</p>
<p>上述案例则应该会被修改成如下形式：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PrettyMenu</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Image</span><span class="o">&gt;</span> <span class="n">bgImage_</span><span class="p">;</span> <span class="c1">//RAII避免了异常发生时的资源泄漏和数据败坏
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//... 省略其他成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">PrettyMenu</span><span class="o">::</span><span class="n">changeBackground</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">&amp;</span> <span class="n">imgSrc</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">CLock</span> <span class="nf">ml</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span><span class="c1">//RAII封装的Lock类，详细可参考 阅读总结(二)-Rule14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">bgImage_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Image</span><span class="p">(</span><span class="n">imgSrc</span><span class="p">));</span><span class="c1">//若new失败，则不会reset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">++</span><span class="n">imageChangeCnt_</span><span class="p">;</span><span class="c1">//把事情做完再++count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>不抛异常</strong>
在原书中，这个“No Throw”不是绝对不抛异常，而是一旦意外抛异常，就会调用unexpected函数进而abort（例如<code>int doSomething() throw();//空白的异常明细</code>）。</p>
</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>原书中例子的 <strong>throw()</strong> 在不同编译器表现不一致，现在已经 <strong>不推荐使用</strong>。</p>
<p>更详细资料可参考<a href="http://gotw.ca/publications/mill22.htm"target="_blank" rel="external nofollow noopener noreferrer">A Pragmatic Look at Exception Specifications<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>和<a href="https://stackoverflow.com/questions/88573/should-i-use-an-exception-specifier-in-c"target="_blank" rel="external nofollow noopener noreferrer">Should I use an exception specifier in C++<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>在C++11中，有了更可靠有效的关键字noexcept，使用也很简单，有操作符和异常提示符两种作用，下方展示简单用法：</p>
<div class="highlight" id="id-51"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// 函数 f() 不会抛出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)()</span> <span class="k">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// fp 指向可能会抛出的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">void</span> <span class="n">pfa</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">);</span>  <span class="c1">// g 接收指向不会抛出的函数的指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// typedef int (*pf)() noexcept; // 错误
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>更详细的<code>noexcept</code>介绍可以访问<a href="https://zh.cppreference.com/w/cpp/language/noexcept"target="_blank" rel="external nofollow noopener noreferrer">cppreference：noexcept操作符<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>和<a href="https://zh.cppreference.com/w/cpp/language/noexcept_spec"target="_blank" rel="external nofollow noopener noreferrer">cppreference：noexcept异常说明符<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</div>
    </div>
  </div>
<h4 id="使用copy-and-swap保障异常安全">使用copy-and-swap保障异常安全</h4>
<p><code>copy-and-swap</code>技术：先拷贝一份想修改的对象，等修改彻底完成后（过程中不抛异常），再与原对象交换。</p>
<p>为了更形象展示这一过程，使用pIml手法对bgImage_封装一下：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ImgPimpl</span><span class="p">{</span> <span class="c1">//选用struct而非Class：方便；最后被private成员形式使用，封装性不用担心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Image</span><span class="o">&gt;</span> <span class="n">bgImage_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">imageChangeCnt_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么PrettyMenu类可以改为如下：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PrettyMenu</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Mutex</span> <span class="n">mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ImgPimpl</span><span class="o">&gt;</span> <span class="n">pImpl_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>  <span class="c1">//构造略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="n">PrettyMenu</span><span class="o">::</span><span class="n">changeBackground</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">&amp;</span> <span class="n">imgSrc</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>   <span class="c1">//参考 阅读总结(二)-Rule25
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">CLock</span> <span class="nf">ml</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span><span class="c1">//RAII封装的Lock类，详细可参考总结(二)-Rule14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ImgPimpl</span><span class="o">&gt;</span> <span class="n">pNewCopy</span><span class="p">(</span><span class="k">new</span> <span class="n">ImgPimpl</span><span class="p">(</span><span class="o">*</span><span class="n">pImpl_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">pNewCopy</span><span class="o">-&gt;</span><span class="n">bgImage_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Image</span><span class="p">(</span><span class="n">imgSrc</span><span class="p">));</span> <span class="c1">//修改副本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">++</span><span class="n">pNewCopy</span><span class="o">-&gt;</span><span class="n">imageChangeCnt_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">pImpl_</span><span class="p">,</span><span class="n">pNewCopy</span><span class="p">);</span><span class="c1">//改完之后swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="异常安全的连带影响side-effects">异常安全的连带影响(side effects)</h4>
<p>函数提供的“异常安全保证等级”只<strong>取决于</strong>其调用的<strong>各个子函数的“最不安全者”</strong>。</p>
<p>考虑以下函数SomeFunc代码：</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">SomeFunc</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// 对local状态做一份副本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f1</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">f2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>  <span class="c1">//将修改后的状态置换过来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>分析</code></strong>：显然copy-and-swap在尽力强烈保证异常安全，但是，f1或者f2的异常安全如果比较低，那么可能需要单独对f1，f2进行copy-and-swap，来尝试保证“强烈异常安全”；即使如此，如果f1能成功做了修改，但是f2修改失败了并回退，那么<strong>f1、f2整体</strong>看起来还是“<strong>改了一部分</strong>”。</p>
<p><strong><code>这也告诫我们</code></strong>，如果引入了异常不安全的旧代码，那么这种特性会波及其他代码。</p>
<p>就设计者而言，只能根据实际情况，尽可能保证“异常安全”，选择3个异常安全等级之一实施。</p>
<h3 id="r30-透彻了解inline的里里外外">R30 透彻了解inline的里里外外</h3>
<p><code>inline</code>是C++的关键字，表示内联函数。<code>直接在对应位置展开代码</code>，免去函数调用的开销，难以避免 “<strong>代码膨胀</strong>”问题。</p>
<p>使用inline时应该注意以下问题：</p>
<ul>
<li>
<p><strong>inline只是对编译器的申请</strong>
inline只是对编译器的申请/建议，不是强制命令，<strong>编译器有权利</strong> 对其认为不适合inline的函数<strong>拒绝</strong>inline。 （原书说：如果编译器拒绝，通常它会给出warning信息。实际本人实测VS2017没看到）
inline有2种申请方式 ：</p>
<ol>
<li>在函数定义 时使用关键字inline<strong>显式强调</strong></li>
<li>实现在Class内的成员函数或friend函数，属于<strong>隐式inline</strong></li>
</ol>
</li>
<li>
<p><strong>inline和Template没有任何必然联系</strong>
虽然有不少简短的Template函数是带有inline（例如下方的std::max），但不是必然为之，<strong>两者没有因果关系</strong>。</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//可以申请inline，但不是必须申请
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>编译器拒绝复杂函数进行inline</strong>
复杂函数的inline会带来较严重的“代码膨胀”问题，并且可能会更慢，因为增加了运行时的“额外换页”行为，降低了指令cache命中率。</p>
<ol>
<li>inline函数内不要出现循环或递归</li>
<li>虚函数也不适合做inline
因为inline是编译期间决定的事，而虚函数是运行时决定的事，两者就不是同一个场景的。</li>
<li>构造/析构函数也不适合做inline
编译器可能会在构造/析构函数内部做精妙复杂的异常处理；以及在继承体系下，Base类函数体到处inline膨胀。</li>
</ol>
</li>
<li>
<p><strong>以函数指针形式的调用通常不能inline</strong>
对绝大多数编译器而言，是否inline是compile阶段决定的事情，少数编译器放到了link阶段。</p>
<p>讨论大多数情况：需要在编译时得知inline的本体，而函数指针办不到，示例代码如下：</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{...}</span> <span class="c1">//假设编译器有意愿inline “对f的调用”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">pf</span><span class="p">)()</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span><span class="c1">//pf 执行f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">();</span>     <span class="c1">//这个调用将被inlined，因为是个正常调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pf</span><span class="p">();</span>     <span class="c1">//这个很可能不被inlined
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>过度inline对调试和发布带来困难</strong>
inline是代码嵌入与展开，而非函数调用，所以某些编译器不支持inline的单步Debug（就像宏展开一样不支持调试）；另外，inline只要已修改，涉及调用它的代码全都要编译，如果是non-inline则可能只需要重新link即可。</p>
</li>
</ul>
<h3 id="r31-将文件间的编译依赖关系降至最低">R31 将文件间的编译依赖关系降至最低</h3>
<p>C++的Class定义式包括了成员变量，假设某成员变量是类对象<code>ClassObjA a</code>，如果<code>ClassObjA</code>类的内部实现发生了改变（哪怕这个<code>ClassObjA.h</code>内只在某处加了一个空格 ），那么include了<code>ClassObjA.h</code>的所有<code>.h</code>文件<code>.cpp</code>文件都会<strong>重新编译</strong>。</p>
<p>👆这就是由“<strong>编译依赖</strong>”关系带来的问题。</p>
<p>使用 <code>PIMPL</code> 手法(pointer to implementation)可以很好地分离声明和定义：</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//Person.h文件  不需要include &#34;PersonImpl.h&#34;和&#34;BirthDay.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">PersonImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BirthDay</span><span class="p">;</span><span class="c1">// 前置声明代替include
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span><span class="c1">// 构造函数这里放实现无所谓，因为是函数指针，不需知道PersonImpl本体实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PersonImpl</span><span class="o">&gt;&amp;</span> <span class="n">pImpl</span><span class="p">);</span><span class="c1">//构造函数的实现也放到cpp里去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">BirthDay</span><span class="o">&amp;</span> <span class="n">GetBirthDay</span><span class="p">();</span><span class="c1">// 注意：这里只声明，把实现部分放到cpp里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetName</span><span class="p">();</span><span class="c1">//实现细节由pImpl_转发实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PersonImpl</span><span class="o">&gt;</span> <span class="n">pImpl_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//Person.cpp文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;PersonImpl.h&#34; //在&#34;PersonImpl.h&#34;文件内include那个&#34;BirthDay.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;Person.h&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意：Impl用法，相关的头文件里不要放置任何函数实现代码 。
上述做法可以让使用Person类的客户不需要再关心PersonImpl以及BirthDay的实现细节了，做到了“接口与实现分离”，关键点在于把“定义的依赖性” 换成 $\Rightarrow$ “<strong>声明的依赖性</strong>”。
这里突出了如何<strong>最小化编译依赖性</strong>的本质：<code>让头文件尽可能自我满足</code>，如果不行，也要依赖于其他文件的声明式而非定义式。</p>
<p>具体到设计策略上，有以下几种做法：</p>
<ul>
<li>
<p>如果能用object references 或 object pointers完成任务，就别用objects
如果要定义某类型的objects，就要使用定义式，指针和应用则可以只用声明式。</p>
</li>
<li>
<p>尽量以class声明式替换class定义式
函数声明种的Class类型可以只用声明式，即使以by-object-value形式传值也是如此。</p>
</li>
<li>
<p>为声明式和定义式提供不同的文件
比如Date类，分为只包含声明式的&quot;Datefwd.h&quot;和包含定义式的&quot;Date.h&quot;，那么使用时用声明式头文件代替前置声明，在需要应用代码client.cpp里include定义式头文件。这种方式在标准库里采用较多，参考<iosfwd>和<sstream>,<fstream>,<streambuf>等。</p>
</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>C/C++可以使用编译器预处理指令<font color=red><code>#pragma message</code></font>，打印出该文件是否参与此次编译，以及参与编译时被哪个文件所依赖。
<div class="highlight" id="id-52"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//比如可以在 testEffective.h 文件内加上这句，就能在编译输出信息里看到打印信息，观察到依赖关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#pragma message(&#34;testEffective.h 参与重新编译&#34;)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//还可以用于测试某些宏是否真的生效，有时IDE的高亮显示不准确而令人生疑。
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>关于头文件include的其他编写规范，可以参考：<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/#"target="_blank" rel="external nofollow noopener noreferrer">Google-C++风格指南：1.头文件<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
</div>
    </div>
  </div>
<p>使用 <font color><strong><code>Interface Class</code></strong></font> 也能做到接口和实现的真正分离：</p>
<p>这种方式常见于输出动态库给到客户使用，客户能见到接口定义和使用，但无法看到内部实现。</p>
<p>用法较为常见，不赘述，直接<strong>show-code</strong>：</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//VirtualPerson.h   //和 lib文件一起提供给到客户
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">VirtualPerson</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> <span class="c1">//create的返回值还可以根据需求，换成RAII的智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">VirtualPerson</span> <span class="o">*</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">salary</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Level</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Salary</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">VirtualPerson</span><span class="p">();</span><span class="c1">// avoid memory leak
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//VirtualPerson.cpp  //源码不提供给客户，而是编译好的二进制 lib文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">VirtualPerson</span><span class="o">*</span> <span class="n">VirtualPerson</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">salary</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//工厂方法，还可以生成其他子类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="nf">Engineer</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">salary</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">VirtualPerson</span><span class="o">::~</span><span class="n">VirtualPerson</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Engineer.h  //Engineer也是参与编译到 lib文件中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Engineer</span><span class="o">:</span> <span class="k">public</span> <span class="n">VirtualPerson</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Engineer</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span><span class="kt">int</span> <span class="n">salary</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Level</span><span class="p">()</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Salary</span><span class="p">()</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">level_</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">salary_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ch6-继承与面向对象设计">CH6. 继承与面向对象设计</h2>
<h3 id="r32-确定你的public继承塑造出is-a关系">R32 确定你的public继承塑造出is-a关系</h3>
<p>原书标题：<strong>Make sure public inheritance models “is-a”</strong>. 侯捷老师翻译为“塑模”，我个人更愿意称为“塑造”。</p>
<ul>
<li><strong>“public继承”意味着is-a</strong>
is-a，即“是一种”，就是说，适用于Base Class身上的每一件事，也一定适用于Derived Class身上。</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>面向设计对象的设计有著名的5大原则， SOLID 原则，每个字母分别代表一种原则：</p>
<ul>
<li>S–单一责任原则(SRP) –Single Responsibility Principle</li>
<li>O–开放封闭原则(OCP)– Open-Closed Principle</li>
<li>L–里式替换原则(LSP)– Liskov Substitution Principle</li>
<li>I –- 接口分离原则(ISP)–Interface Segregation Principle</li>
<li>D–-依赖倒置原则(DIP)– Dependency Inversion Principle</li>
</ul>
<p>更详细的叙述可以参考：<a href="https://cloud.tencent.com/developer/article/1503629"target="_blank" rel="external nofollow noopener noreferrer">腾讯云：SOLID原则<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</div>
    </div>
  </div>
<p>本节条款的中心思想即里氏替换原则：<strong>一个对象出现的地方都可以由其子类代替并且不会出错。</strong></p>
<p>继承关系有时候听起来很好理解，比如 <code>Class Student: public Person</code>理所应当，但有时也会导致误解。比如企鹅属于鸟类，但企鹅不会飞，那么基类<code>Bird::Fly</code>方法又当如何处理，下方满足设计意图：</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bird</span><span class="p">{</span>   <span class="c1">//... 不声明Fly()方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FylingBird</span><span class="o">:</span><span class="k">public</span> <span class="n">Bird</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Fly</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span><span class="p">{</span> <span class="c1">//... 不声明Fly()方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 注：如果Bird类以及子类都不考虑Fly()方法，那么Penguin直接继承于Bird即可
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>还有另一种场景，父类和子类对于同一个方法的数据修改规则不同，导致了继承体系的缺陷。
比如<code>Class Square:public Rectangle</code> $\rightarrow$ 正方形继承于长方形，但是考虑这样一个<strong>类外方法</strong>:</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">makeBigger</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">){</span>  <span class="c1">//普通非成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">oldHeight</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="p">.</span><span class="n">setWidth</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="p">()</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span><span class="c1">//如果r是Squqre，可能内部自动就长宽一起变了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">()</span> <span class="o">==</span> <span class="n">oldHeight</span><span class="p">);</span><span class="c1">//这个assert对于正方形就不合适了,贸然去除又违背设计本意
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应对上述这样的情况，就需要修改设计或修改继承体系了。</p>
<h3 id="r33-避免遮掩由继承得来的名称">R33 避免遮掩由继承得来的名称</h3>
<p>首先，什么是名称的遮掩，通俗地说，是指由于作用域不同带来的变量名覆盖。考虑下方代码：</p>
<div class="highlight" id="id-19"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;x is&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// local作用域找到了x，直接覆盖全局的x，输出0.1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么如果将继承体系考虑进来呢：<strong>Derived的作用域会覆盖Base的作用域</strong>，包括virtual和non-virtual。考虑下方代码：</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::mf1():x =&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::mf2()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::mf3()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::mf3():x =&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::mf1()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::mf3()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很明显存在名称遮掩的问题，Derived的mf1，mf3会遮掩子类的所有同名函数，测试结果如下：</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span><span class="p">.</span><span class="n">mf1</span><span class="p">();</span>      <span class="c1">//OK，输出: Derived::mf1()
</span></span></span><span class="line"><span class="cl"><span class="c1">//d.mf1(100);  编译报错，因为名称被遮掩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">d</span><span class="p">.</span><span class="n">mf2</span><span class="p">();</span>      <span class="c1">//OK，输出: Base::mf2()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">d</span><span class="p">.</span><span class="n">mf3</span><span class="p">();</span>      <span class="c1">//OK，输出: Derived::mf3()
</span></span></span><span class="line"><span class="cl"><span class="c1">//d.mf3(300);  编译报错，同理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">d</span><span class="p">.</span><span class="n">Base</span><span class="o">::</span><span class="n">mf3</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span> <span class="c1">//OK，输出: Base::mf3():x =300 . 但是不太建议这么写，丑！！
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>为解决上述问题，可以采用using声明式或转发函数
<ol>
<li>using 声明式
可以使用using声明式，让Derived可以忽略名称遮掩，看到Base作用域内的函数。可以让上方代码的“编译报错”消失，正常调用d.mf1(100)和d.mf3(300)。
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span><span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> <span class="c1">//修改本节内容中上方代码的Derived类的声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">mf1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">mf3</span><span class="p">;</span> <span class="c1">//这2个using使得Base类作用域内所有mf1,mf3函数都可见
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="c1">// ... 其他，略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>转发函数(forwarding function)
应用场景: 在private继承下，强调的是继承实现而非继承接口，如果想在子类的成员中调用父类函数，此时可以通过函数转发来实现。</li>
</ol>
<div class="highlight" id="id-23"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">private</span> <span class="n">Base</span><span class="p">{</span> <span class="c1">//改写本节上方代码，注意，是私有继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">Base</span><span class="o">::</span><span class="n">mf1</span><span class="p">();</span> <span class="c1">//拿到了父类的函数实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ... 该函数其他部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 应用代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span><span class="p">.</span><span class="n">mf1</span><span class="p">();</span>    <span class="c1">//调用成功，Derived::mf1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">d</span><span class="p">.</span><span class="n">mf1</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>  <span class="c1">//编译失败
</span></span></span></code></pre></td></tr></table>
</div>
</div>当然，public继承也能使用转发函数，写出<code>d.Base::mf3(300)</code>; 这样的代码。但是，一来public继承理应遵循&quot;is-a&quot;规则，using声明拿到所有被遮掩的接口；二来明显代码不美观。</li>
</ul>
<h3 id="r34-区分接口继承和实现继承">R34 区分接口继承和实现继承</h3>
<p>当一个子类Derived继承于父类Base，那么要时刻清楚，对于类中的成员函数，是想继承父类的接口，还是想继承父类的实现。</p>
<ul>
<li>
<p><strong>对于Public继承，接口总是会被继承</strong>
基于“<strong>is-a</strong>”的关系，作用于父类的任何事情也一定要适用于子类。</p>
</li>
<li>
<p><strong>声明纯虚函数(pure-virtual)的目的是让子类只继承函数接口</strong>
对于纯虚函数，子类必须重新实现该接口。注意，<code>父类可以选择性给出纯虚函数的实现</code>，但是一般不会给。</p>
</li>
<li>
<p><strong>隐患：从非纯虚函数(impure-virtual)同时继承接口和缺省实现</strong>
非纯虚函数，可以让子类选择是否重新实现该接口。那么，如果子类是有必要重写，但是<strong>忘记写了</strong>却默默用父类版本，便事与愿违了。
举例：父类Airplane有子类PlaneModelA、PlaneModelB、PlaneModelC，其中C型飞机不同于AB型，是新式飞机：</p>
<div class="highlight" id="id-24"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Airport</span> <span class="p">{...};</span><span class="c1">//机场类，实现略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Airplane</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">(</span><span class="k">const</span> <span class="n">Airport</span><span class="o">&amp;</span> <span class="n">destination</span><span class="p">);</span><span class="c1">//父类还会给出默认的fly实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PlaneModelA</span><span class="o">:</span> <span class="k">public</span> <span class="n">Airplane</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">// 不重写fly，继承父类的fly实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">PlaneModelB</span><span class="o">:</span> <span class="k">public</span> <span class="n">Airplane</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">// B和A一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">PlaneModelC</span><span class="o">:</span> <span class="k">public</span> <span class="n">Airplane</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">//新型飞机，本来要重写fly，结果忘了
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么这个<code>隐患该如何解决</code>呢，也就是说，在实现C型飞机类时别忘了fly方法？
核心思想是“<strong>切断virtual函数接口和其默认实现之间的连接</strong>”。</p>
<ol>
<li>方法1：设置fly为纯虚函数，并新增一个defaultyFly方法
注意细节：defaultFly方法要设置为protected属性的non-virtual函数，代码如下：
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Airplane</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">(</span><span class="k">const</span> <span class="n">Airport</span><span class="o">&amp;</span> <span class="n">destination</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 父类不给出实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">defaultFly</span><span class="p">(</span><span class="k">const</span> <span class="n">Airport</span><span class="o">&amp;</span> <span class="n">destination</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span><span class="c1">//默认的fly实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PlaneModelA</span><span class="o">:</span> <span class="k">public</span> <span class="n">Airplane</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>   <span class="c1">//纯虚接口,子类必须给出实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">(</span><span class="k">const</span> <span class="n">Airport</span><span class="o">&amp;</span> <span class="n">destination</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">defaultFly</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span> <span class="c1">//调用父类的缺省实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span><span class="c1">//PlaneModelB 和 PlaneModelA 类似,略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">PlaneModelC</span><span class="o">:</span> <span class="k">public</span> <span class="n">Airplane</span><span class="p">{</span> <span class="p">...};</span><span class="c1">// 重写fly方法
</span></span></span></code></pre></td></tr></table>
</div>
</div>这样写还有个好处：fly()和defaultFly()享有不同的保护级别。</li>
<li>方法2： 父类的默认实现塞到纯虚接口fly中
这样就不需要定义defaultFly方法了，因为子类必须实现fly方法，对于A 型、B型飞机，子类fly()转发一次父类的fly()即可，C类飞机实现新式的fly()。缺点是让原本在defaultFly内的实现内容暴露在外了(指public属性)。
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><pre><code>  个人认为，这方法2还有个缺点：它让虚基类的纯虚接口承载了接口实现，不够纯粹(比如需要输出给到客户，应该只继承接口)。
</code></pre>
</div>
    </div>
  </div></li>
</ol>
</li>
<li>
<p><strong>non-virtual函数具体指定接口继承和强制性实现继承</strong>
如果成员函数是non-virtual，表示它不打算在子类中有不同的行为，或者说，不变性凌驾于特异性。对应地，绝不应该在子类中重写non-virtual函数。</p>
</li>
</ul>
<h3 id="r35-考虑virtual函数的替代选择">R35 考虑virtual函数的替代选择</h3>
<p>假设这样一个场景：设计一款游戏，不同人物以不同方式计算生命值，那么$\Longrightarrow$ 设计继承体系，子类共同继承父类的public-virtual方法healthValue()，子类各自重新实现healthValue()接口。</p>
<p>😄很好，中规中矩，那么，有没有其他方式呢？</p>
<ul>
<li>
<p><strong><code>NVI手法(non-virtual interface)实现Template Method模式</code></strong>
思路就是父类定义个non-virtual的public方法healthValue()，调用virtual的private方法healthValueImpl。子类直接重写healthValueImpl，达到类似模版方法设计模式的效果。
父类<code>GameCharacter</code>设计如下：</p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GameCharacter</span><span class="p">{</span><span class="c1">//构造函数和虚析构均略去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">healthValue</span><span class="p">()</span><span class="k">const</span><span class="p">{</span> <span class="c1">//ps:方便展示，而写在了头文件里，成了inline
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;Do prepare works...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span><span class="c1">//事前，如加锁,写log,验证条件等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">retVal</span> <span class="o">=</span> <span class="n">healthValueImpl</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Do post works...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span><span class="c1">//事后,如解锁,更新数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">retVal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">healthValueImpl</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;default caculate process... GetValue:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">;</span><span class="c1">//随后进行计算，过程略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>子类<code>GoodGuy</code>和<code>BadGuy</code>设计如下：</p>
<div class="highlight" id="id-27"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GoodGuy</span><span class="o">:</span><span class="k">public</span> <span class="n">GameCharacter</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">healthValueImpl</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;goodGuy caculate ... GetValue: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span><span class="c1">//过程略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BadGuy</span><span class="o">:</span><span class="k">public</span> <span class="n">GameCharacter</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">healthValueImpl</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;badGuy caculate ... GetValue: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span><span class="c1">//过程略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应用端代码如下：</p>
<div class="highlight" id="id-28"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">GameCharacter</span><span class="o">&gt;</span> <span class="n">pGood</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">GoodGuy</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pGood</span><span class="o">-&gt;</span><span class="n">healthValue</span><span class="p">();</span> <span class="c1">//得到60
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">GameCharacter</span><span class="o">&gt;</span> <span class="n">pBad</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BadGuy</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pBad</span><span class="o">-&gt;</span><span class="n">healthValue</span><span class="p">();</span><span class="c1">//得到80
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong><code>用函数指针实现Strategy模式</code></strong>
主体思想是添加一个函数指针为private成员变量pFunc，这个函数通过外部传入，从而实现不同的行为。</p>
<div class="highlight" id="id-29"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GameCharacter</span><span class="p">;</span><span class="c1">//forward declaration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">defaultHealthCalc</span><span class="p">(</span><span class="k">const</span> <span class="n">GameCharacter</span><span class="o">&amp;</span> <span class="n">gc</span><span class="p">);</span><span class="c1">//默认算法实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">GameCharacter</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">HealthCalcFunc</span><span class="p">)(</span><span class="k">const</span> <span class="n">GameCharacter</span><span class="o">&amp;</span> <span class="n">gc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">GameCharacter</span><span class="p">(</span><span class="n">HealthCalcFunc</span> <span class="n">hcf</span> <span class="o">=</span> <span class="n">defaultHealthCalc</span><span class="p">)</span><span class="o">:</span><span class="n">calcFunc_</span><span class="p">(</span><span class="n">hcf</span><span class="p">){}</span><span class="c1">//传入函数指针,自定义实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">healthValue</span><span class="p">()</span><span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">calcFunc_</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">HealthCalcFunc</span> <span class="n">calcFunc_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个设计有2个有趣的<strong>设计弹性</strong>：</p>
<ol>
<li>即使同一个人物类型的不同实体，允许拥有不同的生命值计算方法；</li>
<li>某个人物对象的生命值计算方法，在其生命期内可以任意修改，只要添加一个set方法即可；</li>
</ol>
</li>
<li>
<p><strong><code>用std::function实现Strategy模式</code></strong>
private成员变量由上文的函数指针替换成std::function对象，相当于是<code>指向函数的泛化指针</code>。就<code>更具设计弹性</code>了。std::function可以传入函数指针、仿函数、std::bind函数对象。GameCharacter的类实现修改为：</p>
<div class="highlight" id="id-30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GameCharacter</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">(</span><span class="k">const</span> <span class="n">GameCharacter</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span>  <span class="n">healthCalcFunc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">GameCharacter</span><span class="p">(</span><span class="n">healthCalcFunc</span> <span class="n">hcf</span> <span class="o">=</span> <span class="n">defaultHealthCalc</span><span class="p">)</span><span class="o">:</span><span class="n">healthValueImpl_</span><span class="p">(</span><span class="n">hcf</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">healthValue</span><span class="p">()</span><span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;Do prepare works...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">retVal</span> <span class="o">=</span> <span class="n">healthValueImpl_</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// 这里改了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Do post works...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">retVal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">healthCalcFunc</span> <span class="n">healthValueImpl_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>传入函数指针</li>
</ol>
<div class="highlight" id="id-31"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="n">gameChashort</span> <span class="nf">quickHurtHealthCalc</span><span class="p">(</span><span class="k">const</span> <span class="n">GameCharacter2</span><span class="o">&amp;</span> <span class="n">gc</span><span class="p">);</span><span class="c1">//返回值不是int,可隐式转换;实现略去
</span></span></span><span class="line"><span class="cl"><span class="c1">//应用端代码如下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">GameCharacter</span> <span class="nf">quickGuy</span><span class="p">(</span><span class="n">quickHurtHealthCalc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">quickGuy</span><span class="p">.</span><span class="n">healthValue</span><span class="p">();</span><span class="c1">//内部调用quickHurtHealthCalc
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>传入仿函数
仿函数：即函数对象，而且重载了operator() 。</li>
</ol>
<div class="highlight" id="id-32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">HealthCalculator</span><span class="p">{</span><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">GameCharacter2</span><span class="o">&amp;</span> <span class="n">gc</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">180</span><span class="p">;</span><span class="c1">//省略实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//应用端代码如下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">GameCharacter</span> <span class="nf">functorGuy</span><span class="p">(</span> <span class="p">(</span><span class="n">HealthCalculator</span><span class="p">())</span> <span class="p">);</span><span class="c1">//用括号将仿函数括起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">functorGuy</span><span class="p">.</span><span class="n">healthValue</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>传入<code>std::bind</code>函数对象
std::bind是函数对象模板，接收一个函数指针f和若干函数入参得到fObj，调用fObj等同于调用带参数的f。本例代码如下：</li>
</ol>
<div class="highlight" id="id-33"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GameLevel</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> <span class="c1">//用类内函数作为函数指针f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">health</span><span class="p">(</span><span class="k">const</span> <span class="n">GameCharacter</span><span class="o">&amp;</span> <span class="n">gc</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mf">20.3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//应用端代码如下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">GameLevel</span>  <span class="n">curLevel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">GameCharacter</span> <span class="nf">levelGuy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GameLevel</span><span class="o">::</span><span class="n">health</span><span class="p">,</span> <span class="n">curLevel</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">levelGuy</span><span class="p">.</span><span class="n">healthValue</span><span class="p">();</span><span class="c1">//内部调用等价于curLevel.health(leveGuy);
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><pre><code>其实这里传入C++11新增的Lambda表达式作为std::function也是可以的，而且更方便，示例代码如下：
```c++
GameCharacter  lamGuy([&amp;](const GameCharacter&amp; gc){
 std::cout&lt;&lt; &quot;value is &quot; &lt;&lt; 75 &lt;&lt; std::endl;//具体计算略
   return 75;
   });
lamGuy.healthValue();
```
关于Strategy设计模式更多参考：
  - [Strategy设计模式-原理讲解](https://refactoringguru.cn/design-patterns/strategy)
  - [Strategy设计模式-C++代码参考](https://refactoringguru.cn/design-patterns/strategy/cpp/example)
</code></pre>
</div>
    </div>
  </div>
</li>
</ul>
<h3 id="r36-绝不重新定义继承而来的non-virtual函数">R36 绝不重新定义继承而来的non-virtual函数</h3>
<ul>
<li>
<p>由于名称遮掩，不要重新定义继承而来的non-virtual函数
看个反例：</p>
<div class="highlight" id="id-34"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">mf</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;B::mf()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">mf</span><span class="p">(){</span><span class="c1">//重新定义mf()，违反了Rule33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;D::mf()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么看这样的应用代码：</p>
<div class="highlight" id="id-35"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">D</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span><span class="o">*</span> <span class="n">pD</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">*</span> <span class="n">pB</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span><span class="p">.</span><span class="n">mf</span><span class="p">();</span>    <span class="c1">// 输出 D::mf()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pD</span> <span class="o">-&gt;</span> <span class="n">mf</span><span class="p">();</span><span class="c1">// 输出 D::mf()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pB</span> <span class="o">-&gt;</span> <span class="n">mf</span><span class="p">();</span><span class="c1">// 输出 B::mf()
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这就很诡异了！都通过对象d调用成员函数mf，调用结果应该相同。</p>
<p>另外一点，出于public继承的“<strong>is-a</strong>”特性，这样重新定义non-virtual函数也是<strong>对&quot;is-a&quot;的严重违背</strong>。</p>
</li>
</ul>
<h3 id="r37-绝不重新定义继承而来的缺省入参值">R37 绝不重新定义继承而来的缺省入参值</h3>
<p>这里说的缺省入参，指的是函数入参的默认值，在重写带有缺省入参的virtual函数时，不要修改那个默认参数的默认值。</p>
<p>原因：virtual函数为<code>动态绑定</code>特性，而缺省参数值是<code>静态绑定</code>特性。修改后会造成一些令人费解的现象。</p>
<p>请看下方反面教材：</p>
<div class="highlight" id="id-36"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">GREEN</span> <span class="p">,</span><span class="n">BLUE</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>  <span class="c1">// ：父类默认入参是RED
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">Color</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Shape:col is &#34;</span> <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rectangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">{</span> <span class="c1">// ：子类类修改默认入参为GREEN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Color</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">GREEN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Rectangle:col is &#34;</span> <span class="o">&lt;&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么当出现典型应用场景<code>Base* pB=new Derived</code>时，就会造成“父类子类各出一半力”的情形：</p>
<div class="highlight" id="id-37"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Shape</span> <span class="o">*</span><span class="n">pRec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pRec</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span> <span class="c1">// 输出：Rectangle:col is 0  （0是RED）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果确实调用子类draw，但是默认入参取的是基类的 RED，而非子类的GREEN。
那怎么修改合适呢，都带默认参数，且子类父类相同？带来一个<strong>耦合问题</strong>，如果父类改了，所有子类都得改。
正如Rule35提到的NVI(non-virtual interface)手法，此处便是绝佳的应用场景$\Longrightarrow$ draw方法改为默认参数的non-virtual，把virtual函数放到private里去，代码修改如下：</p>
<div class="highlight" id="id-38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>   <span class="c1">//子类继承该默认入参的non-virtual接口，别重写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">Color</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">drawImpl</span><span class="p">(</span><span class="n">col</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> <span class="c1">//纯虚函数是强制子类重写，看具体情况，impure-virtual也行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">drawImpl</span><span class="p">(</span><span class="n">Color</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//子类重写这个drawImpl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="r38-通过复合塑造出has-a或根据某物实现出">R38 通过复合塑造出has-a或&quot;根据某物实现出”</h3>
<p>原书标题：<code>Model “has-a” or “is-implemented-in-terms-of” through composition</code>，同Rule32，侯捷老师翻译为“塑模”。</p>
<p>复合关系（composition）是一种常见的类关系，当某种类型的对象内含有它种类型的对象时，便是此种关系。</p>
<p>复合关系分为2种：<code>&quot;has-a&quot;</code> 和 <code>“is-implemented-in-terms-of&quot;</code>。</p>
<ul>
<li>“<code>has-a</code>”关系：
指的是<strong>应用域</strong>部分，不参与内的具体各项实现。是一种单纯的完备对象的包含关系，比如Person类有Address、PhoneNumber、Job等类型的成员变量，又或是Image类有Buffer、Mutexx、SearchTree等类型的成员。</li>
<li>“<code>is-implemented-in-terms-of</code>“关系：
指的是<strong>实现域</strong>部分，参与类的各类实现，比如数据结构的设计中，想用现有的 std::list来实现Set类，这样可能效率不高(通常更具效率的实现是采用平衡查找树 )，但是可行。
📌：此处不能让Set以public继承于std::list，因为list允许重复元素，而Set不行，不满足“is-a”关系。
正确实现部分代码示例如下：
<div class="highlight" id="id-39"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Set</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">)</span><span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">rep_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">rep_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rep_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">contains</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="n">rep_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span><span class="c1">// 实现略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// 实现略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">rep_</span><span class="p">;</span> <span class="c1">//用来表述Set的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="r39-明智而审慎地使用private继承">R39 明智而审慎地使用private继承</h3>
<p>“明智而审慎”的意思是👉当考虑了其他方案对比后，仍然觉得private继承是最合适的，才使用它。</p>
<p>首先明确private继承的2个特性：</p>
<ol>
<li>编译器不会自动将一个derived-class对象隐式转换为base-class对象(函数入参时)；</li>
<li>继承而来的成员，在derived-class中都会变成private属性；</li>
</ol>
<p>private继承的意义：意味着<strong>implemented-in-terms-of</strong>，在类关系设计上没有太大意义，只看重软件实现。</p>
<p>考虑以下使用private的2个应用场景：</p>
<ul>
<li>
<p><strong>derived-class想继承base-class的某public接口实现，但又想隐藏此接口</strong>
考虑如下应用场景：对于一个已知的类Widget，想用另一个已知的计时类Timer辅助性能分析，在尽量小改动已有代码的情况下，如何启用Timer？
private继承做法：让Widget类private继承于Timer，重写父类Timer的onTick函数。
具体代码如下：</p>
<div class="highlight" id="id-40"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Timer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Timer</span><span class="p">(</span><span class="kt">int</span> <span class="n">tickFrequency</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">onTick</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">//定时器滴答一次，自动被调用一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span><span class="k">private</span> <span class="n">Timer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> <span class="c1">// private继承而来的所有成员都是private属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onTick</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">//查看并记录Widget数据，资源等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该问题除了上方的private继承，能不能用其他方案替代private继承呢？
👉👉“public继承+复合”替代private继承：在Widget内部嵌套定义private属性的新类WidgetTimer:private Timer，即可同样启用Timer且隐藏了Timer。代码如下：</p>
<div class="highlight" id="id-41"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">WidgetTimer</span><span class="o">:</span><span class="k">public</span> <span class="n">Timer</span><span class="p">{</span><span class="c1">// 类内嵌套定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onTick</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">WidgetTimer</span> <span class="n">wTimer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>⭐⭐ WidgetTimer也可以不定义在Widget类内,类内只放WidgetTimer* 和WidgetTimer的前置声明，完全解耦合，<strong>降低编译依赖性</strong>。而这样的设计自由度是单纯的private继承不具备的。</p>
</li>
<li>
<p><strong>空白基类最优化(EBO,empty base optimization)</strong>
⚡值得一提：空类(Empty Class)是指不含non-static数据成员和virtual-func的类。
空类的size会被C++强制要求至少为1，通常是用1个char占位。如果让Empty-Class作为数据成员，因为内存对齐而导致Derived-Class浪费内存。
示例代码 👇：</p>
<div class="highlight" id="id-42"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Empty</span> <span class="p">{</span> <span class="c1">// 空类，1字节. 不含non-static数据，不含virtual
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">privteFoo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;private non-virtual.&#34;</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="kt">char</span><span class="o">*</span>  <span class="n">pChar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">pFuncReadData</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">url</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="k">class</span> <span class="nc">clolr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">red</span><span class="p">,</span><span class="n">green</span><span class="p">,</span><span class="n">blue</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;public non-virtual!&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="p">;</span><span class="c1">//static 数据也不属于class实体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HoldsIntsAndEmpty</span> <span class="p">{</span> <span class="c1">//内存对齐后12字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">x_</span><span class="p">;</span>   <span class="c1">// 4字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Empty</span> <span class="n">e_</span><span class="p">;</span> <span class="c1">// 1字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">y_</span><span class="p">;</span>   <span class="c1">// 4字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HoldsInts</span><span class="o">:</span><span class="k">private</span> <span class="n">Empty</span> <span class="p">{</span><span class="c1">//使用EBO,类大小8字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">x_</span><span class="p">;</span><span class="c1">//4字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">y_</span><span class="p">;</span><span class="c1">//4字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>EBO优化可以减少Derived-Class的内存大小，注意EBO只适用于单继承。</p>
</li>
</ul>
<h3 id="r40-明智而审慎地使用多重继承">R40 明智而审慎地使用多重继承</h3>
<p>多重继承(multiple inheritance)是指继承一个以上的父类。但是这些父类应该避免拥有共同的祖父类，会形成比较麻烦的“菱形继承”(或者叫钻石继承)。</p>
<ul>
<li>
<p><strong>多重继承的成本以及副作用</strong>
上面说“菱形继承”比较麻烦，主要原因是如果祖父类如果拥有某个成员变量x，那么2个父类分别public形式继承了x，到了目标子类就有了2份x。
解决问题的办法是<strong>虚继承</strong>(virtual inheritance)，如此，上述子类只有一份x。为保证虚继承的正确性，编译器在背后需要付出更多代价，可能造成子类内存更大或运行速度更慢。
👉如果存在菱形继承，那么祖父类尽量不要持有数据成员。
虚继承示例代码如下：</p>
<div class="highlight" id="id-43"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">File</span><span class="p">{...};</span>  <span class="c1">//祖父类最好不要持有non-static数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">InputFile</span><span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">File</span><span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OutputFile</span><span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">File</span><span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">IOFile</span><span class="o">:</span><span class="k">public</span> <span class="n">InputFile</span><span class="p">,</span><span class="k">public</span> <span class="n">OutputFile</span><span class="p">{...};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>应用场景：public继承接口+private继承实现</strong>
思考这样的应用场景，PersonBase类是虚基类，RealPerson是目标子类（需要继承接口），但是获取name和birthDate信息的函数在另一个PersonInfo类都有了现成的实现（只需要简单修改该实现）。</p>
<p>两者结合后，即让RealPerson类public继承于PersonBase，private继承于PersonInfo。</p>
<div class="highlight" id="id-44"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PersonBase</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">PersonBase</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">birthDate</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PersonInfo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span>  <span class="o">~</span><span class="n">PersonInfo</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">PersonInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">pID</span><span class="p">)</span><span class="o">:</span><span class="n">id_</span><span class="p">(</span><span class="n">pID</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">theName</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="kt">char</span> <span class="n">value</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">exampleName</span> <span class="o">=</span> <span class="s">&#34;Luka&#34;</span><span class="p">;</span><span class="c1">// 计算过程略,用固定字符串替代
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">strcpy</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">valueDelimLeft</span><span class="p">());</span>   <span class="c1">// 获取左界定符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">strcat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">exampleName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">strcat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">valueDelimRight</span><span class="p">());</span><span class="c1">// 获取右界定符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">theBirthDate</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;1990-1-1&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">valueDelimLeft</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;[&#34;</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">valueDelimRight</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;]&#34;</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>多重继承的代码为👇:</p>
<div class="highlight" id="id-45"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RealPerson</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PersonBase</span><span class="p">,</span> <span class="k">private</span> <span class="n">PersonInfo</span> <span class="p">{</span><span class="c1">//多重继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">RealPerson</span><span class="p">(</span><span class="kt">int</span> <span class="n">pID</span><span class="p">)</span> <span class="o">:</span><span class="n">PersonInfo</span><span class="p">(</span><span class="n">pID</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// 委托构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="c1">//实现必要的虚基类Person的pure-virtual成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">PersonInfo</span><span class="o">::</span><span class="n">theName</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">birthDate</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">PersonInfo</span><span class="o">::</span><span class="n">theBirthDate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">valueDelimLeft</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">;</span> <span class="p">};</span><span class="c1">//重写界定符函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">valueDelimRight</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最后应用端代码：</p>
<div class="highlight" id="id-46"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">RealPerson</span> <span class="nf">rPerson</span><span class="p">(</span><span class="mi">613</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rPerson</span><span class="p">.</span><span class="n">name</span><span class="p">();</span> <span class="c1">//输出Luka ,而不是[Luka]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，多重继承体系完美解决该问题。</p>
</li>
</ul>
<p>回到本节开头，明智和审慎的意思是👉即使多重继承可以用单继承方案替代解决，思考后，如果多重继承依然是最简洁、最易维护、最合理的做法，那就选择它。</p>
<p>ref:</br>
[1]. <a href="https://blog.csdn.net/cltcj/category_12098441.html"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://kissingfire123.github.io/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"target="_blank" rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>]]></description></item><item><title>Effective STL [7] | 当使用new得指针的容器时，记得在销毁容器前delete那些指针</title><link>https://jianye0428.github.io/posts/clause_7/</link><pubDate>Wed, 26 Jul 2023 18:18:11 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_7/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="stl容器能够做的事情">STL容器能够做的事情</h2>
<ul>
<li>
<p>提供了前向和逆向遍历的迭代器（通过<code>begin</code>、<code>end</code>、<code>rbegin</code>等）；</p>
</li>
<li>
<p>能告诉你所容纳的对象类型（通过<code>value_type</code>的<code>ttypedef</code>）；</p>
</li>
<li>
<p>在插入和删除中，负责任何需要的内存管理；</p>
</li>
<li>
<p>报告容纳了多少对象和最多可能容纳的数量（分别通过<code>size</code>和<code>max_size</code>）；</p>
</li>
<li>
<p>当容器自己被销毁时会自动销毁容纳的每个对象。</p>
</li>
</ul>
<h2 id="容器内包含指针">容器内包含指针</h2>
<p>虽然STL容器被销毁时，能够自动销毁容纳的每个对象，但是如果这些对象是通过new分配的对象的指针时，它不会调用<code>delete</code>，销毁指针所指向的对象。</p>
<p><strong>Example</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;</span> <span class="n">vwp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SOME_MAGIC_NUMBER</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vwp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// Widgets在这里泄漏！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码将直接导致内存泄露。</p>
<p>当<code>vwp</code>结束其生命周期后，<code>vwp</code>的每个元素都被销毁，但不会<code>delete</code>每个<code>new</code>得到的对象。</p>
<p>那样的删除是你的职责，而不是vector的。这是一个特性。只有你知道一个指针是否应该被删除。</p>
<p>可以很简单地实现：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;</span> <span class="n">vwp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vwp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">!=</span> <span class="n">vwp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">delete</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段销毁的代码，仍然有2个问题：</p>
<ul>
<li>新的for循环代码比for_each多得多，没有使用for_each来的清楚</li>
<li>这段代码不是异常安全的。如果在用指针填充了vwp的时候和你要删除它们之间抛出了一个异常，你会再次资源泄漏。</li>
</ul>
<p><strong>for_each删除对象</strong></p>
<p>要把你的类似for_each的循环转化为真正使用for_each，你需要把delete转入一个函数对象中。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DeleteObject</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 这里有这个继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在可以这么删除对象</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">HappyWork</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">for_each</span><span class="p">(</span><span class="n">vwp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vwp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DeleteObject</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>问题</strong></p>
<p>如果有人编写了一个类，该类继承了 string</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecialString</span><span class="o">:</span> <span class="k">public</span> <span class="n">string</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是很危险的行为，因为string，就像所有的标准STL容器，<strong>缺少虚析构函数</strong>，而从没有虚析构函数的类公有继承是一个大的C++禁忌。</p>
<p>当他删除 SpecialString 时就会资源泄露</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">deque</span><span class="o">&lt;</span><span class="n">SpecialString</span><span class="o">*&gt;</span> <span class="n">dssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">for_each</span><span class="p">(</span><span class="n">dssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="c1">// 行为未定义！通过没有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DeleteObject</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">// 虚析构函数的基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// 指针来删除派生对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>解决</strong></p>
<p>可以通过编译器推断传给<code>DeleteObject::operator()</code>的指针的类型来消除这个错误（也减少DeleteObject的用户需要的击键次数）。</p>
<p><strong>把模板化从DeleteObject移到它的operator()</strong>：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DeleteObject</span> <span class="p">{</span> <span class="c1">// 删除这里的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 模板化和基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 模板化加在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过传给<code>DeleteObject::operator()</code>的指针的类型，自动实例化一个<code>operator()</code>。这种类型演绎下降让我们放弃使<code>DeleteObject</code>可适配的能力</p>
<p>现在删除 SpecialString 就会正常了</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">deque</span><span class="o">&lt;</span><span class="n">SpecialString</span><span class="o">*&gt;</span> <span class="n">dssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">for_each</span><span class="p">(</span><span class="n">dssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DeleteObject</span><span class="p">());</span> <span class="c1">// good！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red>现在仍不是异常安全的。</font></p>
<p>果在SpecialString被new但在调用for_each之前抛出一个异常，就会发生泄漏。</p>
<p>这个问题可以以多种方式被解决，但最简单的可能是用<strong>智能指针的容器来代替指针的容器，典型的是引用计数指针</strong>。</p>
<h2 id="boost库中的shared_ptr">Boost库中的shared_ptr</h2>
<p>利用Boost的shared_ptr，本条款的原始例子可以重写为这样：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_</span> <span class="n">ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">SPW</span><span class="p">;</span> <span class="c1">//SPW = &#34;shared_ptr to Widget&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">SPW</span><span class="o">&gt;</span> <span class="n">vwp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SOME_MAGIC_NUMBER</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">vwp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SPW</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">));</span> <span class="c1">// 从一个Widget建立SPW,然后进行一次push_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// 这里没有Widget泄漏，甚至在上面代码中抛出异常
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>STL容器很智能，但它们没有智能到知道是否应该删除它们所包含的指针。</p>
<p>当你要删除指针的容器时要避免资源泄漏，你必须<strong>用智能引用计数指针对象</strong>（比如<code>Boost</code>的<code>shared_ptr</code>）来代替指针，或者你<strong>必须在容器销毁前手动删除容器中的每个指针</strong>。</p>]]></description></item><item><title>Effective STL [8] | 永不建立auto_ptr的容器</title><link>https://jianye0428.github.io/posts/clause_8/</link><pubDate>Thu, 27 Jul 2023 07:45:11 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_8/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="拷贝一个auto_ptr将改变它的值">拷贝一个auto_ptr将改变它的值</h2>
<p>当你拷贝一个<code>auto_ptr</code>时，<code>auto_ptr</code>所指向对象的所有权被转移到拷贝的<code>auto_ptr</code>，而被拷贝的<code>auto_ptr</code>被设为<code>NULL</code>。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">in</span><span class="p">)</span> <span class="o">:</span> <span class="n">randy</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">randy</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">.</span><span class="n">randy</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">randy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw1</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span> <span class="c1">// pw1指向一个Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw2</span><span class="p">(</span><span class="n">pw1</span><span class="p">);</span> <span class="c1">// pw2指向pw1的Widget; pw1被设为NULL。（Widget的所有权从pw1转移到pw2。）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pw1</span> <span class="o">=</span> <span class="n">pw2</span><span class="p">;</span> <span class="c1">// pw1现在再次指向Widget； pw2被设为NULL
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有意思的是，如果你建立一个<code>auto_ptr&lt;Widget&gt;</code>的<code>vector</code>，然后使用一个指向的<code>Widget</code>的值的函数对它进行排序：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">widgetAPCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="n">lhs</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">rhs</span><span class="p">;</span> <span class="c1">// 假设Widget 存在operator&lt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">w1</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">w2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">widgets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">w1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">widgets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">w2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">widgets</span><span class="p">;</span> <span class="c1">// 建立一个vector，然后用Widget的auto_ptr填充它；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 记住这将不能编译！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">widgetAPCompare</span><span class="p">);</span><span class="c1">// 排序这个vector
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码将不能编译</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">warning: ‘template&lt;class&gt; class std::auto_ptr’ is deprecated <span class="o">[</span>-Wdeprecated-declarations<span class="o">]</span>
</span></span><span class="line"><span class="cl">   <span class="m">30</span> <span class="p">|</span>   std::vector&lt;auto_ptr&lt;Widget&gt; &gt;
</span></span><span class="line"><span class="cl">      <span class="p">|</span>               ^~~~~~~~
</span></span><span class="line"><span class="cl">In file included from /usr/include/c++/9/memory:80,
</span></span><span class="line"><span class="cl">                 from temp.cpp:10:
</span></span><span class="line"><span class="cl">/usr/include/c++/9/bits/unique_ptr.h:53:28: note: declared here
</span></span><span class="line"><span class="cl">   <span class="m">53</span> <span class="p">|</span>   template&lt;typename&gt; class auto_ptr<span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>                            ^~~~~~~~
</span></span><span class="line"><span class="cl">temp.cpp:33:3: warning: ‘template&lt;class&gt; class std::auto_ptr’ is deprecated <span class="o">[</span>-Wdeprecated-declarations<span class="o">]</span>
</span></span><span class="line"><span class="cl">   <span class="m">33</span> <span class="p">|</span>   auto_ptr&lt;Widget&gt; w1<span class="o">(</span>new Widget<span class="o">(</span>3<span class="o">))</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>   ^~~~~~~~</span></span></code></pre></td></tr></table>
</div>
</div><p>从概念上看所有东西也都很合理，但结果却完全不合理。例如，在排序过程中widgets中的一个或多个auto_ptr可能已经被设为NULL。</p>
<p>排序这个vector的行为可能已经改变了它的内容！</p>
<h2 id="剖析">剖析</h2>
<p>实现<code>sort</code>的方法是使用了<strong>快速排序算法</strong>的某种变体。</p>
<p>排序一个容器的<strong>基本思想</strong>是，选择容器的某个元素作为“主元”，然后对大于和小于或等于主元的值进行递归排序。</p>
<p>在sort内部，这样的方法看起来像这样：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Compare</span><span class="o">&gt;</span><span class="c1">// 这个sort的声明直接来自于标准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个typedef在下面解释
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">ElementType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">RandomAccessIterator</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// 让i指向主元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ElementType</span> <span class="n">pivotValue</span><span class="p">(</span><span class="o">*</span><span class="p">);</span> <span class="c1">// 把主元拷贝到一个局部临时变量中；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">...</span> <span class="c1">// wor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>源码为：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">_Compare</span> <span class="n">__comp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// concept requirements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">__glibcxx_function_requires</span><span class="p">(</span><span class="n">_Mutable_RandomAccessIteratorConcept</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_RandomAccessIterator</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">__glibcxx_function_requires</span><span class="p">(</span><span class="n">_BinaryPredicateConcept</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">__glibcxx_requires_valid_range</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">__glibcxx_requires_irreflexive_pred</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span> <span class="n">__comp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">__sort</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__ops</span><span class="o">::</span><span class="n">__iter_comp_iter</span><span class="p">(</span><span class="n">__comp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 上面 __gnu_cxx::__ops::__iter_comp_iter(__comp) 的实现如下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Compare</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">inline</span> <span class="n">_Iter_comp_to_iter</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="p">,</span> <span class="n">_Iterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__iter_comp_iter</span><span class="p">(</span><span class="n">_Iter_comp_iter</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="o">&gt;</span> <span class="n">__comp</span><span class="p">,</span> <span class="n">_Iterator</span> <span class="n">__it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">_Iter_comp_to_iter</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="p">,</span> <span class="n">_Iterator</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="n">_GLIBCXX_MOVE</span><span class="p">(</span><span class="n">__comp</span><span class="p">.</span><span class="n">_M_comp</span><span class="p">),</span> <span class="n">__it</span><span class="p">);</span> <span class="c1">// 这里有move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当涉及<code>iterator_traits&lt;RandomAccessIterator&gt;::value_type</code>时，必须在它前面写上<code>typename</code>，因为它是一个<strong>依赖于模板参数类型的名字</strong>，在这里是<code>RandomAccessIterator</code>。</p>
<p>上面代码中棘手的是这一行:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ElementType</span> <span class="nf">pivotValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为它把一个元素从保存的区间拷贝到局部临时对象中。</p>
<p>在例子里，这个元素是一个<code>auto_ptr&lt;Widget&gt;</code>，所以这个拷贝操作默默地把被拷贝的<code>auto_ptr——vector</code>中的那个——设为<code>NULL</code>。</p>
<p>另外，当<code>pivotValue</code>出了生存期，它会自动删除指向的<code>Widget</code>。这时sort调用返回了，<code>vector</code>的内容已经改变了，而且至少一个<code>Widget</code>已经被删除了。</p>
<p>也可能有几个<code>vector</code>元素已经被设为<code>NULL</code>，而且几个<code>widget</code>已经被删除，因为快速排序是一种递归算法，递归的每一层都会拷贝一个主元。</p>
<h2 id="结论">结论</h2>
<p>智能指针的容器是很好的， 但是<code>auto_ptr</code><font color=red>完全不是那样的智能指针</font>。</p>]]></description></item><item><title>Effective STL [9] | 在删除选项中仔细选择</title><link>https://jianye0428.github.io/posts/clause_9/</link><pubDate>Fri, 28 Jul 2023 07:59:27 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_9/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="删除指定值对象">删除指定值对象</h2>
<p>假定你有一个容纳<code>int</code>标准STL容器:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>而你想把c中所有值为2023的对象都去掉。</p>
<p>令人吃惊的是，完成这项任务的方法因不同的容器类型而不同：没有一种方法是通用的。</p>
<ul>
<li>当c是连续内存容器（vector、deque或string），最好的方法是erase-remove惯用法</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">2023</span><span class="p">),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 当c是vector、string或deque时，
</span></span></span><span class="line"><span class="cl"><span class="c1">// erase-remove惯用法是去除特定值的元素的最佳方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><ul>
<li>STL 和 vector中的remove的作用是<strong>将等于value的元素放到vector的尾部</strong>，但并不减少vector的size；</li>
<li>vector中erase的作用是删除掉某个位置position或一段区域(begin, end)中的元素，减少其size，返回被删除元素下一个元素的位置。</li>
</ul>
</div>
    </div>
  </div>
<ul>
<li>这方法也适合于<code>list</code>，但是<code>list</code>的成员函数<code>remove</code>更高效：</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 当c是list时，remove成员函数是去除特定值的元素的最佳方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">c</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">1963</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>当c是标准关联容器（即<code>set</code>、<code>multiset</code>、<code>map</code>或<code>multimap</code>）时，使用任何叫做<code>remove</code>的东西都是完全错误的。这样的容器没有叫做remove的成员函数，而且使用remove算法可能覆盖容器值，潜在地破坏容器。对于关联容器，解决问题的适当方法是调用erase：</li>
</ul>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 当c是标准关联容器时,erase成员函数是去除特定值的元素的最佳方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">2023</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这很高效，只花费对数时间，<strong>序列容器的基于删除的技术需要线性时间</strong>。并且，关联容器的<code>erase</code>成员函数有基于等价而不是相等的优势。</p>
<h2 id="消除判断式">消除判断式</h2>
<p>消除下面判断式，返回真的每个对象:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">badValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 返回x是否是“bad”
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>对于序列容器（<code>vector</code>、<code>string</code>、<code>deque</code>和<code>list</code>），把每个<code>remove</code>替换为<code>remove_if</code>：</li>
</ul>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">badValue</span><span class="p">),</span> <span class="c1">// 当c是vector、string或deque时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 这是去掉badValue返回真的对象的最佳方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="p">.</span><span class="n">remove_if</span><span class="p">(</span><span class="n">badValue</span><span class="p">);</span> <span class="c1">// 当c是list时这是去掉badValue返回真的对象的最佳方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>对于标准关联容器，有两种方法处理该问题，一个更容易编码，另一个更高效。</li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// c现在是一种标准关联容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">goodValues</span><span class="p">;</span> <span class="c1">// 用于容纳不删除的值的临时容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">remove_copy_if</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">inserter</span><span class="p">(</span><span class="n">goodValues</span><span class="p">,</span> <span class="n">goodValues</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span> <span class="n">badValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">goodValues</span><span class="p">);</span> <span class="c1">// 交换c和goodValues的内容
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对这种方法的<strong>缺点</strong>是它拷贝了所有不删除的元素。</p>
<p>因为关联容器没有提供类似<code>remove_if</code>的成员函数，所以必须写一个循环来迭代c中的元素，和原来一样删除元素。不幸的是，那些正确工作的代码很少是跃出脑海的代码。例如，这是很多程序员首先想到的：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span><span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 清晰，直截了当而漏洞百出的,用于删除c中badValue返回真的每个元素的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">badValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 不要这么做！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这有未定义的行为。当容器的一个元素被删时，<strong>指向那个元素的所有迭代器都失效了</strong>。</p>
<p>当<code>c.erase(i)</code>返回时，<code>i</code>已经失效。那对于这个循环是个坏消息，因为在<code>erase</code>返回后，<code>i</code>通过for循环的<code>++i</code>部分自增。为了避免这个问题，我们必须保证在调用<code>erase</code>之前就得到了c中下一元素的迭代器。最容易的方法是当我们调用时在i上使用后置递增：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="cm">/*nothing*/</span> <span class="p">){</span><span class="c1">// for循环的第三部分是空的；i现在在下面自增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">badValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">);</span> <span class="c1">// 对于坏的值，把当前的i传给erase，然后作为副作用增加i；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="c1">// 对于好的值，只增加i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>精髓的地方在于：这种调用<code>erase</code>的解决方法可以工作，因为表达式i++的值是i的旧值，但作为副作用，i增加了。</p>
<p>因此，我们把i的旧值（没增加的）传给<code>erase</code>，但在<code>erase</code>开始执行前i已经自增了。</p>
<p>现在不仅删除<code>badValue</code>返回真的每个元素，而且每当一个元素被删掉时，我们也想把一条消息写到日志文件中。</p>
<ul>
<li>可以通过<strong>直接从原容器删除元素来避开拷贝</strong>。</li>
<li>“更容易但效率较低”的解决方案用<code>remove_copy_if</code><strong>把需要的值拷贝到一个新容器中，然后把原容器的内容和新的交换</strong>：</li>
</ul>
<p>对于<strong>关联容器</strong>，这说多容易就有多容易，因为只需要对刚才开发的循环做一个微不足道的修改就行了：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ofstream</span> <span class="n">logFile</span><span class="p">;</span> <span class="c1">// 要写入的日志文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">AssocContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();){</span><span class="c1">// 循环条件和前面一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">badValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="n">logFile</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Erasing &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span><span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 写日志文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">);</span> <span class="c1">// 删除元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在是<code>vector</code>、<code>string</code>和<code>deque</code>不能再使用<code>erase-remove</code>惯用法，因为没有办法让<code>erase</code>或<code>remove</code>写日志文件。</p>
<p>而且，我们不能使用刚刚为关联容器开发的循环，因为它为<code>vector</code>、<code>string</code>和<code>deque</code>产生未定义的行为！</p>
<p>要记得对于那样的容器，<strong>调用<code>erase</code>不仅使所有指向被删元素的迭代器失效，也使被删元素之后的所有迭代器失效</strong>。</p>
<p>包括所有i之后的迭代器。我们写<code>i++</code>，<code>++i</code>或你能想起的其它任何东西都没有用，因为没有能导致迭代器有效的。必须利用erase的返回值。那个返回值正是我们需要的：<strong>一旦删除完成，它就是指向紧接在被删元素之后的元素的有效迭代器。</strong></p>
<p>我们这么写：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">SeqContainer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">badValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="n">logFile</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Erasing &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 通过把erase的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="c1">// 赋给i来保持i有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong><font color=blue>这可以很好地工作，但只用于标准序列容器</font></strong>。</p>
<p>标准关联容器的<code>erase</code>的返回类型是<code>void</code>。对于那些容器，你必须使用“<strong>后置递增你要传给erase的迭代器</strong>”技术。为了避免你奇怪<code>list</code>的适当方法是什么，事实表明对于迭代和删除，你可以像<code>vector/string/deque</code>一样或像关联容器一样对待list；两种方法都可以为list工作。</p>
<h2 id="结论">结论</h2>
<ol>
<li><strong>去除一个容器中有特定值的所有对象</strong>：</li>
</ol>
<ul>
<li>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove</code>惯用法</li>
<li>如果容器是<code>list</code>，使用<code>list::remove</code></li>
<li>如果容器是标准关联容器，使用它的<code>erase</code>成员函数</li>
</ul>
<ol start="2">
<li><strong>去除一个容器中满足一个特定判定式的所有对象</strong>：</li>
</ol>
<ul>
<li>如果容器是<code>vector</code>、<code>string</code>或<code>deque</code>，使用<code>erase-remove_if</code>惯用法</li>
<li>如果容器是<code>list</code>，使用<code>list::remove_if</code></li>
<li>如果容器是标准关联容器，使用<code>remove_copy_if</code>和<code>swap</code>，或写一个循环来遍历容器元素，当你把迭代器传给<code>erase</code>时记得后置递增它</li>
</ul>
<ol start="3">
<li><strong>在循环内做某些事情（除了删除对象之外）</strong>：</li>
</ol>
<ul>
<li>如果容器是标准<strong>序列容器</strong>，写一个循环来遍历容器元素，<strong>每当调用<code>erase</code>时记得都用它的返回值更新你的迭代器</strong>。</li>
<li>如果容器是标准<strong>关联容器</strong>，写一个循环来遍历容器元素，当<strong>你把迭代器传给<code>erase</code>时记得后置递增它</strong>。</li>
</ul>
<p>如你所见，与仅仅调用erase相比，有效地删除容器元素有更多的东西。</p>
<p><strong>解决问题的最好方法取决于你是怎样鉴别出哪个对象是要被去掉的，储存它们的容器的类型，和当你删除它们的时候你还想要做什么（如果有的话）。</strong></p>
<p>这仅对带有迭代器实参的<code>erase</code>形式是正确的。关联容器也提供一个带有一个值的实参的<code>erase</code>形式，而那种形式返回被删掉的元素个数。但这里，我们只关心通过迭代器删除东西。</p>]]></description></item><item><title>生成对抗网络GAN</title><link>https://jianye0428.github.io/posts/gan_1/</link><pubDate>Wed, 26 Jul 2023 10:03:45 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/gan_1/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="一gan的引入">一、GAN的引入</h2>
<p></p>
<p>GAN（Generative Adversarial Networks）是一种无监督的深度学习模型，提出于2014年，被誉为“近年来复杂分布上无监督学习最具前景的方法之一”。</p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>Yann Lecun对其的评价是：对抗式训练是迄今为止最酷的一件事情。</p>
<p>Adversarial training is the coolest thing since sliced bread.</p>
</div>
    </div>
  </div>
<p>我们来看下原文的标题：</p>
<ul>
<li>Generative：我们知道机器学习模型有两大类，第一个是分辨模型：对于一个数据去分辨它的类别，或者是预测一个实数值；另一类是生成模型，意思是怎么样生成这个数据本身。显然GAN是属于生成模型。</li>
<li>Adversarial：对抗的，这里指的是GAN提出的这种 framework 采用对抗训练的方式来work。</li>
<li>Nets：Network的简写。</li>
</ul>
<h2 id="二gan的应用举例">二、GAN的应用举例</h2>
<ul>
<li>数据生成：生成一些假的图像数据，比如海报中的人脸、文本生成图像等；</br></li>
<li>数据增强：从分割图生成假的真实街景，比如可以方便训练无人汽车等；</br></li>
<li>风格化和艺术的图像创造：比如转换图像风格、AI换脸、修补图像等；</br></li>
<li>声音的转换：比如一个人的声音转为另一个的声音、去除噪声等；</br></li>
<li>&hellip;&hellip;</br></li>
</ul>
<h2 id="三gan的快速概述">三、GAN的快速概述</h2>
<p>比如人脸检测、图像识别、语音识别等，<strong>机器总是在现有事物的基础上，做出描述和判断</strong>。能不能创造这个世界不存在的东西？</p>
<p>GAN就是为此而来，它包含三个部分：<strong>生成</strong>、<strong>判别</strong>、<strong>对抗</strong>。其中 <u>生成</u> 和 <u>判别</u> 是它的结构组成，<u>对抗</u>则是它的训练过程。</p>
<ul>
<li>生成：<strong>生成</strong> 和 <strong>判别</strong> 指的是两个独立的模型，生成器会根据随机向量产生假数据，这些假数据既可以是图片、也可以是文本，并<strong>试图</strong><font color=red>欺骗判别网络</font>；</li>
<li>判别：<strong>判别器</strong>负责判断接受到的数据是否是真实的，即对生成数据进行<font color=red>真伪鉴别</font>，试图正确识别所有假数据，它其实是一个二分类问题，会给出一个概率，代表着内容的真实程度；两者使用哪种网络并没有明确的规定，所以原文中作者称其为framework。比如可以使用擅长处理图片的CNN、常见的全连接等等，只要能够完成相应的功能就可以了。</li>
<li>对抗：这指的是 GAN 的交替训练过程。以图片生成为例，先让<font color=green><strong>生成器</strong></font>产生一些假图片，和收集到的真图片一起交给辨别器，让它学习区分两者，给真的高分，给假的低分，当判别器能够熟练判断现有数据后；再让 <font color=green><strong>生成器</strong></font> 以从 <font color=green><strong>判别器</strong></font> 处获得高分为目标，不断生成更好的假图片，直到能骗过判别器，重复进行这个过程，直到辨别器对任何图片的预测概率都接近0.5，也就是无法分辨图片的真假，就停止训练。</li>
</ul>
<p>也就是说在训练迭代的过程中，两个网络持续地进化和对抗，直到到达一个平衡状态，即判别网络无法识别真假。虽说是对抗，但是生成器和辨别器的关系更像是朋友，最初大家都是“无名之辈”，随着不断的训练“切磋”，共同成为“一代高手”。</p>
<p>我们<font color=red><strong>训练GAN的最终目标</strong></font>是获得好用的生成器，也就是生成足够以假乱真的内容，能完成类似功能的还有波尔斯曼机、变分自编码器等，它们被称为生成模型。</p>
<h2 id="四原文的摘要">四、原文的摘要</h2>
<p></p>
<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">到底什么是GAN？</div>
    </div>
  </div>
<p>首先作者提出一个新的framework，通过一个<strong>对抗过程</strong>来估计一个生成模型。</p>
<p>同时会训练两个模型：</p>
<ul>
<li>第一个模型叫做 <mark><strong>生成模型G</strong></mark>，用来捕获整个数据的分布，其实就是通过 <font color=red>生成器</font> 去拟合和逼近真实的数据分布；</li>
<li>第二个是 <mark><strong>辨别模型D</strong></mark>，它是用来估计一个样本是来自真正的数据、还是来自于<strong>G</strong>生成的。</li>
</ul>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">这里稍微解释一下：<strong>生成模型</strong> 它就是对整个数据的分布进行建模，使得能够生成各种分布。这里“分布”是一个很一般化的词，比如生成图片、生成文本、生成视频等。在统计学眼里，整个世界是通过采样不同的分布来得到的，所以想要生成东西，目的就是要抓住整个数据的一个分布。</div>
    </div>
  </div>
<p>生成模型的任务是尽量的想<strong>让辨别模型犯错</strong>，这个过程是一个<strong>最大最小的博弈</strong>。在任何函数空间的<strong>G</strong>和<strong>D</strong>里面，存在一个独一无二的解，这个解是代表：<strong>G</strong>能够找出训练数据的真实分布（生成的数据分布趋向于真实数据分布），此时辨别器就判别不出来了，所以概率值为$\frac{1}{2}$。</p>
<p>如果<strong>G</strong>和<strong>D</strong>是一个MLP的话，那么整个系统就可以通过误差反向传播来进行训练。作者说这里不需要使用任何的马尔科夫链，或者说是对一个近似的推理过程展开（说白了意思好像就是和别人的方法比比较简单一点），最后就是说实验的效果非常好。</p>
<h2 id="五原文的例子">五、原文的例子</h2>
<p></p>
<p>在对抗网络的框架里有两类模型：一个是<mark><strong>生成模型</strong></mark>、一个是<mark><strong>判别模型</strong></mark>：</p>
<ul>
<li>生成模型比喻成造假的人，它要去产生假币；</li>
<li>判别模型比喻成警察，警察的任务就是很好的鉴别假币和真币；</li>
</ul>
<p>造假者和警察会不断的学习，造假者会提升自己的造假技能，警察也会提升自己判别真币和假币的性能。最后希望造假者能够赢，就是说造的假钱和真钱一模一样，然后警察没有能力去区分真币和假币，那么这个时候就可以使用生成器生成和真实数据一样的数据了。</p>
<h2 id="六gan模型结构--训练gan的目的">六、GAN模型结构 &amp; 训练GAN的目的</h2>
<p>摘要说的已经很清楚了，GAN由两部分组成：</p>
<ul>
<li>生成器G（Generator）；</li>
<li>判别器D（Discriminator）；</li>
</ul>
<p>我们的最终目的是希望生成器<strong>G</strong>，能够<font color=purple>学习到样本的真实分布$P_{\text{data}}(x)$</font>，那么就能生成之前不存在的、但是却又很真实的样本。</p>
<p>那再啰嗦的说明白一点就是：</p>
<ul>
<li>我们把随机向量（随机噪声）定义为 $z$，$z \in F$，可以是任意分布，比如正态分布、均匀分布。</li>
<li>将随机噪声输入到 <strong>生成器G</strong> 中，<strong>G</strong>其实看成一个函数就可以，它可以是任意的一个神经网络，因为神经网络可以逼近任何形式的函数。</li>
<li>随机噪声 $z$ 经过<strong>生成器G</strong>后会产生一个 $G(z)$，生成的这个新的向量 $G(z)$，它可以记为服从$P_G(x)$。但是$P_G(x)$这个分布不是我们想要的，我们想要的是<strong>生成器G</strong>生成一个满足于真实分布$P_{\text{data}}(x)$的数据。</li>
<li>通过不断的训练迭代，更新调整生成器G的参数，使得$P_G(x)$近似于 $P_{\text{data}}(x)$。</li>
</ul>
<p>通过调整 <strong>生成器G</strong> 的参数，使得<font color=violet>它生成的分布和真实的分布尽可能的像</font>，这个就是最终要达到的目的，可以通过 生成器G 生成一些满足真实分布，但又不是真实存在的数据。</p>
<p>我们以手写数字识别为例，图例如下：</p>
<p></p>
<p>GAN模型结构图如下示例：</p>
<p></p>
<ul>
<li>我们将随机噪声输入到<strong>生成器G</strong>中，产生 $G(z)$，我们把它叫做$x_{\text{fake}}$，$x_{\text{fake}}$为生成的图片，就是假的图片；</li>
<li>我们还有满足于真实分布$P_{\text{data}}(x)$的数据，记为$x_{\text{real}}$；</li>
<li>我们把 $x_{\text{real}}$ 和 $x_{\text{fake}}$ 同时送到<strong>判别器D</strong>中去训练，做一个二分类任务，判断是真还是假；</li>
</ul>
<h2 id="七举例理解gan的原理">七、举例理解GAN的原理</h2>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">因为原文举的例子比较敏感，我们以李宏毅老师的例子（中央电视台鉴宝节目：一槌定音）来进行GAN原理的阐述。</div>
    </div>
  </div>
<p></p>
<p>假设现在有一个人，我们称它为小王，小王是一个收藏家，它的收藏室里收藏了很多“国宝”。但是小王不想只做一个收藏家，他还想高仿这些“国宝”，我们这里将高仿的赝品定义为“工艺品”。</p>
<p>基于GAN的目标，我们知道：</p>
<ul>
<li>小王最终想成为一个水平很高的“工艺品大师”；</li>
</ul>
<p>但是如果想成为一个“工艺品”方面的专家，小王自己在家闭门造车肯定是行不通的，因为我们的总目标是想让小王成为一个高水平的、可以以假乱真的工艺品大师。为了达到这个目标，首先需要一个高水平的鉴赏专家（高水平的对手），其次小王本身就要是个高水平的工艺品大师。所以小王还需要找一个水平很高的国宝鉴赏专家。鉴赏专家负责辨别出真的“国宝”和小王的“工艺品”，小王负责高仿生产“工艺品”。</p>
<p></p>
<p>概述来说：<strong>小王需要先有一个高水平的专家，然后才可能成为一个高水平的大师。高水平的专家可以看成一种手段，成为高水平的大师才是我们的目标。</strong></p>
<h2 id="八数学描述">八、数学描述</h2>
<h3 id="81-相关符号">8.1 相关符号</h3>
<p>基于上述鉴宝例子，我们来看一下GAN的数学描述，首先需要强调的是：</p>
<ul>
<li>工艺品经过鉴赏专家判断后，是会受到一个 feedback 的；</li>
<li>对于鉴赏专家而言，它也会从工艺品受到一个 feedback ，当然这是潜在的；</li>
</ul>
<p>我们就来看一下，这个例子如何用数学符号去表示：</p>
<ul>
<li>
<p>&ldquo;国宝&quot;是静态的，它相当于我们的真实样本 ${x_{\text{real}<em>i}}^N</em>{i=1}$ ，这里我们以 $P_{data}$ 表示；</p>
</li>
<li>
<p>工艺品也是从一个概率分布里抽样出来的，我们将工艺品记作 ${x_{\text{fake}<em>i}}^N</em>{i=1}$ ，我们把这个概率分布称作 $P_g(x;\theta_{g})$，g就代表Generator的意思；</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">注意我们并不直接对 $P_g$ 建模，即不直接对生成模型本身进行建模，我们用一个神经网络去逼近这个分布，纯粹的神经网络它是不具备随机性的，所以我们会假设它有一个 $z$，就是前面提到的随机噪声，是来自于一个简单的分布，比如高斯分布： $z \sim P_Z(z)$ ；</div>
    </div>
  </div>
</li>
<li>
<p>原始的GAN里，神经网络就用NN表示，它本身就是一个确定性变换，即是一个复杂函数，表示为 $G(z;\theta_{g})$；</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">$\theta_g$ 在NN里就是表示权重参数，在 $P_g$ 里就是代表概率分布参数。</div>
    </div>
  </div>
</li>
<li>
<p>鉴赏专家也可以看成一个概率分布，我们也用一个NN来描述它：$D(x; \theta_{d})$，代表 $x$ 是国宝的概率</p>
</li>
</ul>
<p></p>
<p>对于鉴赏专家 <strong>(判别器D)</strong> 接收到的来说：</p>
<ul>
<li>可以是来自国宝、也可以是来自于工艺品，是无所谓的，重要的是本身是代表是国宝的概率。</li>
</ul>
<p>对于判别器D的输出来说：</p>
<ul>
<li>$D(x)$ 的值越趋近于1，说明它是国宝的概率就越大；越趋近于0，说明它是工艺品的概率就越大。</li>
</ul>
<p>上图又可简化为：</p>
<p></p>
<p>一方面是从 $P_{data}$ 里来的 $x_{real}$，一方面是 $z$ 输入到生成器后的输出 $x_{fake}$，$z$ 为噪声。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">换句话说, $z$ 是从简单分布中采样，经过生成器后变成 $x$，此时生成的由的先验分布和生成器共同决定。</div>
    </div>
  </div>
<h3 id="82高专家的目标函数">8.2、“高专家”的目标函数</h3>
<p>符号描述表述清楚后，我们看一下GAN的目标函数，首先回顾一下GAN的目标：<u><strong>成为一个高水平的、可以以假乱真的大师</strong></u>。为了达到这个目标，我们又可以分为一个手段和一个目标：</p>
<ul>
<li>手段：<strong>需要一个高水平的鉴别专家</strong>；</li>
<li>目标：<strong>成为高水平的工艺品大师</strong>。</li>
</ul>
<p>也就是说我们需要<u><strong>先成就一个高水平的专家，才有可能成就一个高水平的大师</strong></u>，所以它们的关系是：(高大师(高专家))。</p>
<p>首先看高专家，高专家水平高体现在：国宝判别为真、工艺品判别为假：</p>
<p>$$
高专家：
\begin{equation}
\left{
\begin{aligned}
%\nonumber
if \ x \ is \ from \ P_{data}, \ then D(x) \uparrow\
if \ x \ is \ from \ P_{g}, \ then D(x) \downarrow\
(z \ is \ from \ P_{z}) \
\end{aligned}
\right.
\end{equation}
$$</p>
<p>为了将式子统一起来，我们改写为：</p>
<p>$$
高专家：
\begin{equation}
\left{
\begin{aligned}
%\nonumber
if \ x \ is \ from \ P_{data}, \ then D(x) \uparrow\
if \ x \ is \ from \ P_{g}, \ then \ 1-D(x) \uparrow\
(z \ is \ from \ P_{z}) \
\end{aligned}
\right.
\end{equation}
$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">因为 $D(x)$ 是一个概率值分布，范围是0~1， $D(x)$ 偏小， $1-D(x)$ 则相应的就偏大。</div>
    </div>
  </div>
<p>对于工艺品，$x$ 是从<strong>生成器G</strong>来的，所以可以表示成 $G(z)$：</p>
<p>$$
高专家：
\begin{equation}
\left{
\begin{aligned}
%\nonumber
if \ x \ is \ from \ P_{data}, \ then D(x) \uparrow\
if \ x \ is \ from \ P_{g}, \ then \ 1 - D(G(z)) \uparrow\
(z \ is \ from \ P_{z}) \
\end{aligned}
\right.
\end{equation}
$$</p>
<p>为了使目标函数更容易表达，或者说计算更加方便，我们加上，所以进一步表达为：
$$
高专家：
\begin{equation}
\left{
\begin{aligned}
%\nonumber
if \ x \ is \ from \ P_{data}, \ then \ \log{D(x)} \uparrow\
if \ x \ is \ from \ P_{g}, \ then \ \log{(1 - D(G(z)))} \uparrow\
(z \ is \ from \ P_{z}) \
\end{aligned}
\right.
\end{equation}
$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">$\log$ 为增函数，$\log(x)$ 与 $x$ 的增减性保持一致，在极大化参数的时候，与原始求解是一样的。</div>
    </div>
  </div>
<p>所以对于成就一个高专家来说，目标函数如下：</p>
<p>$$\max_{D} E_{x \sim P_{data}}[\log{D(x)}] + E_{z \sim P_{z}}[\log (1 - D(G(z)))]$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>可能有同学不明白为什么原文这里用期望，其实很简单，我们假设数据分布总共有个样本，那么它的期望可以表示为：</p>
<p>$$E_{x \sim P_{data}}[\log(D(x))] = \frac{1}{N} \sum_{i=1}^{N} \log(D(x_i)), x_i \sim P_{data}$$</p>
</div>
    </div>
  </div>
<h3 id="83高大师的目标函数">8.3、“高大师”的目标函数</h3>
<p>我们再来看高大师的目标函数，<strong>高大师是建立在高专家的水平之上</strong>，对于高大师来讲，希望高专家将所有的工艺品都判断为真：</p>
<p>$$高大师: if \ x \ from \ P_g,\ then \ D(G(z)) \uparrow $$</p>
<p>为了统一起来，我们改写为:</p>
<p>$$高大师: if \ x \ from \ P_g,\ then \ (1 - D(G(z))) \downarrow $$</p>
<p>所以对于高大师来讲，目标函数为:</p>
<p>$$\min_{G} E_{z \sim P_z}[\log (1 - D(G(z)))]$$</p>
<h3 id="84总目标函数">8.4、总目标函数</h3>
<p>本着<strong>先成就 高专家, 再成就 高大师</strong>的原则，GAN的目标函数为：</p>
<p>$$\min_{G} \max_{D} V(D, G) = \mathbb{E_{x\sim p_{data}(x)}}[\log(D(x))] + \mathbb{E_{z\sim p_{z}(z)}}[\log(1 - D(G(z)))]$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">通过目标函数我们也能看出，GAN模型的复杂度，不在于模型的定义，而在于模型的traning，也就是D和G的学习。</div>
    </div>
  </div>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">还有一点需要强调的是，自始至终我们都没有去直接面对 $P_g$，我们实际上使用一个可微神经网络 $G(z)$ 去逼近这个 $P_g$ ，而且是从采样的角度去逼近，换句话说，对于生成网络 $P_g$，GAN是绕过了它，并没有直接去解决 $P_g$，而是从采样的角度去逼近它。所以GAN又被称做：Implicit Density Model.</div>
    </div>
  </div>
<p>公式比较多，所以对目标函数再啰嗦的介绍下：</p>
<p>我们可以得出，它实际上就要对价值函数 $V(D, G)$ 进行min、max的博弈，还有需要注意的是：$D(x)$ 是判别器的输出，它要做二分类，所以经过sigmoid之后 $D(x) \in [0, 1]$；</p>
<p>我们来看一下它是怎么工作的：</p>
<ul>
<li>首先固定住G不动，通过调整D的参数，来最大化价值函数 $V(D, G)$：
<ul>
<li>要想最大化 $V$ ，左边的 $D(x)$ 要趋近于1（这样才能保证log的值尽可能大），同时要让右边的 $D(G(z))$ 趋近于0（这样才能保证 $log(1-D(G(z)))$ 尽可能大）；</li>
<li>$\max V(D, G)$ 其实就是把真实数据和假数据区分的一个过程.
$$\min_{G} \max_{D} V(D, G) = \mathbb{E_{x\sim p_{data}(x)}}[\log(D(x))] + \mathbb{E_{z\sim p_{z}(z)}}[\log(1 - D(G(z)))]$$</li>
</ul>
</li>
<li>然后固定住D不动，此时公式的左部分已经是个定值了，我们<strong>调整G的参数</strong>，来最小化价值函数 $V(D, G)$：
<ul>
<li>要让 $V(D, G)$ 最小，那么就要让 $D(G(z))$ 趋近于1，只有 $V(G(z))$ 趋近于1的时候，定义域里的值才能趋近于0，也就是log会变得越来越小，达到最小化 $V$ 的过程；</li>
<li>这个过程就是想让 $D(G(z))$ 趋近于1，z满足生成数据的分布，它是假的，那么 $min_G$ 的过程就是想要调整生成器，来骗过判别器，从而<strong>使得假数据被判别为真</strong>。
$$\min_{G} \max_{D} V(D, G) = \mathbb{E_{x\sim p_{data}(x)}}[\log(D(x))] + \mathbb{E_{z\sim p_{z}(z)}}[\log(1 - D(G(z)))]$$</li>
</ul>
</li>
</ul>
<p>总结如下：</p>
<ul>
<li>固定G, 调整D, 最大化 $V(D, G)$, 导致 $D(x) \rightarrow 1, D(G(z)) \rightarrow 0$</li>
<li>固定D, 调整G, 最小化 $\max_{D}V(D, G)$, 导致 $D(G(z)) \rightarrow 1$</li>
</ul>
<p>想必肯定有同学会发现这里出现的一个矛盾：上面的趋近于0，下面的趋近于1，这个矛盾、冲突，就理解为GAN中的<strong>对抗</strong>的意思。</p>
<h2 id="九全局最优解推导">九、全局最优解推导</h2>
<p>因为公式多、篇幅长，所以在推导最优解之前，我们先回顾一下GAN里的三个角色：</p>
<ul>
<li>真实样本分布$P_{data}$；</li>
<li><strong>生成器 Generator</strong> 对应概率分布为:$P_g$，即代表生成器生成数据的概率分布；</li>
<li><strong>判别器 Discriminator</strong> 对应的条件概率分布是离散的，就是0-1分布（伯努利分布），给定x的情况下，1代表正品、0代表工艺品（赝品）；</li>
</ul>
<p>我们的最终目标，就<strong>是想让生成器生成的样本的概率分布$P_g$无限的接近于$P_{data}$</strong>，即：$P_g \rightarrow P_{data}$；</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>我们常规的生成模型（不是GAN），是直接对$P_g$进行建模: $P_g \rightarrow \theta_{g}$, 极大似然估计表示如下：</p>
<p>$$\theta_g = \argmax_{\theta_g} \sum_{i=1}^N \log{P_g}(x_i) = \argmin KL(P_{data} || P_g)$$</p>
<p>从距离的角度讲，是最小化KL散度，最终想让$P_{data} = P_g$，这就是原先如何把参数求出来的策略。</p>
</div>
    </div>
  </div>
<h3 id="91关于-d-的最大值">9.1、关于 D 的最大值</h3>
<p>GAN从<strong>对抗学习</strong>的角度去构造目标函数，我们上面构造的目标函数，只是从逻辑上觉得它没有问题，那么我们可能会考虑：</p>
<ul>
<li>这个最大最小问题，它的最优解存在不存在？</li>
<li>如果最优解 $P_g$（就是G）存在，那么全局最优的情况下，$P_g$是否等于$P_{data}$？</li>
</ul>
<p>如果这个不成立的话，那么其实这个目标函数是没有意义的，我们来看一下，方便记作，直接用论文中的符号来描述：</p>
<p></p>
<p>我们记：</p>
<p>$$V(D, G) = \mathbb{E}<em>{x\sim p</em>{data}(x)}[\log{D(x)}] + \mathbb{E}<em>{z\sim p</em>{z}}[\log{1 - D(G(z))}]$$</p>
<p>我们先求max，根据期望的定义：$E_{x \sim P(x)} = \int_x p(x)f(x)dx$，将其展为积分的形式：</p>
<p>$\quad For \quad fixed \quad G, 求： \max_D(V(D, G))$
$$
\begin{align}
\max_D V(D, G) &amp;= \int P_{data} \cdot \log D dx + \int P_g \cdot \log (1 - D) dx \
&amp;= \int {[P_{data} \cdot \log D + P_g \cdot \log(1 - D)]} dx
\end{align}
$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">这里两个积分中的x确实是不同的变量，但是积分微元的符号可以做任意变换，不用纠结这里。</div>
    </div>
  </div>
<p>我们要求里面函数关于x积分的最大值，那么就看一下它的导数：</p>
<p>$$
\begin{align}
\frac{\partial}{\partial{D}}(\max V(D, G)) &amp;= \frac{\partial}{\partial D}\int {[P_{data} \cdot \log D + P_g \cdot \log(1 - D)]} \
&amp;= \int \frac{\partial}{\partial D} {[P_{data} \cdot \log D + P_g \cdot \log(1 - D)]} \
&amp;= \int {[P_{data} \cdot \frac{1}{D} + P_g \cdot \frac{-1}{\log(1 - D)}]} \Longleftrightarrow 0\
\end{align}
$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>因为积分是对x积的，求导是对D求的，两者互不干扰可以交换词序。</p>
<p>最优的时候导数为0。</p>
</div>
    </div>
  </div>
<p>$$\therefore P_{data} \cdot \frac{1}{D} = P_g \cdot \frac{1}{1-D}$$</p>
<p>所以当固定G时，最优的D为:</p>
<p>$$D^*<em>G = \frac{P</em>{data}}{P_{data} + P_g}$$</p>
<h3 id="92-关于-g-的最小值">9.2 关于 G 的最小值</h3>
<p>最大值求出来之后，我们再来看关于G的最小值，我们将$D^*$带进去：</p>
<p>$$
\begin{align}
\min_G \max_D V(D, G) &amp;= \min_G V(D^*<em>G, G) \
&amp;= \min_G E</em>{x \sim P_{data}}[\log(\frac{P_{data}}{P_{data} + P_g})] + E_{x \sim P_{g}}[\log(1 - \frac{P_{data}}{P_{data} + P_g})] \
&amp;= \min_G E_{x \sim P_{data}}[\log(\frac{P_{data}}{P_{data} + P_g})] + E_{x \sim P_{g}}[\log(\frac{P_{g}}{P_{data} + P_g})]\
\end{align}
$$</p>
<p>这里 $P_{data}$ 和 $P_g$，和KL散度的定义非常类似，KL divergence定义：</p>
<p>$$KL(P||Q) = E_{x \sim P}[\log(\frac{P(x)}{Q(x)})]$$</p>
<p>但是我们不能直接这么写，我们需要保证分子和分母必须同时为两个概率分布，但是分母是$P_{data} + P_g$，是两个概率分布相加，那它的取值就变成[0, 2]了。</p>
<p>所以我们给它再除以个2就可以了，取值范围就又变成[0, 1]了。换句话说，可以把它看成概率密度函数，具体什么样子无所谓，它的取值在[0, 1]之间，并且是连续的。</p>
<p>$$
\begin{align}
\min_G \max_D V(D, G) &amp;= \min_G V(D^*<em>G, G) \
&amp;= \min_G E</em>{x \sim P_{data}}[\log(\frac{P_{data}}{P_{data} + P_g})] + E_{x \sim P_{g}}[\log(1 - \frac{P_{data}}{P_{data} + P_g})] \
&amp;= \min_G E_{x \sim P_{data}}[\log(\frac{P_{data}}{P_{data} + P_g})] + E_{x \sim P_{g}}[\log(\frac{P_{g}}{P_{data} + P_g})]\
&amp;= \min_G E_{x \sim P_{data}}[\log(\frac{P_{data}}{(P_{data} + P_g)/2} \cdot\frac{1}{2})] + E_{x \sim P_{g}}[\log(\frac{P_{g}}{(P_{data} + P_g)/2}\cdot\frac{1}{2})]\
&amp;= \min_{G} KL (P_{data} || \frac{P_{data} + P_g}{2}) + KL (P_{g} || \frac{P_{data} + P_g}{2}) - \log4\
\end{align}
$$</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">将两个$\log(\frac{1}{2})$拿出去，$\log(\frac{1}{2}) = \log1 - \log2 = -\log2,$，$-\log2$的期望就是它自己，两个就是$-\log2-\log2 = -\log4$</div>
    </div>
  </div>
<p>我们得出上式，发现它又满足 JS divergence 的定义：</p>
<p>$$JSD(P||Q) = \frac{1}{2} KL(P || M) + \frac{1}{2} KL (Q||M), 其中 M = \frac{P + Q}{2}$$</p>
<p>所以上式又可写成：</p>
<p>$$\min_G - \log 4 + 2 JSP(P_{data}||P_g)$$</p>
<p>JS divergence是衡量两个分布之间的距离，所以只有当这两个分布越来越相等的时候，就找到这个式子的最小值了，故：</p>
<p>当$P_g(x) = P_{data}(x)$时，上式可得最小值。</p>
<p>所以我们只需要优化：</p>
<p>$$\min_G\max_D V(D, G) = \mathbb{E}<em>{x\sim{p</em>{data}(x)}}[\log D(x)] + \mathbb{E}<em>{z\sim{p</em>{z}(z)}}[1 - \log D(G(z))]$$</p>
<p>就可以得到$P_g(x) = P_{data}(x)$.</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">另外，当 $P_g(x) = P_{data}(x)$ 时，又因为 $D^<em><em>G = \frac{P</em>{data}}{P_{data} + P_g}$， 所以此时 $D^</em> = \frac{1}{2}$ 。意思是，在最优的情况下，鉴赏专家已经没有分辨真假的能力了，概率都0.5，这个时候判别器对于生成器而言，已经没有继续学习的必要了。</div>
    </div>
  </div>
<h2 id="十原文给出的训练步骤">十、原文给出的训练步骤</h2>
<p></p>
<ul>
<li>在每一个step里先采样m个噪音样本；</li>
<li>再采样m个来自于真实数据的样本；这样就组成了一个大小为2m的小批量；</li>
<li>将样本分别放到 <strong>生成器</strong> 和 <strong>辨别器</strong> 去求梯度，更新 <strong>辨别器</strong> 参数；</li>
</ul>
<p>做完之后：</p>
<ul>
<li>再采样m个噪音样本，放到公式的第二项里面（因为我们要<strong>更新生成器</strong>，生成器与第一项无关），算出它的梯度；</li>
<li>然后对生成器进行参数更新。</li>
</ul>
<p>这样就完成了一次迭代，可以看到每次迭代里，我们是<strong>先更新辨别器，再更新生成器</strong>。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>k是一个超参数，不能太小也不能太大，要保证辨别器有足够的更新，但也不要更新太好了。如果没有足够好的更新，就是生成器变换了之后，没有把辨别器更新的足够好，</p>
<p>
G已经做了变化，但是D没有做什么改变，再更新G来糊弄D，其实意义不大。</p>
<p>反过来讲，如果一更新就把D训练到完美，那么1-D就会变成0，对一个0的东西求导，那么就会在生成模型上更新有困难。</p>
<p>回到原文的例子，辨别器是警察，生成器就是造假者，假设警察特别厉害，造假者产一点假钞出来就被连锅端了，那造假者就没能力改进和提升自己了，但反过来讲，如果警察无力，造假者随便造点东西，警察也看不出来，那造假者就不会有动力去改进和提升自己。</p>
<p>所以最好是两者实力相当、相爱相杀，大家一起进步。所以k的调参，要使得D的更新和G的更新进度都差不多。</p>
</div>
    </div>
  </div>
<h2 id="十一gan原理及训练过程总结">十一、GAN原理及训练过程总结</h2>
<h3 id="111gan原理总结">11.1、GAN原理总结</h3>
<p>GAN主要包括了两部分：</p>
<ul>
<li><mark>生成器（Generator）</mark>：生成器主要用来学习真实数据的分布，从而让自身生成的数据更加真实，骗过判别器；</li>
<li><mark>判别器（Discriminator）</mark>：判别器则需要对接受的数据进行真假判断。</li>
</ul>
<p>在训练过程中，生成器努力地让生成的数据更加真实，而判别器则努力地去识别出数据的真假，这个过程相当于一个二人博弈，随着时间的推移，生成器和判别器在不断的进行对抗，这就是它对抗的含义。</p>
<p>最终两个网络达到了一个动态均衡：生成器生成的数据接近于真实数据分布，而判别器识别不出真假数据，对于给定数据的预测为真的概率基本接近0.5（相当于随机猜测类别）。</p>
<p>GAN设计的关键在于损失函数的处理：</p>
<ul>
<li>对于判别模型，损失函数是容易定义的，判断一张图片是真实的还是生成的，显然是一个二分类问题。</li>
<li>对于生成模型，损失函数的定义就不是那么容易，我们希望生成器可以生成接近于真实的图片，对于生成的图片是否像真实的，我们人类肉眼容易判断，但具体到代码中，是一个抽象的，难以数学公里化定义的范式。</li>
</ul>
<p>针对这个问题，我们不妨把生成模型的输出，交给判别模型处理，让判别器判断这是一个真实的图像还是假的图像，因为深度学习模型很适合做分类，这样就将生成器和判别器紧密地联合在了一起。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>tips<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">假如我们直接用生成器训练，它的训练结果并不会得到一个真实的图像，而会得到一个比较模糊的图像，因为我们无法构建一个合适的损失去判断它是否像真实图片，所以它会将所有训练样本做平均，产生一个比较糊的图片。这就是为什么要将生成器的样本交给判别器来构建损失。</div>
    </div>
  </div>
<h3 id="112gan算法流程总结">11.2、GAN算法流程总结</h3>
<ul>
<li>$G$ 是一个生成图片的网络，它接收一个随机的噪声z，通过这个噪声生成图片$G(z)$，记作；</li>
<li>$D$ 是一个判别网络，判别一张图片是不是“真实的”，它的输入参数是x，x代表一张图片，输出$D(x)$，代表x为真实图片的概率，如果为1，就代表100%是真实的图片，输出为0，就代表不是真实图片。</li>
</ul>
<p>在训练过程中，将随机噪声输入生成网络G，得到生成的图片；判别器接受生成的图片和真实的图片，并尽量将两者区分开来。在这个计算过程中，能否正确区分生成的图片和真实的图片将作为判别器的损失；而能否生成近似真实的图片、并使得判别器将生成的图片判定为真，将作为生成器的损失。</p>
<p>生成器的损失是通过判别器的输出来计算的，而判别器的输出是一个概率值，我们可以通过交叉熵来计算。</p>
<h2 id="十二torch复现">十二、torch复现</h2>
<p><a href="https://wangguisen.blog.csdn.net/article/details/127820071"target="_blank" rel="external nofollow noopener noreferrer">https://wangguisen.blog.csdn.net/article/details/127820071<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
ref:</br>
[1]. <a href="https://arxiv.org/abs/1406.2661"target="_blank" rel="external nofollow noopener noreferrer">https://arxiv.org/abs/1406.2661<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://www.bilibili.com/video/BV1eE411g7xc"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/BV1eE411g7xc<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://www.bilibili.com/video/BV1rb4y187vD"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/BV1rb4y187vD<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[4]. <a href="https://www.bilibili.com/video/BV1HD4y1S7Pe"target="_blank" rel="external nofollow noopener noreferrer">https://www.bilibili.com/video/BV1HD4y1S7Pe<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>]]></description></item><item><title>Effective STL [34] | 注意哪个算法需要有序区间</title><link>https://jianye0428.github.io/posts/clause_34/</link><pubDate>Sat, 26 Aug 2023 10:55:58 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_34/</guid><description><![CDATA[<p>不是所有算法可以用于任意区间。比如，<strong>remove需要前向迭代器和可以通过这些迭代器赋值的能力</strong>。所以，它不能应用于由输入迭代器划分的区间，也不能是map或multimap，也不能是set和multiset的一些实现。</p>
<p>同样，<strong>很多排序算法需要随机访问迭代器</strong>，所以不可能在一个list的元素上调用这些算法。</p>
<p>最常见的就是一些算法<strong>需要有序值的区间</strong>。无论何时都应该坚持这个需求，因为冒犯它不仅会导致编译器诊断，而且会造成未定义的运行期行为。</p>
<p>既可以和有序又可以和无序区间合作的算法很少，但<strong>当操作有序区间的时候它们最有用</strong>。</p>
<h2 id="只能操作有序数据的算法的表">只能操作有序数据的算法的表</h2>
<ul>
<li>binary_search</li>
<li>lower_bound</li>
<li>upper_bound</li>
<li>equal_range</li>
<li>set_union</li>
<li>set_intersection</li>
<li>set_difference</li>
<li>set_symmetric_difference</li>
<li>merge</li>
<li>inplace_merge</li>
<li>includes</li>
</ul>
<h2 id="一般用于有序区间但不强制要求">一般用于有序区间，但不强制要求</h2>
<ul>
<li>unique</li>
<li>unique_copy</li>
</ul>
<h2 id="binary_searchlower_boundupper_bound和equal_range"><code>binary_search</code>、<code>lower_bound</code>、<code>upper_bound</code>和<code>equal_range</code></h2>
<p>搜索算法binary_search、lower_bound、upper_bound和equal_range需要<strong>有序区间</strong>，因为它们<strong>使用二分法查找来搜索</strong>值。像C库中的bsearch，这些算法保证了<strong>对数时间的查找</strong>，但作为交换的是，你必须给它们已经排过序的值。</p>
<p>实际上，仅当传给它们的是随机访问迭代器时它们才能保证有那样的性能。</p>
<p>如果给它们威力比较小的迭代器（比如双向迭代器），它们仍然进行对数次比较，但运行是线性时间的。那是因为，缺乏进行“<strong>迭代器算术（arithmetic）</strong>”的能力。它们在搜索的区间中需要花费线性时间来从一个地方移动到另一个地方。</p>
<h2 id="unionset_intersectionset_difference和set_symmetric_difference"><code>union</code>、<code>set_intersection</code>、<code>set_difference</code>和<code>set_symmetric_difference</code></h2>
<p>算法<code>set_union</code>、<code>set_intersection</code>、<code>set_difference</code>和<code>set_symmetric_difference</code>的四人组提供了线性时间设置它们名字所提出的操作的性能。</p>
<p>为什么它们需要有序区间？因为如果不是的话，它们不能以线性时间完成它们的工作。</p>
<p>你会发现，<strong>需要有序区间的算法为了比它们用于可能无序区间提供更好的性能而这么做</strong>。</p>
<h2 id="merge和inplace_merge">merge和inplace_merge</h2>
<p>merge和inplace_merge执行了有效的单遍合并排序算法：它们读取两个有序区间，然后产生一个包含了两个源区间所有元素的新有序区间。</p>
<p>它们以线性时间执行，如果它们不知道源区间已经有序就不能完成。</p>
<h2 id="includes">includes</h2>
<p>includes 用来检测是否一个区间的所有对象也在另一个区间中。</p>
<p>因为includes可能假设它的两个区间都已经有序，所以它保证了线性时间性能。没有那个保证，一般来说它会变慢。</p>
<h2 id="unique和unique_copy">unique和unique_copy</h2>
<p>unique和unique_copy甚至在无序区间上也提供了定义良好的行为。</p>
<p>看看标准是怎么描述unique的行为的：</p>
<blockquote>
<p>从每个相等元素的连续组中去除第一个以外所有的元素。</p>
</blockquote>
<p>如果你要unique从一个区间去除所有重复值（也就是，让区间中所有值“唯一”），你必须先确保所有重复值一个接着一个。那是排序完成的东西之一。</p>
<p>实际上，unique一般用于从区间中去除所有重复值，所以你几乎总是要确保你传递给unique（或unique_copy）的区间是有序的。Unix开发者会发现STL的unique和Unix的uniq之间有惊人的相似。</p>
<p>顺便说说，unique从一个区间除去元素的方式和remove一样，也就是说它只是区分出不除去的元素。</p>
<h2 id="排序">排序</h2>
<p>因为STL允许你指定用于排序的比较函数，<strong>不同的区间可能以不同的方式排序</strong>。</p>
<p>比如，给定两个int的区间，一个可能以默认方式排序（也就是升序），而另一个使用<code>greater&lt;int&gt;</code>排序，因此是降序。</p>
<p>给定Widget的两个区间，一个可能以价格排序而另一个可能以年龄排序。因为有很多不同的方式来排序，所以保证给STL所使用的排序相关信息一致是很重要的。</p>
<p><strong>如果你传一个区间给一个也带有比较函数的算法，确保你传递的比较函数行为和你用于排序这个区间的一样。</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector，把一些数据放进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">// 降序排列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用这个vector（没有改变它）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在这个vector中搜索5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">is3Exists</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 假设它是升序排列！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下，binary_search假设它搜索的区间是以“&lt;”排序（也就是，值是升序），但在本例中，这个vector是降序。当你在值的排列顺序和算法所期望的不同的区间上调用binary_search (或lower_bound等）会导致未定义的结果。</p>
<h3 id="正确排序方式">正确排序方式</h3>
<p>要让代码行为正确，你必须告诉binary_search要使用和sort同样的比较函数：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">is3Exists</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 搜索3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 比较函数把greater作为
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=blue>所有需要有序区间的算法（也就是除了unique和unique_copy外本条款的所有算法）通过等价来判断两个值是否“相同”，就像标准关联容器（它们本身是有序的）。相反，unique和unique_copy判断两个对象“相同”的默认方式是通过相等</font>，但是你可以通过传给这些算法一个定义了“相同”的意义的判断式来覆盖这个默认情况。</p>
<h2 id="总结">总结</h2>
<p>11个需要有序区间的算法为了比其他可能性提供更好的性能而<font color=blue>需要传给它们有序区间，需要保证用于算法的比较函数和用于排序的一致</font>。</p>
]]></description></item><item><title>Effective STL [33] | 提防在指针的容器上使用类似remove的算法</title><link>https://jianye0428.github.io/posts/clause_33/</link><pubDate>Sat, 26 Aug 2023 10:55:54 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_33/</guid><description><![CDATA[<h2 id="删除含有指针的容器元素">删除含有指针的容器元素</h2>
<p>如果你在管理一堆动态分配的Widgets，每一个都可能通过检验，你把结果指针保存在一个vector中：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个Widget是否通过检验
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isCertified</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector然后用动态分配的Widget的指针填充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当和v工作一段时间后，你决定除去未通过检验的Widget，因为你不再需要它们了。</p>
<p><strong>尽量用算法调用代替显式循环和关于remove和erase之间关系的描述</strong>，你自然会想到转向erase-remove惯用法，虽然这次你使用了remove_if：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 删除未通过检验的Widget指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">not1</span><span class="p">(</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">isCertified</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 关于mem_fun的信息参见条款41
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>条款7介绍过摧毁容器中的一个指针也不会删除指针指向的东西的讨论，所以这里当调用erase时，极可能你已经泄漏了资源。</p>
<h2 id="资源泄露分析">资源泄露分析</h2>
<p>我们假设在调用remove_if前，v看起来像这样：</p>
<p></p>
<p>在调用remove_if后，一般来说v看起来像这样（包含从remove_if返回的迭代器）：</p>
<p></p>
<p>资源泄漏的理由现在很明朗了。指向Widget B和C的“删除的”指针被vector中后面的“不删除的”指针覆盖。没有什么指向两个未通过检验的Widget，它们也没有被删除，它们的内存和其他资源泄漏了。</p>
<p>一旦remove_if和erase返回后，情况看起来像这样：</p>
<p></p>
<p>现在你也很清楚为什么应该努力避免在动态分配的指针的容器上使用remove和类似算法（remove_if和unique）。</p>
<p>在很多情况下，你会发现<strong>partition算法是合理的替代品</strong>。</p>
<h2 id="正确删除做法">正确删除做法</h2>
<p>如果你无法避免在那样的容器上使用remove，排除这个问题一种方法是在<strong>应用erase-remove惯用法之前先删除指针并设置它们为空，然后除去容器中的所有空指针</strong>：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">delAndNullifyUncertified</span><span class="p">(</span><span class="n">Widget</span> <span class="o">*&amp;</span><span class="n">pWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果*pWidget是一个未通过检验Widget，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pWidget</span><span class="o">-&gt;</span><span class="n">isCertified</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 删除指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">delete</span> <span class="n">pWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 并且设置它为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pWidget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 把所有指向未通过检验Widget的指针删除并且设置为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">delAndNullifyUncertified</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 从v中除去空指针0必须映射到一个指针，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">               <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">*&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 让C++可以正确地推出remove的第三个参数的类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，这假设vector并不容纳任何你想保留的空指针。如果有的话，你可能必须自己写循环来按你的方式删除指针。</p>
<h3 id="智能指针">智能指针</h3>
<p>如果你把指针的容器替换成<strong>执行引用计数的智能指针的容器</strong>，删除相关的困难就不存在了，你可以直接使用erase-remove惯用法：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RCSP = “引用计数智能指针”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">RCSP</span> <span class="p">{</span> <span class="p">...};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RCSPW = “RCSP to Widget”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">RCSP</span><span class="o">&lt;</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">RCSPW</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector，用动态分配Widget的智能指针填充它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RCSPW</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">RCSPW</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// erase未通过检验的Widget的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">  <span class="n">not1</span> <span class="p">(</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">isCertified</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 没有资源泄漏
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要让这些工作，你的<strong>智能指针类型就必须可以（比如<code>RCSP&lt;Widget&gt;</code>）隐式转换为相应的内建指针类型（比如<code>Widget*</code>）</strong>。那是因为容器持有智能指针，但被调用的成员函数（比如Widget::isCertified）要的是内建指针。如果不存在隐式转换，你的编译器会抗议的。</p>
]]></description></item><item><title>Effective STL [32] | 如果你真的想删除东西的话就在类似remove的算法后接上erase</title><link>https://jianye0428.github.io/posts/clause_32/</link><pubDate>Sat, 26 Aug 2023 10:55:50 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_32/</guid><description><![CDATA[<h2 id="remove实际作用">remove实际作用</h2>
<h3 id="remove的声明">remove的声明</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ForwardIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardIterator</span> <span class="n">remove</span><span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>remove接收指定它操作的元素区间的一对迭代器。它不接收一个容器，所以<strong>remove不知道它作用于哪个容器</strong>。</p>
<p>此外，remove也不可能发现容器，因为没有办法从一个迭代器获取对应于它的容器。</p>
<h3 id="remove不做什么">remove不做什么</h3>
<p>从容器中除去一个元素，唯一的方法是调用那个容器的一个成员函数，几乎都是erase的某个形式，(list有几个除去元素的成员函数不叫erase，但它们仍然是成员函数。)因为唯一从容器中除去一个元素的方法是在那个容器上调用一个成员函数，而且因为remove无法知道它正在操作的容器，所以remove不可能从一个容器中除去元素。</p>
<p>从一个容器中remove元素不会改变容器中元素的个数：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector&lt;int&gt; 用1-10填充它(调用reserve的解释在条款14)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 打印10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设置3个元素为99
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">);</span> <span class="c1">// 删除所有等于99的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// 仍然是10！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=blue>remove并不“真的”删除东西，因为它做不到。</font></p>
<p><strong>remove不知道它要从哪个容器删除东西，而没有容器，它就没有办法调用成员函数。</strong></p>
<h3 id="remove-做了什么">remove 做了什么</h3>
<p>remove移动指定区间中的元素直到所有“不删除的”元素在区间的开头(相对位置和原来它们的一样)。它返回一个指向最后一个的下一个“不删除的”元素的迭代器。返回值是区间的“新逻辑终点”。</p>
<p>举个例子，这是v在调用remove前看起来的样子：</p>
<p></p>
<p>如果我们把remove的返回值存放在一个叫做newEnd的新迭代器中:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">newEnd</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是调用后v看起来的样子:</p>
<p></p>
<p>如果“不删除的”元素在v中的v.begin()和newEnd之间，“删除的”元素就必须在newEnd和v.end()之间。</p>
<p><strong>remove并没有改变区间中元素的顺序，所以不会把所有“删除的”元素放在结尾，并安排所有“不删除的”值在开头。</strong></p>
<p>如果你不想失去任何值，你可能应该调用partition或stable_partition而不是remove。</p>
<h3 id="remove-实际操作流程">remove 实际操作流程</h3>
<p>在内部，remove遍历这个区间，把要“删除的”值覆盖为后面要保留的值。这个覆盖通过对持有被覆盖的值的元素赋值来完成。</p>
<ol>
<li>remove检测v[0]，发现它的值不是要被删除的，然后移动到v[1]。同样的情况发生在v[1]和v[2]。</li>
<li>发现v[3]应该被删除，所以它记录下v[3]的值应该被覆盖，然后它移动到v[4]。这类似记录v[3]是一个需要填充的“洞”。</li>
<li>发现v[4]的值应该被保持，所以它把v[4]赋给v[3]，记录下v[4]应该被覆盖，然后移动到v[5]。继续类似的压缩，它用v[4]“填充”v[3]而且记录v[4]现在是一个洞。</li>
<li>发现v[5]应该被删除，所以忽略并它移动到v[6]。仍然记得v[4]是一个等待填充的洞。</li>
<li>发现v[6]是一个应该保留的值，所以把v[6]赋给v[4]。记得v[5]现在是下一个要被填充的洞，然后移到v[7]。</li>
<li>在某种意义上类似上面的，检查v[7]、v[8]和v[9]。把v[7]赋给v[5]，v[8]赋给v[6]，忽略v[9]，因为v[9]的值是要被删除的。</li>
<li>返回指定下一个要被覆盖的元素的迭代器，在这个例子中这个元素是v[7]。</li>
</ol>
<p></p>
<p>事实上当remove在删除时覆盖的值是指针时，会有重要的影响。但是对于本条款，知道remove不从容器中除去任何元素因为它做不到就够了。</p>
<h2 id="应该在remove后面接上erase">应该在remove后面接上erase</h2>
<p>只有容器成员函数可以除去容器元素，而那是本条款的整个要点：<strong>如果你真的要删除东西的话，你应该在remove后面接上erase</strong>。</p>
<p>要除去那些元素，你要做的所有事情就是用那两个迭代器调用erase的区间形式。因为remove本身很方便地返回了区间新逻辑终点的迭代器:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正如从前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 真的删除所有等于99的元素，现在返回7
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>事实上，remove和erase是亲密联盟，这两个整合到list成员函数remove中。这是STL中唯一名叫remove又能从容器中除去元素的函数：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">li</span><span class="p">;</span>  <span class="c1">// 建立一个list放一些值进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">li</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">99</span><span class="p">);</span> <span class="c1">// 除去所有等于99的元素：真的删除元素，所以它的大小可能改变了
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用这个remove函数是一个STL中的矛盾。在关联容器中类似的函数叫erase，list的remove也可以叫做erase。但它没有，所以我们都必须习惯它。</p>
<p><strong>对于list，调用remove成员函数比应用erase-remove惯用法更高效。</strong></p>
<h2 id="类似remove的算法">类似remove的算法</h2>
<p><code>remove_if</code>和<code>unique</code>。 remove和remove_if之间的相似性很直截了当。</p>
<p>unique行为也像remove。它用来从一个区间删除东西(邻近的重复值)而不用访问持有区间元素的容器。如果你真的要从容器中删除元素，你也必须成对调用unique和erase，unique在list中也类似于remove。正像list::remove真的删除东西(而且比erase-remove惯用法高效得多)。</p>
<p><code>list::unique</code>也真的删除邻近的重复值(也比erase-unique高效)。</p>
]]></description></item><item><title>Effective STL [31] | 了解你的排序选择</title><link>https://jianye0428.github.io/posts/clause_31/</link><pubDate>Sat, 26 Aug 2023 10:19:35 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_31/</guid><description><![CDATA[<h2 id="稳定排序-vs-不稳定排序">稳定排序 VS 不稳定排序</h2>
<p>有些排序算法是稳定的。在稳定排序中，如果一个区间中的两个元素有等价的值，它们的相对位置在排序后不改变。不稳定的算法没做这个保证。</p>
<p>例如，在（未排序的）widgets vector中Widget A在Widget B之前，而且两者都有相同的质量等级，那么稳定排序算法会保证在这个vector排序后，Widget A仍然在Widget B之前。</p>
<h2 id="partial_sort"><code>partial_sort</code></h2>
<p>sort是个令人称赞的算法，如果不需要完全排序时，比如有一个存有Widget 的vector，你想选择20个质量最高的Widget发送给客户，20个之外的Widget可以保持无序，也就是你需要的是部分排序，这时就可以用partial_sort。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">qualityCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回lhs的质量是不是比rhs的质量好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把最好的20个元素（按顺序）放在widgets的前端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">partial_sort</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用widgets...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用完partial_sort后，widgets的前20个元素是容器中最好的而且它们按顺序排列，质量最高的Widget是widgets[0]，第二高的是widgets[1]等。</p>
<p>partial_sort是不稳定的。</p>
<h2 id="nth_element">nth_element</h2>
<p>如果你不关心哪个Widget给哪个客户，你需要的只是任意顺序的20个最好的Widget。STL中nth_element可以精确地完成了你需要的。</p>
<p>nth_element排序一个区间，在n位置（你指定的）的元素是如果区间被完全排序后会出现在那儿的元素。</p>
<p><strong>Example</strong></p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">randy</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//默认求第m大的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">randy</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//定义cmp可求第m小的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">randy</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>函数是将第 m 大的元素放在 arr 数组数组中适当位置，其他元素按照第 m 元素的大小划分。 在[ 0, n ]这个范围内，在第 m 个元素之前的元素都小于或等于第 m 个元素，而且第 m 个元素后面的每个元素都会比它大。</p>
<p><code>nth_element()</code>函数仅将第 m 大/小的数在 randy 数组中排好了位置，并不返回值。输出 randy[m] 即是第 m 大/小的数。</p>
<p><strong>排序Widget数组</strong></p>
<p>使用nth_element来保证最好的20个Widget在widgets vector的前端：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">nth_element</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">19</span><span class="p">,</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把最好的20个元素放在widgets前端，但不用担心它们的顺序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用nth_element本质上等价于调用partial_sort，两个算法都把20个质量最高的Widget移动到vector前端。</p>
<p>它们结果的唯一区别是partial_sort排序了在位置1-20的元素，而nth_element不排序。</p>
<p><strong>其他用法</strong></p>
<p>除了能帮你找到区间顶部的n个元素，它也可以用于找到区间的中值或者找到在指定百分点的元素：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 迭代器的变量方便地表示widgets的起点和终点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这个迭代器指示了下面代码要找的中等质量等级的Widget的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">goalPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 兴趣的Widget会是有序的vector的中间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">goalPosition</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">widgets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 找到widgets中中等质量等级的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">nth_element</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">goalPosition</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// goalPosition现在指向中等质量等级的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 下面的代码能找到质量等级为75%的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1">// 指出兴趣的Widget离开始有多远
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">goalOffset</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">widgets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 找到质量值为75%的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">nth_element</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">goalOffset</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// begin + goalOffset现在指向质量等级为75%的Widget
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="元素有同样质量">元素有同样质量</h2>
<p>假设有12个元素质量是1级（可能是最好的），15个元素质量是2级（第二好的）。在这种情况下，选择20个最好的Widget就是选择12个1级的和15个中的8个2级的。partial_sort和nth_element怎么判断15个中的哪些要放到最好的20个中？对于这个问题，当多个元素有等价的值时sort怎么判断元素的顺序？</p>
<p>partial_sort和nth_element以任何它们喜欢的方式排序值等价的元素，而且你不能控制它们在这方面行为。</p>
<p>nth_element、sort也没有提供稳定性。</p>
<h2 id="stable_sort">stable_sort</h2>
<p>stable_sort 是稳定排序，STL并不包含partial_sort和nth_element的稳定版本。</p>
<p>当指定范围内包含多个相等的元素时，sort() 排序函数无法保证不改变它们的相对位置。那么，如果既要完成排序又要保证相等元素的相对位置，可以使用stable_sort()函数</p>
<p>stable_sort() 函数完全可以看作是 sort() 函数在功能方面的升级版。stable_sort() 和 sort() 具有相同的使用场景，就连语法格式也是相同的（后续会讲），只不过前者在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">//对 [first, last) 区域内的元素做默认的升序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">stable_sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">stable_sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;     // std::cout</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;    // std::stable_sort</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // std::vector</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//以普通函数的方式实现自定义排序规则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">randy_comp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//以函数对象的方式实现自定义排序规则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">kim_comp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">jeff_num</span><span class="p">{</span><span class="mi">88</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>  <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 2 13 22 88 1 30 3 33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//利用STL标准库提供greater&lt;T&gt;进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>  <span class="c1">// 88 22 13 2 1 30 3 33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//通过自定义比较规则进行排序,这里也可以换成 kim_comp()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">randy_comp</span><span class="p">);</span>  <span class="c1">// 1 2 3 13 22 30 33 88
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="partition">partition</h2>
<p>但是完全排序需要很多工作，而且对于这个任务做了很多不必要的工作。一个更好的策略是使用partition算法，它重排区间中的元素以使所有满足某个标准的元素都在区间的开头。</p>
<p>比如，移动所有质量等级为2或更好的Widget到widgets前端：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">hasAcceptableQuality</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 返回w质量等级是否是2或更高;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 把所有满足hasAcceptableQuality的widgets移动到widgets前端，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 并且返回一个指向第一个不满足的widget的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">goodEnd</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">hasAcceptableQuality</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此调用完成后，从widgets.begin()到goodEnd的区间容纳了所有质量是1或2的Widget，从goodEnd到widgets.end()的区间包含了所有质量等级更低的Widget。</p>
<p>如果在分割时保持同样质量等级的Widget的相对位置很重要，我们自然会用stable_partition来代替partition。</p>
<p><strong>list排序</strong></p>
<p>唯一我们可能会但不能使用<code>sort</code>、<code>stable_sort</code>、<code>partial_sort</code>或<code>nth_element</code>的容器是<code>list</code>，<code>list</code>通过提供<code>sort</code>成员函数做了一些补偿。（有趣的是，list::sort提供了<u>稳定排序</u>。）</p>
<p>如果你想要对list中的对象进行partial_sort或nth_element，你必须间接完成：</p>
<ol>
<li>把元素拷贝到一个支持随机访问迭代器的容器中，然后对它应用需要的算法;</li>
<li>建立一个list::iterator的容器，对那个容器使用算法，然后通过迭代器访问list元素;</li>
<li>使用有序的迭代器容器的信息来迭代地把list的元素接合到你想让它们所处的位置。</li>
</ol>
<h2 id="总结">总结</h2>
<p><strong>算法sort、stable_sort、partial_sort和nth_element需要随机访问迭代器，所以它们可能只能用于vector、string、deque和数组。</strong></p>
<p>对标准关联容器排序元素没有意义，因为这样的容器使用它们的比较函数来在任何时候保持有序。</p>
<p>partition和stable_partition与sort、stable_sort、partial_sort和nth_element不同，它们只需要双向迭代器。因此你可以在任何标准序列迭代器上使用partition和stable_partition。</p>
<ol>
<li>如果需要在vector、string、deque或数组上进行<strong>完全排序</strong>，你可以使用<code>sort</code>或<code>stable_sort</code>。</li>
<li>如果你有一个vector、string、deque或数组，<strong>只需要排序前n个元素</strong>，应该用<code>partial_sort</code>。</li>
<li>如果你有一个vector、string、deque或数组，<strong>需要鉴别出第n个元素或你需要鉴别出最前的n个元素，而不用知道它们的顺序</strong>，nth_element是你应该注意和调用的。</li>
<li>如果你需要<strong>把标准序列容器的元素或数组分隔为满足和不满足某个标准</strong>，你大概就要找partition或stable_partition。</li>
<li>如果你的数据是在list中，你可以直接使用partition和stable_partition，你可以使用list的sort来代替sort和stable_sort。如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务。</li>
</ol>
<p>你可以通过把数据放在标准关联容器中的方法以<strong>保持在任何时候东西都有序</strong>。你也可能会考虑标准非STL容器priority_queue，它也可以总是保持它的元素有序。</p>
<p>一般来说，<font color=blue>做更多工作的算法比做得少的要花更长时间，而必须稳定排序的算法比忽略稳定性的算法要花更长时间</font>。</p>
<p>本节讨论的算法需要更少资源（时间和空间）的算法排序：</p>
<ol>
<li>partition</li>
<li>partial_sort</li>
<li>stable_partition</li>
<li>sort</li>
<li>nth_element</li>
<li>stable_sort</li>
</ol>
]]></description></item><item><title>Effective STL 精度总结 [6] | 仿函数、仿函数类、函数等</title><link>https://jianye0428.github.io/posts/partsix/</link><pubDate>Tue, 22 Aug 2023 19:22:49 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partsix/</guid><description><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-STL总结系列分为七部分，本文为第六部分，涉及原书第六章，内容范围Rule38~42。为方便书写，Rule38简写为R38。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-STL系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<h2 id="r38-遵循按值传递的原则来设计函数子类">R38: 遵循按值传递的原则来设计函数子类</h2>
<p>函数指针是按值传递的。</p>
<p>函数对象往往按值传递和返回。所以，编写的函数对象必须尽可能地小巧，否则复制的开销大；函数对象必须是<strong>单态</strong>的（不是多态），不得使用虚函数。</p>
<p>如果你希望创建一个包含大量数据并且使用了多态性的函数子类，该怎么办呢？</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFCImpl</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">BPFCImpl</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">friend</span> <span class="k">class</span> <span class="nc">BPFC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>					<span class="c1">// 允许BPFC访问内部数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFC</span><span class="o">:</span>								<span class="c1">// 新的BPFC类：短小、单态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">BPFCImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>					<span class="c1">// BPFC唯一的数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span>	<span class="c1">// 现在这是一个非虚函数，将调用转到BPFCImpl中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pImpl</span><span class="o">-&gt;</span><span class="k">operator</span><span class="p">()(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么你应该创建一个小巧、单态的类，其中包含一个指针，指向另一个实现类，并且将所有的数据和虚函数都放在实现类中（“Pimpl Idiom”）。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFCImpl</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">BPFCImpl</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">friend</span> <span class="k">class</span> <span class="nc">BPFC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>					<span class="c1">// 允许BPFC访问内部数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFC</span><span class="o">:</span>								<span class="c1">// 新的BPFC类：短小、单态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">BPFCImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>					<span class="c1">// BPFC唯一的数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span>	<span class="c1">// 现在这是一个非虚函数，将调用转到BPFCImpl中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pImpl</span><span class="o">-&gt;</span><span class="k">operator</span><span class="p">()(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="r39-确保判别式是-纯函数">R39 确保判别式是 “纯函数”</h2>
<p><strong>判别式（predicate）：一个返回值为 bool 类型的函数。</strong></p>
<p><strong>纯函数：指返回值仅仅依赖于其参数的函数。</strong></p>
<p>判别式类（predicate class）：一个函数子类，它的 operator() 函数是一个判别式（返回 true 或 false）。</p>
<p>STL 中凡是可以接受一个判别式类对象的地方，也就可以接受一个判别式函数。</p>
<p>判别式应该是一个纯函数，而纯函数应该没有状态。</p>
<h2 id="r40-使仿函数类可适配">R40 使仿函数类可适配</h2>
<p>对函数指针，要先应用<code>ptr_fun</code>之后再应用<code>not1</code>之后才可以工作。</p>
<p>4 个标准的函数配接器（<code>not1</code>、<code>not2</code>、<code>bind1st</code>、<code>bind2nd</code>）都要求一些特殊的类型定义，提供这些必要类型定义（<code>argument_type</code>、<code>first_argument_type</code>、<code>second_argument_type</code>、<code>result_type</code>）的函数对象被称为可配接(可适配)（<code>adaptable</code>）的函数对象。</p>
<p>提供这些类型定义最简单的方法：让函数子从一个基结构继承。</p>
<ul>
<li>对于 unary_function，必须指定函数子类 operator() 所带的参数类型，以及 operator() 返回类型。</li>
<li>对于 binary_function，必须指定 3 个类型：operator() 第一个和第二个参数类型，以及 operator() 返回类型。</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MeetsThreshold</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">unary_function</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">T</span> <span class="n">threshold</span><span class="p">;</span>						<span class="c1">// 包含状态信息，使用类封装。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MeetsThreshold</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">threshold</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">WidgetNameCompare</span><span class="o">:</span>					<span class="c1">// STL中所有无状态函数子类一般都被定义成结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">Widget</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，一般情况下，传递给 binary_function 或 unary_function 的非指针类型需要去掉 const 和应用（&amp;）部分。</p>
<h2 id="r41-理解-ptr_funmem_fun-和-mem_fun_ref-的来由">R41 理解 ptr_fun、mem_fun 和 mem_fun_ref 的来由</h2>
<p>STL语法惯例：函数或者函数对象被调用时，总是使用非成员函数的语法形式。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">test</span><span class="p">);</span>					<span class="c1">// 调用1：f(x)，f为非成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">test</span><span class="p">);</span>			<span class="c1">// 调用2：x.f()，f为成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">// x是一个对象或对象的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">*&gt;</span> <span class="n">lpw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">lpw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lpw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Widgettest</span><span class="p">);</span>			<span class="c1">// 调用3：p-&gt;f()，f为成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">// p是一个指向对象x的指针。
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>mem_fun、mem_fun_t：mem_fun 将语法 3 调整为语法 1。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>		<span class="c1">//该mem_fun声明针对不带参数的非const成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mem_fun_t</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span>							<span class="c1">//C是类，R是所指向的成员函数返回的类型。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mem_fun</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">pmf</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>mem_fun 带一个指向某个成员函数的指针参数 pmf，并且返回一个 mem_fun_t 类型的对象。</p>
<p>mem_fun_t 是一个函数子类，它拥有该成员函数的指针，并提供了 operator() 函数，在 operator() 中调用了通过参数传递进来的对象上的该成员函数。</p>
<p>类似地，mem_fun_ref 将语法 2 调整为语法 1。</p>
<p><strong>总结:</strong></p>
<ul>
<li>std::ptr_fun：将函数指针转换为函数对象。</li>
<li>std::mem_fun：将成员函数转换为函数对象(指针版本)。</li>
<li>std::mem_fun_ref：将成员函数转换为函数对象(引用版本)。</li>
</ul>
<h2 id="r42">R42</h2>
<p>Ref:</p>
<p>[1]. <a href="https://www.cnblogs.com/Sherry4869/p/15162253.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/Sherry4869/p/15162253.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[2]. <a href="https://blog.csdn.net/zhuikefeng/article/details/108164117#t35"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/zhuikefeng/article/details/108164117#t35<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[3]. <a href="https://zhuanlan.zhihu.com/p/458156007"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/458156007<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Transformer Q &amp; A</title><link>https://jianye0428.github.io/posts/transformerqanda/</link><pubDate>Mon, 21 Aug 2023 07:59:36 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/transformerqanda/</guid><description><![CDATA[<h2 id="1-2017年深度学习领域的重大突破是什么">1. 2017年深度学习领域的重大突破是什么？</h2>
<p>Transformer。有两方面的原因:</p>
<p>1.1 一方面，Transformer是深度学习领域继MLP、RNN、CNN之后的第4大特征提取器(也被称为基础模型)。</br>
<strong>什么是特征提取器？</strong></br>
特征提取器是计算机模仿大脑，与外部世界(图像、文字、语音等)交互的方式，如图1所示。举例而言: Imagenet数据集中包含1000类图像，人们已经根据自己的经验把这一百万张图像分好1000类，每一类图像(如美洲豹)都有独特的特征。这时，神经网络(如ResNet18)也是想通过这种分类的方式，把每一类图像的特征尽可能提取或识别出来。分类不是最终目的，而是一种提取图像特征的手段，掩码补全图像也是一种提取特征的方式，图像块顺序打乱也是一种提取特征的方式。</p>
<p></p>
<p>1.2 另一方面，Transformer在深度学习领域扮演的角色: 第3次和第4次热潮的基石，如下图2所示。</p>
<p></p>
<h2 id="2-transformer的提出背景是什么">2. Transformer的提出背景是什么？</h2>
<p><strong>2.1 在领域发展背景层面</strong>: 当时时处2017年，深度学习在计算机视觉领域已经火了几年。从Alexnet、VGG、GoogleNet、ResNet、DenseNet;从图像分类、目标检测再到语义分割;但在自然语言处理领域并没有引起很大反响。</p>
<p><strong>2.2 技术背景层面</strong>:
(1)当时主流的序列转录任务(如机器翻译)的解决方案如下图3所示，在Sequence to Sequence架构下(Encoder-Decoder的一种)，RNN来提取特征，Attention机制将Encoder提取到的特征高效传递给Decoder。
(2)这种做法有两个不足之处，一方面是在提取特征时的RNN天生<strong>从前向后时序传递</strong>的结构决定了其无法并行运算，其次是当序列长度过长时，最前面序列的信息有可能被遗忘掉。因此可以看到，在这个框架下，RNN是相对薄弱急需改进的地方。</p>
<p></p>
<h2 id="3-transformer到底是什么">3. Transformer到底是什么？</h2>
<p>3.1 Transformer是一种由Encoder和Decoder组成的架构。那么什么是架构呢？最简单的架构就是A + B + C。</p>
<p>3.2 Transformer也可以理解为一个函数，输入是“我爱学习”，输出是“I love study”。</p>
<p>3.3 如果把Transformer的架构进行分拆，如图4所示。</p>
<p></p>
<h2 id="4-什么是transformer-encoder">4. 什么是Transformer Encoder？</h2>
<p>4.1 从<font color=red>功能角度</font>，Transformer Encoder的核心作用是<strong>提取特征</strong>，也有使用Transformer Decoder来提取特征。例如，一个人学习跳舞，Encoder是看别人是如何跳舞的，Decoder是将学习到的经验和记忆(key和value的匹配程度)，展现出来</p>
<p>4.2 从<font color=red>结构角度</font>，如图5所示，Transformer Encoder = Embedding + Positional Embedding + N * (子Encoder block1 + 子Encoder block2);</p>
<p>子Encoder block1 = Multi head attention + ADD + Norm;</p>
<p>子Encoder block2 = Feed Forward + ADD + Norm;</p>
<p>4.3 从<font color=red>输入输出角度</font>，N个Transformer Encoder block中的第一个Encoder block的输入为一组向量 X = (Embedding + Positional Embedding)，向量维度通常为512*512，其他N个TransformerEncoder block的输入为上一个 Transformer Encoder block的输出，输出向量的维度也为<code>512*512</code>(输入输出大小相同)。</p>
<p>4.4 为什么是<code>512*512</code>？<font color=red>前者是指token的个数</font>，如“我爱学习”是4个token，这里设置为512是为了囊括不同的序列长度，不够时padding。<font color=red>后者是指每一个token生成的向量维度</font>，也就是每一个token使用一个序列长度为512的向量表示。人们常说，Transformer不能超过512，否则硬件很难支撑;其实512是指前者，也就是token的个数，因为每一个token要做self attention操作;但是后者的512不宜过大，否则计算起来也很慢。</p>
<p></p>
<h2 id="5-什么是transformer-decoder">5. 什么是Transformer Decoder？</h2>
<p>5.1 从功能角度，相比于Transformer Encoder，Transformer Decoder更擅长做<strong>生成式任务</strong>，尤其对于自然语言处理问题。</p>
<p>5.2 从结构角度，如图6所示，Transformer Decoder = Embedding + Positional Embedding + N*(子Decoder block1 + 子Decoder block2 + 子Decoder block3)+ Linear + Softmax;</p>
<p>子Decoder block1 = Mask Multi head attention + ADD + Norm;</p>
<p>子Decoder block2 = Multi head attention + ADD + Norm;</p>
<p>子Decoder block3 = Feed Forward + ADD + Norm;</p>
<p></p>
<p>5.3 从(Embedding+Positional Embedding)(N个Decoder block)(Linear + softmax) 这三个每一个单独作用角度:</p>
<p>Embedding + Positional Embedding: 以机器翻译为例，输入“Machine Learning”，输出“机器学习”; 这里的Embedding是把“机器学习”也转化成向量的形式。</p>
<p>N个Decoder block: 特征处理和传递过程。</p>
<p>Linear + softmax: softmax是预测下一个词出现的概率，如图7所示，前面的Linear层类似于分类网络(ResNet18)最后分类层前接的MLP层。</p>
<p></p>
<p>5.4 Transformer Decoder的输入、输出是什么？在Train和Test时是不同的。</p>
<p>在Train阶段，如图8所示。这时是知道label的，decoder的第一个输入是begin字符，输出第一个向量与label中第一个字符使用cross entropy loss。Decoder的第二个输入是第一个向量的label，Decoder的第N个输入对应的输出是End字符，到此结束。这里也可以看到，在Train阶段是可以进行<strong>并行训练</strong>的。</p>
<p></p>
<p>在Test阶段，下一个时刻的输入是前一个时刻的输出，如图9所示。因此，Train和Test时候，Decoder的输入会出现Mismatch，在Test时候确实有可能会出现一步错，步步错的情况。有两种解决方案: 一种是train时偶尔给一些错误，另一种是Scheduled sampling。</p>
<p></p>
<p>5.5 Transformer Decoder block内部的输入和输出是什么？</p>
<p>前面提到的是在整体train和test阶段，Decoder的输入和输出，那么Transformer Decoder内部的Transformer Decoder block，如图10所示，的输入输出又是什么呢？</p>
<p></p>
<p>对于N=6中的第1次循环(N=1时): 子Decoder block1 的输入是 embedding +Positional Embedding，子Decoder block2 的输入的Q来自子Decoder block1的输出，KV来自Transformer Encoder最后一层的输出。</p>
<p>对于N=6的第2次循环: 子Decoder block1的输入是N=1时，子Decoder block3的输出，KV同样来自Transformer Encoder的最后一层的输出。</p>
<p>总的来说，可以看到，无论在Train还是Test时，Transformer Decoder的输入不仅来自(ground truth或者上一个时刻Decoder的输出)，还来自Transformer Encoder的最后一层。</p>
<p>训练时: 第i个decoder的输入 = encoder输出 + ground truth embedding。</p>
<p>预测时: 第i个decoder的输入 = encoder输出 + 第(i-1)个decoder输出.</p>
<h2 id="6-transformer-encoder和transformer-decoder有哪些不同">6. Transformer Encoder和Transformer Decoder有哪些不同？</h2>
<p>6.1 作用上，Transformer Encoder常用来<strong>提取特征</strong>，Transformer Decoder常用于<strong>生成式任务</strong>。Transformer Encoder和Transformer Decoder是两条不同的技术路线，<strong>Bert采用的前者，GPT系列模型采用的是后者</strong>。</p>
<p>6.2 结构上，Transformer Decoder block包括了3个子Decoder block，而Transformer Encoder block 包括2个子Encoder block，且Transformer Decoder中使用了Mask multi-head Attention。</p>
<p>6.3 从二者的输入输出角度，N个Transformer Encoder运算完成之后，它的输出才正式输入进Transformer Decoder，作为QKV中的K和V，给Transformer Decoder使用。那么TransformerEncoder最后层的输出是如何送给Decoder呢？如图11所示。</p>
<p></p>
<p>那么，为什么Encoder和Decoder必须要用这种交互的方式呢？其实也并不一定，后续有不同交互方式的提出，如图12。</p>
<p></p>
<h2 id="7-什么是embedding">7. 什么是Embedding？</h2>
<p>7.1 Embedding在Transformer架构中的位置如图13所示。</p>
<p>7.2 提出背景:  计算机无法直接处理一个单词或者一个汉字，需要把一个token转化成计算机可以识别的向量，这也就是embedding过程。</p>
<p>7.3 实现方式:  最简单的embedding操作就是one hot vector，但one hot vector有一个弊端就是没有考虑词语前后之间的关系，后来也就产生了WordEmbedding，如图13。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">wordembedding将单词token向量化，并且考虑的单词与单词之间的相关性。</div>
    </div>
  </div>
<p></p>
<h2 id="8-什么是positional-embedding">8. 什么是Positional Embedding？</h2>
<p>8.1 Positional Embedding在Transformer架构中的位置如图14所示。</p>
<p>8.2 提出背景:  RNN作为特征提取器，是自带词的前后顺序信息的;而Attention机制并没有考虑先后顺序信息，但前后顺序信息对语义影响很大，因此需要通过Positional Embedding这种方式把前后位置信息加在输入的Embedding上。</p>
<p>8.3 实现方式:  传统位置编码和神经网络自动训练得到。</p>
<p></p>
<h2 id="9-什么是attention">9. 什么是Attention？</h2>
<p>9.1 介绍Transformer，为什么要介绍Attention呢？因为在Transformer中最多的multi head attention和Mask multi head attention来自Scaled dot product attention，而scaled dot product attention来自self attention，而self attention是attention的一种，因此首先需要了解Attention，如图15所示。</p>
<p></p>
<p>9.2 Attention到底是什么意思呢？</p>
<p>对于图像而言，attention就是人们看到图像中的核心关注的区域，是图像中的重点，如图16所示。对于序列而言，Attention机制本质上是为了找到<strong>输入中不同token之间的相互关系</strong>，通过权重矩阵来自发地找到词与词之间的关系。</p>
<p></p>
<p>9.3 Attention是如何实现的呢？</p>
<p>是通过QKV实现的。</p>
<p>那么什么是QKV呢？Q是query，K是keys，V是values。如图17所示，举例而言，Q是大脑发出的信号，我口渴了;K是环境信息，眼睛看到的世界;V是对环境中不同的物品赋予不同的比重，水的比重加大。</p>
<p>总之，Attention就是通过计算QK的相似度，与V相乘得到注意力数值。</p>
<p>$$\text{Attention}(\mathrm{Query},\mathrm{Source})=\sum\text{Similarity}(\mathrm{Query},\mathrm{Key}<em>\mathrm{i})*\mathrm{Value}</em>\mathrm{i}$$</p>
<p></p>
<p>9.4 为什么必须要有QKV三者？</p>
<p>为什么不是只有Q？因为Q1与Q2之间的关系权重，不止需要a12，也需要a21。你可能会问？我们让a12=a21不行吗？也可以尝试，但从原理上讲效果应该没有a12和a21效果好。</p>
<p>为什么不是只有QK？求得的权重系数需要放到输入中，可以乘Q，也可以乘K，为什么要重新乘V呢？我觉得可能是多了一组可训练参数$W_V$，使网络具有更强的学习能力。</p>
<h2 id="10-什么是self-attention">10. 什么是Self Attention？</h2>
<p>10.1 介绍Transformer，为什么要介绍self Attention呢？因为在Transformer中最多的multi head attention和Mask multi head attention来自Scaled dot product attention，而scaled dot product attention来自self attention，如图15所示。</p>
<p>10.2 什么是Self Attention呢？self attention和local attention、stride attention都是attention的一种;self attention是每一个Q与每一个K依次计算注意力系数，如图18所示，而像local attention是Q只与相邻的K计算注意力系数，stride attention是Q通过跳连的方式与K计算注意力系数。</p>
<p></p>
<p>10.3 Self attention为什么可以用于处理像机器翻译这种序列数据?</p>
<p>输入序列中的每一个位置的数据，可以关注其他位置的信息，由此通过Attention score来提取特征或者捕获输入序列每一个token之间的关系。</p>
<p>10.4 Self attention是如何具体实现的? 总共分为4步，如图19所示</p>
<p></p>
<h2 id="11-什么是scaled-dot-product-attention">11. 什么是Scaled dot product attention？</h2>
<p>11.1 self attention最常见的有两种，一种是dot product attention、另一种是additive attention，如图20所示，前者的计算效率更高。</p>
<p></p>
<p>11.2 什么是Scaled ?</p>
<p>scaled的具体实现方式如图21所示，这一操作的目的是为了防止内积过大，从梯度角度考虑，避免靠近1，易训练;与batch normalization有一些相似的功能。</p>
<p>$$\text{Attention}(Q,K,V)=\text{softmax}(\frac{QK^T}{\sqrt{d_k}})V$$</p>
<h2 id="12-什么是multi-head-attention">12. 什么是Multi head attention？</h2>
<p>12.1 Multi head attention在Transformer架构中的位置如图15所示。</p>
<p>12.2 提出背景: CNN具有多个channel，可以提取图像不同维度的特征信息，那么Self attention是否可以有类似操作，可以提取不同距离token的多个维度信息呢？</p>
<p>12.3 什么是group 卷积？如图22所示，将输入的特征多个channel分成几个group单独做卷积，最后再进行con c操作。</p>
<p></p>
<p>12.4 Multi head attention的实现方式？与self attention根本不同是什么？</p>
<p>如图23所示，以2个head的为例，将输入的Q、K、V分成两份，每一小份的Q与对应的K、V分别操作，最后计算得到的向量再进行conc操作，由此可以看出，Multi head attention与group卷积有着相似的实现方式。</p>
<p></p>
<p>12.5 如何从输入输出的维度来理解Multi head attention？如图24所示。</p>
<p></p>
<h2 id="13-什么是mask-multi-head-attention">13. 什么是Mask Multi head attention？</h2>
<p>13.1 Mask Multi head attention在transformer架构中的位置如图15所示。</p>
<p>13.2 为什么要有Mask这种操作？</p>
<p>Transformer预测第T个时刻的输出，不能看到T时刻之后的那些输入，从而保证训练和预测一致。</p>
<p>通过 Masked 操作可以防止第 i 个单词知道 i+1 个单词之后的信息，如图25所示。</p>
<p></p>
<p>13.3 Mask操作是如何具体实现的呢？</p>
<p>Q1只跟K1计算，Q2只跟K1、K2计算，而对于K3、K4等，在softmax之前给一个非常大的负数，由此经过softmax之后变为0，其在矩阵上的计算原理实现如图26所示。</p>
<p></p>
<h2 id="14-什么是add">14. 什么是ADD？</h2>
<p>14.1 Add就是残差连接，由2015年ResNet这篇文章发扬光大(目前引用量已超过16万)，与Skip connection的区别在于需要大小维度全部相同。</p>
<p>14.2 作为大道至简想法的极致，几乎每一个深度学习模型都会用到这个技术，可以<strong>防止网络退化</strong>，常用于解决多层网络难训练的问题。</p>
<p></p>
<h2 id="15-什么是norm">15. 什么是Norm？</h2>
<p>15.1 Norm就是layer normalization。</p>
<p>15.2 核心作用: 为了训练更加稳定，和batch normalization有相同的作用，都是为了使输入的样本均值为零，方差为1。</p>
<p>15.3 为什么不使用batch normalization，使用的是layer normalization呢？因为一个时序数据，句子输入长度有长有短，如果使用batch normalization，则很容易造成因样本长短不一造成“训练不稳定”。BN是对同一个batch内的所有数据的同一个特征数据进行操作;而LN是对同一个样本进行操作。</p>
<p></p>
<ol start="16">
<li>什么是FFN？</li>
</ol>
<p>16.1 FFN就是feed forward networks。</p>
<p>16.2 为什么有了Self attention层，还要有FFN？Attention已经有了想要的序列信息特征，MLP的作用是把信息投影到特定的空间里，再做一次非线性映射，和Self attention交替使用。</p>
<p>16.3 结构上: 包括两层MLP，第一层的维度为$512<em>2048$，第二层的维度为$2048</em>512$，且第二层MLP没有使用激活函数，如图29所示。</p>
<p></p>
<h2 id="17-transformer是如何训练出来的">17. Transformer是如何训练出来的？</h2>
<p>17.1 数据上，在Transformer论文中有提到，用到了4.5M和36M的翻译句子对。</p>
<p>17.2 硬件上，base模型是8个P100 GPU训练了12个小时，大模型是训练了3.5天。</p>
<p>17.3 模型参数和调参层面:</p>
<p>第一，可训练的参数包括$W_Q$、$W_K$、$W_V$、$W_O$，换包括$FFN$层的参数。</p>
<p>第二，可调的参数包括: 每一个token向量表示的维度(d_model)、head的头数、Encoder和Decoder中block重复的次数N、FFN中间层向量的维度、Label smoothing(置信度0.1)和dropout(0.1)。</p>
<h2 id="18-transformer为什么效果好">18. Transformer为什么效果好？</h2>
<p>18.1 虽然题目是Attention is all you need，但后续一些研究表明，Attention、残差连接、layer normalization、FFN，这些因素共同成就了Transformer。</p>
<p>18.2 Transformer优点包括:</p>
<p>第一，提出深度学习继MLP、CNN、RNN后的第4大特征提取器。</p>
<p>第二，一开始用在机器翻译，随着GPT和Bert彻底出圈;是一个转折点，在这个点之后，NLP领域快速发展，之后多模态、大模型、视觉Transformer等开始兴起。</p>
<p>第三，给人们信心，原来CNN和RNN之后，还可以有效果更好的特征提取器。</p>
<p>18.3 Transformer的不足之处？</p>
<p>第一，计算量大，对硬件要求高。</p>
<p>第二，因为无归纳偏置，需要很多数据才可以取得很好的效果。</p>
<p>Ref:</br>
[1]. <a href="https://mp.weixin.qq.com/s/sNyh3SzhIdsk8feYfQlTSA"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/sNyh3SzhIdsk8feYfQlTSA<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Transformer | 如何理解attention中的Q,K,V？</title><link>https://jianye0428.github.io/posts/attentionaqkv/</link><pubDate>Sun, 20 Aug 2023 17:44:07 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/attentionaqkv/</guid><description><![CDATA[<h2 id="解答一">解答一</h2>
<p>我们直接用torch实现一个SelfAttention来说一说：</p>
<ol>
<li>首先定义三个线性变换矩阵，query, key, value：</li>
</ol>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，这里的query, key, value只是一种操作(线性变换)的名称，实际的Q/K/V是它们三个的输出
2. 假设三种操作的输入都是同一个矩阵(暂且先别管为什么输入是同一个矩阵)，这里暂且定为长度为L的句子，每个token的特征维度是768，那么输入就是(L, 768)，每一行就是一个字，像这样：

乘以上面三种操作就得到了Q/K/V，(L, 768)*(768,768) = (L,768)，维度其实没变，即此刻的Q/K/V分别为：

代码为:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden_states</span><span class="p">):</span> <span class="c1"># hidden_states 维度是(L, 768)</span>
</span></span><span class="line"><span class="cl">     <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>
<p>然后来实现这个操作:
$$Attention(Q,K_i,V_i)\color{red}{\boxed{=softmax(\frac{Q^TK_i}{\sqrt{d_k}})V_i}}$$
① 首先是Q和K矩阵乘，(L, 768)*(L, 768)的转置=(L,L)，看图：

首先用Q的第一行，即“我”字的768特征和K中“我”字的768为特征点乘求和，得到输出(0，0)位置的数值，这个数值就代表了“我想吃酸菜鱼”中“我”字对“我”字的注意力权重，然后显而易见输出的第一行就是“我”字对“我想吃酸菜鱼”里面每个字的注意力权重；整个结果自然就是“我想吃酸菜鱼”里面每个字对其它字(包括自己)的注意力权重(就是一个数值)了~</p>
<p>② 然后是除以根号dim，这个dim就是768，至于为什么要除以这个数值？主要是为了缩小点积范围，确保softmax梯度稳定性，具体推导可以看这里：<a href="https://zhuanlan.zhihu.com/p/149903065"target="_blank" rel="external nofollow noopener noreferrer">莲生三十二：Self-attention中dot-product操作为什么要被缩放<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，然后就是为什么要softmax，一种解释是为了保证注意力权重的非负性，同时增加非线性，还有一些工作对去掉softmax进行了实验，如<a href="https://zhuanlan.zhihu.com/p/157490738"target="_blank" rel="external nofollow noopener noreferrer">PaperWeekly：线性Attention的探索：Attention必须有个Softmax吗？<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>③ 然后就是刚才的注意力权重和V矩阵乘了，如图：
</p>
<p>注意力权重 x VALUE矩阵 = 最终结果 </br>
首先是“我”这个字对“我想吃酸菜鱼”这句话里面每个字的注意力权重，和V中“我想吃酸菜鱼”里面每个字的第一维特征进行相乘再求和，这个过程其实就相当于用每个字的权重对每个字的特征进行加权求和，然后再用“我”这个字对对“我想吃酸菜鱼”这句话里面每个字的注意力权重和V中“我想吃酸菜鱼”里面每个字的第二维特征进行相乘再求和，依次类推~最终也就得到了(L,768)的结果矩阵，和输入保持一致~</p>
<p>整个过程在草稿纸上画一画简单的矩阵乘就出来了，一目了然~最后上代码：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hidden_states</span><span class="p">):</span> <span class="c1"># hidden_states 维度是(L, 768)</span>
</span></span><span class="line"><span class="cl">     <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">     <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">attention_scores</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attention_head_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">attention_probs</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">attention_scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_probs</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">out</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>为什么叫<strong>自注意力网络</strong>？</br>
因为可以看到Q/K/V都是通过同一句话的输入算出来的，按照上面的流程也就是一句话内每个字对其它字(包括自己)的权重分配；那如果不是自注意力呢？简单来说，Q来自于句A，K、V来自于句B即可~</br></p>
</li>
<li>
<p>注意，K/V中，如果同时替换任意两个字的位置，对最终的结果是不会有影响的，至于为什么，可以自己在草稿纸上画一画矩阵乘；也就是说注意力机制是没有位置信息的，不像CNN/RNN/LSTM；这也是为什么要引入positional embeding的原因。</p>
</li>
</ol>
<h2 id="解答二">解答二</h2>
<p>其实直接用邱锡鹏老师PPT里的一张图就可以直观理解——假设D是输入序列的内容，完全忽略线性变换的话可以近似认为Q=K=V=D(所以叫做Self-Attention，因为这是输入的序列对它自己的注意力)，于是序列中的每一个元素经过Self-Attention之后的表示就可以这样展现：</p>
<p></p>
<p>也就是说，The这个词的表示，实际上是整个序列加权求和的结果——权重从哪来？点积之后Softmax得到——这里Softmax(QK)就是求权重的体现。我们知道，向量点积的值可以表征词与词之间的相似性，而此处的“整个序列”包括The这个词自己(再一次强调这是Self-Attention)，所以最后输出的词的表示，其“主要成分”就主要地包含它自身和跟它相似的词的表示，其他无关的词的表示对应的权重就会比较低。</p>
<h2 id="解答三">解答三</h2>
<p>首先附上链接：<a href="https://zhuanlan.zhihu.com/p/37601161"target="_blank" rel="external nofollow noopener noreferrer">张俊林：深度学习中的注意力模型(2017版)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 。这个几乎是我读到过的讲解Attention最为透彻的篇章之一了。</p>
<p>Q(Querry)代表查询值，对应Decoder的H(t-1)状态。这里要正确理解H(t-1)，想要解码出t时刻的输出，你送入Decoder的必然有前一时刻计算出的隐状态。好了，所谓查询，就是你要拿着这个Decoder中的H(t-1)去和Encoder中各个时刻的隐状态<a href="%e4%b9%9f%e5%b0%b1%e6%98%af%e5%90%84%e4%b8%aaKey">H(1), H(2), &hellip; , H(T)</a>去比，也就是二者计算相似度(对应于文献中的各种energy函数)。最后算出来的结果用Softmax归一化，这个算出来的权重就是带有注意力机制的权重，其实在翻译任务中，Key和Value是相等的。在Transformer的实现源码中，Key和Value的初始值也是相等的。有了这个权重之后，就可以用这个权重对Value进行加权求和，生成的这个新的向量就是带有注意力机制的语义向量 Context vector，而这个语义向量会权衡Target与Source的token与token的关系，从而实现解码输出时，与Source中“真正有决定意义”的token关联。</p>
<p>姑且画蛇添足的再说几句：
首先，Attention机制是由Encoder-Decoder架构而来，且最初是用于完成NLP领域中的翻译(Translation)任务。那么输入输出就是非常明显的 Source-Target的对应关系，经典的Seq2Seq结构是从Encoder生成出一个语义向量(Context vector)而不再变化，然后将这个语义向量送入Decoder配合解码输出。这种方法的最大问题就是这个语义向量，我们是希望它一成不变好呢？还是它最好能配合Decoder动态调整自己，来使Target中的某些token与Source中的真正“有决定意义”的token关联起来好呢？
这就是为什么会有Attention机制的原因。说到底，Attention机制就是想生成会动态变化的语义向量来配合解码输出。而新贵 Self-Attention则是为了解决Target与Source各自内部token与token的关系。在Transformer中，这两种注意力机制得到了有机的统一，释放出了异常惊人的潜力。</p>
<p>ref:</br>
[1]. <a href="https://mp.weixin.qq.com/s/v7N3lhMBSdoGCz4K3TmsmA"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/v7N3lhMBSdoGCz4K3TmsmA<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [30] | 确保目标区间足够大</title><link>https://jianye0428.github.io/posts/clause_30/</link><pubDate>Sat, 19 Aug 2023 15:32:43 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_30/</guid><description><![CDATA[<p>STL容器在被添加时（通过insert、push_front、push_back等）自动扩展它们自己来容纳新对象。</p>
<h2 id="插入数据">插入数据</h2>
<p><strong>尾部插入 back_inserter</strong></p>
<p>当你想向容器中插入对象但并没有告诉STL他们所想的时，问题出现了:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">transmogrify</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 自定义的这个函数从x产生一些新值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把数据放入values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify应用于values中的每个对象
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把这个返回的values附加到results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这段代码有bug！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>transform被告知它的目的区间是从<code>results.end()</code>开始的，所以那就是开始写在values的每个元素上调用<code>transmogrify</code>的结果的地方。</p>
<p>就像所有使用目标区间的算法，<code>transform</code>通过对目标区间的元素赋值的方法写入结果，<code>transform</code>会把<code>transmogrify</code>应用于<code>values[0]</code>并把结果赋给<code>*results.end()</code>。</p>
<p>然后它会把<code>transmogrify</code>应用于<code>value[1]</code>并把结果赋给<code>*(results.end()+1)</code>。</p>
<p>那只能带来灾难，因为在<code>*results.end()</code>没有对象，<code>*(results.end()+1)</code>也没有！因为<code>transform</code>并没有在尾部创造新的对象。</p>
<p>调用<code>transform</code>是错误的，因为它会给不存在的对象赋值。</p>
<p><strong>正确做法</strong></p>
<p>把<code>transform</code>的结果放入<code>results</code>容器的结尾的方式是调用<code>back_inserter</code>来产生指定目标区间起点的迭代器:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify应用于values中的每个对象，在results的结尾插入返回的values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在内部，<code>back_inserter</code>返回的迭代器会调用<code>push_back</code>，所以你可以在任何提供<code>push_back</code>的容器上使用<code>back_inserter</code>(也就是任何标准序列容器: <code>vector</code>、<code>string</code>、<code>deque</code>和<code>list</code>)。</p>
<p><strong>前端插入 front_inserter</strong></p>
<p>如果你想让一个算法在容器的前端插入东西，你可以使用<code>front_inserter</code>。</p>
<p>在内部，<code>front_inserter</code>利用了<code>push_front</code>，所以<code>front_insert</code>只和提供那个成员函数的容器配合(也就是<code>deque</code>和<code>list</code>):</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// results现在是list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 在results前端   以反序   插入transform的结果
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为<code>front_inserter</code>用<code>push_front</code>把每个对象添加到<code>results</code>，<code>results</code>中的对象顺序会和<code>values</code>中对应的对象顺序相反。</p>
<p><code>vector</code>不提供<code>push_front</code>，所以<code>front_inserter</code>不能用于<code>vector</code>。</p>
<p><strong>同序插入</strong></p>
<p>如果你要<code>transform</code>把输出结果放在<code>results</code>前端，但你也要输出和<code>values</code>中对应的对象顺序相同，只要以相反的顺序迭代<code>values</code>:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在results前端 插入transform的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 保持相对的对象顺序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>任意位置插入 inserter</strong></p>
<p><code>front_inserter</code>让你强制算法在容器前端插入它们的结果，<code>back_inserter</code>让你告诉它们把结果放在容器后端，有点惊人的是<code>inserter</code>允许你强制算法把它们的结果插入容器中的任意位置:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同上，除了现在在调用transform前 results已经有一些数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify的结果插入results的中间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">inserter</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="插入效率">插入效率</h2>
<p>不管你是否使用了<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>，<code>transform</code>会对目的区间每次写入一个值，你无法改变。</p>
<p>当你要插入的容器是<code>vector</code>或<code>string</code>时，你可以最小化这个代价，<strong>预先调用<code>reserve</code></strong>。</p>
<p>你仍然要承受每次发生插入时移动元素的开销，但至少你避免了重新分配容器的内在内存:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 确定results至少还能装得下values.size()个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上，但results没有任何重新分配操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">inserter</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当使用<code>reserve</code>来提高一连串插入的效率时，总是应该记住<code>reserve</code><strong>只增加容器的容量：容器的大小仍然没有改变</strong>。</p>
<p>即使调用完<code>reserve</code>，当你想要让容器把新元素加入到<code>vector</code>或<code>string</code>时，你也必须对算法使用插入迭代器(比如，从<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>返回的迭代器之一)，因为赋值只在两个对象之间操作时有意义，而不是在一个对象和一块原始的比特之间。</p>
<p>第一个例子正确的写法:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify的结果写入results的结尾，处理时避免了重新分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="p">,</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="覆盖原始数据">覆盖原始数据</h2>
<p>有时候你要覆盖现有容器的元素而不是插入新的。</p>
<p><strong>当这种情况时，你不需要插入迭代器，但你仍然需要按照本条款的建议来确保你的目的区间足够大。</strong></p>
<p>假设你让<code>transform</code>覆盖<code>results</code>的元素。如果<code>results</code>至少有和<code>values</code>一样多的元素，那很简单。如果没有， 你也必须使用<code>resize</code>来确保它有。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 确保results至少和values一样大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl"> <span class="n">results</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 覆盖values.size()个 results的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者你可以清空results然后用通常的方式使用插入迭代器:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 销毁results中的所有元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">results</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 保留足够空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transform地返回值// 放入results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>无论何时你使用一个要求指定目的区间的算法，确保目的区间已经足够大或者在算法执行时可以增加大小。</p>
<p>如果你选择增加大小，就使用插入迭代器，比如<code>ostream_iterators</code>或从<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>返回的迭代器。</p>
]]></description></item><item><title>Effective STL [29] | 需要一个一个字符输入时考虑使用istreambuf_iterator</title><link>https://jianye0428.github.io/posts/clause_29/</link><pubDate>Fri, 18 Aug 2023 07:55:51 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_29/</guid><description><![CDATA[<h2 id="istream_iterator-拷贝文件">istream_iterator 拷贝文件</h2>
<p>假设要把一个文本文件拷贝到一个字符串对象中。似乎可以用一种很有道理的方法完成：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把inputFile读入fileData；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 关于为什么它不是很正确请看下文关于这个语法的警告参见条款6
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很快你就会发现这种方法无法把文件中的空格拷贝到字符串中。</p>
<p>那是因为<code>istream_iterators</code>使用<code>operator&gt;&gt;</code>函数来进行真的读取，而且<code>operator&gt;&gt;</code>函数在默认情况下忽略空格。</p>
<p>假如你想保留空格，你要的做就是覆盖默认情况。只要清除输入流的skipws标志就行了：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">inputFile</span><span class="p">.</span><span class="n">unset</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">skipws</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 关闭inputFile的忽略空格标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在inputFile中的所有字符都拷贝到fileData中了。</p>
<p><strong>拷贝速度</strong></p>
<p>你会发现它们的拷贝速度不像你想象的那么快。</p>
<p><code>istream_iterators</code>所依靠的<code>operator&gt;&gt;</code>函数进行的是格式化输入，这意味着每次你调用的时候它们都必须做大量工作：</p>
<ol>
<li>
<p>必须建立和销毁岗哨（sentry）对象（为每个<code>operator&gt;&gt;</code>调用进行建立和清除活动的特殊的<code>iostream</code>对象）；</p>
</li>
<li>
<p>必须检查可能影响它们行为的流标志（比如skipws）；</p>
</li>
<li>
<p>必须进行全面的读取错误检查；</p>
</li>
<li>
<p>如果它们遇到问题，它们必须检查流的异常掩码来决定是否该抛出一个异常。</p>
</li>
</ol>
<p>如果进行格式化输入，那些都是重要的活动，但如果你需要的只是从输入流中抓取下一个字符，那就过度了。</p>
<h2 id="istreambuf_iterators-拷贝文件">istreambuf_iterators 拷贝文件</h2>
<p>你可以像<code>istream_iterator</code>一样使用<code>istreambuf_iterator</code>，但<code>istream_iterator&lt;char&gt;</code>对象使用<code>operator&gt;&gt;</code>来从输入流中读取单个字符。 <code>istreambuf_iterator</code>对象进入流的缓冲区并直接读取下一个字符。（更明确地说，<code>istreambuf_iterator&lt;char&gt;</code> 对象从一个<code>istream s</code>中读取会调用<code>s.rdbuf()-&gt;sgetc()</code>来读<code>s</code>的下一个字符。）把我们的文件读取代码改为使用<code>istreambuf_iterator</code>相当简单，大多数Visual Basic程序员都可以在两次尝试内做对：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl"><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意这里不需要“<code>unset</code>” <code>skipws</code>标志，<code>istreambuf_iterator</code>不忽略任何字符。它们只抓取流缓冲区的下一个字符。</p>
<p>相对于<code>istream_iterator</code>，它们抓取得更快。</p>
<p>如果你需要一个一个地读取流中的字符，你不需要格式化输入的威力，你关心的是它们花多少时间来读取流，和明显的性能提高相比，为每个迭代器多键入三个字符的代价是微弱的。对于无格式的一个一个字符输入，你总是应该考虑使用<code>istreambuf_iterator</code>。</p>
<h2 id="结论">结论</h2>
<p>当你了解它之后，你也应该考虑把<code>ostreambuf_iterator</code>用于相应的无格式一个一个字符输出的作。</p>
<p>它们没有了<code>ostream_iterator</code>的开销（和灵活性），所以它们通常也做得更好。</p>
]]></description></item><item><title>Effective STL [28] | 了解如何通过reverse_iterator的base得到iterator</title><link>https://jianye0428.github.io/posts/clause_28/</link><pubDate>Thu, 17 Aug 2023 20:04:40 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_28/</guid><description><![CDATA[<h2 id="example">Example</h2>
<p>通过reverse_iterator的base初始化一个iterator:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 参见条款14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="err">；</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 向vector插入1到5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">ri</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 使ri指向3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 使i和ri的base一样
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>执行上述代码后，可以想到产生的结果就像这样:</p>
<p></p>
<p>上图显示了<code>reverse_iterator</code>和它对应的<code>base iterator</code>之间特有的偏移量，就像<code>rbegin()</code>和<code>rend()</code>与相关的<code>begin()</code>和<code>end()</code>一样，但是它并没有解释怎样在<code>ri</code>上实现你在i上想要完成的操作。</p>
<p>正如条款26解释的，有些容器的成员函数只接受<code>iterator</code>类型的参数，所以如果你想要在<code>ri</code>所指的位置插入一个新元素，你不能直接这么做，因为<code>vector</code>的<code>insert</code>函数不接受<code>reverse_iterator</code>。</p>
<p>如果你想要删除ri所指位置上的元素也会有同样的问题。<code>erase</code>成员函数会拒绝<code>reverse_iterator</code>，坚持要求<code>iterator</code>。</p>
<h2 id="reverse_iterator转换成iterator">reverse_iterator转换成iterator</h2>
<p>为了完成删除和一些形式的插入操作，你必须先通过base函数将reverse_iterator转换成iterator，然后用iterator来完成工作。</p>
<p><strong>插入操作</strong></p>
<p>假设你要在ri指出的位置上把一个新元素插入v。假设你要插入的值是99。</p>
<p>**ri在上图中遍历的顺序是自右向左，而且插入操作会将新元素插入到ri位置，并且将原先ri位置的元素移到遍历过程的“下一个”位置，我们认为3应该出现在99的左侧。**插入操作之后，v看起来像这样:</p>
<p></p>
<p>我们不能用<code>ri</code>来指定插入的地方，因为它不是一个<code>iterator</code>。我们必须用<code>i</code>来代替。如上所述，当<code>ri</code>指向3时，<code>i</code>（就是<code>ri.base()</code>）指向4。</p>
<p>如果我们用<code>ri</code>来指定插入位置，那么用i指向插入位置，那个假设就是正确的。</p>
<p><strong>结论</strong></p>
<blockquote>
<p>要实现在一个reverse_iterator ri指出的位置上插入新元素，在ri.base()指向的位置插入就行了。
对于insert操作而言，ri和ri.base()是等价的，而且ri.base()真的是ri对应的iterator。</p>
</blockquote>
<p><strong>删除操作</strong></p>
<p>如果你要删除ri指向的元素，你不能直接使用i了，因为i与ri不是指向同一个元素。因此，你要删除的是i的前一个元素。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 向v插入1到5，同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vecot</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">ri</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 同上，ri指向3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="o">--</span><span class="n">ri</span><span class="p">.</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 尝试删除ri.base()前面的元素；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 对于vector，一般来说编译不通过
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>--ri.base()</code>确实能够指出我们需要删除的元素。而且，它们能够处理除了<code>vector</code>和<code>string</code>之外的其他所有容器。</p>
<p>它可能也能处理vector和string，但对于大多数vector和string的实现，它无法通过编译。</p>
<p>在这样的实现下，<code>iterator</code>(和<code>const_iterator</code>)会采用内建的指针来实现，所以<code>ri.base()</code>的结果是一个指针。</p>
<p><strong>原因剖析</strong></p>
<p>C和C++都规定了不能直接修改函数返回的指针，所以在string和vector的迭代器是指针的STL平台上，像<code>--ri.base()</code>这样的表达式无法通过编译。</p>
<p>要移植从一个由<code>reverse_iterator</code>指出的位置删除元素时，你应该尽量避免修改base的返回值。</p>
<p>所以，如果你不能减少调用<code>base</code>的返回值，只需要先增加<code>reverse_iterator</code>的值，然后再调用<code>base</code>！</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">((</span><span class="o">++</span><span class="n">ri</span><span class="p">).</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 删除ri指向的元素；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这下编译没问题了！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>这个方法适用于所有的标准容器，这是删除一个由reverse_iterator指出的元素时首选的技巧</strong></p>
<h2 id="结论">结论</h2>
<p><code>reverse_iterator</code>的<code>base</code>成员函数返回一个“对应的”<code>iterator</code>的说法并不准确：对于插入操作而言，的确如此; 但是对于删除操作，并非如此。</p>
<p>当需要把<code>reverse_iterator</code>转换成<code>iterator</code>的时候，有一点非常重要的是你必须知道你准备怎么处理返回的<code>iterator</code>，因为只有这样你才能决定你得到的<code>iterator</code>是否是你需要的。</p>
]]></description></item><item><title>Effective STL [27] | 用distance和advance把const_iterator转化成iterator</title><link>https://jianye0428.github.io/posts/clause_27/</link><pubDate>Thu, 17 Aug 2023 07:54:00 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_27/</guid><description><![CDATA[<h2 id="把const_iterator转化为iterator">把const_iterator转化为iterator</h2>
<p>有些容器成员函数只接受iterator作为参数，而不是const_iterator。如果你只有一个const_iterator，要在它所指向的容器位置上插入新元素呢？</p>
<p>上一条款说并不存在从const_iterator到iterator之间的隐式转换，那该怎么办？</p>
<p>看看当你把一个const_iterator映射为iterator时会发生什么:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 方便的typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// ci是const_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// 错误！没有从const_iterator 到iterator隐式转换的途径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="nf">i</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Iter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ci</span><span class="p">));</span> <span class="c1">// 仍是个错误！不能从const_iterator 映射为iterator！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里只是以deque为例，但是用其它容器类——list、set、multiset、map、multimap甚至条款25描述的散列表容器——的结果一样。使用映射的行也许在vector或string的代码时能够编译，但这是我们马上要讨论的非常特殊的情形。</p>
<p>上述代码不能通过编译的原因在于，对于这些容器而言，<font color=red>iterator和const_iterator是完全不同的类。</font></p>
<p>在两个毫无关联的类之间进行<code>const_cast</code>映射是荒谬的，所以<code>reinterpret_cast</code>、<code>static_cast</code>甚至C风格的映射也会导致同样的结果。</p>
<p><strong>不能编译的代码对于vector和string容器来说也许能够通过编译</strong></p>
<p>那是因为通常情况下大多数实现都会采用真实的指针作为那些容器的迭代器。</p>
<p>就这种实现而言，<code>vector&lt;T&gt;::iterator</code>是<code>T*</code>的<code>typedef</code>，而<code>vector&lt;T&gt;::const_iterator</code>是<code>const T*</code>的<code>typedef</code>，<code>string::iterator</code>是<code>char</code>的<code>typedef</code>，而<code>string::const_iterator</code>是<code>const char*</code>的<code>typedef</code>。</p>
<p>在这种实现的情况下，用<code>const_cast</code>把<code>const_iterator</code>映射成<code>iterator</code>当然可以编译而且没有问题，因为<code>const_iterator</code>与<code>iterator</code>之间的<code>const_cast</code>映射被最终解释成<code>const T*</code>到<code>T*</code>的映射。但是，即使是在这种实现中，<code>reverse_iterator</code>和<code>const_reverse_iterator</code>也是真正的类，所以你仍然不能直接用<code>const_cast</code>把<code>const_reverse_iterator</code>映射成<code>reverse_iterator</code>。</p>
<p>而且这些实现通常只会在Release模式时才使用指针表示vector和string的迭代器。</p>
<p>所有这些事实表明，把const迭代器映射为迭代器是病态的，即使是对vector和string来说也时，因为移植性很值得怀疑。</p>
<h2 id="const_iterator转换为iterator">const_iterator转换为iterator</h2>
<p>有一种安全的、可移植的方法获取它所对应的iterator，而且，用不着陷入类型系统的转换。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 和以前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">IntDeque</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 让ci指向d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// 初始化i为d.begin()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 把i移到指向ci位置（但请留意下面关于为什么在它编译前要调整的原因）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要得到与const_iterator指向同一位置的iterator:</p>
<ol>
<li>将iterator指向容器的起始位置，</li>
<li>把它向前移到和const_iterator距离容器起始位置的偏移量一样的位置即可</li>
</ol>
<p>这个任务得到了两个函数模板advance和distance的帮助，它们都在<iterator>中声明:</p>
<ul>
<li>distance返回两个指向同一个容器的iterator之间的距离；</li>
<li>advance则用于将一个iterator移动指定的距离。</li>
</ul>
<p>如果<code>i</code>和<code>ci</code>指向同一个容器，那么表达式<code>advance(i, distance(i, ci))</code>会将<code>i</code>移动到与<code>ci</code>相同的位置上。</p>
<p>上述代码编译存在问题。</p>
<p>先来看看distance的定义：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_InputIterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="n">_GLIBCXX17_CONSTEXPR</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_InputIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span>
</span></span><span class="line"><span class="cl">  <span class="n">distance</span><span class="p">(</span><span class="n">_InputIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_InputIterator</span> <span class="n">__last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// concept requirements -- taken care of in __distance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">__distance</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">__iterator_category</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当遇到<code>distance</code>调用时，你的编译器需要根据使用的实参类型推断出<code>InputIterator</code>的类型。</p>
<p>再来看看我所说的不太正确的<code>distance</code>调用:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 调整i，指向ci位置
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有两个参数传递给distance，i和ci。i的类型是Iter，即<code>deque&lt;int&gt;::iterator</code>的typedef。</p>
<p>对编译器来说，这表明调用<code>distance</code>的<code>InputIterator</code>是<code>deque::iterator</code>。但<code>ci</code>是<code>ConstIter</code>，即<code>deque::const_iterator</code>的<code>typedef</code>。</p>
<p>表明那个<code>InputIterator</code>是<code>deque&lt;int&gt;::const_iterator</code>。</p>
<p><code>InputIterator</code>不可能同时有两种不同的类型，所以调用<code>distance</code>失败。</p>
<p>一般会造成一些冗长的出错信息，可能会也可能不会说明是编译器无法得出<code>InputIterator</code>是什么类型。</p>
<p>要顺利地调用<code>distance</code>，你需要排除歧义。</p>
<p>最简单的办法就是显式的指明<code>distance</code>调用的模板参数类型，从而避免编译器自己得出它们的类型:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们现在知道了怎么通过<code>advance</code>和<code>distance</code>获取<code>const_iterator</code>相应的<code>iterator</code>了。</p>
<p><strong>效率如何？</strong></p>
<p>答案很简单。<strong>取决于你所转换的究竟是什么样的迭代器。</strong></p>
<p>对于<strong>随机访问的迭代器</strong>（比如<code>vector</code>、<code>string</code>和<code>deque</code>的）而言，这是<strong>常数时间</strong>的操作。</p>
<p>对于<strong>双向迭代器</strong>（也就是，所有其它容器和包括散列容器的一些实现）而言，这是<strong>线性时间</strong>的操作。</p>
<p>因为它可能花费线性时间的代价来产生一个和<code>const_iterator</code>等价的<code>iterator</code>，并且因为如果不能访问<code>const_iterator</code>所属的容器这个操作就无法完成。</p>
<p>从这个角度出发，也许你需要重新审视你从<code>const_iterator</code>产生<code>iterator</code>的设计。</p>
<p>当处理容器时尽量用<code>iterator</code>代替<code>const</code>和<code>reverse</code>迭代器。</p>
]]></description></item><item><title>Effective STL [26] | 尽量用iterator代替const_iterator，reverse_iterator和const_reverse_iterator</title><link>https://jianye0428.github.io/posts/clause_26/</link><pubDate>Wed, 16 Aug 2023 19:06:25 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_26/</guid><description><![CDATA[<h2 id="4种迭代器">4种迭代器</h2>
<p>每个标准容器类都提供4种迭代器类型:<code>iterator</code>,<code>const_iterator</code>，<code>reverse_iterator</code>和<code>const_reverse_iterator</code></p>
<p>对于<code>container&lt;T&gt;</code>而言，<code>iterator</code>的作用相当于<code>T*</code>，而<code>const_iterator</code>则相当于<code>const T*</code>。</p>
<p>增加一个<code>iterator</code>或者<code>const_iterator</code>可以在一个从容器开头趋向尾部的遍历中让你移动到容器的下一个元素。</p>
<p><code>reverse_iterator</code>与<code>const_reverse_iterator</code>同样相当于对应的<code>T</code>和<code>const T</code>，所不同的是，增加<code>reverse_iterator</code>或者<code>const_reverse_iterator</code>会在从尾到头的遍历中让你移动到容器的下一个元素。</p>
<h2 id="vectort的insert和erase的样式">vector<T>的insert和erase的样式</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">rangeBegin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">rangeEnd</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些方法只接受<code>iterator</code>类型的参数，而不是<code>const_iterator</code>、<code>reverse_iterator</code>或<code>const_reverse_iterator</code>。总是<code>iterator</code>。</p>
<h2 id="迭代器之间存在的转换关系">迭代器之间存在的转换关系</h2>
<p></p>
<p>图中显示了从<code>iterator</code>到<code>const_iterator</code>、从<code>iterator</code>到<code>reverse_iterator</code>和从<code>reverse_iterator</code>到<code>const_reverse_iterator</code>可以进行隐式转换。</p>
<p>并且，<code>reverse_iterator</code>可以通过调用其<code>base成员函数</code>转换为<code>iterator</code>。<code>const_reverse_iterator</code>也可以类似地通过<code>base</code>转换成为<code>const_iterator</code>。</p>
<p>通过base得到的也许并非你所期待的iterator。</p>
<p>而且，<strong>没有办法从一个const_iterator转换得到一个iterator，也无法从const_reverse_iterator得到reverse_iterator</strong>。</p>
<p>所以，当你需要指出插入位置或删除的元素时，const迭代器几乎没有用。</p>
<h2 id="尽量使用iterator取代const或者reverse类型的迭代器">尽量使用iterator取代const或者reverse类型的迭代器</h2>
<ol>
<li>
<p><code>insert</code>和<code>erase</code>的一些版本要求<code>iterator</code>。如果你需要调用这些函数，你就必须产生<code>iterator</code>，而不能用<code>const</code>或<code>reverse iterators</code>。</p>
</li>
<li>
<p>不可能把<code>const_iterator</code>隐式转换成<code>iterator</code>。从一个<code>const_iterator</code>产生一个<code>iterator</code>的技术并不普遍适用，而且不保证高效。</p>
</li>
<li>
<p>从<code>reverse_iterator</code>转换而来的<code>iterator</code>在转换之后可能需要相应的调整。</p>
</li>
</ol>
<p><code>iterator</code>与<code>reverse_iterator</code>之间的选择显而易见——依赖于从前到后或从后到前的遍历。</p>
<p><strong>迭代器比较</strong></p>
<p>当在<code>iterator</code>和<code>const_iterator</code>之间作选择的时候，你有更充分的理由选择<code>iterator</code>，即使<code>const_iterator</code>同样可行而且即使你并不需要调用容器类的任何成员函数。其中的令人讨厌的原因包括<code>iterator</code>与<code>const_iterator</code>之间的比较：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// typedef可以极大地简化STL容器类和iterator的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 同一个容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ci</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 比较iterator和const_iterator
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>唯一的变化是等号的一边的类型是<code>iterator</code>，而另一边的类型是<code>const_iterator</code>。</p>
<p><strong>因为<code>iterator</code>应该在比较之前隐式的转换成<code>const_iterator</code>，真正的比较应该在两个<code>const_iterator</code>之间进行。</strong></p>
<p><strong>如果一些实现将<code>const_iterator</code>的<code>operator==</code>作为<code>const_iterator</code>的一个成员函数而不是非成员函数。</strong></p>
<p>而问题的解决之道显得非常有趣：只要像这样交换两个<code>iterator</code>的位置：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ci</span> <span class="o">==</span> <span class="n">i</span><span class="p">)...</span> <span class="c1">// 当上面比较无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>迭代器混用</strong></p>
<p>不仅是比较是否相等，只要你在同一个表达式中混用<code>iterator</code>和<code>const_iterator</code>（或者<code>reverse_iterator</code>和<code>const_reverse_iterator</code>），这样的问题就可能会出现:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 如果i与ci之间至少有三个元素...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果迭代器的类型不同，你的正确的代码可能会被错误地拒绝。</p>
<p>本例中最简单的解决方法是<strong>通过一个（安全的）映射把iterator转换为const_iterator</strong>:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 当上面的代码无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>避免这类问题的最简单的方法是减少混用不同类型的迭代器的机会。</strong></p>
]]></description></item><item><title>Effective STL [25] | 熟悉非标准散列容器</title><link>https://jianye0428.github.io/posts/clause_25/</link><pubDate>Wed, 16 Aug 2023 08:21:08 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_25/</guid><description><![CDATA[<p><strong>STL没有散列表。</strong></p>
<p>兼容STL的散列关联容器可以从多个来源获得，而且它们甚至有事实上的标准名字：<code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>和<code>hash_multimap</code>。在C++标准委员会的议案中，散列容器的名字是<code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>和<code>unordered_multimap</code>。</p>
<p><strong>它们在接口、能力、内在数据结构和支持操作的相关效率方面不同。</strong></p>
<p>最常见的两个来自<code>SGI</code>和<code>Dinkumware</code>，<code>STLport</code>也提供散列容器，但是<code>STLport</code>的散列容器是基于来自<code>SGI</code>的。</p>
<p>散列容器是关联容器，它们需要知道储存在容器中的对象类型，用于这些对象的比较函数，以及用于这些对象的分配器。</p>
<h2 id="散列容器声明">散列容器声明</h2>
<p>散列容器需要散列函数的说明。下面是散列容器声明：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_container</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这非常接近于散列容器的SGI声明，主要差别是SGI为HashFunction和CompareFunction提供了默认类型。</p>
<p><strong>SGI 设计举例</strong></p>
<p><code>hash_set</code>的SGI声明看起来基本上像这样：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">equa_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>SGI</code>设计的一个值得注意的方面是使用<code>equal_to</code>作为默认比较函数。<strong>这违背标准关联容器的约定——默认比较函数是less。</strong></p>
<p><code>SGI</code>的散列容器确定在一个散列容器中的两个对象是否有相同的值是通过相等测试，而不是等价。</p>
<p>因为散列关联容器，不像它们在标准中的（通常基于树）兄弟，不需要保持有序。</p>
<p><strong>Dinkumware 设计举例</strong></p>
<p>Dinkumware设计的散列容器采取一些不同的策略。它仍然允许你指定对象类型、散列函数类型、比较函数类型和分配器类型，但是<strong>它把默认的散列和比较函数移进一个单独的类似特性的叫做hash_compare的类</strong>，而且它把<code>hash_compare</code>作为容器模板的<code>HashingInfo</code>实参的默认值。</p>
<p>这是<code>Dinkumware</code>的hash_set声明（再次为演示而调整过）:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">HashingInfo</span> <span class="o">=</span> <span class="n">hash_compare</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种接口设计有趣的地方是<code>HashingInfo</code>的使用。</p>
<p><strong>容器的散列和比较函数储存在<code>HashingInfo</code>中，但HashingInfo类型也容纳了控制表中桶（bucket）最小数量，以及容器元素对桶的最大允许比率的枚举。</strong></p>
<p>当这比率被超过时，表中桶的数量就增加，而表中的一些元素需要重新散列。（SGI提供具有类似控制表中桶和表中元素对桶比率的成员函数。）</p>
<p><strong>hash_compare</strong></p>
<p><code>hash_compare</code>（HashingInfo的默认值）看起来或多或少像这样:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bucket_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// 元素对桶的最大比率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">min_buckets</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1">// 桶的最小数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 散列函数比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// 忽略一些东西，包括 CompareFunction的使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>重载<code>operator()</code>（在这里是实现散列和比较函数）是比你可以想象的更经常出现的一个策略。</p>
<p><code>Dinkumware</code>设计允许你写你自己的类似hash_compare的类（也许通过从<code>hash_compare</code>本身派生而来），而且只要你的类定义了<code>bucket_size</code>、<code>min_buckets</code>、两个<code>operator()</code>函数（一个带有一个实参，一个带有两个），加上已经省去的一些东西，就能使用它来控制Dinkumware的<code>hash_set</code>或<code>hash_multiset</code>的配置和行为。</p>
<p><code>hash_map</code>和<code>hash_multimap</code>的配置控制也相似。</p>
<h2 id="决策留给实现">决策留给实现</h2>
<p>注意不管是SGI还是Dinkumware的设计，你都能把全部决策留给实现:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 建立一个int的散列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">hash_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intTable</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要让这个可以编译，散列表必须容纳一个整数类型（例如int），因为<strong>默认散列函数一般局限于整数类型。</strong></p>
<p><strong>实现方法不同</strong></p>
<p>在后端，SGI和Dinkumware的实现方法非常不同。</p>
<ol>
<li>SGI利用常用的一个元素的单链表的指针数组（桶）组成的开放散列法。</li>
<li>Dinkumware也利用了开放散列法，但是它的设计是基于一种新颖的数据结构——由迭代器（本质是桶）的数组组成的元素双向链表，迭代器的相邻对表示在每个桶里元素的范围。</li>
</ol>
<p><strong>链表不同</strong></p>
<ol>
<li>SGI实现在<strong>单链表</strong>中储存表的元素</li>
<li>Dinkumware实现使用一个双向链表</li>
</ol>
<p><strong>迭代器种类不同</strong></p>
<ol>
<li>SGI的散列容器提供了前向迭代器，因此你得放弃进行反向迭代的能力：在SGI的散列容器中没有rbegin或者rend成员函数。</li>
<li>用于Dinkumware散列容器的迭代器是双向的，所以它们可以提供前向和反向遍历。</li>
</ol>
<p><strong>内存使用量方面不同</strong></p>
<p>SGI的设计比Dinkumware的节俭一点点。</p>
<h2 id="结论">结论</h2>
<p>虽然STL本身缺乏散列容器，兼容STL的散列容器（有不同的接口、能力和行为权衡）不难得到。就SGI和STLport的实现而言，你甚至可以免费下载得到它们。</p>
]]></description></item><item><title>Effective STL [24] | 当关乎效率时应该在map::operator[]和map-insert之间仔细选择</title><link>https://jianye0428.github.io/posts/clause_24/</link><pubDate>Tue, 15 Aug 2023 08:10:23 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_24/</guid><description><![CDATA[<h2 id="example-map插入">Example map插入</h2>
<p>假设有一个支持默认构造函数以及从一个double构造和赋值的Widget类:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设我们想建立一个从int到Widget的map，而且我们想有初始化有特定值的映射:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.67</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">45.8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0003</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>map operator[] 工作原理</strong></p>
<p>map的<code>operator[]</code>函数是个奇怪的东西。它与vector、deque和string的<code>operator[]</code>函数无关，也和内建的数组operator[]无关。</p>
<p><code>map::operator[]</code>被设计为简化“添加或更新”功能。即，给定<code>map&lt;K, V&gt; m</code>;这个表达式</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>检查键k是否已经在map里。如果不，就添加上，以v作为它的对应值。如果k已经在map里，它的关联值被更新成v。</strong></p>
<p>这项工作的原理是<code>operator[]</code>返回一个与k关联的值对象的引用。然后v赋值给所引用（<code>从operator[]</code>返回的）的对象。</p>
<p>当要更新一个已存在的键的关联值时很直接，因为已经有<code>operator[]</code>可以用来返回引用的值对象。</p>
<p>但是如果k还不在map里，<code>operator[]</code>就没有可以引用的值对象。那样的话，它使用值类型的默认构造函数从头开始建立一个，然后<code>operator[]</code>返回这个新建立对象的引用。</p>
<p>让我们再次地看看原先例子的第一部分：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>m[1]</code>是<code>m.operator[](1)</code>的简化，所以这是一个<code>map::operator[]</code>的调用。</p>
<p>这个函数必须返回一个Widget的引用，因为m 的映射类型是Widget。</p>
<p>在这里，m里面还没有任何东西，所以键1在map里没有入口。因此<code>operator[]</code>默认构造一个Widget来作为关联到1的值，然后返回到那个Widget的引用。</p>
<p>最后，Widget成为赋值目标：被赋值的值是1.50。</p>
<p>所以，下面这个语句</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>功能上等价于这个:</strong></p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 方便的 typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">IntWidgetMap</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 用键1建立新映射入口和一个默认构造的值对象；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Widget</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 赋值给值类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>现在已经很清楚为什么这种方法可能降低性能了：先默认构造一个Widget，然后我们立即赋给它新值。</strong></p>
<p><strong><code>map insert</code>更高效</strong></p>
<p>如果<strong>用想要的值构造Widget比默认构造Widget然后进行赋值显然更高效</strong>，就应该用直截了当的insert调用来替换operator[]的使用（包括它的构造加赋值）:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.50</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这与上面的那些代码有相同的最终效果，除了它<strong>通常节省了3次函数调用</strong>：</p>
<ol>
<li>一个建立临时的默认构造Widget对象</li>
<li>一个销毁那个临时的对象</li>
<li>一个对Widget的赋值操作。</li>
</ol>
<p>这些函数调用越昂贵，你通过使用map-insert代替<code>map::operator[]</code>就能节省越多。</p>
<p>上面的代码利用了每个标准容器都提供的value_type typedef。这typedef没有什么特别重要的，但对于map和multimap（以及非标准容器的hash_map和hash_multimap——参见条款25），记住它是很重要的，容器元素的类型总是某种pair。</p>
<p>之前谈及的<code>operator[]</code>被设计为简化“添加或更新”功能，而且现在我们理解了当“增加”被执行时，<code>insert</code>比<code>operator[]</code>更高效。当做更新时，情形正好相反，也就是，当一个等价的键这已经在map里时。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 使用operator[]来把k的值更新为v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 来把k的值更新为v使用insert
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)).</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="operator-与-insert-权衡">operator[] 与 insert 权衡</h2>
<p>insert的调用需要<code>IntWidgetMap::value_type</code>类型的实参（即<code>pair&lt;int, Widget&gt;</code>），所以当调用insert时，我们必须构造和析构一个那种类型的对象。那耗费了一对构造函数和析构函数，也会造成一个Widget的构造和析构，因为<code>pair&lt;int, Widget&gt;</code>本身包含了一个Widget对象，<strong>operator[]没有使用pair对象，所以没有构造和析构pair和Widget。</strong></p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>情形选择:</p>
<ol>
<li>因此出于对效率的考虑，当给<code>map</code>添加一个元素时，我们断定<code>insert</code>比<code>operator[]</code>好；</li>
<li>从效率和美学考虑，当更新已经在<code>map</code>里的元素值时<code>operator[]</code>更好。</li>
</ol>
</div>
    </div>
  </div>
<p>如果STL提供一个两全其美的函数，即，在句法上吸引人的包中的高效的“添加或更新”功能:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 如果键k不再map m中；高效地把pair(k, v)添加到m中；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 否则高效地把和k关联的值更新为v。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 返回一个指向添加或修改的pair的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">iterator</span> <span class="n">affectedPair</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，在STL内没有像这样的函数，正如下面的代码所演示的，自己写一个并不难。那些注释总结了正在做什么，而且随后的段落也提供了一些附加的解释。</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// map的类型KeyArgType和ValueArgtype是类型参数的原因请看下面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MapType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">KeyArgType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ValueArgtype</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">MapType</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">KeyArgType</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValueArgtype</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 找到k在或应该在哪里；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Ib</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果Ib指向一个pair, 它的键等价于k...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span><span class="p">(</span><span class="n">Ib</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">k</span><span class="p">,</span> <span class="n">Ib</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 更新这个pair的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Ib</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 并返回指向pair的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">Ib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">value_type</span> <span class="n">MVT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 把pair(k, v)添加到m并// 返回指向新map元素的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Ib</span><span class="p">,</span> <span class="n">MVT</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>执行一个高效的增加或更新，我们需要能<strong>找出k的值是否在map中; 如果是这样，那它在哪里; 如果不是，它该被插入哪里。</strong></p>
<p>这个工作是为<code>low_bound</code>量身定做的，所以在这里我们调用那个函数。确定lower_bound是否用我们要寻找的键找到了一个元素，我们对后半部分进行一个等价测试，一定要对map使用正确的比较函数: 通过<code>map::key_comp</code>提供的比较函数。等价测试的结果告诉我们应该进行增加还是更新。</p>
<p>如果是更新，代码很直截了当。插入分支更有趣，因为它使用了insert的“提示”形式。结构<code>m.insert(Ib，MVT(k，v))</code>“提示”了**<code>Ib</code>鉴别出了键等价于k的新元素正确的插入位置，而且保证如果提示正确，那么插入将在分摊的常数时间内发生，而不是对数时间**。在<code>efficientAddOrUpdate</code>里，我们知道Ib鉴别出了适当的插入位置，因此insert的调用被保证为是一次常数时间操作。</p>
<p><strong>KeyArgType和ValueArgType</strong></p>
<p>这个实现的一个有趣方面是<code>KeyArgType</code>和<code>ValueArgType</code>不必是储存在map里的类型。它们只需要可以转换到储存在map里的类型。</p>
<p>一个可选的方法是去掉类型参数<code>KeyArgType</code>和<code>ValueArgType</code>，改为使用<code>MapType::key_type</code>和<code>MapType::mapped_type</code>。</p>
<p>但是，如果我们那么做，<strong>在调用时我们可能强迫发生不必要的类型转换</strong>:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 别忘了Widget接受从一个double赋值：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在考虑<code>efficientAddOrUpdate</code>的调用:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设是一次更新操作，即，m已经包含键是10的元素。那样的话，上面的模板推断出<code>ValueArgType</code>是<code>double</code>，<strong>函数体直接把1.5作为double赋给与10相关的那个Widget</strong>。那是通过调用<code>Widget::operator(double)</code>完成的。</p>
<p>如果我们用了<code>MapType::mapped_type</code>作为<code>efficientAddOrUpdate</code>的第3个参数的类型，在调用时我们得把1.5转化成一个Widget，那样的话我们就得<strong>花费本来不需要的一次Widget构造（以及随后的析构）</strong>。</p>
<h2 id="结论">结论</h2>
<p>当关乎效率时应该在map::operator[]和map-insert之间仔细选择。</p>
<p><font color=red>如果你要更新已存在的map元素，operator[]更好，但如果你要增加一个新元素，insert则有优势。</font></p>
]]></description></item><item><title>Effective STL [23] | 考虑用有序vector代替关联容器</title><link>https://jianye0428.github.io/posts/clause_23/</link><pubDate>Mon, 14 Aug 2023 19:13:32 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_23/</guid><description><![CDATA[<p>当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>。</p>
<p>如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。</p>
<p>对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的<code>set</code>、<code>map</code>和它们的<code>multi</code>同事。</p>
<p>即使你需要的就只是==对数时间==查找的保证，标准关联容器仍然可能不是你的最佳选择。和直觉相反，对于标准关联容器，所提供的性能也经常劣于本该比较次的<code>vector</code>。</p>
<h2 id="关联容器数据结构">关联容器数据结构</h2>
<p>标准关联容器的典型实现是<strong>平衡二叉查找树</strong>。</p>
<p>一个平衡二叉查找树是一个对<strong>插入</strong>、<strong>删除</strong>和<strong>查找</strong>的混合操作优化的数据结构。</p>
<p>换句话说，它被设计为应用于进行一些插入，然后一些查找，然后可能再进行一些插入，然后也许一些删除，然后再来一些查找，然后更多的插入或删除，然后更多的查找等。这个事件序列的关键特征是插入、删除和查找都是混合在一起的。</p>
<p>一般来说，没有办法预测对树的下一个操作是什么。</p>
<p><strong>使用数据结构的3阶段</strong></p>
<ol>
<li><strong>建立</strong>。通过插入很多元素建立一个新的数据结构。在这个阶段，几乎所有的操作都是插入和删除。几乎没有或根本没有查找。</li>
<li><strong>查找</strong>。在数据结构中查找指定的信息片。在这个阶段，几乎所有的操作都是查找。几乎没有或根本没有插入和删除。</li>
<li><strong>重组</strong>。修改数据结构的内容，通过删除所有现有数据和在原地插入新数据。从动作上说，这个阶段等价于阶段1。一旦这个阶段完成，应用程序返回阶段2。</li>
</ol>
<h2 id="有序vector更高效">有序vector更高效</h2>
<p>一个vector可能比一个关联容器能提供更高的性能（时间和空间上都是）。</p>
<p>但不是任意的<code>vector</code>都会，只有有序vector。因为只有有序容器才能正确地使用查找算法——<code>binary_search</code>、<code>lower_bound</code>、<code>equal_range</code>等。</p>
<p>Q: 为什么一个（有序的）vector的二分法查找比一个二叉树的二分法查找提供了更好的性能？</p>
<p>A: 其中的一个是<strong>大小问题</strong>，其中的一个是<strong>引用局部性问题</strong>。</p>
<p><strong>大小问题</strong></p>
<p>假设我们需要一个容器来容纳Widget对象，而且，因为查找速度对我们很重要，我们考虑一个Widget的关联容器和一个有序<code>vector&lt;Widget&gt;</code>。</p>
<p><strong>关联容器数据结构</strong></p>
<p>如果选择一个关联容器，我们几乎确定了要使用平衡二叉树。这样的树是由树节点组成，每个都不仅容纳了一个Widget，而且保存了一个该节点到左孩子的指针，一个到它右孩子的指针，和（典型的）一个到它父节点的指针。</p>
<p>这意味着<strong>在关联容器中用于存储一个Widget的空间开销至少会是三个指针</strong>。</p>
<p><strong>vector数据结构</strong></p>
<p>与之相对的是，当在vector中存储Widget并没有开销：简单地存储一个Widget。</p>
<p>当然，<strong>vector本身有开销</strong>，在vector结尾也可能有空的（保留）空间，但是每个vector开销是可以忽略的（通常是三个机器字，比如，三个指针或两个指针和一个int），而且如果必要的话，末尾空的空间可以通过“交换技巧”去掉。即使这个附加的空间没有去掉，也并不影响下面的分析，因为当查找时不会引用那段内存。</p>
<p><strong>内存大小</strong></p>
<p>假设我们的数据结构足够大，它们可以分成多个内存页面，但是vector比关联容器需要的页面要少。</p>
<p>因为vector不需要每个Widget的开销，而关联容器给每个Widget上附加了三个指针。</p>
<p>假设在你使用的系统上一个Widget的大小是12个字节，指针是4个字节，一个内存页面是4096（4K）字节。</p>
<p>忽略每个容器的开销，当用vector保存时，你可以在一页面上放置341个Widget $(4096\div12\approx341)$，但使用关联容器时你最多只能放170个 $4096\div(12+4\times3)\approx170)$。</p>
<p><strong>因此关联容器和vector比起来，你将会使用大约两倍的内存。</strong></p>
<p>如果你使用的环境可以用<strong>虚拟内存</strong>，就很可以容易地看出那会<strong>造成大量的页面错误，因此一个系统会因为大数据量而明显慢下来</strong>。</p>
<p><strong>引用局部性问题</strong></p>
<p>假设在二叉树中的节点都群集在一个相关的小内存页面集中，实际情况下关联容器很乐观的。</p>
<p><strong>大部分STL实现使用自定义内存管理器来达到这样的群集，但是如果你的STL实现没有改进树节点中的引用局部性，这些节点会分散在所有你的内存空间。那会导致更多的页面错误。</strong></p>
<p>即使使用了自定义群集内存管理器，关联容器也会导致很多页面错误，因为，不像连续内存容器，比如vector，<strong>基于节点的容器更难保证在容器的遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个。</strong></p>
<p><strong>当进行二分查找时那种内存组织方式（译注：遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个）正好是页面错误最少的。</strong></p>
<h2 id="vector的缺点">vector的缺点</h2>
<p><font color=red>有序vector的大缺点是必须保持有序！</font></p>
<p>因为vector中所有的元素都必须拷贝，所以：</p>
<ol>
<li>
<p>当一个新元素插入时，大于这个新元素的所有东西都必须向上移一位，非常昂贵；</p>
</li>
<li>
<p>如果vector必须重新分配它的内在内存，则会更昂贵；</p>
</li>
<li>
<p>如果一个元素从vector中被删除，所有大于它的元素都要向下移动。</p>
</li>
</ol>
<p>vector的插入和删除都很昂贵，但是关联容器的插入和删除则很轻量。</p>
<p>这就是为什么只有当你知道你的数据结构使用的时候查找几乎不和插入和删除混合时，使用有序vector代替关联容器才有意义。</p>
<p><strong>概要</strong></p>
<ol>
<li>
<p>在有序vector中存储数据很有可能比在标准关联容器中保存相同的数据消耗更少的内存；</p>
</li>
<li>
<p>当页面错误值得重视的时候，在有序vector中通过二分法查找可能比在一个标准关联容器中查找更快。</p>
</li>
</ol>
<h2 id="example">Example</h2>
<blockquote>
<p>vector代替set</p>
</blockquote>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="c1">// 代替set&lt;Widget&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">vw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结束建立阶段。（当模拟一个multiset时，你可能更喜欢用stable_sort 来代替；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于查找的值的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span><span class="c1">// 开始查找阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过binary_search查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过lower_bound查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 条款19解释了“!(w &lt; *i)”测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">i</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过equal_range查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                       <span class="n">equal_range</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">)...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 结束查找阶段，开始重组阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 开始新的查找阶段...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>里面最难的东西就是<strong>怎么在搜索算法中做出选择</strong>（比如，<code>binary_search</code>、<code>lower_bound</code>等）</p>
<blockquote>
<p>vector代替map或multimap</p>
</blockquote>
<p>当你决定用vector代替map或multimap时，事情会变得更有趣，因为<strong>vector必须容纳pair对象</strong>。</p>
<p>但是要注意，如果你声明一个map&lt;K, V&gt;的对象（或者等价的multimap），保存在map中的元素类型是<code>pair&lt;const K, V&gt;</code>。</p>
<p>如果要用vector模拟<code>map</code>或者<code>multimap</code>，<strong>必须去掉const</strong>，因为当你对vector排序时，元素的值将会通过赋值移动，那意味着pair的两个组件都必须是可赋值的。</p>
<p>当使用vector来模拟map&lt;K, V&gt;时，<strong>保存在vector中数据的类型将是<code>pair&lt;K, V&gt;</code></strong>，而不是<code>pair&lt;const K, V&gt;</code>。</p>
<p>map和multimap以顺序的方式保存他们的元素，但<strong>用于排序目的时它们只作用于元素的key部分</strong>（pair的第一个组件），所以当排序vector时你必须做一样的事情。</p>
<p>你需要为你的pair写一个自定义比较函数，因为<code>pair</code>的<code>operator&lt;</code>作用于pair的两个组件。</p>
<p><strong>2个比较函数来进行查找</strong></p>
<p>用来排序的比较函数将作用于两个pair对象，但是查找只用到key值。</p>
<p>必须传给用于查找的比较函数一个key类型的对象（要查找的值）和一个pair（存储在vector中的一个pair）——两个不同的类型。</p>
<p>还有一个附加的麻烦，你不会知道key还是pair是作为第一个实参传递的，所以你真的需要两个用于查找的比较函数：<strong>一个key值先传递，一个pair先传递</strong></p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">Data</span><span class="p">;</span> <span class="c1">// 在这个例子里&#34;map&#34;容纳的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DataCompare</span> <span class="p">{</span> <span class="c1">// 用于比较的类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于排序的比较函数keyLess在下面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">keyLess</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于查找的比较函数（形式1）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">Ihs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">keyLess</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于查找的比较函数（形式2）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span>  <span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">keyLessfk</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// “真的”比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">keyLess</span><span class="p">(</span><span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">k1</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们假设有序vector将模拟<code>map&lt;string, int&gt;</code>。</p>
<p>这段代码几乎是上面讨论的字面转换，除了存在成员函数<code>keyLess</code>。</p>
<p>那个函数的存在是用来<strong>保证几个不同的<code>operator()</code>函数之间的一致性</strong>。</p>
<p>每个这样的函数只是简单地比较两个key的值，所以我们把这个测试放在keyLess中并让operator()函数返回keyLess所做的事情，这比复制那个逻辑要好。</p>
<p>这个软件工程中绝妙的动作增强了<code>DataCompare</code>的可维护性，但<strong>有一个小缺点，它提供了有不同参数类型的operator()函数，这将导致函数对象无法适配。</strong></p>
<p>把有序vector用作map本质上和用作set一样。</p>
<p><strong>唯一大的区别是必须把DataCompare对象用作比较函数:</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 代替map&lt;string, int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;</span> <span class="n">vd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结束建立阶段。（当模拟multimap时，你可能更喜欢用stable_sort来代替）；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于查找的值的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 开始查找阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过binary_search查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">()))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 再次通过lower_bound查找，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 条款45解释了“!DataCompare()(s, *i)”测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">DataCompare</span><span class="p">()(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">i</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过equal_range查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">equal_range</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">)...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 结束查找阶段，开始重组阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 开始新的查找阶段...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DataCompare</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如你所见，一旦你写了DataCompare，东西都很好地依序排列了。</p>
<p>而一旦位置合适了，它们往往比相应的使用真的map的设计运行得更快而且使用更少内存。</p>
<p>如果你的程序不是按照阶段的方式操作数据结构，那么使用有序vector代替标准关联容器几乎可以确定是在浪费时间。</p>
]]></description></item><item><title>Effective STL [22] | 避免原地修改set和multiset的键</title><link>https://jianye0428.github.io/posts/clause_22/</link><pubDate>Mon, 14 Aug 2023 08:13:21 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_22/</guid><description><![CDATA[<p><strong>所有标准关联容器，set和multiset保持它们的元素有序，这些容器的正确行为依赖于它们保持有序。</strong></p>
<p>如果你改了关联容器里的一个元素的值（例如，把10变为1000），新值可能不在正确的位置，而且那将破坏容器的有序性。</p>
<h2 id="修改map和multimap值">修改map和multimap值</h2>
<p>试图改变这些容器里的一个键值的程序将不能编译:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 错误！map键不能改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">mm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">mm</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 错误！multimap键也不能改变
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition tip open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-lightbulb fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">因为<code>map&lt;K, V&gt;</code>或<code>multimap&lt;K, V&gt;</code>类型的对象中元素的类型是<code>pair&lt;const K, V&gt;</code>。因为键的类型const K，它不能改变。</div>
    </div>
  </div>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">map</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">key_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Tp</span>     <span class="n">mapped_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&gt;</span>  <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span>     <span class="n">key_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Alloc</span>     <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你使用一个<code>const_cast</code>，或许能改变它，后面会讨论到。</p>
<h2 id="修改set和multiset值">修改set和multiset值</h2>
<p>对于<code>set&lt;T&gt;</code>或<code>multiset&lt;T&gt;</code>类型的对象来说，储存在容器里的元素类型只不过是<code>T</code>，并非<code>const T</code>。因此，<code>set</code>或<code>multiset</code>里的元素可能在你想要的任何时候改变。不需要映射。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">set</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// typedefs:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///@{
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Public typedefs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">key_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span> <span class="n">key_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span> <span class="n">value_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Alloc</span>   <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">///@}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>为什么set或multiset里的元素不是常数？</strong></p>
<p>假设我们有一个雇员的类:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Employee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>       <span class="c1">// 获取雇员名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span> <span class="c1">// 设置雇员名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">getTitle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>   <span class="c1">// 获取雇员头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setTitle</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">);</span>     <span class="c1">// 设置雇员头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">idNumber</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>             <span class="c1">// 获取雇员ID号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们做合理的假设，每个雇员有唯一的ID号，就是<code>idNumber</code>函数返回的数字。然后，建立一个雇员的<code>set</code>，很显然应该只以<code>ID</code>号来排序<code>set</code>:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">IDNumberLess</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">Employee</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 参见条款40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Employees</span> <span class="n">lhs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">idNumber</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">idNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">IDNumberLess</span><span class="o">&gt;</span> <span class="n">EmpIDSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EmpIDSet</span> <span class="n">se</span><span class="p">;</span> <span class="c1">// se是雇员的set， 按照ID号排序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，雇员的<code>ID</code>号是<code>set</code>中元素的键。<strong>其余的雇员数据只是虚有其表</strong>。在这里，没有理由不能把一个特定雇员的头衔改成某个有趣的东西:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Employee</span> <span class="n">selectedID</span><span class="p">;</span> <span class="c1">// 容纳被选择的雇员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span> <span class="c1">// ID号的变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">-&gt;</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 给雇员新头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为在这里我们只是改变雇员的一个与set排序的方式无关的方面（一个雇员的非键部分），所以这段代码不会破坏set。那是它合法的原因。但它的合法排除了<code>set/multiset</code>的元素是<code>const</code>的可能。而且那是它们为什么不是的原因。</p>
<p>因为<code>set</code>或<code>multiset</code>里的值不是<code>const</code>，所以试图改变它们可以编译。</p>
<p><font color=red>如果你改变<code>set</code>或<code>multiset</code>里的元素， 你必须<strong>确保不改变一个键部分——影响容器有序性的元素部分</strong>。如果你做了，你会破坏容器，再使用那个容器将产生未定义的结果， 而且那是你的错误。另一方面，这个限制只应用于被包含对象的键部分。对被包含元素的所有其他部分来说，是开放的: 随便改变！</font></p>
<h2 id="阻止修改set和multiset值">阻止修改set和multiset值</h2>
<p>即使<code>set</code>和<code>multiset</code>的元素不是<code>const</code>，实现仍然有很多方式可以阻止它们被修改。</p>
<p>例如，实现可以让用于<code>set&lt;T&gt;::iterator的operator*</code>返回一个常数<code>T&amp;</code>。即，它可以让<code>set</code>的迭代器解引用的结果是<code>set</code>元素的常量引用。</p>
<p>在这样的实现下，将没有办法修改<code>set</code>或<code>multiset</code>的元素，因为所有访问那些元素的方法都将在让你访问之前加一个<code>const</code>。</p>
<h2 id="要不要修改set和multiset值">要不要修改set和multiset值</h2>
<ol>
<li>如果<strong>不关心移植性</strong>，你想要改变set或multiset中元素的值，而且你的STL实现让你侥幸成功，继续做。只是要确定不要改变元素的键部分，即，会影响容器有序性的元素部分。</li>
<li>如果<strong>在乎移植性</strong>，就认为set和multiset中的元素不能被修改，至少不能在没有映射的情况下</li>
</ol>
<p><strong>Solution: 映射到一个引用</strong></p>
<p>有时候完全有理由改变<code>set</code>或<code>multiset</code>元素的非键部分。例如刚看的不能在一些实现下编译的<code>setTitle</code>调用:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">-&gt;</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 有些STL实现会拒绝这样，因为*i是const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了让它可以编译并且行为正确，我们必须映射掉*i的常量性。这是那么做的正确方法:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 映射掉*i的常量性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>这可以得到i指向的对象，告诉你的编译器把映射的结果当作一个（非常数）Employee的引用，然后在那个引用上调用setTitle。</strong></p>
<p><strong>错误版本的映射</strong></p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">  <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 把*i映射到一个Employee
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>它也等价于如下内容:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">((</span><span class="n">Employee</span><span class="p">)(</span><span class="o">*</span><span class="n">i</span><span class="p">)).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 使用C映射语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这两个都能编译，而且因为它们等价，所以它们错的原因也相同。</p>
<p><strong>在运行期，它们不能修改<code>*i</code>！</strong></p>
<p><strong>在这两个情况里，映射的结果是一个<code>*i</code>副本的临时匿名对象，而setTitle是在匿名的物体上调用，不在<code>*i</code>上<code>！*i</code>没被修改，因为setTitle从未在那个对象上调用，它在那个对象的副本上调用。</strong></p>
<p>两个句法形式等价于这个:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Employee</span> <span class="nf">tempCopy</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 把*i拷贝到tempCopy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tempCopy</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 修改tempCopy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过映射到引用，我们避免了建立一个新对象。</p>
<p>取而代之的是，映射的结果是一个现有对象的引用，<code>i</code>指向的对象。</p>
<p>当我们在有这个引用指定的对象上调用setTitle时，我们是在<code>*i</code>上调用setTitle，而且那正是我们想要的。</p>
<p><strong>为什么不能去掉map和multimap的常量性</strong></p>
<p>注意<code>map&lt;K, V&gt;</code>或<code>multimap&lt;K, V&gt;</code>包含<code>pair&lt;const K, V&gt;</code>类型的元素。</p>
<p>那个<code>const</code>表明<code>pair</code>的第一个组件被定义为常量，而那意味着试图修改它是未定义的行为（即使映射掉它的常量性）。</p>
<p>理论上，一个STL实现可能把这样的值写到一个只读的内存位置（比如，一旦写了就通过系统调用进行写保护的虚拟内存页），而且试图映射掉它的常量性，最多，没有效果。</p>
<p>如果你是一个坚持遵循标准拟定的规则的人，你绝不会试图映射掉<code>map</code>或<code>multimap</code>键的常量性。</p>
<h2 id="安全修改元素步骤">安全修改元素步骤</h2>
<p>想要总是可以工作而且总是安全地改变set、multiset、map或multimap里的元素，按5个简单的步骤去做：</p>
<ol>
<li>定位你想要改变的容器元素。如果你不确定最好的方法， 条款45提供了关于怎样进行适当搜寻的指导。</li>
<li>拷贝一份要被修改的元素。对map或multimap而言，确定不要把副本的第一个元素声明为const。毕竟，你想要改变它！</li>
<li>修改副本，使它有你想要在容器里的值。</li>
<li>从容器里删除元素，通常通过调用erase（参见条款9）。</li>
<li>把新值插入容器。如果新元素在容器的排序顺序中的位置正好相同或相邻于删除的元素，使用insert的“提示”形式把插入的效率从对数时间改进到分摊的常数时间。使用你从第一步获得的迭代器作为提示。</li>
</ol>
<p><strong>一句话概括就是：先删除，再插入新的。</strong></p>
<p><strong>Example:</strong></p>
<p>这是同一个累人的雇员例子，这次以安全、可移植的方式写:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EmpIDSet</span> <span class="n">se</span><span class="p">;</span> <span class="c1">// 同前，se是一个以ID号排序的雇员set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Employee</span> <span class="n">selectedID</span><span class="p">;</span> <span class="c1">// 同前，selectedID是一个带有需要ID号的雇员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span> <span class="c1">// 第一步：找到要改变的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Employee</span> <span class="nf">e</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 第二步：拷贝这个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">se</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>  <span class="c1">// 第三步：删除这个元素；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// 自增这个迭代器以
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// 保持它有效（参见条款9）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">e</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 第四步：修改这个副本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">se</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>               <span class="c1">// 第五步：插入新值；提示它的位置和原先元素的一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Effective STL [21] | 永远让比较函数对相等的值返回false</title><link>https://jianye0428.github.io/posts/clause_21/</link><pubDate>Fri, 11 Aug 2023 17:11:35 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_21/</guid><description><![CDATA[<h2 id="example-set">Example set</h2>
<p>建立一个set，比较类型用<code>less_equal</code>，然后插入整型数字33(称为 $33_{A}$):</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// s以“&lt;=”排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span> <span class="c1">// 插入33
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在尝试再插入一次33(称为 $33_{B}$):</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于这个insert的调用，set必须先要判断出 $33_{A}$ 是否已经位于其中了，查找哪儿适合插入 $33_{B}$。最终，它总要检查 $33_{B}$是否与 $33_{A}$ 相同。</p>
<p>关联容器对“相同”的定义是等价，因此set测试 $33_{B}$是否等价于 $33_{A}$。</p>
<p>当执行这个测试时，它自然是使用set的比较函数。在这一例子里，是<code>operator&lt;=</code>，因为我们指定<code>set</code>的比较函数为<code>less_equal</code>，而<code>less_equal</code>意思就是<code>operator&lt;=</code>。</p>
<p>可以看看<code>less_equal</code>的源码实现：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// One of the @link comparison_functors comparison functors@endlink.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">less_equal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_GLIBCXX14_CONSTEXPR</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__y</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span> <span class="o">&lt;=</span> <span class="n">__y</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 此处是 &lt;=
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>于是，set将计算这个表达式是否为真:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="mi">33</span><span class="n">A</span> <span class="o">&lt;=</span> <span class="mi">33</span><span class="n">B</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="mi">33</span><span class="n">B</span> <span class="o">&lt;=</span> <span class="mi">33</span><span class="n">A</span><span class="p">)</span> <span class="c1">// 测试33A和33B是否等价
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>$33_{A}$ 和 $33_{B}$ 都是33，因此， $33_{A}$&lt;=$33_{B}$ 肯定为真。同样清楚的是，$33_{B}$ &lt;= $33_{A}$。于是上述的表达式简化为:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再简化就是</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果当然是false。</p>
<p>也就是说，set得出的结论是 $33_{B}$ 与 $33_{B}$ 不等价，因此不一样，于是它将 $33_{B}$ 插入容器中的旁边。</p>
<p>在技术上而言，这个做法导致未定义的行为，但是通常的结果是set以拥有了两个为33的值的拷贝而告终，也就是说它不再是一个set了。通过使用less_equal作为我们的比较类型，我们破坏了容器！</p>
<p><strong>测试</strong></p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">snumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">snumber</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">snumber</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">for_each</span><span class="p">(</span><span class="n">snumber</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">snumber</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">33</span>
</span></span><span class="line"><span class="cl"><span class="mi">33</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="example-string">Example string*</h2>
<p><code>条款20</code>描述了该如何写一个比较函数以使得容纳<code>string*</code>指针的容器根据string的值排序，而不是对指针的值排序。那个比较函数是按升序排序的，但现在假设你需要<code>string*</code>指针的容器的降序排序的比较函数。</p>
<p>自然是抓现成的代码来修改了。如果不细心，可能会这么干:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrGreater</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 这代码是有瑕疵的！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">);</span> <span class="c1">// 只是相反了旧的测试；这是不对的！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的想法是通过将比较函数内部结果取反来达到反序的结果。很不幸，取反“&lt;”不会给你（你所期望的）“&gt;”，它给你的是 “&gt;=”。</p>
<p>而你现在知道，因为它将对相等的值返回true，对关联容器来说，它是一个无效的比较函数。</p>
<p>你真正需要的比较类型是这个:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrGreater</span><span class="o">:</span> <span class="c1">// 对关联容器来说这是有效的比较类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="n">ps2</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps1</span><span class="p">;</span> <span class="c1">// 返回*ps2是否大于*ps1（也就是交换操作数的顺序）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要避免掉入这个陷阱，你所要记住的就是比较函数的返回值表明的是在此函数定义的排序方式下，一个值是否大于另一个。</p>
<p><strong>相等的值绝不该一个大于另一个，所以比较函数总应该对相等的值返回<code>false</code></strong></p>
<h2 id="example-multiset">Example multiset</h2>
<p>multiset和multimap那些容器可以容纳复本可能包含副本，如果容器认为两个值相等的对象不等价，它将会把两个都存储进去的，这正是multi系列容器的所要支持的事情。</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">msnum</span><span class="p">;</span> <span class="c1">// 仍然以“&lt;=”排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">msnum</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// 插入22A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">msnum</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// 插入22B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">22</span>
</span></span><span class="line"><span class="cl"><span class="mi">22</span></span></span></code></pre></td></tr></table>
</div>
</div><p>s里有两个22的拷贝，<strong>因此我们期望如果我们在它上面做一个<code>equal_range</code>，我们将会得到一对指出包含这两个拷贝的范围的迭代器。但那是不可能的。</strong></p>
<p><code>equal_range</code>，虽然叫这个名字，但不是指示出相等的值的范围，而是等价的值的范围。在这个例子中，s的比较函数说22A和22B是不等价的，所以不可能让它们同时出现在equal_range所指示的范围内。</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//在 myvector 容器中找到所有的元素 22
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">range2</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">22</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">my multiset：&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">range2</span><span class="p">.</span><span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">range2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果没有得到期望结果:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">my multiset:</span></span></code></pre></td></tr></table>
</div>
</div><p>如果改为<code>less</code>比较:</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">range2</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">22</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">my</span> <span class="n">multiset</span><span class="err">：</span><span class="mi">22</span> <span class="mi">22</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red><strong>除非你的比较函数总是为相等的值返回false，你将会打破所有的标准关联型容器，不管它们是否允许存储复本。</strong></font></p>
<h2 id="总结">总结</h2>
<p>从技术上说，用于排序关联容器的比较函数必须在它们所比较的对象上定义一个“<strong>严格的弱序化(strict weakordering)</strong>”。（传给sort等算法（参见条款31）的比较函数也有同样的限制）。</p>
<p><strong>任何一个定义了严格的弱序化的函数都必须在传入相同的值的两个拷贝时返回false。</strong></p>
]]></description></item><item><title>Effective STL [20] | 为指针的关联容器指定比较类型</title><link>https://jianye0428.github.io/posts/clause_20/</link><pubDate>Fri, 11 Aug 2023 16:10:59 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_20/</guid><description><![CDATA[<h2 id="example">Example</h2>
<p>假定你有一个string*指针的set，你把一些动物的名字插入进set:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Anteater&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Wombat&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Lemur&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Penguin&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ssp = “set of string ptrs”
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后你写了下列代码打印set的内容，希望字符串按字母顺序出现。毕竟，确定set保持它们的内容有序。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你期望看到</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Anteater
</span></span><span class="line"><span class="cl">Wombat
</span></span><span class="line"><span class="cl">Lemur
</span></span><span class="line"><span class="cl">Penguin</span></span></code></pre></td></tr></table>
</div>
</div><p>实际运行结果:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mh">0x5566364b5eb0</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5f10</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5f70</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5fd0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果是4个十六进制的数，代表指针的值。 因为set容纳指针，<code>*i</code>不是一个<code>string</code>，是一个<code>string</code>的指针。</p>
<p>如果你已经改为调用copy算法，</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">copy</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span><span class="c1">// 把ssp中的字符串拷贝到cout（但这不能编译）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个copy的调用将不能编译，因为<code>ostream_iterator</code>需要知道被打印的对象的类型，所以当你告诉它是一个string时（通过作为模板参数传递），编译器检测到那和ssp中储存的对象类型(是<code>string*</code>)之间不匹配，它们会拒绝编译代码。</p>
<p>把显式循环中的<code>*i</code>改为<code>**i</code>，你可能可以得到你想要的输出，但也可能不。动物名字将被打印，但它们按字母顺序出现的机会只是24份之1。ssp保持它的内容有序，但是它容纳的是指针，所以它以指针的值排序，而不以string值。对于四个指针值可能有24种排列（），所以指针被储存时有24种可能的顺序。因此你看见字符串按字母排序有24份之1的几率。</p>
<p>或者打印 <code>*string</code>的<code>char*</code>数组</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="solution">Solution</h2>
<p>当我们写下<code>set&lt;string*&gt; ssp</code>;，其实省略了一个默认参数<code>set&lt;string*, less&lt;string*&gt; &gt; ssp</code>;，实际上还有个默认参数:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">,</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="自定义仿函数">自定义仿函数</h2>
<p>如果想要<code>string*</code>指针以字符串值确定顺序被储存在<code>set</code>中，不能使用默认比较仿函数类<code>less&lt;string*&gt;</code>。</p>
<p><strong>必须改为写自己的比较仿函数类，它的对象带有string*指针并按照指向的字符串值来进行排序:</strong></p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrLess</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后可以使用<code>StringPtrLess</code>作为<code>ssp</code>的比较类型:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">StringPtrLess</span><span class="o">&gt;</span> <span class="n">StringPtrSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">StringPtrSet</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立字符串的集合，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 按照StringPtrLess定义的顺序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 和前面一样插入
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同样四个字符串
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在循环最后将做想要它做的（也就是前面你使用*i代替**i所修正的问题）:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">StringPtrSet</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>指针之前对它们解引用的函数，然后和<code>for_each</code>联用那个函数:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ps</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="p">);</span><span class="c1">// 在ssp中的每个元素上调用print
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者你想象并写出了泛型的解引用仿函数类，然后让它和transform与ostream_iterator连用:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 当本类型的仿函数被传入一个T*时，它们返回一个const T&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Dereference</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过解引用“转换” ssp中的每个元素，把结果写入cout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">Dereference</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要点是无论何时你建立一个指针的标准关联容器，你必须记住容器会以指针的值排序。这基本上不是你想要的，所以你几乎总是需要建立自己的仿函数类作为比较类型。</p>
<p><strong>比较类型 vs 比较函数</strong></p>
<p>注意到这里写的是“比较类型”。</p>
<p>你可能奇怪为什么必须特意创造一个仿函数类而不是简单地为set写一个比较函数:</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">stringPtrLess</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">ps2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 将成为用于按字符串值排序的string*指针的比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">return</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">stringPtrLess</span><span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span><span class="c1">// 假设使用stringPtrLess 作为ssp的比较函数；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这不能编译
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的问题是每个set模板的第三个参数都是一种类型，而<code>stringPtrLess</code>不是一种类型，它是一个函数。这就是为什么尝试使用<code>stringPtrLess</code>作为set的比较函数不能编译的原因，set不要一个函数，它要的是能在内部用实例化建立函数的一种类型。</p>
<p><strong>无论何时你建立指针的关联容器，注意你也得指定容器的比较类型。</strong></p>
<p>大多数时候，你的比较类型只是解引用指针并比较所指向的对象（就像上面的<code>StringPtrLess</code>做的那样）。</p>
<p>鉴于这种情况，你手头最好也能有一个用于那种比较的仿函数模板。像这样:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DereferenceLess</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PtrType</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">PtrType</span> <span class="n">pT1</span><span class="p">,</span> <span class="n">PtrType</span> <span class="n">pT2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="c1">// 参数是值传递的因为我们希望它们是（或行为像）指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">pT1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pT2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的模板消除了写像<code>StringPtrLess</code>那样的类的需要，因为我们可以改为使用<code>DereferenceLess</code>:</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">DereferenceLess</span><span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 行为就像 set&lt;string*, StringPtrLess&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>本条款是关于指针的关联容器，但它也可以应用于表现为指针的对象的容器，例如，智能指针和迭代器。</p>
<p>如果你有一个智能指针或迭代器的关联容器，那也得为它指定比较类型。幸运的是，指针的这个解决方案也可以用于类似指针的对象。正如DereferenceLess适合作为T*的关联容器的比较类型一样，它也 可以作为T对象的迭代器和智能指针容器的比较类型。</p>
<p>实际上，这24种排列很可能不是平等的，所以“24份之1”的陈述有点使人误解。确实，有24个不同的顺序，而且你可能得到它们中的任何一个。</p>
]]></description></item><item><title>Effective STL [19] | 了解相等和等价的区别</title><link>https://jianye0428.github.io/posts/clause_19/</link><pubDate>Thu, 10 Aug 2023 08:30:55 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_19/</guid><description><![CDATA[<h2 id="比较对象">比较对象</h2>
<p>STL充满了比较对象是否有同样的值。比如，当你用<code>find</code>来定位区间中第一个有特定值的对象的位置，<code>find</code>必须可以比较两个对象，看看一个的值是否与另一个相等。同样，当你尝试向<code>set</code>中插入一个新元素时，<code>set::insert</code>必须可以判断那个元素的值是否已经在<code>set</code>中了。</p>
<p><code>find</code>算法和<code>set</code>的<code>insert</code>成员函数是很多必须判断两个值是否相同的函数的代表。但它们实现方式不同，find对“相同”的定义是相等，基于<code>operator==</code>。<code>set::insert</code>对“相同”的定义是等价，通常基于<code>operator&lt;</code>。因为有定义不同，所以有可能一个定义规定了两个对象有相同的值而另一个定义判定它们没有。结果，如果你想有效使用STL，那么你必须明白相等和等价的区别。</p>
<p><strong>相等</strong></p>
<p>操作上来说，相等的概念是基于<code>operator</code>的。如果表达式“<code>x == y</code>”返回true，<code>x</code>和<code>y</code>有相等的值，否则它们没有。</p>
<p><strong><font color=red>x和y有相等的值并不意味着所有它们的成员有相等的值</font></strong>。比如，我们可能有一个内部记录了最后一次访问的Widget类。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="n">TimeStamp</span> <span class="n">lastAccessed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以有一个用于Widget的忽略这个域的operator:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 忽略lastAccessed域的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，两个<code>Widget</code>即使它们的<code>lastAccessed</code>域不同也可以有相等的值。</p>
<p>一般而言，相等意味着两个变量的值相同，但是如果比较2个对象，因为比较函数可以自定义，因此有时候对象的某些成员变量值不同也会设定2个对象相等。</p>
<p><strong>等价</strong></p>
<p>==等价是基于在一个有序区间中对象值的相对位置==。</p>
<p>等价一般在每种标准关联容器（比如，set、multiset、map和multimap）的一部分——排序顺序方面有意义。注意这里的应用场景是==排序==。</p>
<p>两个对象x和y如果在关联容器c的排序顺序中没有哪个排在另一个之前，那么它们关于c使用的排序顺序有等价的值。</p>
<p>举一个例子，一个set<Widget> s。两个Widget w1和w2，如果在s的排序顺序中没有哪个在另一个之前，那么关于s它们有等价的值。set<Widget>的默认比较函数是less<Widget>，而默认的less<Widget>简单地对Widget调用operator&lt;，所以w1和w2关于operator&lt;有等价的值如果下面表达式为真：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="n">w1</span> <span class="o">&lt;</span> <span class="n">w2</span><span class="p">)</span> <span class="c1">// w1 &lt; w2时它非真
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&amp;&amp;</span> <span class="c1">// 而且
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">!</span><span class="p">(</span><span class="n">w2</span><span class="o">&lt;</span><span class="n">w1</span><span class="p">)</span> <span class="c1">// w2 &lt; w1时它非真
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个有意义：<font color=red>两个值如果没有哪个在另一个之前（关于某个排序标准），那么它们等价（按照那个标准）。</font>在一般情况下，用于关联容器的比较函数不是<code>operator&lt;</code>或甚至<code>less</code>，它是用户定义的判断式。每个标准关联容器通过它的<code>key_comp</code>成员函数来访问排序判断式，所以如果下式求值为真，两个对象x和y关于一个关联容器c的排序标准有等价的值：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// 在c的排序顺序中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果x在y之前它非真，同时在c的排序顺序中,如果y在x之前它非真
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要完全领会==相等==和==等价==的含义，考虑一个忽略大小写的<code>set&lt;string&gt;</code>，也就是set的比较函数忽略字符串中字符大小写的<code>set&lt;string&gt;</code>。这样的比较函数会认为“STL”和“stL”是等价的。条款35演示了怎么实现一个函数，<code>ciStringCompare</code>，它进行了忽略大小写比较，但set要一个比较函数的类型，不是真的函数。要填平这个鸿沟，我们写一个operator()调用了ciStringCompare的仿函数类:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CIStringCompare</span><span class="o">:</span> <span class="c1">// 用于忽略大小写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span> <span class="c1">// 字符串比较的类；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">ciStringCompare</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// 关于ciStringCompare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>具体实现为:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">ciCharCompare</span><span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">)</span> <span class="c1">// 忽略大小写比较字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>   <span class="c1">// c1和c2，如果c1 &lt; c2返回-1，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果c1==c2返回0，如果c1 &gt; c2返回1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Ic1</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c1</span><span class="p">));</span><span class="c1">// 转成小写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Ic2</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Ic1</span> <span class="o">&lt;</span> <span class="n">Ic2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">lc1</span> <span class="o">&gt;</span> <span class="n">Ic2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>给定<code>CIStringCompare</code>，要建立一个忽略大小写的set<string>就很简单了:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">CIStringCompare</span><span class="o">&gt;</span> <span class="n">ciss</span><span class="p">;</span> <span class="c1">// ciss = “case-insensitive
</span></span></span><span class="line"><span class="cl"><span class="c1">// string set”
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们向这个set中插入“<code>Persephone</code>”和“<code>persephone</code>”，只有第一个字符串加入了，因为第二个等价于第一个：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ciss</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">);</span> <span class="c1">// 一个新元素添加到set中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ciss</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">);</span> <span class="c1">// 没有新元素添加到set中
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们现在使用set的find成员函数搜索字符串“persephone”，搜索会成功，</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ciss</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试会成功
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但如果我们用非成员的find算法，搜索会失败：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">ciss</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试会失败
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那是因为“<code>persephone</code>”等价于“<code>Persephone</code>”（关于比较仿函数CIStringCompare），但不等于它（因为string(&ldquo;persephone&rdquo;) != string(&ldquo;Persephone&rdquo;)）。你可能会奇怪为什么标准关联容器是基于等价而不是相等。毕竟，大多数程序员对相等有感觉而缺乏等价的感觉。</p>
<p><font color=red>标准关联容器保持有序，所以每个容器必须有一个定义了怎么保持东西有序的比较函数（默认是less）。等价是根据这个比较函数定义的，所以标准关联容器的用户只需要为他们要使用的任意容器指定一个比较函数（决定排序顺序的那个）。</p>
<p>如果关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器就需要，除了用于排序的比较函数，还需要一个用于判断两个值是否相等的比较函数。（默认的，这个比较函数大概应该是equal_to，但有趣的是equal_to从没有在STL中用做默认比较函数。当在STL中需要相等时，习惯是简单地直接调用operator==。比如，这是非成员find算法所作的。）</font></p>
<p><strong><font color=blue>说白了，就是等价是为容器排序服务的，如果容器想要插入多个转化为小写后相等的单词，容器会判定这些单词等价，虽然它们本身不相等，这样就能够很好地保持容器内单词的唯一性和单词的有序性。否则通过查找或插入该单词的时候，容器内部就会发生歧义，造成不符合使用者逻辑。</font></strong></p>
<p>让我们假设我们有一个类似set的STL容器叫做<code>set2CF</code>，“set with two comparison functions”。<strong><font color=red>第一个比较函数用来决定set的排序顺序，第二个用来决定是否两个对象有相同的值。</font></strong> 现在考虑这set2CF：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set2CF</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">CIStringCompare</span><span class="p">,</span> <span class="n">equal_to</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，s内部排序它的字符串时不考虑大小写，等价标准直觉上是这样：如果两个字符串中一个等于另一个，那么它们有相同的值。让我们向s中插入哈迪斯强娶的新娘（Persephone）的两个拼写:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如果我们说<code>&quot;Persephone&quot; != &quot;persephone&quot;</code>然后两个都插入s，它们应该是什么顺序？</p>
</blockquote>
<p>记住排序函数不能分别告诉它们。我们可以以任意顺序插入，因此放弃以确定的顺序遍历set内容的能力吗？（不能以确定的顺序遍历关联容器元素已经折磨着<code>multiset</code>和<code>multimap</code>了，因为标准没有规定等价的值（对于multiset）或键（对于multimap）的相对顺序。）或者我们坚持s的内容的一个确定顺序并忽略第二次插入的尝试（“persephone”的那个）? 如果我们那么做，这里会发生什么？</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试成功或失败？
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>大概**<font color=red>find使用了等价检查</font>**，但如果我们为了维护s中元素的一个确定顺序而忽略了第二个insert的调用，这个find会失败，即使“persephone”的插入由于它是一个重复的值的原则而被忽略！</p>
<h2 id="总结">总结</h2>
<p>通过只使用一个比较函数并使用等价作为两个值“相等”的意义的仲裁者，标准关联容器避开了很多会由允许两个比较函数而引发的困难。</p>
<p>一开始行为可能看起来有些奇怪（特别是当你发现成员和非成员find可能返回不同结果），但最后，它避免了会由在标准关联容器中混用相等和等价造成的混乱。</p>
]]></description></item><item><title>Effective STL [18] | 避免使用vector&lt;bool></title><link>https://jianye0428.github.io/posts/clause_18/</link><pubDate>Wed, 09 Aug 2023 14:39:18 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_18/</guid><description><![CDATA[<h2 id="vectorbool-问题">vector<bool> 问题</h2>
<p>作为一个STL容器，vector<bool>确实只有1个问题:</p>
<ul>
<li>它不是一个STL容器；</li>
<li>它并不容纳bool。</li>
</ul>
<h2 id="剖析">剖析</h2>
<p>一个东西要成为STL容器就必须满足所有在C++标准23.1节中列出的容器必要条件。</p>
<p>如果c是一个T类型对象的容器，且c支持operator[]，那么以下代码必须能够编译:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">T</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 无论operator[]返回什么，都可以用这个地址初始化一个T*
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>换句话说，如果你使用<code>operator[]</code>来得到Container中的一个T对象，你可以通过取它的地址而获得指向那个对象的指针。(假设T没有倔强地重载一些操作符。) 然而如果vector是一个容器，这段代码必须能够编译：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 用vector&lt;bool&gt;::operator[]返回的东西的地址初始化一个bool*
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但它不能编译。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">test_vector.cpp:154:19: error: taking address of rvalue <span class="o">[</span>-fpermissive<span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="m">154</span> <span class="p">|</span>   bool *pb <span class="o">=</span> <span class="p">&amp;</span>r2<span class="o">[</span>0<span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>                   ^
</span></span><span class="line"><span class="cl">test_vector.cpp:154:14: error: cannot convert ‘std::vector&lt;bool&gt;::reference*’ <span class="o">{</span>aka ‘std::_Bit_reference*’<span class="o">}</span> to ‘bool*’ in initialization
</span></span><span class="line"><span class="cl">  <span class="m">154</span> <span class="p">|</span>   bool *pb <span class="o">=</span> <span class="p">&amp;</span>r2<span class="o">[</span>0<span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              ^~~~~~
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              <span class="p">|</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              std::vector&lt;bool&gt;::reference* <span class="o">{</span>aka std::_Bit_reference*<span class="o">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为<code>vector&lt;bool&gt;</code>是一个伪容器，并不保存真正的bool，而是打包bool以节省空间。在一个典型的实现中，每个保存在“vector”中的“bool”占用一个单独的比特，而一个8比特的字节将容纳8个“bool”。</p>
<p>在内部，<code>vector&lt;bool&gt;</code>使用了与位域（bitfield）等价的思想来表示它假装容纳的bool。</p>
<p><font color=blue>位域也只表现为两种可能的值，但真的bool和化装成bool的位域之间有一个重要的不同：你可以创建指向真的bool的指针，但却禁止有指向单个比特的指针。</font></p>
<h2 id="实际实现">实际实现</h2>
<p>vector::operator[]返回一个对象，其行为类似于比特的引用，也称为代理对象。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">_Bvector_base</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bvector_base</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;</span>   <span class="n">_Base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_Bit_pointer</span>  <span class="n">_Bit_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_Bit_alloc_traits</span>  <span class="n">_Bit_alloc_traits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if __cplusplus &gt;= 201103L
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="k">friend</span> <span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="kt">bool</span>     <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">size_t</span>     <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">ptrdiff_t</span>     <span class="n">difference_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_reference</span>    <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="kt">bool</span>     <span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_reference</span><span class="o">*</span>    <span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">const</span> <span class="kt">bool</span><span class="o">*</span>    <span class="n">const_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_iterator</span>    <span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_const_iterator</span>   <span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">const_reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span>  <span class="n">reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Alloc</span>     <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">allocator_type</span>
</span></span><span class="line"><span class="cl">      <span class="nf">get_allocator</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="k">return</span> <span class="n">_Base</span><span class="o">::</span><span class="n">get_allocator</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_allocate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_deallocate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_S_nword</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_get_Bit_allocator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="n">reference</span>
</span></span><span class="line"><span class="cl">      <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">__n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="nf">iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_p</span>
</span></span><span class="line"><span class="cl">    <span class="o">+</span> <span class="n">__n</span> <span class="o">/</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">),</span> <span class="n">__n</span> <span class="o">%</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">const_reference</span>
</span></span><span class="line"><span class="cl">      <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">__n</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="nf">const_iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_p</span>
</span></span><span class="line"><span class="cl">        <span class="o">+</span> <span class="n">__n</span> <span class="o">/</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">),</span> <span class="n">__n</span> <span class="o">%</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码不能编译的原因很明显：<code>bool *pb = &amp;v[0]</code>右边的表达式是<code>vector&lt;bool&gt;::reference*</code>类型，不是<code>bool*</code>。</p>
<h2 id="替代品">替代品</h2>
<h3 id="1-dequebool">1. deque<bool></h3>
<p><code>deque</code>提供了几乎所有<code>vector</code>所提供的（唯一值得注意的是<code>reserve</code>和<code>capacity</code>），而<code>deque&lt;bool&gt;</code>是一个STL容器，它保存真正的<code>bool</code>值。</p>
<p><code>deque</code>内部内存不是连续的。所以不能传递<code>deque&lt;bool&gt;</code>中的数据给一个希望得到<code>bool</code>数组的<code>C API</code>。</p>
<p>条款16中用于<code>vector</code>的技术不能在<code>vector&lt;bool&gt;</code>上通过编译，因为它们依赖于能够取得指向容器中包含的元素类型的指针。</p>
<h3 id="2-bitset">2. bitset</h3>
<p><code>bitset</code>不是一个STL容器，但它是C++标准库的一部分。与STL容器不同，<strong>它的大小（元素数量）在编译期固定</strong>，因此它不支持插入和删除元素。</p>
<p>因为它不是一个STL容器，它也不支持iterator。但就像<code>vector&lt;bool&gt;</code>，<strong>它使用一个压缩的表示法，使得它包含的每个值只占用一比特。</strong></p>
<p>它提供<code>vector&lt;bool&gt;</code>特有的<code>flip</code>成员函数，还有一系列其他操作位集<code>(collection of bits)</code>所特有的成员函数。</p>
<h2 id="总结">总结</h2>
<p><code>vector&lt;bool&gt;</code>不满足STL容器的必要条件，你最好不要使用它；</p>
<p>而<code>deque&lt;bool&gt;</code>和<code>bitset</code>是基本能满足你对<code>vector&lt;bool&gt;</code>提供的性能的需要的替代数据结构。</p>
]]></description></item></channel></rss>