# Effective STL [14] | 使用reserve来避免不必要的重新分配


## 自动扩容

STL 容器只要存储的对象不超过「**最大大小**」，就可以自动增长到足以容纳放进去的数据。这个最大值，只要调用名叫max_size的成员函数就可以查询到。

对于vector和string，只要需要更多空间，就以`realloc`等价的思想来增长。

realloc的操作有4个部分：
  1. 「**分配新的内存块**」。在大部分实现中，vector和string的容量每次以「**2**」为因数增长，即容量每次翻倍。
  2. 「**把所有元素从容器的旧内存拷贝到新内存**」。
  3. 「**销毁旧内存中的对象**」。
  4. 「**回收旧内存**」。
这就是分配，回收，拷贝和析构4个步骤，这些步骤代价都很昂贵。

即便是简单地把一个元素插入vector或string的动作也可能因为需要更新其他使用了指向vector或string中的迭代器、指针或引用的数据结构而膨胀。

## 4个成员函数

这4个STL容器成员函数，只有vector和string提供了所有这些函数。

|成员函数|	说明|
|:---|:---|
|size()	|「容器中有多少元素」。没有说明容器为容纳的元素分配了多少内存。|
|capacity()	|「容器已经分配的内存中可以容纳多少元素」。那是容器在那块内存中总共可以容纳多少元素，而不是还可以容纳多少元素。如果想知道一个vector或string中有多少没有被占用的内存，必须从capacity()中减去size()。如果size和capacity返回同样的值，容器中就没有剩余空间了，而下一次插入（通过insert或push_back等）会引发上面的重新分配步骤。|
|resize(Container::size_type n)	|「强制把容器改为容纳n个元素」。调用resize之后，size将会返回n。如果n小于当前大小，容器尾部的元素会被销毁。如果n大于当前大小，新默认构造的元素会添加到容器尾部。如果n大于当前容量，在元素加入之前会发生重新分配。|
|reserve(Container::size_type n)	|「强制容器把它的容量改为至少n，提供的n不小于当前大小」。这一般强迫进行一次重新分配，因为容量需要增加。|

---

> 作者: [Jian YE](https://github.com/jianye0428)  
> URL: https://jianye0428.github.io/posts/clause_14/  

