<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Effective C++ (第3版) 精读总结 [3] - yejian's blog</title><meta name=author content="Jian YE"><meta name=author-link content="https://github.com/jianye0428"><meta name=description content><meta name=keywords content="Effective"><meta itemprop=name content="Effective C++ (第3版) 精读总结 [3]"><meta itemprop=description content><meta itemprop=datePublished content="2023-07-31T07:26:00+08:00"><meta itemprop=dateModified content="2023-07-31T15:56:02+08:00"><meta itemprop=wordCount content="6336"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="Effective,"><meta property="og:title" content="Effective C++ (第3版) 精读总结 [3]"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://jianye0428.github.io/posts/partthree/"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-31T07:26:00+08:00"><meta property="article:modified_time" content="2023-07-31T15:56:02+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="Effective C++ (第3版) 精读总结 [3]"><meta name=twitter:description content><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/partthree/><link rel=prev href=https://jianye0428.github.io/posts/parttwo/><link rel=next href=https://jianye0428.github.io/posts/partfour/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Effective C++ (第3版) 精读总结 [3]","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/partthree\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"Effective","wordcount":6336,"url":"https:\/\/jianye0428.github.io\/posts\/partthree\/","datePublished":"2023-07-31T07:26:00+08:00","dateModified":"2023-07-31T15:56:02+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Effective C++ (第3版) 精读总结 [3]</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-07-31 07:26:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-07-31>2023-07-31</time></span>&nbsp;<span title="更新于 2023-07-31 15:56:02"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-07-31>2023-07-31</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 6336 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 13 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="Effective C++ (第3版) 精读总结 [3]">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#ch5-实现>CH5. 实现</a><ul><li><a href=#r26-尽可能延后变量定义式的出现时间>R26 尽可能延后变量定义式的出现时间</a></li><li><a href=#r27-尽量少做转型动作>R27 尽量少做转型动作</a></li><li><a href=#r28-避免返回handles指向对象内部成分>R28 避免返回handles指向对象内部成分</a></li><li><a href=#r29-为异常安全而努力是值得的>R29 为“异常安全”而努力是值得的</a><ul><li><a href=#异常安全的3个等级>异常安全的3个等级</a></li><li><a href=#使用copy-and-swap保障异常安全>使用copy-and-swap保障异常安全</a></li><li><a href=#异常安全的连带影响side-effects>异常安全的连带影响(side effects)</a></li></ul></li><li><a href=#r30-透彻了解inline的里里外外>R30 透彻了解inline的里里外外</a></li><li><a href=#r31-将文件间的编译依赖关系降至最低>R31 将文件间的编译依赖关系降至最低</a></li></ul></li><li><a href=#ch6-继承与面向对象设计>CH6. 继承与面向对象设计</a><ul><li><a href=#r32-确定你的public继承塑造出is-a关系>R32 确定你的public继承塑造出is-a关系</a></li></ul></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><h1 id=前言>前言</h1><blockquote><p>Effective-C++总结系列分为四部分，本文为第二部分，涉及原书第3~4章，内容范围Rule13~25。为方便书写，Rule13简写为R13。</p></blockquote><div class="details admonition Note"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本博客站点系列内容如下：</br>💡 <a href=https://jianye0428.github.io/posts/partone/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/parttwo/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/partthree/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/partfour/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br></div></div></div><p>由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人<code>开发经验</code>新增一些个人感悟👉<code>By the way</code>环节。</p><h2 id=ch5-实现>CH5. 实现</h2><h3 id=r26-尽可能延后变量定义式的出现时间>R26 尽可能延后变量定义式的出现时间</h3><ul><li>尽可能延后变量定义式的出现，可增加程序清晰度和效率<ol><li>定义后，在使用前就遭遇抛异常
这种情况，如果是定义了对象<code>ObjectA a</code>，便白白地浪费了对象a的构造和析构成本。</li><li>不只是延后变量定义到使用时，而是尽量延后到能给它初值时</li></ol><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encryptPassword</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>password</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>password</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>8</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>logic_error</span><span class=p>(</span><span class=s>&#34;Password is too short&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span><span class=c1>// 考虑1：在异常之后定义变量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encrypted</span><span class=p>(</span><span class=n>password</span><span class=p>);</span><span class=c1>//考虑2：定义延后至变量能赋初值的时机
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>encrypt</span><span class=p>(</span><span class=n>encrypted</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>思考变量定义<strong>是否</strong>该在循环内</li></ol><ul><li>方法A：定义于循环外<div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Widget</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=err> </span> <span class=err> </span> <span class=n>w</span> <span class=o>=</span> <span class=n>foo</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err> </span> <span class=err> </span><span class=c1>// other...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li>方法B：定义于循环内<div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=nf>w</span><span class=p>(</span><span class=n>foo</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=c1>// other...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><p><strong>究竟是A还是B方法好</strong>，取决于 <code>一个赋值成本</code>和<code>一组构造+析构</code>成本，这2者之间，如果是赋值成本低，那么A更好，否则B更好。</p><h3 id=r27-尽量少做转型动作>R27 尽量少做转型动作</h3><p>通常的转型是可能会这样写：函数风格的<code>int(expression)</code>或者C风格的(int)<code>expression</code>，这都被成为“旧式转型”。</p><ul><li><p>在C++中，有4种新式转型操作符：</p><ol><li><strong>const_cast (expression)</strong>
作用是移除变量的常量性(cast away the constness)，是唯一有此能力的操作符。</li><li><strong>dynamic_cast(expression)</strong>
作用是“安全向下转型”(safe downcasting)，决定某个对象是否属于某继承体系。耗费重大运行成本（原因：需要查询RTTI信息，而且不同编译器实现的方法和效率有所不同）。</li><li><strong>reinterpret_cast(expression)</strong>
执行低级转型，实际结果取决于编译器，移植性差。（比如int* 转为int）要清楚自己在做什么，慎用。</li><li><strong>static_cast(expression)</strong>
强迫隐式类型转换，代替C风格的"旧式转换"。也可以给变量加上const特性。</li></ol><p>新式转换的好处：很容易在代码找到“类型系统在何处转变或破坏”；对const特性的严控，让类型系统更健壮。</p></li><li><p>派生类里直接调用基类成员函数时，不要用转型</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpecialWindow</span><span class=o>:</span><span class=k>public</span> <span class=n>Window</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onResize</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Window</span><span class=o>::</span><span class=n>onResize</span><span class=p>();</span><span class=c1>//不要使用 static_cast&lt;Window&gt;(*this).onResize();
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li><li><p>关于dynamic_cast需要注意的</p><ol><li>如何替代和避免
一般是持有一个<code>Base *pBase</code>，但是指向的是DerivedObj，于是转型为pDerived</li></ol><ul><li>可以这样修改：
修改设计，窄化类型，持有一个pDerived即可；或者将想做的事放到虚函数中，利用多态去完成。</li></ul><ol start=2><li>避免串联
避免下方这样的代码，一连串的dynamic_cast：</li></ol><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Window</span><span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 定义子类 SpecialWindow1,SpecalWindow2,SpecialWindow3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Window</span><span class=o>*</span> <span class=n>winPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 省略winPtr的其他操作 ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=n>SpecialWindow1</span> <span class=o>*</span><span class=n>psw1</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWindow1</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>winPtr</span><span class=p>)){</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>  <span class=nf>if</span><span class=p>(</span><span class=n>SpecialWindow2</span> <span class=o>*</span><span class=n>psw2</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWindow2</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>winPtr</span><span class=p>)){</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>  <span class=nf>if</span><span class=p>(</span><span class=n>SpecialWindow3</span> <span class=o>*</span><span class=n>psw3</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWindow3</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>winPtr</span><span class=p>)){</span> <span class=p>...</span> <span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这样的代码又大又慢，每次继承体系有所改变，代码就需要重新检阅判断。这样的代码应该用“基于virtual函数调用”取代它。</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>自 <strong>C++11</strong> 起，针对智能指针 shared_ptr 的转型，推出了另外 4 个模版函数：</p><ul><li><code>std::static_pointer_cast</code>
函数的原型声明为：<div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=k>class</span> <span class=nc>U</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>static_pointer_cast</span><span class=p>(</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;</span> <span class=n>r</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div>含义以及应用场景与 <code>static_cast</code> 类似，比如子类型指针转为父类型：<div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>basePtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>derivedPtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>basePtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>static_pointer_cast</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span><span class=p>(</span><span class=n>derivedPtr</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div>或许我们会有疑问，是否有必要用这个函数进行转型呢，如下实现不是一样的吗?<div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>basePtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>derivedPtr</span><span class=p>.</span><span class=n>get</span><span class=p>()));</span></span></span></code></pre></td></tr></table></div></div>🤔 当然不一样，static_cast&lt;T*>((U*)nullptr)是未定义行为，而且就语法描述上来看，哪个更简洁不言自明。
另外，自 C++20 起支持右值引用，也就是如下形式：<div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=k>class</span> <span class=nc>U</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>static_pointer_cast</span><span class=p>(</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;&amp;</span> <span class=n>r</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></li><li><code>std::dynamic_pointer_cast</code>
含义以及应用场景与 dynamic_cast 类似，用法传参与 std::static_pointer_cast 类似，且自 C++20 起支持右值引用，不赘述。</li><li><code>std::const_pointer_cast：</code>与前 2 者类似，不赘述。</li><li><code>std::reinterpret_pointer_cast：</code>与前 3 者类似，不赘述。</li></ul></div></div></div><h3 id=r28-避免返回handles指向对象内部成分>R28 避免返回handles指向对象内部成分</h3><p>这里的<strong>handles（号码牌）包括</strong>指向对象内部的<strong>指针</strong>、<strong>迭代器</strong>、<strong>引用</strong>。</p><p>以下讲述当返回对象内部的handles时，存在的2个问题：</p><ul><li>可能会破坏封装性
考虑一个场景：public函数返回一个private成员的非const引用，就让外界有了修改private的机会，破坏了封装性。
此时，需要将非const引用改为const引用，只读属性。<div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Pixel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>float</span> <span class=n>r</span><span class=p>,</span><span class=n>g</span><span class=p>,</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Image</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>  <span class=c1>//注意：后面这const只保证成员变量vPixPtrs_不改
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Pixel</span><span class=o>&amp;</span> <span class=n>GetThePixel</span><span class=p>(</span><span class=kt>int</span> <span class=n>idx</span><span class=p>)</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>  <span class=n>vPixPtrs_</span><span class=p>[</span><span class=n>i</span><span class=p>];}</span><span class=c1>//隐患：其实外部调用者仍能直接修改Pixel的rgb值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 上一句的返回值应该改为 &#34;const Pixel&amp;&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Pixel</span><span class=o>&gt;&gt;</span> <span class=n>vPixPtrs_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li>可能会引起“空悬handles”
即使用const解决了封装性的问题，因为很容易出现**“handles比其所指对象更长寿”**，可能存在对象已析构，但handles还留存的问题。尤其是临时变量的析构，不太容易察觉。<div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SceneGraph</span><span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Image</span> <span class=nf>CaptureImage</span><span class=p>(</span><span class=k>const</span> <span class=n>SceneGraph</span><span class=o>&amp;</span> <span class=n>graph</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//那么调用方可能会这样使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SceneGraph</span> <span class=n>Grap</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//下面这句之后，Image临时对象被销毁，pPix指向一个不存在的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>Pixel</span> <span class=o>*</span><span class=n>pPix</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>CaptureImage</span><span class=p>(</span><span class=n>Grap</span><span class=p>).</span><span class=n>GetThePixel</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span></span></span></code></pre></td></tr></table></div></div>注意，CaptureImage的确能返回一个临时Image对象，能成功调用GetThePixel，但这句结束后，临时对象立马会被销毁，造成空悬现象，或叫虚吊(dangling) ！</li></ul><h3 id=r29-为异常安全而努力是值得的>R29 为“异常安全”而努力是值得的</h3><p>“<strong>异常安全</strong>”是指，当异常抛出时，代码依然能做到如下2点：</p><ol><li>不泄露任何资源
包括内存资源，锁资源。</li><li>不允许数据败坏
不会因为异常而导致空悬指针等未定义行为。</li></ol><p>考虑下方的示例代码，（如果<code>new Image</code>抛<code>std::bad_alloc</code>异常）则会同时违背了上述2条：</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mutex</span> <span class=n>mutex_</span><span class=p>;</span> <span class=c1>//互斥器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Image</span><span class=o>*</span> <span class=n>bgImage_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imageChangeCnt_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span><span class=c1>// 这个可以改为RAII的锁，来保证异常安全
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>bgImage_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>imageChangeCnt_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//这里new Image抛异常，导致无法解锁；且bgImage_指向资源已经释放，空悬指针
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bgImage_</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageSrc_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h4 id=异常安全的3个等级>异常安全的3个等级</h4><p>异常安全的函数，有<strong>3个等级</strong>的异常安全保证，会满足<strong>三者之一</strong>：</p><ul><li><p><strong>基本承诺</strong>
如果异常被抛出，程序内的任何事务仍然保持在有效状态下，也没有任何数据败坏。比如上例中如果抛异常，会另外添加实现，使bgImage_持有某个默认图像，或保持原值，让程序继续有效运行。</p></li><li><p><strong>强烈保证</strong>
如果异常被抛出，程序状态不改变。这样的函数要么成功，要么退回到执行前的状态。</p><p>上述案例则应该会被修改成如下形式：</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Image</span><span class=o>&gt;</span> <span class=n>bgImage_</span><span class=p>;</span> <span class=c1>//RAII避免了异常发生时的资源泄漏和数据败坏
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//... 省略其他成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>CLock</span> <span class=nf>ml</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span><span class=c1>//RAII封装的Lock类，详细可参考 阅读总结(二)-Rule14
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bgImage_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imgSrc</span><span class=p>));</span><span class=c1>//若new失败，则不会reset
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>imageChangeCnt_</span><span class=p>;</span><span class=c1>//把事情做完再++count
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>不抛异常</strong>
在原书中，这个“No Throw”不是绝对不抛异常，而是一旦意外抛异常，就会调用unexpected函数进而abort（例如<code>int doSomething() throw();//空白的异常明细</code>）。</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>原书中例子的 <strong>throw()</strong> 在不同编译器表现不一致，现在已经 <strong>不推荐使用</strong>。</p><p>更详细资料可参考<a href=http://gotw.ca/publications/mill22.htm target=_blank rel="external nofollow noopener noreferrer">A Pragmatic Look at Exception Specifications<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>和<a href=https://stackoverflow.com/questions/88573/should-i-use-an-exception-specifier-in-c target=_blank rel="external nofollow noopener noreferrer">Should I use an exception specifier in C++<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><p>在C++11中，有了更可靠有效的关键字noexcept，使用也很简单，有操作符和异常提示符两种作用，下方展示简单用法：</p><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span> <span class=c1>// 函数 f() 不会抛出
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span> <span class=c1>// fp 指向可能会抛出的函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>g</span><span class=p>(</span><span class=kt>void</span> <span class=n>pfa</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>);</span>  <span class=c1>// g 接收指向不会抛出的函数的指针
</span></span></span><span class=line><span class=cl><span class=c1>// typedef int (*pf)() noexcept; // 错误
</span></span></span></code></pre></td></tr></table></div></div><p>更详细的<code>noexcept</code>介绍可以访问<a href=https://zh.cppreference.com/w/cpp/language/noexcept target=_blank rel="external nofollow noopener noreferrer">cppreference：noexcept操作符<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>和<a href=https://zh.cppreference.com/w/cpp/language/noexcept_spec target=_blank rel="external nofollow noopener noreferrer">cppreference：noexcept异常说明符<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p></div></div></div><h4 id=使用copy-and-swap保障异常安全>使用copy-and-swap保障异常安全</h4><p><code>copy-and-swap</code>技术：先拷贝一份想修改的对象，等修改彻底完成后（过程中不抛异常），再与原对象交换。</p><p>为了更形象展示这一过程，使用pIml手法对bgImage_封装一下：</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ImgPimpl</span><span class=p>{</span> <span class=c1>//选用struct而非Class：方便；最后被private成员形式使用，封装性不用担心
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Image</span><span class=o>&gt;</span> <span class=n>bgImage_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>imageChangeCnt_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么PrettyMenu类可以改为如下：</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mutex</span> <span class=n>mutex_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>ImgPimpl</span><span class=o>&gt;</span> <span class=n>pImpl_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>  <span class=c1>//构造略
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>;</span>   <span class=c1>//参考 阅读总结(二)-Rule25
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CLock</span> <span class=nf>ml</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span><span class=c1>//RAII封装的Lock类，详细可参考总结(二)-Rule14
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>ImgPimpl</span><span class=o>&gt;</span> <span class=n>pNewCopy</span><span class=p>(</span><span class=k>new</span> <span class=n>ImgPimpl</span><span class=p>(</span><span class=o>*</span><span class=n>pImpl_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>pNewCopy</span><span class=o>-&gt;</span><span class=n>bgImage_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imgSrc</span><span class=p>));</span> <span class=c1>//修改副本
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>pNewCopy</span><span class=o>-&gt;</span><span class=n>imageChangeCnt_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>pImpl_</span><span class=p>,</span><span class=n>pNewCopy</span><span class=p>);</span><span class=c1>//改完之后swap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h4 id=异常安全的连带影响side-effects>异常安全的连带影响(side effects)</h4><p>函数提供的“异常安全保证等级”只<strong>取决于</strong>其调用的<strong>各个子函数的“最不安全者”</strong>。</p><p>考虑以下函数SomeFunc代码：</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>SomeFunc</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=c1>// 对local状态做一份副本
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>f2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>  <span class=c1>//将修改后的状态置换过来
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><strong><code>分析</code></strong>：显然copy-and-swap在尽力强烈保证异常安全，但是，f1或者f2的异常安全如果比较低，那么可能需要单独对f1，f2进行copy-and-swap，来尝试保证“强烈异常安全”；即使如此，如果f1能成功做了修改，但是f2修改失败了并回退，那么<strong>f1、f2整体</strong>看起来还是“<strong>改了一部分</strong>”。</p><p><strong><code>这也告诫我们</code></strong>，如果引入了异常不安全的旧代码，那么这种特性会波及其他代码。</p><p>就设计者而言，只能根据实际情况，尽可能保证“异常安全”，选择3个异常安全等级之一实施。</p><h3 id=r30-透彻了解inline的里里外外>R30 透彻了解inline的里里外外</h3><p><code>inline</code>是C++的关键字，表示内联函数。<code>直接在对应位置展开代码</code>，免去函数调用的开销，难以避免 “<strong>代码膨胀</strong>”问题。</p><p>使用inline时应该注意以下问题：</p><ul><li><p><strong>inline只是对编译器的申请</strong>
inline只是对编译器的申请/建议，不是强制命令，<strong>编译器有权利</strong> 对其认为不适合inline的函数<strong>拒绝</strong>inline。 （原书说：如果编译器拒绝，通常它会给出warning信息。实际本人实测VS2017没看到）
inline有2种申请方式 ：</p><ol><li>在函数定义 时使用关键字inline<strong>显式强调</strong></li><li>实现在Class内的成员函数或friend函数，属于<strong>隐式inline</strong></li></ol></li><li><p><strong>inline和Template没有任何必然联系</strong>
虽然有不少简短的Template函数是带有inline（例如下方的std::max），但不是必然为之，<strong>两者没有因果关系</strong>。</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>){</span> <span class=c1>//可以申请inline，但不是必须申请
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>b</span> <span class=p>:</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>编译器拒绝复杂函数进行inline</strong>
复杂函数的inline会带来较严重的“代码膨胀”问题，并且可能会更慢，因为增加了运行时的“额外换页”行为，降低了指令cache命中率。</p><ol><li>inline函数内不要出现循环或递归</li><li>虚函数也不适合做inline
因为inline是编译期间决定的事，而虚函数是运行时决定的事，两者就不是同一个场景的。</li><li>构造/析构函数也不适合做inline
编译器可能会在构造/析构函数内部做精妙复杂的异常处理；以及在继承体系下，Base类函数体到处inline膨胀。</li></ol></li><li><p><strong>以函数指针形式的调用通常不能inline</strong>
对绝大多数编译器而言，是否inline是compile阶段决定的事情，少数编译器放到了link阶段。</p><p>讨论大多数情况：需要在编译时得知inline的本体，而函数指针办不到，示例代码如下：</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{...}</span> <span class=c1>//假设编译器有意愿inline “对f的调用”
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span> <span class=n>pf</span><span class=p>)()</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span><span class=c1>//pf 执行f
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>();</span>     <span class=c1>//这个调用将被inlined，因为是个正常调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pf</span><span class=p>();</span>     <span class=c1>//这个很可能不被inlined
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>过度inline对调试和发布带来困难</strong>
inline是代码嵌入与展开，而非函数调用，所以某些编译器不支持inline的单步Debug（就像宏展开一样不支持调试）；另外，inline只要已修改，涉及调用它的代码全都要编译，如果是non-inline则可能只需要重新link即可。</p></li></ul><h3 id=r31-将文件间的编译依赖关系降至最低>R31 将文件间的编译依赖关系降至最低</h3><p>C++的Class定义式包括了成员变量，假设某成员变量是类对象<code>ClassObjA a</code>，如果<code>ClassObjA</code>类的内部实现发生了改变（哪怕这个<code>ClassObjA.h</code>内只在某处加了一个空格 ），那么include了<code>ClassObjA.h</code>的所有<code>.h</code>文件<code>.cpp</code>文件都会<strong>重新编译</strong>。</p><p>👆这就是由“<strong>编译依赖</strong>”关系带来的问题。</p><p>使用 <code>PIMPL</code> 手法(pointer to implementation)可以很好地分离声明和定义：</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//Person.h文件  不需要include &#34;PersonImpl.h&#34;和&#34;BirthDay.h&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>PersonImpl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BirthDay</span><span class=p>;</span><span class=c1>// 前置声明代替include
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span><span class=c1>// 构造函数这里放实现无所谓，因为是函数指针，不需知道PersonImpl本体实现
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Person</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>PersonImpl</span><span class=o>&gt;&amp;</span> <span class=n>pImpl</span><span class=p>);</span><span class=c1>//构造函数的实现也放到cpp里去
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=n>BirthDay</span><span class=o>&amp;</span> <span class=n>GetBirthDay</span><span class=p>();</span><span class=c1>// 注意：这里只声明，把实现部分放到cpp里
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>GetName</span><span class=p>();</span><span class=c1>//实现细节由pImpl_转发实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>PersonImpl</span><span class=o>&gt;</span> <span class=n>pImpl_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//Person.cpp文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;PersonImpl.h&#34; //在&#34;PersonImpl.h&#34;文件内include那个&#34;BirthDay.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Person.h&#34;</span></span></span></code></pre></td></tr></table></div></div><p>注意：Impl用法，相关的头文件里不要放置任何函数实现代码 。
上述做法可以让使用Person类的客户不需要再关心PersonImpl以及BirthDay的实现细节了，做到了“接口与实现分离”，关键点在于把“定义的依赖性” 换成 $\Rightarrow$ “<strong>声明的依赖性</strong>”。
这里突出了如何<strong>最小化编译依赖性</strong>的本质：<code>让头文件尽可能自我满足</code>，如果不行，也要依赖于其他文件的声明式而非定义式。</p><p>具体到设计策略上，有以下几种做法：</p><ul><li><p>如果能用object references 或 object pointers完成任务，就别用objects
如果要定义某类型的objects，就要使用定义式，指针和应用则可以只用声明式。</p></li><li><p>尽量以class声明式替换class定义式
函数声明种的Class类型可以只用声明式，即使以by-object-value形式传值也是如此。</p></li><li><p>为声明式和定义式提供不同的文件
比如Date类，分为只包含声明式的"Datefwd.h"和包含定义式的"Date.h"，那么使用时用声明式头文件代替前置声明，在需要应用代码client.cpp里include定义式头文件。这种方式在标准库里采用较多，参考<iosfwd>和<sstream>,<fstream>,<streambuf>等。</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><ul><li>C/C++可以使用编译器预处理指令<font color=red><code>#pragma message</code></font>，打印出该文件是否参与此次编译，以及参与编译时被哪个文件所依赖。<div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//比如可以在 testEffective.h 文件内加上这句，就能在编译输出信息里看到打印信息，观察到依赖关系
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#pragma message(&#34;testEffective.h 参与重新编译&#34;)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//还可以用于测试某些宏是否真的生效，有时IDE的高亮显示不准确而令人生疑。
</span></span></span></code></pre></td></tr></table></div></div></li><li>关于头文件include的其他编写规范，可以参考：<a href=https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/# target=_blank rel="external nofollow noopener noreferrer">Google-C++风格指南：1.头文件<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul></div></div></div><p>使用 <font color><strong><code>Interface Class</code></strong></font> 也能做到接口和实现的真正分离：</p><p>这种方式常见于输出动态库给到客户使用，客户能见到接口定义和使用，但无法看到内部实现。</p><p>用法较为常见，不赘述，直接<strong>show-code</strong>：</p><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//VirtualPerson.h   //和 lib文件一起提供给到客户
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>VirtualPerson</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span> <span class=c1>//create的返回值还可以根据需求，换成RAII的智能指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=n>VirtualPerson</span> <span class=o>*</span> <span class=n>create</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>int</span> <span class=n>salary</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Level</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Salary</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>VirtualPerson</span><span class=p>();</span><span class=c1>// avoid memory leak
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//VirtualPerson.cpp  //源码不提供给客户，而是编译好的二进制 lib文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VirtualPerson</span><span class=o>*</span> <span class=n>VirtualPerson</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>int</span> <span class=n>salary</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>level</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//工厂方法，还可以生成其他子类
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=k>new</span> <span class=nf>Engineer</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>salary</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>VirtualPerson</span><span class=o>::~</span><span class=n>VirtualPerson</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Engineer.h  //Engineer也是参与编译到 lib文件中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Engineer</span><span class=o>:</span> <span class=k>public</span> <span class=n>VirtualPerson</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Engineer</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span><span class=kt>int</span> <span class=n>salary</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Level</span><span class=p>()</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Salary</span><span class=p>()</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>level_</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>salary_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h2 id=ch6-继承与面向对象设计>CH6. 继承与面向对象设计</h2><h3 id=r32-确定你的public继承塑造出is-a关系>R32 确定你的public继承塑造出is-a关系</h3><p>ref:</br>[1]. <a href=https://blog.csdn.net/cltcj/category_12098441.html target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>[2]. <a href=https://kissingfire123.github.io/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/ target=_blank rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br></p></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-07-31 15:56:02">更新于 2023-07-31&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/6233eda9aabfee5e9f2805f360dbb1cce386bb8a rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) 6233eda9aabfee5e9f2805f360dbb1cce386bb8a: feat: add c++ effective part three"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>6233eda</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/partthree/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/Effective_C++/PartThree/index.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/partthree/ data-title="Effective C++ (第3版) 精读总结 [3]" data-hashtags=Effective><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/partthree/ data-hashtag=Effective><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/partthree/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/partthree/ data-title="Effective C++ (第3版) 精读总结 [3]"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/partthree/ data-title="Effective C++ (第3版) 精读总结 [3]"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/effective/ class=post-tag>Effective</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/parttwo/ class=post-nav-item rel=prev title="Effective C++ (第3版) 精读总结 [2]"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Effective C++ (第3版) 精读总结 [2]</a>
<a href=/posts/partfour/ class=post-nav-item rel=next title="Effective C++ (第3版) 精读总结 [4]">Effective C++ (第3版) 精读总结 [4]<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.115.4">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> 李瑞豪',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>