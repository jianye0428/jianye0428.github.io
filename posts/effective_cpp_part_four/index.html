<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Effective C++ (第3版) 精读总结 [4] - yejian's blog</title><meta name=author content="Jian YE">
<meta name=author-link content="https://github.com/jianye0428"><meta name=description content><meta name=keywords content='Effective'><meta itemprop=name content="Effective C++ (第3版) 精读总结 [4]"><meta itemprop=datePublished content="2023-07-31T07:26:06+08:00"><meta itemprop=dateModified content="2023-10-07T09:25:23+08:00"><meta itemprop=wordCount content="10032"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="Effective"><meta property="og:url" content="https://jianye0428.github.io/posts/effective_cpp_part_four/"><meta property="og:site_name" content="yejian's blog"><meta property="og:title" content="Effective C++ (第3版) 精读总结 [4]"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-31T07:26:06+08:00"><meta property="article:modified_time" content="2023-10-07T09:25:23+08:00"><meta property="article:tag" content="Effective"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="Effective C++ (第3版) 精读总结 [4]"><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/effective_cpp_part_four/><link rel=prev href=https://jianye0428.github.io/posts/effective_cpp_part_three/><link rel=next href=https://jianye0428.github.io/posts/ddpm/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Effective C++ (第3版) 精读总结 [4]","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/effective_cpp_part_four\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"Effective","wordcount":10032,"url":"https:\/\/jianye0428.github.io\/posts\/effective_cpp_part_four\/","datePublished":"2023-07-31T07:26:06+08:00","dateModified":"2023-10-07T09:25:23+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Effective C++ (第3版) 精读总结 [4]</span></h1><p class="single-subtitle animate__animated animate__fadeIn">改善程序与设计的55个具体做法(Rule41-55)</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-07-31 07:26:06"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-07-31>2023-07-31</time></span>&nbsp;<span title="更新于 2023-10-07 09:25:23"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-10-07>2023-10-07</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 10032 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 21 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="Effective C++ (第3版) 精读总结 [4]">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#ch7-模板与泛型编程>CH7 模板与泛型编程</a><ul><li><a href=#r41-了解隐式接口和编译期多态>R41 了解隐式接口和编译期多态</a></li><li><a href=#r42-了解typename的双重意义>R42 了解typename的双重意义</a></li><li><a href=#r43-学习处理模板化基类内的名称>R43 学习处理模板化基类内的名称</a></li><li><a href=#r44-将与参数无关的代码抽离templates>R44 将与参数无关的代码抽离templates</a></li><li><a href=#r45-运用模板成员函数接受所有兼容类型>R45 运用模板成员函数接受所有兼容类型</a></li><li><a href=#r46-需要类型转换时请为模板定义非成员函数>R46 需要类型转换时请为模板定义非成员函数</a></li><li><a href=#r47-请使用traits-classes表现类型信息>R47 请使用traits classes表现类型信息</a></li><li><a href=#r48-认识template模板元编程>R48 认识Template模板元编程</a></li></ul></li><li><a href=#ch8-定制new和delete>CH8 定制new和delete</a><ul><li><a href=#r49-了解new-handler的行为>R49 了解new-handler的行为</a></li><li><a href=#r50-了解new和delete的合理替换时机>R50 了解new和delete的合理替换时机</a></li><li><a href=#r51-编写new和delete时需固守常规>R51 编写new和delete时需固守常规</a></li><li><a href=#r52-写了placement-new-也要写placement-delete>R52 写了placement-new 也要写placement-delete</a></li></ul></li><li><a href=#ch9-杂项讨论>CH9 杂项讨论</a><ul><li><a href=#r53-不要轻易忽略编译器的警告>R53 不要轻易忽略编译器的警告</a></li><li><a href=#r54-熟悉包括tr1在内的标准程序库>R54 熟悉包括TR1在内的标准程序库</a></li><li><a href=#r55-让自己熟悉boost>R55 让自己熟悉Boost</a></li></ul></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2023-10-07，文中内容可能已过时。</div></div></div><h1 id=前言>前言</h1><blockquote><p>Effective-C++总结系列分为四部分，本文为第二部分，涉及原书第3~4章，内容范围Rule13~25。为方便书写，Rule13简写为R13。</p></blockquote><div class="details admonition Note"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本博客站点系列内容如下：</br>💡 <a href=https://jianye0428.github.io/posts/partone/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/parttwo/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/partthree/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/partfour/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br></div></div></div><p>由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人<code>开发经验</code>新增一些个人感悟👉<code>By the way</code>环节。</p><h2 id=ch7-模板与泛型编程>CH7 模板与泛型编程</h2><h3 id=r41-了解隐式接口和编译期多态>R41 了解隐式接口和编译期多态</h3><p>面向对象编程的通常做法：</p><ul><li><strong>显式</strong>定义接口（参数和返回值类型都是确定的，函数签名 就是确定的）</li><li>虚函数实现<strong>运行时多态</strong></li></ul><p>那么编译期多态呢？在面向对象编程中，我们的答案通常是函数重载。</p><p>在Templates 及泛型编程中，更为注重的是<strong>隐式接口</strong>和<strong>编译期多态</strong>：</p><ul><li><code>隐式接口</code>:
Template的接口属于隐式接口，因为它类型不确定，所以是基于有效表达式来区分。再加上运算符重载等特性，隐式接口的自由度非常大。</li><li><code>编译期多态</code>:
Template的多态是通过Template具现化和函数重载决议发生于编译期。</li></ul><p>上述描述看起来有点抽象，分析下方Template函数代码：</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doProcessing</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>w</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>w</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>10</span> <span class=o>&amp;&amp;</span> <span class=n>w</span> <span class=o>!=</span> <span class=n>someNastyWidget</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>doProcessing属于隐式接口，类型不定，传入不同类型T，就得到不同的函数。</p><p>由于 <code>操作符重载(operator overloading)</code> 的存在，隐式接口对传入的 T 类型的要求比较宽松，列举如下：</p><ol><li>T类型或其父类型具有 size() 接口，size() 接口返回类型S为整型或者S类型有 <code>bool operator>(int)</code> 接口；</li><li>T类型有 <code>bool operator != (const T&)</code>接口；或T类型可以隐式转换为某S类型，S可以与someNastyWidget进行 != 比较，或者干脆someNastyWidget就是T类型；</li><li>上述1 、 2 点的描述没有将 <code>operator &&</code> 考虑进来，否则情况会更为复杂，这里不赘述了。</li></ol><h3 id=r42-了解typename的双重意义>R42 了解typename的双重意义</h3><ul><li><code>typename</code> 和 <code>class</code> 关键字在声明 Template 参数的时候，没有任何区别
如下示例，效果是一致的：</li></ul><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Widget</span> <span class=p>;</span> <span class=c1>//早期C++使用这个声明Template参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Widget</span><span class=p>;</span> <span class=c1>//现在更推荐用这个，暗示参数不一定是个class类型
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>使用关键字 <code>typename</code> 标识 <strong>嵌套从属类型名称</strong>
模板内的从属类型，是指在模板函数/模板类中，需要<strong>依赖传入的 template 参数间接表示</strong>的类型，如果呈嵌套状，就叫嵌套从属名称/类型。 如下示例的 <code>C::const_iterator</code> 就是嵌套从属类型。</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>printContainer2ndVal</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span><span class=o>&amp;</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>container</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>C</span><span class=o>::</span><span class=n>const_iterator</span> <span class=n>iter</span><span class=p>(</span><span class=n>container</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;this container&#39;s second value is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*++</span><span class=n>iter</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>此时，typename 的作用就是告诉编译器 C::const_iterator 是个类型，否则会编译报错。此时可以用 class 关键字替代，但是不建议。</p><p>typename 使用范围不只是 template 函数内部，也包括了函数入参 ：</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>foo</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span><span class=o>&amp;</span> <span class=n>container</span><span class=p>,</span>    <span class=c1>// 不允许使用 &#34;typename&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>typename</span> <span class=n>C</span><span class=o>::</span><span class=n>iterator</span> <span class=n>iter</span><span class=p>);</span> <span class=c1>// 必须使用 &#34;typename&#34;
</span></span></span></code></pre></td></tr></table></div></div><p>⚠️ 其他特殊情况：不要在 基类列表base class list 或 成员初始化列member initialization list 使用 typename</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Nested</span><span class=p>{</span> <span class=c1>//基类列表不允许使用typename
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>Derived</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span><span class=o>:</span><span class=n>Base</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Nested</span><span class=p>(</span><span class=n>x</span><span class=p>){</span><span class=c1>// 成员初值列也不允许typename
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>Base</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Nested</span> <span class=n>NestedType</span><span class=p>;</span><span class=c1>//结合typedef定义，常规用法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NestedType</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span><span class=c1>// 其他操作
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=r43-学习处理模板化基类内的名称>R43 学习处理模板化基类内的名称</h3><p><strong>模板化基类</strong>：指定义 template 模板类时，继承于某基类 Base<t>，这个 Base<t> 类就是模板化基类。</p><p>🤔 那么 Base<t> 类有关的函数等名称该如何处理，在子类中直接使用吗？还是有注意事项？这，就是本节要讨论的问题。示例如下：</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Company</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MsgSender</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>SendPlain</span><span class=p>(){</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;send plain</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SendEncrypted</span><span class=p>(){</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;send encrypted</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>  <span class=c1>// 基类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Company</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoggingMsgSender</span><span class=o>:</span> <span class=k>public</span> <span class=n>MsgSender</span><span class=o>&lt;</span><span class=n>Company</span><span class=o>&gt;</span><span class=p>{</span><span class=c1>//子类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>SendPlainMsg</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=n>SendPlain</span><span class=p>();</span><span class=c1>//  ==&gt; 这样直接调用是不行的，想想为什么？
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>上述注释中问题的原因：因为当全特化时可随意去除 MsgSender 内的函数，那么编译器无法确定基类是否仍有 SendPlain 这个方法。所以，编译器干脆<strong>拒绝在编译时</strong>去模板化基类中<strong>主动寻找</strong>继承而来的名称。</p><p>解决方法有三个：</p><ol><li>使用 <code>this-></code> 调用SendPlain()，即可转化为运行时的问题，推荐这个方法；</li><li>使用 <code>using MsgSender::SendPlain;</code> 这样的 using 声明式，我们在 Rule 33: 避免遮掩由继承得来的名称 中用过这种方法，显式地告诉编译器扩大名称搜索范围，尝试去基类找找；</li><li>使用显式调用，即 <code>MsgSender::SendPlain();</code> ，但这样做的坏处是直接断绝了 virtual 函数的灵活性和可能，不太推荐</li></ol><h3 id=r44-将与参数无关的代码抽离templates>R44 将与参数无关的代码抽离templates</h3><p>通常，在非模板代码中，我们很容易看出重复的代码或者类，一般采用抽取公共部分为单独函数，或者采用类的继承/聚合等面向对象设计方式。</p><p>但是， template 有关的代码，有时代码重复是隐晦的。 这一节是为了解决 template 的 <code>代码膨胀(code bloat)</code> 问题，主要原则为 <code>共性与差异性分析(commonality and variability analysis)</code> 。</p><p>**某些不恰当的设计，会导致无畏的代码膨胀。**先看下方这个反面教材：</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrix</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>invert</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;size is &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>应用代码如下：</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//下面这2句，模板类实例化 1 次。 invert函数有 1 份实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SquareMatrix</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>mat5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>SquareMatrix</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>mat5New</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//换成下面这2句，模板类实例化 2 次。invert函数有 2 份实现(问题暴露)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SquareMatrix</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>mat5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>SquareMatrix</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=o>&gt;</span> <span class=n>mat10</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p><strong>膨胀原因</strong>：在编译器看来，SquareMatrix&lt;int, 5> 和 SquareMatrix&lt;int, 10> 是2个<strong>完全不同的 C++ 类</strong>，实例化了2次，生成了这2个类。试想，如果代码中还需要其他 size 的SquareMatrix ，都会再生成一个新类，那么最后二进制文件就多了许多重复的目标代码，也就是膨胀。</p><p>如果能<strong>抽离参数相关代码</strong>，做到尺寸无关，便可解决这个问题。</p><p><strong>解决思路</strong>：新建一个基类 BaseMatrix ，将尺寸参数传入给到基类作为成员变量保管，具体的数据可以用数组指针形式托管。不论有多少个与尺寸有关的派生类，一个 T 类型就<strong>只有一个基类</strong>，所以基类 <code>baseInvert</code> <strong>函数实现只有一份</strong>。</p><p><mark>基类实现</mark>代码如下：</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BaseSqaureMatrix</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>BaseSqaureMatrix</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=p>,</span><span class=n>T</span><span class=o>*</span> <span class=n>dataPtr</span><span class=p>)</span> <span class=o>:</span><span class=n>n_</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>dataPtr_</span><span class=p>(</span><span class=n>dataPtr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>baseInvert</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;invert: pData = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>dataPtr_</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; , size = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n_</span>  <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetDataPtr</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>dataPtr</span><span class=p>)</span> <span class=p>{</span> <span class=n>dataPtr_</span> <span class=o>=</span> <span class=n>dataPtr</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=n>dataPtr_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p><mark>目标派生类</mark>实现如下：</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SquareMatrix</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BaseSqaureMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SquareMatrix</span><span class=p>()</span> <span class=o>:</span><span class=n>BaseSqaureMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>data_</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>n</span><span class=o>*</span><span class=n>n</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>SetDataPtr</span><span class=p>(</span><span class=n>data_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>invert</span><span class=p>()</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>baseInvert</span><span class=p>();</span> <span class=p>}</span><span class=c1>// 参考Rule43
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data_</span> <span class=p>;</span><span class=c1>// RAII管理资源
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>最终效果：相同 T 类型的template实例类(比如SquareMatrix&lt;float,5>和SquareMatrix&lt;float,6>)，<mark>共享实现码</mark>，祛除代码膨胀。</p><h3 id=r45-运用模板成员函数接受所有兼容类型>R45 运用模板成员函数接受所有兼容类型</h3><p>众所周知，<code>Base *pBase = pDerived</code>; 这样普通类型裸指针的隐式转换是被 C++ 所认可的。</p><p>那么如果换成智能指针模板类 SmartPtr<base> 和 SmartPtr <derived>呢，还能这样<strong>不需额外配置</strong>就随意转换吗，答案显然<strong>是不行</strong>的（纵然 Base 和 Derived 是兼容类型也不行）。</p><p>本节，就采用<mark>模板成员函数</mark>来解决这一问题。</p><ul><li><strong>使用模板成员函数，接受所有兼容类型的“泛化构造”/“泛化赋值”</strong>
<code>泛化(generalized)Copy构造</code>，是指接受其他兼容类型进行模板函数的Copy构造。举例一个粗糙的 RAII 智能指针实现，代码如下👇:<div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SmartPtr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>SmartPtr</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>origPtr</span><span class=p>)</span> <span class=o>:</span><span class=n>originPtr_</span><span class=p>(</span><span class=n>origPtr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=n>SmartPtr</span><span class=p>(</span><span class=k>const</span> <span class=n>SmartPtr</span><span class=o>&amp;</span> <span class=n>smt</span><span class=p>)</span> <span class=o>:</span><span class=n>originPtr_</span><span class=p>(</span><span class=n>smt</span><span class=p>.</span><span class=n>get</span><span class=p>())</span> <span class=p>{}</span><span class=c1>// 正常Copy构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//正常copy操作符函数: 简单演示，就浅复制吧
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SmartPtr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SmartPtr</span><span class=o>&amp;</span> <span class=n>smt</span><span class=p>)</span> <span class=p>{</span> <span class=n>originPtr_</span> <span class=o>=</span> <span class=n>smt</span><span class=p>.</span><span class=n>get</span><span class=p>();</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>U</span><span class=o>&gt;</span> <span class=c1>//泛化构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SmartPtr</span><span class=p>(</span><span class=k>const</span> <span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;</span> <span class=n>other</span><span class=p>)</span><span class=o>:</span><span class=n>originPtr_</span><span class=p>(</span><span class=n>other</span><span class=p>.</span><span class=n>get</span><span class=p>())</span> <span class=p>{</span> <span class=p>}</span> <span class=c1>//为了隐式转换不加 explict
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>U</span><span class=o>&gt;</span> <span class=c1>//泛化赋值操作符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SmartPtr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>originPtr_</span> <span class=o>=</span> <span class=n>other</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span><span class=c1>//简单演示，浅复制
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>*</span> <span class=nf>get</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>originPtr_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>SmartPtr</span><span class=p>()</span> <span class=p>{</span> <span class=k>delete</span> <span class=n>originPtr_</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>*</span> <span class=n>originPtr_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div>有上述的代码支持，我们就能写出如下的应用代码：<div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BaseObj</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DerivedObj</span><span class=o>:</span><span class=k>public</span> <span class=n>BaseObj</span> <span class=p>{};</span><span class=c1>//DerivedObj是BaseObj兼容类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>DerivedObj</span><span class=o>&gt;</span> <span class=n>smDerived</span><span class=p>(</span><span class=k>new</span> <span class=n>DerivedObj</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>BaseObj</span><span class=o>&gt;</span> <span class=n>smBase</span><span class=p>(</span><span class=n>smDerived</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>SmartPtr</span><span class=o>&lt;</span><span class=n>BaseObj</span><span class=o>&gt;</span> <span class=n>smBase2</span> <span class=o>=</span> <span class=n>smDerived</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></li><li><strong>即使有 “泛化构造/ 赋值”，也需要正常的 Copy构造/赋值</strong>
注意，模板成员函数不会改变语言规则，也就是说“泛化构造”不能代替正常的 copy 构造函数。所以，需要同时声明正常的 Copy 构造函数和 Copy 赋值操作符函数。</li></ul><h3 id=r46-需要类型转换时请为模板定义非成员函数>R46 需要类型转换时请为模板定义非成员函数</h3><p>有时我们希望 class 支持类型转换，类似本书的另外一节👉 <a href=https://jianye0428.github.io/posts/parttwo/#r24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%B7%E9%87%87%E7%94%A8non-member target=_blank rel="external nofollow noopener noreferrer">Rule24:若所有参数皆需类型转换，请采用non-member<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 。</p><p>如果 Rule24 中的 Rational 类是 template 模板类，直接仿照 Rule24 利用 non-member 函数做混合运算是行不通的，原因是 <strong>template 实参推导</strong>是不采纳 “通过构造函数而发生的”隐式类型转换。</p><p>解决办法如下:</p><ul><li><p><strong>使用 “template class 内部的friend函数” 完成参数隐式转换</strong>
将 Rule24 的 non-member 的 <strong>operator *函数</strong>改为 <code>inline-friend</code> 函数，因为 template 实例化的时候需要找到该 friend 函数的定义实现，类外定义实现是会链接错误的，所以需要 inline 。
参考代码实现如下：</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>RationalNew</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>RationalNew</span><span class=p>(</span><span class=n>T</span> <span class=n>numerator</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>T</span> <span class=n>denominator</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=o>:</span><span class=n>numerator_</span><span class=p>(</span><span class=n>numerator</span><span class=p>),</span> <span class=n>denominator_</span><span class=p>(</span><span class=n>denominator</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=nf>numerator</span><span class=p>()</span><span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>numerator_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=nf>denominator</span><span class=p>()</span><span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>denominator_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>numerator</span><span class=p>()</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>numerator</span><span class=p>(),</span><span class=n>lhs</span><span class=p>.</span><span class=n>denominator</span><span class=p>()</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>denominator</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=n>numerator_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=n>denominator_</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么，对如下的应用代码，就使用自如了：</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>RationalNew</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>oneHalf</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span><span class=mf>2.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>RationalNew</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=n>oneHalf</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>RationalNew</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>res2</span> <span class=o>=</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>oneHalf</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>若inline-friend函数体太大，可以抽离出类外辅助函数供inline调用</strong>
上述的 operator* 函数体只有一行，实现简单，但如果实现过程复杂代码量大，考虑 inline 带来的冲击以及代码可读性，可以抽取个函数出来供 inline-friend 调用。</p><p>修改方式如下：</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>RationalNew</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=c1>//  其他部分略。注意 operator* 函数体实现，改为调用doMultiply
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>friend</span> <span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>doMultiply</span><span class=p>(</span><span class=n>lhs</span><span class=p>,</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 类外函数  doMultiply
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>doMultiply</span><span class=p>(</span><span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>RationalNew</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>numerator</span><span class=p>()</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>numerator</span><span class=p>(),</span> <span class=n>lhs</span><span class=p>.</span><span class=n>denominator</span><span class=p>()</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>denominator</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=r47-请使用traits-classes表现类型信息>R47 请使用traits classes表现类型信息</h3><p>C++ 中通常把 Traits 称为<strong>类型萃取</strong>技术，即：在 template 编程中，获取模板参数的类型信息，并在编译阶段针对不同的类型响应不同的处理。同时，这个技术要求对C++<strong>内置类型built-in</strong> 和 <strong>用户自定义user-defined</strong> 类型的表现必须一样好。</p><p>本节讨论此议题，并且以一个 C++ 标准的模板函数作为切入口进行讨论(std::advance，作用是兼容不同类型迭代器，用于后续取用指定偏移量的元素 )。</p><p>下方 “By the way” 环节简单展示了 std::advance 标准C++的声明式和基本用法： 👇（单击展开）</p><p><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>std::advance 需要的头文件包含为 <code>#include&lt;iterator></code> ，再看下它的函数原型声明：</p><div class=highlight id=id-35><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>InputIt</span><span class=p>,</span> <span class=k>class</span> <span class=nc>Distance</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>advance</span><span class=p>(</span> <span class=n>InputIt</span><span class=o>&amp;</span> <span class=n>it</span><span class=p>,</span> <span class=n>Distance</span> <span class=n>n</span> <span class=p>);</span>       <span class=c1>// C++17 之前
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>InputIt</span><span class=p>,</span> <span class=k>class</span> <span class=nc>Distance</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>void</span> <span class=n>advance</span><span class=p>(</span> <span class=n>InputIt</span><span class=o>&amp;</span> <span class=n>it</span><span class=p>,</span> <span class=n>Distance</span> <span class=n>n</span> <span class=p>);</span> <span class=c1>// 自C++17 开始
</span></span></span></code></pre></td></tr></table></div></div><p>再看下示例应用代码：</p><div class=highlight id=id-36><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>nums</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>vIter</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>advance</span><span class=p>(</span><span class=n>vIter</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after advance  3 offset: *vIter = &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>vIter</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>deque</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>fNums</span><span class=p>{</span><span class=mf>0.1</span><span class=p>,</span><span class=mf>0.2</span><span class=p>,</span><span class=mf>0.3</span><span class=p>,</span><span class=mf>0.4</span><span class=p>,</span><span class=mf>0.5</span><span class=p>,</span><span class=mf>0.6</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>dIter</span> <span class=o>=</span> <span class=n>fNums</span><span class=p>.</span><span class=n>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>advance</span><span class=p>(</span><span class=n>dIter</span><span class=p>,</span><span class=o>-</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after advance -2 offset: *dIter = &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>dIter</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>chList</span><span class=p>{</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>,</span><span class=mi>30</span><span class=p>,</span><span class=mi>40</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>cIter</span> <span class=o>=</span> <span class=n>chList</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>advance</span><span class=p>(</span><span class=n>cIter</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after advance  2 offset: *cIter = &#34;</span> <span class=o>&lt;&lt;</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>cIter</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>最终输出信息如下：</p><div class=highlight id=id-37><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>after advance  <span class=m>3</span> offset: *vIter <span class=o>=</span> <span class=m>4</span>
</span></span><span class=line><span class=cl>after advance -2 offset: *dIter <span class=o>=</span> 0.5
</span></span><span class=line><span class=cl>after advance  <span class=m>2</span> offset: *cIter <span class=o>=</span> <span class=m>30</span></span></span></code></pre></td></tr></table></div></div></div></div></div>背景知识 👉 STL 迭代器按照功能分为 5 类，如下方表格所述：</p><table><thead><tr><th>描述</th><th>特点</th><th>应用</th><th></th></tr></thead><tbody><tr><td>input 迭代器</td><td>只向前移动，一次一步，只读</td><td>istream_iterators</td><td></td></tr><tr><td>output迭代器</td><td>只向前移动，一次一步，只写</td><td>ostream_iterators</td><td></td></tr><tr><td>forward迭代器</td><td>只向前移动，一次一步，可读写</td><td>single-list iterator</td><td></td></tr><tr><td>Bidirectional迭代器</td><td>双向移动，一次一步，可读写</td><td>set/multiset/map/multimap</td><td></td></tr><tr><td>random-access迭代器</td><td>双向移动，一次多步，可读写</td><td>vetor/deque/string</td><td></td></tr></tbody></table><p><mark>如何设计一个 trait_class 并运用起来呢？</mark></p><ul><li><strong>Step1： 确认若干个希望获取的类型信息</strong> (本例只有一个 iterator 类别信息)
针对5 种迭代器分类，C++ 提供了专属的 <strong>卷标结构tag struct</strong> 加以区分(可以理解为编译期的枚举作用)，继承关系如下：<div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>input_iterator_tag</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>output_iterato_tag</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>forward_iterator_tag</span><span class=o>:</span><span class=k>public</span> <span class=n>input_iterator_tag</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>bidirectional_iterator_tag</span><span class=o>:</span> <span class=k>public</span> <span class=n>forward_iterator_tag</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>random_access_iterator_tag</span><span class=o>:</span> <span class=k>public</span> <span class=n>bidirectional_iterator_tag</span><span class=p>{};</span><span class=err>`</span></span></span></code></pre></td></tr></table></div></div></li><li><strong>Step2：为该信息选一个名称</strong> (例如 iterator_category)
那么 vector，set之类的<strong>目标容器类</strong>，如何与上述 iterator_tag <strong>联系起来</strong>呢，需要一个名称传递出去：<div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=p>...</span> <span class=o>&gt;</span> <span class=c1>//省略template 参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>vector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>iterator</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>   <span class=c1>// ps: C++11 之后使用的都是 using 定义式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>typedef</span> <span class=n>random_access_iterator_tag</span> <span class=n>iterator_category</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li><li><strong>Step3：提供一个 template 类和一组特化版本</strong>（特化版本支持某些特殊情况）
<code>Traits 技术</code>针对于迭代器的关键模板类 iterator_traits 定义如下：<div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=o>&gt;</span>  <span class=c1>//  注意：使用的是 struct
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>iterator_traits</span> <span class=p>{</span> <span class=c1>//这里的 IterT 就可以传入vector等容器类
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>typedef</span> <span class=k>typename</span> <span class=n>IterT</span><span class=o>::</span><span class=n>iterator_category</span>  <span class=n>iterator_category</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div>注意，这里的 IterT 类型不能是指针类型，因为 pointer 不能后续嵌套。那么就需要一个特化版本了，代码如下：<div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>iterator_traits</span><span class=o>&lt;</span><span class=n>IterT</span><span class=o>*&gt;</span><span class=p>{</span> <span class=c1>// 指针类型和 random 迭代器类似
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>typedef</span> <span class=n>random_access_iterator_tag</span> <span class=n>iterator_category</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul><p>至此，iterator_traits 的基本实现就完成了，也就是说 <code>iterator_traits&lt;IterT>::iterator_category</code> 可以在编译期确定，接下来看看advance 函数如何使用它。</p><p>💗 正确做法：利用 <strong>函数重载overloading</strong> 技术，使得 <strong>trait classes 在编译期对类型执行 if … else 测试</strong>。</p><p>回顾我们的 advance 函数，只有迭代器类型 IterT 和 偏移量 DistT 。可以重载其子函数 doAdvance ，完成类型萃取后的自适应：</p><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doAdvance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>random_access_iterator_tag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>iter</span> <span class=o>+=</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doAdvance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>bidirectional_iterator_tag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>--</span><span class=p>)</span> <span class=o>++</span><span class=n>iter</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span> <span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>++</span><span class=p>)</span> <span class=o>--</span><span class=n>iter</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>doAdvance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>input_iterator_tag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>out_of_range</span><span class=p>(</span><span class=s>&#34;Negative distance&#34;</span><span class=p>);}</span><span class=c1>//ps: msvc中的C++实现是采用编译期间的asset判定
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>d</span><span class=o>--</span><span class=p>)</span> <span class=o>++</span><span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>自然地，advance 函数的实现如下所示：</p><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>IterT</span><span class=p>,</span> <span class=k>typename</span> <span class=n>DistT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>  <span class=n>advance</span><span class=p>(</span><span class=n>IterT</span><span class=o>&amp;</span> <span class=n>iter</span><span class=p>,</span> <span class=n>DistT</span> <span class=n>d</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>doAdvance</span><span class=p>(</span><span class=n>iter</span><span class=p>,</span><span class=n>d</span><span class=p>,</span> <span class=cm>/*不论 category 的tag类型是什么，重载能找到匹配函数。即编译期的 if...else 测试*/</span>
</span></span><span class=line><span class=cl>              <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>iterator_traits</span><span class=o>&lt;</span><span class=n>IterT</span><span class=o>&gt;::</span><span class=n>iterator_category</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>至此，一个完整的 (以 iterator_traits 为例)Traits 技术实现与运用的过程就完成了。</p><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><ul><li><p>关于 iterator_traits ，不止有 iterator_category，还有 difference_type, value_type, pointer, reference 等4个成员，<a href=https://zh.cppreference.com/w/cpp/iterator/iterator_traits target=_blank rel="external nofollow noopener noreferrer">详细可参考 cpp参考手册：iterator_traits<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 。</p></li><li><p>C++ 标准库中类似 iterator_traits 应用了 Traits 技术的模板有十几个。</p><p>举例常用的数值类型萃取 <code>numeric_limits</code> ，需要注意2个细节：</p><ol><li>头文件是 #include<limits>;</li><li>成员函数 lowest/min/max 按照顺序，分别代表给定类型的 最低有限值、最小非负值、最大有限值。尤其是 float/double，取最小值是 lowest() ，不是 min().</li></ol></li></ul></div></div></div><h3 id=r48-认识template模板元编程>R48 认识Template模板元编程</h3><p><strong>TMP，模板元编程template metaprogramming</strong> ，是编写 template-based C++ 程序并执行于编译期的过程。TMP 过程结束后，若干 C++ 源码会被 templates 具现化出来，便会一如往常地被编译。</p><p>TMP 有 2 个强大的作用：</p><ol><li>可以完成非 TMP 的常规编程做不到的事情
比如代码生成，类型适配等。</li><li>可以将某些工作从运行期转移到编译期
可以将运行期的错误提前暴露在编译期，可以获得更小的可执行文件，更快地运行，更少地内存需求，缺点是明显增加编译时间。</li></ol><p>TMP 已被证明是个“<strong>图灵完备</strong>”的机器，意思是它强大到可以计算任何事物。使用 TMP 可以声明变量、执行循环、编写及调用函数…等等。</p><p>比较特别的是，TMP 实现上述各类功能的方式不同于常规 C++ 程序。比如上一节 Rule47 中使用重载完成了编译期的 if…else 条件分支。TMP 循环功能也通常会使用 “<strong>递归具现化</strong>” 来完成的。</p><p>下方代码示范如何使用 TMP 的方式来计算阶乘：</p><div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Factorial</span>
</span></span><span class=line><span class=cl><span class=p>{</span>   <span class=c1>// 递归的形式体现: f(n) = n * f(n -1)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>enum</span> <span class=p>{</span><span class=n>value</span> <span class=o>=</span> <span class=n>n</span><span class=o>*</span> <span class=n>Factorial</span><span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Factorial</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>  <span class=c1>// 模板全特化: 实际是初始化 f(0) = 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>enum</span> <span class=p>{</span><span class=n>value</span> <span class=o>=</span> <span class=mi>1</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么阶乘计算在编译期就完成了，运行时就是直接取用了：</p><div class=highlight id=id-23><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Factorial(&#34;</span> <span class=o>&lt;&lt;</span> <span class=mi>5</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Factorial</span><span class=o>&lt;</span><span class=mi>5</span><span class=o>&gt;::</span><span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Factorial(&#34;</span> <span class=o>&lt;&lt;</span> <span class=mi>7</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Factorial</span><span class=o>&lt;</span><span class=mi>7</span><span class=o>&gt;::</span><span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><h2 id=ch8-定制new和delete>CH8 定制new和delete</h2><h3 id=r49-了解new-handler的行为>R49 了解new-handler的行为</h3><p>当 <code>operator new</code> 无法满足某个内存分配需求时，一般会抛出 <code>std::bad_alloc</code> 异常。</p><blockquote><p>如果用 std::nothrow 修饰 new 操作符，使得内存分配阶段不会抛异常，失败了就返回 null 指针。举例 :</p><div class=highlight id=id-24><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>pArr</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>nothrow</span><span class=p>)</span> <span class=kt>int</span><span class=p>[</span><span class=mh>0x1fffffff</span><span class=p>];</span> <span class=c1>//即使分配失败，也不抛异常，而是得到null指针.
</span></span></span><span class=line><span class=cl><span class=c1>//  nothroow-new 不能保证 class 后续的构造函数不抛异常
</span></span></span></code></pre></td></tr></table></div></div></blockquote><p>new-hanlder 的使用示例如下：</p><div class=highlight id=id-25><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//先定义一个函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>OutOfMemTip</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;new memory fail,out of memory!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>abort</span><span class=p>();</span><span class=c1>//终止程序，若调试模式会弹窗提示
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 故意制造new失败的情形，程序会调用 OutOfMemTip，触发std::abort()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>OutOfMemTip</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>pArr</span> <span class=o>=</span>  <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mh>0x1fffffff</span><span class=p>];</span><span class=c1>//约2GB,如果扛的住，调大这个数
</span></span></span></code></pre></td></tr></table></div></div><p>可以看出这样的函数指针给了使用者非常大的设计弹性，可以做到以下事情：</p><ul><li>提前申请内存，让 new_handler 触发下一次分配使用；</li><li>安装另一个 new_handler ，或许新的 handler 可以申请到内存；</li><li>卸载 new_handler ，只要传 null 指针即可；</li><li>手动抛 std::bad_alloc 的异常；</li><li>不返回，通常调用 std::abort() 或 std::exit() ;</li></ul><p>🤔 我们思考另外一个问题：是否可以 让不同的 <strong>C++ 类拥有自己的 new-handler</strong> 呢？ C++ 标准机制是不支持的，我们可以自己实现。有两个实现途径，列举如下：</p><ol><li><strong>针对某个特定类 ，类内重载 static 类型的 <code>operator new</code> 以及 <code>set_new_handler</code>方法</strong>
具体实现略，只想指出这样做法有个明显弊端，就是每个类都得这么做，比较麻烦，也容易代码冗余。</li><li><strong>使用 CRTP 方法（即 <code>怪异的循环模板模式curiously recurring template pattern</code> ）将上述方法 1 塞进 template 类</strong>
这样做的好处是使用模板类赋予上述 operator new 和 set_new_hanler 的操作，使用起来方便。
CRTP 方法中的基类 NewHandlerSupport 实现如下 👇(点击打开折叠) ：</li></ol><div class=highlight id=id-26><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NewHandlerSupport</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>set_new_handler</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>p</span><span class=p>)</span><span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>oldHandler</span> <span class=o>=</span> <span class=n>currentHandler_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>currentHandler_</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>oldHandler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>oldHandle</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>currentHandler_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=o>*</span><span class=n>res</span> <span class=o>=</span> <span class=o>::</span><span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>size</span><span class=p>);</span> <span class=c1>//new完后复原global-new-handler
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>oldHandle</span><span class=p>);</span><span class=c1>//原书使用RAII手法在还原这个handler，这里作用类似
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>new_handler</span> <span class=n>currentHandler_</span><span class=p>;</span><span class=c1>//初始化动作放到类外cpp文件里去
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么目标类 <code>TestNewHandler</code> 只要基于 <code>CRTP</code> 方法继承于基类就可以了，实现如下：</p><div class=highlight id=id-27><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>TestNewHandler</span> <span class=o>:</span> <span class=k>public</span> <span class=n>NewHandlerSupport</span><span class=o>&lt;</span><span class=n>TestNewHandler</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//不必声明 set_new_handler 或 operator new
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//最终应用时也非常简单
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>TestNewHandler</span><span class=o>::</span><span class=n>set_new_handler</span><span class=p>(</span><span class=n>OutOfMemTip</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>TestNewHandler</span><span class=o>*</span> <span class=n>pTestHandle</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TestNewHandler</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><h3 id=r50-了解new和delete的合理替换时机>R50 了解new和delete的合理替换时机</h3><p>替换编译器提供的 <code>operator new</code> 和 <code>operator delete</code> 的 常见理由 如下：</p><ol><li><p><strong>检测运用上的错误</strong>
自定义的new/delete可以很方便地校验实际控制的区段内存，比如可以在目标区块前后额外空间添加内存签名(比如写入特定 int 值)，监测越界的问题。
越界分2种：underruns (区块内存起点之前) 和 overruns (区块内存末尾之后)。</p></li><li><p><strong>时间或内存使用的优化</strong>
通用的 new/delete 需要适用各种分配形态和场景，对于内存碎片或时间性能都是中庸水平。
对特定的需求和场景，定制化地内存管理会有很好的优化效果。</p></li><li><p><strong>收集内存使用的统计数据</strong>
对内存分配细节的把控，例如分配区块的大小分布、存续周期、FIFO/LIFO次序分配回收、内存峰值等情况。</p></li><li><p><strong>弥补默认内存分配器的 非最佳对齐位suboptimal alignment</strong>
例如x86体系结构CPU上访问double都是8bytes对齐，如果能在内存分配时就做好内存对齐，可提升访问效率。</p></li><li><p><strong>将相关对象成簇集中</strong>
比如已知某个数据结构往往一起使用，那么分配的时候应该尽量让所有数据的内存集中一些，避免频繁触发 换页中断page faults ，提升访问效率。</p></li><li><p><strong>其他的非传统行为</strong>
想完成一些系统编译器办不到的事情。比如希望分配释放共享内存的区块，但是只有 C-API 能做到，那就需要定制版的 new/delete 去包裹封装这样的API。</p></li></ol><h3 id=r51-编写new和delete时需固守常规>R51 编写new和delete时需固守常规</h3><p>上一个条款讲了重写 new/delete 的原因，这一节将讲述具体需要遵守的几个规则。</p><ol><li><p><strong>正确处理 new 失败的情况</strong>
如果分配正常，直接返回区块对应的指针即可。可如果失败，就必须得正确调用 new-handler 函数，参考 R49 了解new-handler的行为。</p></li><li><p><strong>如果要求分配 0 byte 空间</strong>
C++规定，如果客户要求分配 0 byte 内存申请，就返回 1byte 空间申请，并返回该有效地址。</p></li><li><p><strong>理解 operator new 内部的无穷循环</strong>
operator new 有个 while(true) 循环，分配成功可以return，或由 new-handler 为 nullptr 时抛出 std::bad_alloc 异常。伪代码pseudocode 如下：</p></li></ol><div class=highlight id=id-28><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>size</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=err>尝试分配</span> <span class=n>size</span> <span class=n>bytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=err>分配成功</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>  <span class=n>target_pointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new_handler</span> <span class=n>globalHandler</span> <span class=o>=</span> <span class=n>set_new_handler</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>set_new_handler</span><span class=p>(</span><span class=n>globalHandler</span><span class=p>);</span><span class=c1>//分配失败了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>globalHandler</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=n>globalHanler</span><span class=p>)();</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ol start=4><li><strong>当基类的 operator new 被子类继承时</strong>
当基类被继承时，成员 operator new 也一起被继承了，要注意的是基类和子类的 size 通常是不一样的。推荐实现如下：</li></ol><div class=highlight id=id-29><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span><span class=k>throw</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Base</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>::</span><span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>size</span><span class=p>);</span><span class=c1>//子类走这里
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>值得注意的是，<strong>operator new[] 不能这样在基类中区分</strong>。因为即使在Base类，也无法假定每个元素是 sizeof(Base)，通常还有额外内存空间来保存元素个数。</p><ol start=5><li>operator delete 的注意事项
C++ 需要保证 “<code>删除NULL指针永远安全</code>”，所以必须兑现这个规则。针对null指针，就什么也不做，直接return。</li></ol><h3 id=r52-写了placement-new-也要写placement-delete>R52 写了placement-new 也要写placement-delete</h3><p>placement-new，是指“<code>除size参数以外，接受一个额外参数参与构造</code>”的 特定 operator-new。</p><p>其中，“<code>接受一个指针指向对象该被构造之处</code>”是<strong>最常使用</strong>的 placement-new，即“<code>一个特定位置上的new</code>”，形式如下为：</p><div class=highlight id=id-30><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//这个特殊的也是最常涉及的 placement-new 已被纳入C++标准程序库
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>,</span><span class=kt>void</span><span class=o>*</span> <span class=n>pMemory</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>先暂时考虑一个调用了placement-new的正常构造过程：</p><div class=highlight id=id-31><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 有这样一个placement-new,接收一个ostream来log分配时的相关信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>,</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>logStream</span><span class=p>)</span> <span class=k>throw</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Widget</span><span class=o>*</span> <span class=n>pw</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>cerr</span><span class=p>)</span> <span class=n>Widget</span><span class=p>;</span><span class=c1>//传入ostream
</span></span></span></code></pre></td></tr></table></div></div><p>对于任何的new对象构造过程，至少可分为下述2个过程：</p><ol><li>operator new 分配对象需要的内存空间；</li><li>执行对应的构造函数
如果上述过程 1 成功了，过程 2 抛异常，已经申请的内存就需要及时回收避免memory-leak，运行期系统就会尝试寻找并调用“<strong>额外参数个数和类型都与operator new 一致的operator delete</strong>”，完成内存回收。</li></ol><p>那么上述事实，就是 placement-new 和 placement-delete 需要<strong>成对实现的理由</strong>。</p><p>针对上例额外参数是 std::ostream 的operator new，operator delete，类声明形式如下:</p><div class=highlight id=id-32><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span><span class=o>*</span> <span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>,</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>logStream</span><span class=p>)</span> <span class=k>throw</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//不抛异常时，最后对象析构时正常调用这个
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>void</span> <span class=k>operator</span> <span class=nf>delete</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pMemory</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//new抛异常时，调用这个 额外参数个数和类型都一致的 placement-delete
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>void</span> <span class=k>operator</span> <span class=nf>delete</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pMemory</span><span class=p>,</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>logStream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>⚠️ <strong>One More Thing</strong> : C++ 在global 作用域提供以下形式的 operator new:</p><div class=highlight id=id-33><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=k>throw</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>,</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span> <span class=k>operator</span> <span class=nf>new</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>,</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>nothrow_t</span> <span class=o>&amp;</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span><span class=c1>//见条款49 new-Handler的行为
</span></span></span></code></pre></td></tr></table></div></div><p>😎 所以，如果在class 内声明了上述 operator new， 则global作用域的 operator new 会被<code>名称遮掩</code>。</p><p>🤔 <code>解决办法</code>：在基类对global作用域的 ::operator new 进行封装调用，然后在子类中使用using 声明式破除名称遮掩。</p><h2 id=ch9-杂项讨论>CH9 杂项讨论</h2><h3 id=r53-不要轻易忽略编译器的警告>R53 不要轻易忽略编译器的警告</h3><ul><li><p><strong>严肃对待编译器发出的警告信息</strong>
编译器发出的警告信息，经常会被忽略。No-Warning是值得追崇的，除非你对编译 warning 信息是充分了解并确信是无关紧要的。</p><p>下面举一个较为常见的例子：</p><div class=highlight id=id-34><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BaseWarn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>GetWarnInfo</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=s>&#34;Base&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DerivedWarn</span> <span class=o>:</span><span class=k>public</span> <span class=n>BaseWarn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>GetWarnInfo</span><span class=p>()</span>  <span class=p>{</span><span class=c1>//缺了const
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>return</span> <span class=s>&#34;Derived&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>如上代码所示，没有成功实现虚函数重写，而是造成了“<strong>名称遮掩</strong>”。
这样的错误较为隐蔽，有些编译器会给出警告信息，有些甚至连警告信息都没有（Ps：我自行测试了VS2017，没有warning信息）。
<code>如果编译器给出了警告信息，请认真对待</code>。</p></li><li><p><strong>不要过度依赖编译器的报警能力</strong>
还是上面的例子，不同编译器处理态度不同，警告信息甚至可能换个编译器就消失了。</p></li></ul><h3 id=r54-熟悉包括tr1在内的标准程序库>R54 熟悉包括TR1在内的标准程序库</h3><p><strong>C++ Technical Report 1 (TR1)</strong> 并非标准，而是一份草稿文件，对C++标准库的第一次扩展，它提出了对C++标准函式库的追加项目。</p><p>这份文件的目标在于「为扩充的C++标准函式库建立更为广泛的现实作品」。</p><blockquote><p><code>我的理解</code>：200x 年发布的 C++ 称为 “C++0x”，持续修改中，所有修改将合并于 TR1，最终绝大部分都定版、收录发布于 <strong>C++11</strong>。</p></blockquote><p>TR1详细叙述了许多新特性，都放在 <code>std::tr1</code> 命名空间内（以下简称 <code>tr1::</code> ），列举如下</p><ol><li><code>智能指针</code>：tr1::shared_ptr 和 tr1::weak_ptr ，RAII 基础，不赘述；</li><li><code>tr1::function</code>：表示 可调用物callable entity，即任何函数或函数对象，只要签名一致即可；</li><li><code>tr1::bind</code>：对函数调用的封装，将函数和其参数绑定一起；</li><li><code>Hash tables</code>：采哈希表形式参与构成，名称以 unordered_ 开头的 set/multiset/map/multimap；</li><li><code>正则表达式</code>：头文件在 <regrex>；</li><li><code>Tuple 元组(或叫变量组)</code>：不定长变量组，是 std::pair 的一种泛化；</li><li><code>tr1::array</code>: 和 C 语言数组一样，是个定长数组，包裹了 STL 用法；</li><li><code>tr1::mem_fn</code>: 传入一个函数指针（支持对成员函数取址）作为入参，构造一个函数对象，进而调用，类似地还有 mem_fn_ref;</li><li><code>tr1::reference_wrapper</code>：“封装引用为一个对象”，通常用于对引用进行封装然后装入标准容器(直接往容器塞引用是不行的)；</li><li><code>随机数生成工具</code>：random_device，可以直接生成或者使用不同的 随机数引擎 和 随机分布算法进行生成，头文件是 <random>；</li><li><code>数学特殊函数</code>：包括Laguerre多项式、Bessel 函数、完全椭圆积分等特殊数学函数，注意，这些 在 C++17 才引入C++标准，可参考cppreference: special math ，头文件在 <cmath>；</li><li><code>C99兼容扩充</code> ：C99标准是C语言的官方标准第二版，1999年发布，TR1对其进行了兼容；</li><li><code>Type traits 类型萃取</code>：template编程的精华之一，参考 Rule47:使用trait表现类型信息，头文件为 &lt;type_traits>，功能十分丰富，可参考cppreference: type_traits；</li><li><code>tr1::result_of</code> ：可以对函数返回值做推断，得到返回值类型，头文件为 &lt;type_traits> ，示例用法如下：
<code>c++ // 假设有个函数 double calcDaySale(int); std::tr1::result_of&lt;calcDaySale(int)>::type x = 3.14;//x就是double类型. C++11中直接 std::result_of </code>更详细的定版TR1信息可以参考<a href=https://aristeia.com/EC3E/TR1_info.html target=_blank rel="external nofollow noopener noreferrer">Effective-C++：TR1 information<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</li></ol><h3 id=r55-让自己熟悉boost>R55 让自己熟悉Boost</h3><p>Boost是一个C++开发者集结的社群，也是个可自由下载的程序库集，网址是 <code>http://boost.org</code>。</p><p><strong>其特殊性</strong>：和C++标准委员会有着独一无二的密切关系，且具有很深影响力；接纳程序库非常严谨，需要一次以上的同行专家评审。</p><p>Boost 程序库集可处理的场景有许多（且<strong>囊括了TR1</strong>的实现），可区分出数十个类别，并且还在持续增加，<strong>列举一小部分</strong>如下：</p><ul><li><strong>字符串与文本处理</strong></li><li><strong>容器</strong></li><li><strong>函数对象与高级编程</strong></li><li><strong>泛型编程</strong>：覆盖一大组 traits classes</li><li><strong>模板元编程</strong>：覆盖一个针对编译器 assertions 而写的程序库，以及 Boost MPL程序库</li><li><strong>数学和数值</strong>:包括有理数、八元数、四元数、公约数、多重运算、随机数等等</li><li><strong>正确性与测试性</strong></li><li><strong>数据结构</strong></li><li><strong>语言间的支持</strong>：允许 C++ 和 Python 之间的无缝互联</li><li><strong>内存</strong>：覆盖Pool程序库和智能指针等</li><li><strong>杂项</strong>：包括 CRC 校验、日期和时间的处理、文件系统等内容</li></ul><p>总的来说，Boost 是一个社群，也是个网站。致力于免费、源码开放、同行复审的 C++ 程序库开发，非常值得经常访问与学习。</p><p>ref:</br>[1]. <a href=https://blog.csdn.net/cltcj/category_12098441.html target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>[2]. <a href=https://kissingfire123.github.io/2022/05/17_effective-c-%e4%b9%8b%e9%98%85%e8%af%bb%e6%80%bb%e7%bb%93%e5%9b%9b/ target=_blank rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2022/05/17_effective-c-%e4%b9%8b%e9%98%85%e8%af%bb%e6%80%bb%e7%bb%93%e5%9b%9b/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br></p></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-10-07 09:25:23">更新于 2023-10-07&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/f43a10a9b4079963a6d78279f6f805b045e519d1 rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) f43a10a9b4079963a6d78279f6f805b045e519d1: bug: modify effective c++ naming rules"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>f43a10a</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/effective_cpp_part_four/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/Effective_C++/Effective_CPP_Part_Four/index.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/effective_cpp_part_four/ data-title="Effective C++ (第3版) 精读总结 [4]" data-hashtags=Effective><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/effective_cpp_part_four/ data-hashtag=Effective><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/effective_cpp_part_four/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/effective_cpp_part_four/ data-title="Effective C++ (第3版) 精读总结 [4]"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/effective_cpp_part_four/ data-title="Effective C++ (第3版) 精读总结 [4]"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/effective/ class=post-tag>Effective</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/effective_cpp_part_three/ class=post-nav-item rel=prev title="Effective C++ (第3版) 精读总结 [3]"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Effective C++ (第3版) 精读总结 [3]</a>
<a href=/posts/ddpm/ class=post-nav-item rel=next title="Diffusion 扩散模型（DDPM）">Diffusion 扩散模型（DDPM）<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.127.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> jianye',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>