<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>More Effective C++ 阅读笔记 - yejian's blog</title><meta name=author content="Jian YE">
<meta name=author-link content="https://github.com/jianye0428"><meta name=description content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向(代表)另一个对象，但是也有可能它不指向(代表)任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta name=keywords content="More Effective C++"><meta itemprop=name content="More Effective C++ 阅读笔记"><meta itemprop=description content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向(代表)另一个对象，但是也有可能它不指向(代表)任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta itemprop=datePublished content="2023-09-06T19:40:01+08:00"><meta itemprop=dateModified content="2023-10-07T09:25:23+08:00"><meta itemprop=wordCount content="19097"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="More Effective C++,"><meta property="og:title" content="More Effective C++ 阅读笔记"><meta property="og:description" content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向(代表)另一个对象，但是也有可能它不指向(代表)任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta property="og:type" content="article"><meta property="og:url" content="https://jianye0428.github.io/posts/more_effective_c-/"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-06T19:40:01+08:00"><meta property="article:modified_time" content="2023-10-07T09:25:23+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="More Effective C++ 阅读笔记"><meta name=twitter:description content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向(代表)另一个对象，但是也有可能它不指向(代表)任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/more_effective_c-/><link rel=prev href=https://jianye0428.github.io/posts/effective_stl_38/><link rel=next href=https://jianye0428.github.io/posts/effective_stl_part_two/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"More Effective C++ 阅读笔记","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/more_effective_c-\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"More Effective C\u002b\u002b","wordcount":19097,"url":"https:\/\/jianye0428.github.io\/posts\/more_effective_c-\/","datePublished":"2023-09-06T19:40:01+08:00","dateModified":"2023-10-07T09:25:23+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=wide><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>More Effective C++ 阅读笔记</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-09-06 19:40:01"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-09-06>2023-09-06</time></span>&nbsp;<span title="更新于 2023-10-07 09:25:23"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-10-07>2023-10-07</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 19097 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 39 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="More Effective C++ 阅读笔记">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#一-基础议题basics>一、 基础议题(Basics)</a><ul><li><a href=#条款-1-仔细区别-pointers和references>条款 1: 仔细区别 pointers和references</a></li><li><a href=#条款-2-最好使用-c转型操作符>条款 2: 最好使用 C++转型操作符</a></li><li><a href=#条款-3-绝对不要以多态polymorphically方式处理数组>条款 3: 绝对不要以多态(polymorphically)方式处理数组</a></li><li><a href=#条款-4-避免无用的缺省构造函数>条款 4: 避免无用的缺省构造函数</a></li></ul></li><li><a href=#二运算符操作符>二、运算符(操作符)</a><ul><li><a href=#条款-5-谨慎定义类型转换函数>条款 5: 谨慎定义类型转换函数</a></li><li><a href=#条款-6-区别-incrementdecrement-操作符的前置和后置形式s>条款 6: 区别 increment/decrement 操作符的前置和后置形式s</a></li><li><a href=#条款-7-千万不要重载-和操作符>条款 7: 千万不要重载&&，|| 和，操作符</a></li><li><a href=#条款8-了解各种不同意义的-new-和-delete>条款8: 了解各种不同意义的 new 和 delete</a></li></ul></li><li><a href=#三-异常>三、 异常</a><ul><li><a href=#条款-9-利用-destructors-避免泄漏资源>条款 9: 利用 destructors 避免泄漏资源</a></li><li><a href=#条款-10-在-constructors-内阻止资源泄漏resource-leak>条款 10: 在 constructors 内阻止资源泄漏(resource leak)</a></li><li><a href=#条款-11-禁止异常exceptions流出destructors之外>条款 11: 禁止异常(exceptions)流出destructors之外</a></li><li><a href=#条款12-了解抛出一个exception与传递一个参数或调用一个虚函数之间的差异>条款12: 了解“抛出一个exception”与“传递一个参数”或“调用一个虚函数”之间的差异</a></li><li><a href=#条款13-以-by-reference方式捕捉-exceptions>条款13: 以 by reference方式捕捉 exceptions</a></li><li><a href=#条款14-审慎使用异常规格exception-specifications>条款14: 审慎使用异常规格(exception specifications)</a></li><li><a href=#条款15-了解异常处理的系统开销>条款15: 了解异常处理的系统开销</a></li></ul></li><li><a href=#四效率>四、效率</a><ul><li><a href=#条款16-谨记-80-20-法则>条款16: 谨记 80-20 法则</a></li><li><a href=#条款17-考虑使用-lazy-evaluation缓式评估>条款17: 考虑使用 lazy evaluation(缓式评估)</a></li><li><a href=#条款18-分期摊还预期的计算成本>条款18: 分期摊还预期的计算成本</a></li><li><a href=#条款19-理解临时对象的来源>条款19: 理解临时对象的来源</a></li><li><a href=#条款20-协助完成返回值优化-rvo>条款20: 协助完成返回值优化 (RVO)</a></li><li><a href=#条款21-通过重载避免隐式类型转换>条款21: 通过重载避免隐式类型转换</a></li><li><a href=#条款22-考虑用运算符的赋值形式op取代其单独形式op>条款22: 考虑用运算符的赋值形式(op=)取代其单独形式(op)</a></li><li><a href=#条款23-考虑使用其他程序库>条款23: 考虑使用其他程序库</a></li><li><a href=#条款24-理解虚拟函数多继承虚基类和rtti所需的代码>条款24: 理解虚拟函数、多继承、虚基类和RTTI所需的代码</a></li></ul></li><li><a href=#五技术-techniquesidiomspatterns>五、技术 (Techniques，Idioms，Patterns)</a><ul><li><a href=#条款25-将构造函数和非成员函数虚拟化>条款25: 将构造函数和非成员函数虚拟化</a></li><li><a href=#条款26-限制某个类所能产生的对象数量>条款26: 限制某个类所能产生的对象数量</a></li><li><a href=#条款27-要求或禁止对象产生于-heap之中>条款27: 要求（或禁止）对象产生于 heap之中</a></li><li><a href=#条款28-灵巧smart指针>条款28: 灵巧(smart)指针</a></li></ul></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><h2 id=一-基础议题basics>一、 基础议题(Basics)</h2><h3 id=条款-1-仔细区别-pointers和references>条款 1: 仔细区别 pointers和references</h3><p>没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向(代表)另一个对象，但是也有可能它不指向(代表)任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 null。换个角度看，如果这个变量总是必须代表一个对象，也就是说如果你的设计并不允许这个变量为 null，那么你应该使用reference。</p><p>Pointers 和 references 之间的另一个重要差异就是，pointers 可以被重新赋值，指向另一个对象，reference 却总是指向(代表)它最初获得的那个对象。</p><p>一般而言，当你需要考虑“不指向任何对象”的可能性时，或是考虑“在不同时间指向不同对象”的能力时，你就应该采用 pointer。前一种情况你可以将 pointer设为 null，后一种情况你可以改变pointer 所指对象。而当你确定“总是会代表某个对象”，而且“一旦代表了该对象就不能够再改变”，那么你应该选用 reference。</p><p>当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references。任何其他时候，请采用 pointers。</p><p><strong>在任何情况下都不能使用指向空值的引用</strong>。一个引用必须总是指向某些对象。在C++里，引用应被初始化。</p><p>不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。
指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变。</p><p>关于引用的更多介绍参考: <a href=https://blog.csdn.net/fengbingchun/article/details/69820184 target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/fengbingchun/article/details/69820184<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printDouble</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span><span class=o>&amp;</span> <span class=n>rd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>rd</span><span class=p>;</span> <span class=c1>// 不需要测试rd,它肯定指向一个double值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printDouble</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span><span class=o>*</span> <span class=n>pd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>pd</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 检查是否为NULL
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;*</span><span class=n>pd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>pc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 设置指针为空值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>char</span><span class=o>&amp;</span> <span class=n>rc</span> <span class=o>=</span> <span class=o>*</span><span class=n>pc</span><span class=p>;</span> <span class=c1>// 让指针指向空值，这是非常有害的，结果将是不确定的
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//std::string&amp; rs; // 错误，引用必须被初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>(</span><span class=s>&#34;xyzzy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span> <span class=c1>// 正确,rs指向s
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>ps</span><span class=p>;</span> <span class=c1>// 未初始化的指针，合法但危险
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s1</span><span class=p>(</span><span class=s>&#34;Nancy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s2</span><span class=p>(</span><span class=s>&#34;Clancy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>s1</span><span class=p>;</span> <span class=c1>// rs引用s1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>ps</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s1</span><span class=p>;</span> <span class=c1>// ps指向s1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>rs</span> <span class=o>=</span> <span class=n>s2</span><span class=p>;</span> <span class=c1>// rs仍旧引用s1,但是s1的值现在是&#34;Clancy&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>ps</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s2</span><span class=p>;</span> <span class=c1>// ps现在指向s2,s1没有改变
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// 这个被赋值的目标对象就是操作符[]返回的值，如果操作符[]
</span></span></span><span class=line><span class=cl><span class=c1></span>		   <span class=c1>// 返回一个指针，那么后一个语句就得这样写: *v[5] = 10;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款-2-最好使用-c转型操作符>条款 2: 最好使用 C++转型操作符</h3><p>C++通过引进四个新的类型转换(cast)操作符克服了C风格类型转换的缺点(过于粗鲁，能允许你在任何类型之间进行转换；C风格的类型转换在程序语句中难以识别)，这四个操作符是: <code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>。</p><p>static_cast在功能上基本上与C风格的类型转换一样强大，含义也一样。它也有功能上限制。例如，不能用static_cast像用C 风格的类型转换一样把struct转换成int类型或者把double类型转换成指针类型，另外，static_cast不能从表达式中去除const属性，因为另一个新的类型转换操作符const_cast有这样的功能。</p><p>const_cast用于类型转换掉表达式的const或volatileness属性。如果你试图使用const_cast来完成修改constness或者volatileness属性之外的事情，你的类型转换将被拒绝。</p><p><strong>dynamic_cast</strong>被用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能用dynamic_cast把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功。失败的转换将返回空指针(当对指针进行类型转换时)或者抛出异常(当对引用进行类型转换时)。dynamic_cast在帮助你浏览继承层次上是有限制的，它不能被用来缺乏虚函数的类型上，也不能用它来转换掉constness。如你想在没有继承关系的类型中进行转换，你可能想到static_cast。如果是为了去除const，你总得用const_cast。</p><p>reinterpret_cast使用这个操作符的类型转换，其转换结果几乎都是执行期定义(implementation-defined)。因此，使用reinterpret_cast的代码很难移植。此操作符最普通的用途就是在函数指针之间进行转换。</p><p>关于类型转换更多介绍参考: <a href=https://blog.csdn.net/fengbingchun/article/details/51235498 target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/fengbingchun/article/details/51235498<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>func</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpecialWidget</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>func</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=n>SpecialWidget</span><span class=o>*</span> <span class=n>psw</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>updateViaRef</span><span class=p>(</span><span class=n>SpecialWidget</span><span class=o>&amp;</span> <span class=n>rsw</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>FuncPtr</span><span class=p>)();</span> <span class=c1>// FuncPtr是一个指向函数的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>doSomething</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>firstNumber</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>secondNumber</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>result1</span> <span class=o>=</span> <span class=p>((</span><span class=kt>double</span><span class=p>)</span><span class=n>firstNumber</span><span class=p>)</span> <span class=o>/</span> <span class=n>secondNumber</span><span class=p>;</span> <span class=c1>// C风格
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>double</span> <span class=n>result2</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>firstNumber</span><span class=p>)</span> <span class=o>/</span> <span class=n>secondNumber</span><span class=p>;</span> <span class=c1>// C++风格类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>SpecialWidget</span> <span class=n>sw</span><span class=p>;</span> <span class=c1>// sw是一个非const对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>const</span> <span class=n>SpecialWidget</span><span class=o>&amp;</span> <span class=n>csw</span> <span class=o>=</span> <span class=n>sw</span><span class=p>;</span> <span class=c1>// csw是sw的一个引用，它是一个const对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//update(&amp;csw); // 错误，不能传递一个const SpecialWidget*变量给一个处理SpecialWidget*类型变量的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>update</span><span class=p>(</span><span class=k>const_cast</span><span class=o>&lt;</span><span class=n>SpecialWidget</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>csw</span><span class=p>));</span> <span class=c1>// 正确，csw的const显示地转换掉(csw和sw两个变量值在update函数中能被更新)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>update</span><span class=p>((</span><span class=n>SpecialWidget</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>csw</span><span class=p>);</span> <span class=c1>// 同上，但用了一个更难识别的C风格的类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>*</span> <span class=n>pw</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SpecialWidget</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//update(pw); // 错误，pw的类型是Widget*，但是update函数处理的是SpecialWidget*类型
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//update(const_cast&lt;SpecialWidget*&gt;(pw)); // 错误，const_cast仅能被用在影响constness or volatileness的地方，不能用在向继承子类进行类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>*</span> <span class=n>pw2</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>update</span><span class=p>(</span><span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWidget</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>pw2</span><span class=p>));</span> <span class=c1>// 正确，传递给update函数一个指针是指向变量类型为SpecialWidget的pw2的指针， 如果pw2确实指向一个对象，否则传递过去的将是空指针
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>*</span> <span class=n>pw3</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SpecialWidget</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>updateViaRef</span><span class=p>(</span><span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWidget</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=n>pw3</span><span class=p>));</span> <span class=c1>// 正确，传递给updateViaRef函数SpecailWidget pw3指针，如果pw3确实指向了某个对象，否则将抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//double result3 = dynamic_cast&lt;double&gt;(firstNumber) / secondNumber; // 错误，没有继承关系
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>const</span> <span class=n>SpecialWidget</span> <span class=n>sw4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//update(dynamic_cast&lt;SpecialWidget*&gt;(&amp;sw4)); // 错误，dynamic_cast不能转换掉const
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>FuncPtr</span> <span class=n>funcPtrArray</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// funcPtrArray是一个能容纳10个FuncPtr指针的数组
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//funcPtrArray[0] = &amp;doSomething; // 错误，类型不匹配
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>funcPtrArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>FuncPtr</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>doSomething</span><span class=p>);</span> <span class=c1>// 转换函数指针的代码是不可移植的(C++不保证所有的函数指针都被用一样的方法表示)，在一些情况下这样的转换会产生不正确的结果，所以应该避免转换函数指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款-3-绝对不要以多态polymorphically方式处理数组>条款 3: 绝对不要以多态(polymorphically)方式处理数组</h3><p>C++允许你通过基类指针和引用来操作派生类数组。不过这根本就不是一个特性，因为这样的代码几乎从不如你所愿地那样运行。数组与多态不能用在一起。值得注意的是如果你不从一个具体类(concrete classes)(例如BST)派生出另一个具体类(例如BalancedBST)，那么你就不太可能犯这种使用多态性数组的错误。</p><p><strong>原因:</strong></p><ul><li>derived class 对象一般比base class对象小。所以当使用一个 base class数组存储derived class时，在访问 array[i] 时，会访问array+i*sizeof(base class)的地址，造成访问错误。</li><li>由base 指针删除一个derived class 数组，结果未定义。因为删除时，析构从最后一个开始，但是计算地址时跟tips1一样，造成访问错误。</li></ul><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BST</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=o>~</span><span class=n>BST</span><span class=p>()</span> <span class=p>{</span> <span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BST::~BST</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>score</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BalancedBST</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BST</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=o>~</span><span class=n>BalancedBST</span><span class=p>()</span> <span class=p>{</span> <span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BalancedBST::~BalancedBST</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// 如果增加此一个int成员，执行test_item_3会segmentation fault，注释掉此变量，运行正常
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_3</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BST size: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BST</span><span class=p>));</span> <span class=c1>// 16
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BalancedBST size: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BalancedBST</span><span class=p>));</span> <span class=c1>// 24
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>BST</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BalancedBST</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=p>[]</span> <span class=n>p</span><span class=p>;</span> <span class=c1>// 如果sizeof(BST) != sizeof(BalancedBST)，则会segmentation fault
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款-4-避免无用的缺省构造函数>条款 4: 避免无用的缺省构造函数</h3><p>构造函数能初始化对象，而<strong>缺省构造函数</strong>则可以不利用任何在建立对象时的外部数据就能初始化对象。有时这样的方法是不错的。例如一些行为特性与数字相仿的对象被初始化为空值或不确定的值也是合理的，还有比如链表、哈希表、图等等数据结构也可以被初始化为空容器。但不是所有的对象都属于上述类型，对于很多对象来说，不利用外部数据进行完全的初始化是不合理的。比如一个没有输入姓名的地址薄对象，就没有任何意义。</p><p>利用指针数组代替一个对象数组这种方法有两个缺点: 第一你必须删除数组里每个指针所指向的对象。如果忘了，就会发生内存泄漏。第二增加了内存分配量，因为正如你需要空间来容纳EquipmentPiece对象一样，你也需要空间来容纳指针。</p><p>对于类里没有定义缺省构造函数还会造成它们无法在许多基于模板(template-based)的容器类里使用。因为实例化一个模板时，模板的类型参数应该提供一个缺省构造函数。在多数情况下，通过仔细设计模板可以杜绝对缺省构造函数的需求。</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>EquipmentPiece</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>EquipmentPiece</span><span class=p>(</span><span class=kt>int</span> <span class=n>IDNumber</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_4</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//EquipmentPiece bestPieces[10]; // 错误，没有正确调用EquipmentPiece构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//EquipmentPiece* bestPieces2 = new EquipmentPiece[10]; // 错误，与上面的问题一样
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ID1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>ID2</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>EquipmentPiece</span> <span class=n>bestPieces3</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID1</span><span class=p>),</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID2</span><span class=p>)</span> <span class=p>};</span> <span class=c1>// 正确，提供了构造函数的参数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// 利用指针数组来代替一个对象数组
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>typedef</span> <span class=n>EquipmentPiece</span><span class=o>*</span> <span class=n>PEP</span><span class=p>;</span> <span class=c1>// PEP指针指向一个EquipmentPiece对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>PEP</span> <span class=n>bestPieces4</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// 正确，没有调用构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>PEP</span><span class=o>*</span> <span class=n>bestPieces5</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PEP</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// 也正确
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 在指针数组里的每一个指针被重新赋值，以指向一个不同的EquipmentPiece对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>bestPieces5</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 为数组分配raw memory,可以避免浪费内存，使用placement new方法在内存中构造EquipmentPiece对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span><span class=o>*</span> <span class=n>rawMemory</span> <span class=o>=</span> <span class=k>operator</span> <span class=k>new</span><span class=p>[](</span><span class=mi>10</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>EquipmentPiece</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=c1>// make bestPieces6 point to it so it can be treated as an EquipmentPiece array
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>EquipmentPiece</span><span class=o>*</span> <span class=n>bestPieces6</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>EquipmentPiece</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>rawMemory</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// construct the EquipmentPiece objects in the memory使用&#34;placement new&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bestPieces6</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 以与构造bestPieces6对象相反的顺序解构它
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>9</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>bestPieces6</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=o>~</span><span class=n>EquipmentPiece</span><span class=p>();</span> <span class=c1>// 如果使用普通的数组删除方法，程序的运行将是不可预测的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// deallocate the raw memory
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>delete</span> <span class=p>[]</span> <span class=n>rawMemory</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=二运算符操作符>二、运算符(操作符)</h2><h3 id=条款-5-谨慎定义类型转换函数>条款 5: 谨慎定义类型转换函数</h3><ol><li>C++ 允许内置数据类型之间(例如char和int，int和double等)进行隐式转换，对于内置类型之间的隐式转换有详细的规则，但不管怎样，这些都是语言提供的，既相对安全，我们又无法更改。</li></ol><p>对于自定义的类类型，隐式转换可以通过<strong>单参数构造函数(single-argument constructors)<strong>和</strong>隐式类型转换操作符</strong>来实现。所谓”单一自变量(单参数)指的是可以有多个参数，但除了第一个参数其他参数必须有默认实参)。所谓隐式类型转换操作符，是一个 member function: 关键词operator 之后加一个类型名称，例如: <code>operator double() const</code>;</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=kt>double</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span> <span class=c1>// 将Rational 转换为 double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这个函数会在以下情况被自动调用:</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Rational</span> <span class=nf>r</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>  <span class=c1>// r的值是 1/2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>d</span> <span class=o>=</span> <span class=mf>0.5</span> <span class=o>*</span> <span class=n>r</span><span class=p>;</span> <span class=c1>// 将r的值转换为double，然后执行运算。
</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>但是下面这个情况就会出问题: <code>std::cout &lt;&lt; r</code>;</li></ol><p>如果你忘了为 Rational 类重载一个 operator&#171;，那么按道理应该打印不成功。但是编译器面对上述动作，它会想尽办法(包括找出一系列可接受的隐式类型转换)让函数调用动作成功。此时编译器发现 只需调用 Rational::operator double， 将 r 转换为 double，就可以成功调用 std::cout &#171; r;，以浮点数的形式输出。</p><p>解决办法就是以功能对等的另一个函数取代类型转换操作符。即: 定义一个 doube asDouble() const;函数。虽然使用时有些许不便，但“可因为不再默默调用那些不打算调用的函数而获得弥补”。C++ 标准库中的 string 类从没有 string 到 char* 的隐式类型转换操作符而采用 c_str 函数可能就是这个原因。</p><ol start=3><li>拥有单个参数(或除第一个参数外都有默认值的多参数)构造函数的类，很容易被隐式类型转换，最好加上 explicit 防止隐式类型转换。</li></ol><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Array</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Array</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[](</span><span class=kt>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=k>const</span> <span class=n>Array</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Array</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Array</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span> <span class=n>b</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]){</span> <span class=c1>//想要写 a[i] == b[i]，但是这时候编译器并不会报错
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//  do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><code>if(a == b[i])</code> 并不会报错。因为编译器发现只要调用 <code>Array\ constructor</code>(需一个 int 作为自变量)，就可以把 int 转为 <code>Array\ object</code>。就会产生类似这样的代码:</p><p><code>if( a == static_cast&lt;Array&lt;int> >(b[i]))</code> 将 <code>b[i]</code> 转为 <code>Array</code>。此时程序会正常运行，但是结果却不尽人意。</p><p>解决办法就是使用 C++ 特性: <font color=red>关键词 <code>explicit</code></font>。这个特性之所以被导入，就是为了解决隐式类型转换带来的问题。<code>explict Array(int size)</code>;</p><p>还有一种被称为 proxy classes 的方法:</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Array</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>ArraySize</span> <span class=p>{</span> <span class=c1>// 这个类是新的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  	<span class=n>ArraySize</span><span class=p>(</span><span class=kt>int</span> <span class=n>numElements</span><span class=p>)</span><span class=o>:</span><span class=n>theSize</span><span class=p>(</span><span class=n>numElements</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>  	<span class=kt>int</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>theSize</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  	<span class=kt>int</span> <span class=n>theSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>Array</span><span class=p>(</span><span class=kt>int</span> <span class=n>lowBound</span><span class=p>,</span> <span class=kt>int</span> <span class=n>highBound</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Array</span><span class=p>(</span><span class=n>ArraySize</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// 注意新的声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>这样写的代码在 Array\ a(10); 的时候，编译器会先通过类型转换将 int 转换成 ArraySize，然后再进行构造，虽然麻烦很多，效率也低了很多，但是在一定程度上可以避免隐式转换带来的问题。</p><p>对于自定义类型的类型转换，有一个规则: &ldquo;<strong>没有任何一个转换程序可以内含一个以上的‘用户定制转换行为’(亦即单自变量constructor亦即隐式类型转换操作符)</strong>"，也就是说，必要的时候编译器可以先进行内置类型之间的转换再调用带单自变量的构造函数或者先调用隐式类型转换操作符在进行内置类型之间的转换，但不可能连续进行两次用户定制的类型转换！</p><p>所以 此时 <code>if(a == b[i])</code> 就会报错。不能从 int 转换成 ArraySize，再从 ArraySize 转为 Array。</p><ol start=4><li>总结允许编译器执行隐式转换弊大于利，所以<strong>非必要不要提供转换函数</strong>！</li></ol><h3 id=条款-6-区别-incrementdecrement-操作符的前置和后置形式s>条款 6: 区别 increment/decrement 操作符的前置和后置形式s</h3><ol><li>由于 increment/decrement 操作符的前置和后置式都是一元运算符，没有参数。因此重载时通过在后置式中加一个 int 型参数(哑元参数)加以区分，当后置式被调用时，编译器自动在为该参数指定一个0值。</li></ol><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>UPInt</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>UPInt</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>++</span><span class=p>();</span>          <span class=c1>// 前置式++
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=n>UPInt</span> <span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>  <span class=c1>// 后置式++
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>UPInt</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>--</span><span class=p>();</span>          <span class=c1>// 前置式--
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=n>UPInt</span> <span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>  <span class=c1>// 前置式--
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>前置累加操作符和后置累加操作符实现:</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 前缀形式: 增加然后取回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>UPInt</span><span class=o>&amp;</span> <span class=n>UPInt</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=k>this</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 增加
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=c1>// 取回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// postfix form: fetch and increment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>UPInt</span> <span class=n>UPInt</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>UPInt</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>++</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 取回值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 增加
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>oldValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 返回被取回的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><strong>前置式返回 reference，后置式返回 const 对象！</strong></p><p>后置 operator++(int) 的叠加是不允许的，即: i++++。</p><p>原因有两个: 一是与内建类型行为不一致(内建类型支持前置叠加)；二是其效果跟调用一次 operator++(int) 效果一样，这是违反直觉的。另外，后置式操作符使用 operator++(int)，参数的唯一目的只是为了区别前置式和后置式而已，当函数被调用时，编译器传递一个0作为int参数的值传递给该函数。</p><ol start=2><li>处理用户定制类型时，应该尽可能使用前置式。</li><li>后置式increment 和decrement 操作符的实现应以其前置式兄弟为基础。如此一来你就只需维护前置式版本，因为后置式版本会自动调整为一致的行为。</li></ol><h3 id=条款-7-千万不要重载-和操作符>条款 7: 千万不要重载&&，|| 和，操作符</h3><p>C++ 对于“真假值表达式” 采用所谓的“短路” 评估方式(short-circuit evaluation)。意思是一旦该表达式的真价值确定，及时表达式中还以后部分尚未检验，整个评估工作仍然结束。</p><p>“函数调用”语义和所谓的“短路” 评估方式语义有两个重大的区别。第一，当函数调用动作被执行，所有参数值都必须评估完成，所以当我们调用 operator&&和 operator||时，两个参数都已评估完成。换句话说没有什么骤死式语义。第二，C++语言规范并未明确定义函数调用动作中各参数的评估顺序，所以没办法知道expression1 和 expression2 哪个会先被评估。这与骤死式评估法形成一个明确的对比，后者总是由左向右评估其自变量。</p><p>C++同样也有一些规则用来定义逗号操作符面对内建类型的行为。表达式如果内含逗号，那么逗号左侧会先被评估，然后逗号的右侧再被评估；最后，整个逗号表达式的结果以逗号右侧的值为代表。</p><p>你不能重载以下操作符:</p><table><thead><tr><th style=text-align:center><code>.</code></th><th style=text-align:center><code>.*</code></th><th style=text-align:center><code>::</code></th><th style=text-align:center><code>?:</code></th></tr></thead><tbody><tr><td style=text-align:center><code>new</code></td><td style=text-align:center><code>delete</code></td><td style=text-align:center><code>sizeof</code></td><td style=text-align:center><code>typeid</code></td></tr><tr><td style=text-align:center><code>static_cast</code></td><td style=text-align:center><code>dynamic_cast</code></td><td style=text-align:center><code>const_cast</code></td><td style=text-align:center><code>reinterpret_cast</code></td></tr></tbody></table><h3 id=条款8-了解各种不同意义的-new-和-delete>条款8: 了解各种不同意义的 new 和 delete</h3><ul><li><p><strong>new operator</strong>: new操作符，用于动态分配内存并进行初始化, 它的动作分为两方面。第一，它分配足够的内存，用来放置某类型的对象。以上例而言，它分配足够放置一个string 对象的内存。第二，它调用一个 constructor，为刚才分配的内存中的那个对象设定初值。;</p><ul><li>new operator，不能被重载</li><li>当你写出这样的代码:<div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>string</span> <span class=o>*</span><span class=n>ps</span> <span class=o>=</span> <span class=k>new</span> <span class=n>string</span><span class=p>(</span><span class=err>“</span><span class=n>Memory</span> <span class=n>Mangement</span><span class=err>”</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div>你所使用的 new 是所谓的 new operator。它的动作分为两个方面: 1、分配足够的内存，用来放置某类型的对象；2、调用 constructor，为刚才的内存中的那个对象设定初值。</li></ul></li><li><p><strong>operator new</strong>: 标准库的函数，只分配内存不进行初始化(或者传递一个可用的内存地址)，可以自己进行重载，也可以主动调用。</p><ul><li>和 malloc 一样，operator new 的唯一任务就是分配内存。</li><li><code>void *rawMemory = operator new(sizeof(string));</code> 返回值类型是 void* ！！！</li><li>可以<strong>重载</strong> operator new，但是第一个参数类型必须总是 size_t。</li><li><code>string *ps = new string("Memory Mangement");</code>等价于<div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=n>rawMemory</span> <span class=o>=</span> <span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>string</span><span class=p>));</span>   <span class=c1>// 取得原始内存，用来存放有一个string对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>call</span> <span class=n>string</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;Memory Mangement&#34;</span><span class=p>)</span> <span class=n>on</span> <span class=o>*</span><span class=n>memory</span><span class=p>;</span> <span class=c1>// 将内存中的对象初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=o>*</span><span class=n>ps</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>string</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>memory</span><span class=p>);</span> <span class=c1>// 让ps 指向新完成的对象
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><strong>placement new (定位new)</strong>: new operator的另外一种用法 ，在已分配的内存上构造对象;</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>注意: new operator是操作符，placement new是这个操作符的一种用法，而operator new是标准库中的函数，new operator调用了 operator new。</p><ol><li>将对象产生与 heap，请使用 new operator。它不但分配内存而且为该对象调用一个 constructor。</li><li>如果你只是打算分配内存，请调用 operator new，那就没有任何 constructor 会被调用。</li><li>如果你打算在 heap objects 产生时自己决定内存分配方式，请写一个自己的 operator new，并使用 new operator，它会自动调用你所写的 operator new。</li><li>如果你打算在已分配并拥有指针的内存中构造对象，请使用 placement new。</li></ol></div></div></div><h2 id=三-异常>三、 异常</h2><p>程序之所以在 exceptions 出现时仍有良好行为，不是因为碰巧如此，而是因为它们加入了 exceptions 的考虑。</p><p>exceptions 无法被忽略。如果一个函数利用“设定状态变量”的方式或是利用“返回错误码”的方式发出一个异常信号，无法保证此函数的调用者会检查那个变量或检验那个错误码。于是程序的执行可能会一直继续下去，远离错误发生地点。但是如果函数以抛出 exception 的方式发出异常信号，而该 exception 未被捕捉，程序的执行便会立刻中止。</p><p>如果你需要一个“绝对不会被忽略的”异常信号发射方法，而且发射后的 stack处理过程又能够确保局部对象的 destructors 被调用，那么你需要 C++exceptions。它是最简单的方法了。</p><h3 id=条款-9-利用-destructors-避免泄漏资源>条款 9: 利用 destructors 避免泄漏资源</h3><p>每当 new 一个新的对象，一定要确保成功 delete 它，否则就会造成内存泄漏。</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processAdoptions</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>(</span><span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    	<span class=n>ALA</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=n>readALA</span><span class=p>(</span><span class=n>dataSource</span><span class=p>);</span> <span class=c1>// new 新的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pa</span><span class=o>-&gt;</span><span class=n>processAdoption</span><span class=p>();</span> <span class=c1>// 处理事务
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>pa</span><span class=p>;</span> <span class=c1>// 删除pa指向的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>但是如果 <code>pa->processAdoption();</code>抛出异常，之后的所有语句都会被跳过，不再执行，这意味着 <code>deleta pa;</code>不会执行，造成内存泄漏。</p><p>解决方法1:</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processAdoptions</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>ALA</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=n>readALA</span><span class=p>(</span><span class=n>dataSource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pa</span><span class=o>-&gt;</span><span class=n>processAdoption</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span><span class=p>(...){</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>pa</span><span class=p>;</span> <span class=c1>//在抛出异常的时候避免泄露
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>throw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>pa</span><span class=p>;</span> <span class=c1>//在不抛出异常的时候避免泄
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>因为这种情况会需要删除两次pa，代码维护很麻烦，所以需要进行优化:</p><p>只要我们能够将 “一定得执行的清理代码” 移到 processAdoptions 函数的某个局部对象的 destructors 内即可。因为局部对象总是会在函数结束时被析构，不论函数如何结束。</p><p>如何把 delete 动作从 processAdoptions 函数移到函数内的某个局部对象的 destructor 内: 以一个 “类似指针的对象(智能指针)”取代指针 pa。当这个类似指针的对象被(自动)销毁，我们可以令其 destructor 调用 delete。</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processAdoptions</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>ALA</span><span class=o>&gt;</span> <span class=n>pa</span><span class=p>(</span><span class=n>readALA</span><span class=p>(</span><span class=n>dataSource</span><span class=p>));</span> <span class=c1>// 现在auto_ptr已被弃用，推荐使用 shared_ptr!!!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pa</span><span class=o>-&gt;</span><span class=n>processAdoption</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款-10-在-constructors-内阻止资源泄漏resource-leak>条款 10: 在 constructors 内阻止资源泄漏(resource leak)</h3><p>考虑下面的情况:</p><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::</span><span class=n>BookEntry</span><span class=p>()</span><span class=o>:</span><span class=n>theImage</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>theAudioClip</span><span class=p>(</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>theImage</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>theAudioClip</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AudioClip</span><span class=p>(</span><span class=n>audioClipFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::~</span><span class=n>BookEntry</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=n>theImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>theAudioClip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>如果 <code>theAudioClip = new AudioClip(audioClipFileName);</code> 有 exception 抛出，那么函数构造失败，destructor 自然不会被调用。但是 theImage 对象构造成功了，这就导致 BookEntry constructor 所分配的 Image object 还是泄漏了。</p><p>由于C++ 不自动清理那些 “构造期间抛出 exceptions” 的对象，所以你必须设计你的 constructor，使得它们能够自动清理。通常只需将所有可能的 exceptions 捕捉起来，执行某种清理工作，然后重新抛出 exception，使它继续传播出去即可。</p><p>解决办法一:</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::</span><span class=n>BookEntry</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=n>theImage</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    	<span class=n>theAudioClip</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AudioClip</span><span class=p>(</span><span class=n>audioClipFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span><span class=p>(...){</span> <span class=c1>// 在构造函数内捕捉异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=k>delete</span> <span class=n>theImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=k>delete</span> <span class=n>theAudioClip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=k>throw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>一个更好的解答是，接收条款9的忠告，将 theImage 和 theAudioClip 所指对象视为资源，交给局部对象来管理。 不论 theImage 和 theAudioClip 都是指向动态分配而得的对象，当指针本身停止活动，那些对象都应该被删除。</p><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BookEntry</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span><span class=p>......</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>Image</span><span class=o>&gt;</span> <span class=n>theImage</span><span class=p>;</span> <span class=c1>// 同样的，现在auto_ptr已被弃用，推荐使用 shared_ptr!!!
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>const</span> <span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>AudioClip</span><span class=o>&gt;</span> <span class=n>theAudioClip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::</span><span class=n>BookEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>imageFileName</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>audioClipFileName</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>theImage</span><span class=p>(</span><span class=n>imageFileName</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=o>?</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageFileName</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=n>theAudioClip</span><span class=p>(</span><span class=n>audioClipFileName</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=o>?</span> <span class=k>new</span> <span class=n>AudiaClip</span><span class=p>(</span><span class=n>audioClipFileName</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span></span></span></code></pre></td></tr></table></div></div><p>这样不仅解决了在 constructors 内阻止资源泄漏，而且还大幅简化 destructor。</p><p><code>BookEntry::~BookEntry(){} // 不需要做什么事！</code></p><h3 id=条款-11-禁止异常exceptions流出destructors之外>条款 11: 禁止异常(exceptions)流出destructors之外</h3><p>两种情况下 destructor 会被调用。第一种情况是当对象在正常状态下被销毁，也就是当它离开了它的生存空间(scope)或是被明确地删除；第二种情况是当对象被 exception 处理机制——也就是exception 传播过程中的 stack-unwinding(栈展开)机制——销毁。</p><p>因为如果控制权基于 exception 的因素离开 destructor，而此时正有另一个 exception 处于作用状态，C++会调用 terminate 函数。此函数的作为正如其名: 将你的程序结束掉——它会立刻动手，甚至不等局部对象被销毁。</p><p>因此，有两个好理由支持我们“全力阻止exceptions传出 destructors之外”。第一，它可以避免 terminate函数在 exception传播过程的栈展开(stack-unwinding)机制中被调用；第二，它可以协助确保 destructors 完成其应该完成的所有事情。</p><p>如何避免exception传出destructor之外呢?</p><p><strong>在析构函数中使用<code>try{} catch(){}</code>结构, 并且在catch的<code>{}</code>中什么也不做。</strong></p><h3 id=条款12-了解抛出一个exception与传递一个参数或调用一个虚函数之间的差异>条款12: 了解“抛出一个exception”与“传递一个参数”或“调用一个虚函数”之间的差异</h3><p>你调用函数时，程序的控制权最终还会返回到函数的调用处，但是当你抛出一个异常时，控制权永远不会回到抛出异常的地方。</p><p>C++规范要求被作为异常抛出的对象必须被复制。即使被抛出的对象不会被释放，也会进行拷贝操作。抛出异常运行速度比参数传递要慢。</p><p>当异常对象被拷贝时，拷贝操作是由对象的拷贝构造函数完成的。该拷贝构造函数是对象的静态类型(static type)所对应类的拷贝构造函数，而不是对象的动态类型(dynamic type)对应类的拷贝构造函数。</p><p>catch子句中进行异常匹配时可以进行两种类型转换:</p><ul><li>第一种是继承类与基类间的转换。一个用来捕获基类的catch子句也可以处理派生类类型的异常。这种派生类与基类(inheritance_based)间的异常类型转换可以作用于数值、引用以及指针上。</li><li>第二种是允许从一个类型化指针(typed pointer)转变成无类型指针(untyped pointer)，所以带有const void*指针的catch子句能捕获任何类型的指针类型异常。</li></ul><p>catch子句匹配顺序总是取决于它们在程序中出现的顺序。因此一个派生类异常可能被处理其基类异常的catch子句捕获，即使同时存在有能直接处理该派生类异常的catch子句，与相同的try块相对应。不要把处理基类异常的catch子句放在处理派生类异常的catch子句的前面。</p><p>把一个对象传递给函数或一个对象调用虚拟函数与把一个对象作为异常抛出，这之间有三个主要区别:</p><ul><li>第一，异常对象在传递时总被进行拷贝；当通过传值方式捕获时，异常对象被拷贝了两次。对象作为参数传递给函数时不一定需要被拷贝。</li><li>第二，对象作为异常被抛出与作为参数传递给函数相比，前者类型转换比后者要少(前者只有两种转换形式)。</li><li>最后一点，catch子句进行异常类型匹配的顺序是它们在源代码中出现的顺序，第一个类型匹配成功的catch将被用来执行。当一个对象调用一个虚拟函数时，被选择的函数位于与对象类型匹配最佳的类里，即使该类不是在源代码的最前头。</li></ul><p>try_catch 介绍参考: <a href=https://blog.csdn.net/fengbingchun/article/details/65939258 target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/fengbingchun/article/details/65939258<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><h3 id=条款13-以-by-reference方式捕捉-exceptions>条款13: 以 by reference方式捕捉 exceptions</h3><p><strong>catch by pointer的问题:</strong>
他们是否应该删除他们接受的指针？如果是在堆中建立的异常对象，那他们必须删除它，否则会造成资源泄漏。如果不是在堆中建立的异常对象，他们绝对不能删除它，否则程序的行为将不可预测。通过指针捕获异常，将遇到一个哈姆雷
特式的难题: 是删除还是不删除？这是一个难以回答的问题。所以你最好避开它。</p><p><strong>catch by value的问题:</strong></p><ul><li>当它们被抛出时系统将对异常对象拷贝两次(参见条款 M12)。</li><li>当抛出的是派生类对象，但是用基类捕获，会场生slicing 问题。</li></ul><p><strong>catch by reference的优势:</strong>
如果 catch by reference，你就可以避开对象删除问题，你也可以避开 exception objects 的切割(slicing)问题；你可以保留捕捉标准 exceptions 的能力；你也约束了 exception objects 需被复制的次数。</p><p>通过指针捕获异常不符合C++语言本身的规范。四个标准的异常&mdash;-bad_alloc(当operator new不能分配足够的内存时被抛出)；bad_cast(当dynamic_cast针对一个引用(reference)操作失败时被抛出)；bad_typeid(当dynamic_cast对空指针进行操作时被抛出)；bad_exception(用于unexpected异常)&mdash;-都不是指向对象的指针，所以你必须通过值或引用来捕获它们。</p><p>std::exception的介绍参考: <a href=https://blog.csdn.net/fengbingchun/article/details/78303734 target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/fengbingchun/article/details/78303734<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><h3 id=条款14-审慎使用异常规格exception-specifications>条款14: 审慎使用异常规格(exception specifications)</h3><p>如果一个函数抛出一个不在异常规格范围里的异常，系统在运行时能够检测出这个错误，然后一个特殊函数std::unexpected将被自动地调用(This function is automatically called when a function throws an exception that is not listed in its dynamic-exception-specifier.)。std::unexpected缺省的行为是调用函数std::terminate，而std::terminate缺省的行为是调用函数abort。应避免调用std::unexpected。</p><ul><li><strong>避免踏上 unexpected之路的第一个技术是:</strong> 不应该将 templates 和 exceptionspecifications 混合使用。</li><li><strong>避免踏上 unexpected之路的第二个技术是:</strong> 如果A 函数内调用了 B 函数，而B 函数无 exceptionspecifications，那么 A 函数本身也不要设定exception specifications。</li><li><strong>避免踏上 unexpected 之路的第三个技术是:</strong> 处理“系统”可能抛出的exceptions。其中最常见的就是 bad_alloc，那是在内存分配失败时由operator new和 operator new[]抛出的(见条款8)。</li></ul><h3 id=条款15-了解异常处理的系统开销>条款15: 了解异常处理的系统开销</h3><p>异常功能是需要一定开销的,即使是完全没有进行使用,虽然在某些情况下可以进行异常功能的关闭,但前提是,当前的所有代码所有模块都没有进行异常功能的使用,一旦有一个模块使用了异常,将导致程序无法运行.</p><p>抛出异常这个工作是比较消耗资源的,相对于平常的函数返回值,大约是3倍的资源消耗,但是不必恐慌,除非将异常作为了一种常规手段,否则偶尔的使用基本是不会影响整体效率的</p><p>异常功能整体上会使程序变大 5%~10%,同时也一定比例的减慢程序的运行速度.</p><p>这就是异常处理的系统开销。</p><h2 id=四效率>四、效率</h2><p>本章的内容从两个角度阐述效率的问题。</p><ul><li>第一是从语言独立的角度，关注那些你能在任何语言里都能使用的东西。C++为它们提供了特别吸引人的实现途径，因为它对封装的支持非常好，从而能够用更好的算法与数据结构来替代低效的类似实现，同时接口可以保持不变。</li><li>第二是关注 C++语言本身。高性能的算法与数据结构虽然非常好，但如果实
际编程中代码实现得很粗糙，效率也会降低得相当多。潜在危害性最大的错误是
既容易犯而又不容易察觉的错误，濒繁地构造和释放大量的对象就是一种这样的
错误。过多的对象构造和对象释放对于你的程序性能来说就象是在大出血，在每
次建立和释放不需要的对象的过程中，宝贵的时间就这么流走了。这个问题在
C++程序中很普遍，我将用四个条款来说明这些对象从哪里来的，在不影响程序
代码正确性的基础上又如何消除它们。</li></ul><h3 id=条款16-谨记-80-20-法则>条款16: 谨记 80-20 法则</h3><p>80-20准则说的是大约20%的代码使用了80%的程序资源；大约20%的代码耗用了大约80%的运行时间；大约20%的代码使用了80%的内存；大约20%的代码执行80%的磁盘访问；80%的维护投入于大约20%的代码上。</p><p><strong>基本的观点:</strong> 软件整体的性能取决于代码组成中的一小部分。一个程序大量的资源是消耗在少部分的代码上面,所有的程序都符合这个规则,所以,我们要做的并不是对每一处代码都进行优化,虽然这么做固然很好,但是每个人的能力和精力是一个固定值,一味的优化80%部分的代码,提升的效果可能达不到20%中的几行代码,我们要善于利用各种工具,找到真正需要进行优化的逻辑,然后去进行优化.</p><h3 id=条款17-考虑使用-lazy-evaluation缓式评估>条款17: 考虑使用 lazy evaluation(缓式评估)</h3><p>lazy evaluation(缓式评估)。一旦你采用 lazy evaluation，就是以某种方式撰写你的 classes，使它们延缓运算，直到那些运算结果刻不容缓地被迫切需要为止。如果其运算结果一直不被需要，运算也就一直不执行。</p><ul><li><strong>引用计数</strong>
这种“数据共享”的行动细节(及相应代码)在条款 29有详细叙述，其观念便是 lazy evaluation：在你真正需要之前，不必着急为某物做一个副本。取而代之的是，以拖延战术应付之——只要能够，就使用其他副本。在某些应用领域，你常有可能永远不需要提供那样一个副本。</li><li><strong>区别对待读取和写入</strong><div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>string</span> <span class=n>s</span> <span class=o>=</span> <span class=s>&#34;Homer&#39;s liad&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;x&#39;</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div>首先调用 operator[]用来读取 string 的部分值，但是第二次调用该函数是为了完成写操作。我们应能够区别对待读调用和写调用，因为读取reference-counted string 是很容易的，而写入这个 string 则需要在写入前对该string 值制作一个新拷贝。
为了能够这样做，需要在 operator[]里采取不同的措施(根据是为了完成读取操作而调用该函数还是为了完成写入操作而调用该函数)。我们如果判断调用 operator[]的 context 是读取操作还是写入操作呢？残酷的事实是我们不可能判断出来。通过使用 lazy evaluation 和条款 M30 中讲述的proxy class，我们可以推迟做出是读操作还是写操作的决定，直到我们能判断出正确的答案。</li><li><strong>Lazy Fetching (懒惰提取)</strong>
实现 lazy fetching 时，你必须面对一个问题：null 指针可能会在任何 member functions(包括const member functions，如 field1)内被赋值，以指向真正的数据。然而当你企图在 constmember functions 内修改 data members，编译器不会同意。所以你必须用某种方法告诉编译器说：“放轻松，我知道我正在干什么”。说这句话的最好方法就是将指针字段声明为 mutable，意思是这样的字段可以在任何member function 内被修改，甚至是在 const member functions 内(见条款 E21)。</li><li><strong>Lazy Expression Evaluation(懒惰表达式计算)</strong>
lazy evaluation 在许多领域中都可能有用途：可避免非必要的对象复制，可区别 operator[]的读取和写动作，可避免非必要的数据库读取动作，可避免非必要的数值计算动作。</li></ul><h3 id=条款18-分期摊还预期的计算成本>条款18: 分期摊还预期的计算成本</h3><p>现在我鼓励你改善软件性能的方法是：令你的代码超前进度地做“要求以外”的更多工作。此条款背后的哲学可称为超急评估(over-eager evaluation): 在被要求之前就先把事情做下去。</p><p>Over-eager evaluation 背后的观念是，如果你预期程序常常会用到某个计算，你可以降低每次计算的平均成本，办法就是设计一份数据结构以便能够极有效率地处理需求。</p><p><strong>Caching</strong> 是“分期摊还预期计算之成本”的一种做法,即caching(缓存)那些已经被计算出来而以后还有可能需要的值。</p><p><strong>Prefetching</strong>(预先取出)是另一种做法。Prefetch需要空间放置被 prefetch 的东西，但是它减少了访问它们所需
的时间。</p><p>以上两种方法都是通过<strong>以空间换时间</strong>的方式来提高代码的运行效率。</p><p>可通过over-eager evaluation 如 caching和prefetching 等做法分期摊还预期运算成本——和我在条款 17 所提的 lazy evaluation 并不矛盾。当你必须支持某些运算而其结果并不总是需要的时候，lazy evaluation 可以改善程序效率。当你必须支持某些运算而其结果几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation 可以改善程序效率。</p><h3 id=条款19-理解临时对象的来源>条款19: 理解临时对象的来源</h3><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>countChar</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>,</span> <span class=kt>char</span> <span class=n>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 建立一个string类型的临时对象，通过以buffer做为参数调用string的构造函数来初始化这个临时对象,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// countChar的参数str被绑定在这个临时的string对象上，当countChar返回时，临时对象自动释放
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// 将countChar(const std::string&amp; str, char ch)修改为countChar(std::string&amp; str, char ch)则会error
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_STRING_LEN 64
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_19</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=n>MAX_STRING_LEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>setw</span><span class=p>(</span><span class=n>MAX_STRING_LEN</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;There are &#34;</span><span class=o>&lt;&lt;</span><span class=n>countChar</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>c</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=s>&#34; occurrences of the character &#34;</span><span class=o>&lt;&lt;</span><span class=n>c</span><span class=o>&lt;&lt;</span><span class=s>&#34; in &#34;</span><span class=o>&lt;&lt;</span><span class=n>buffer</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>C++真正的所谓的临时对象是不可见的——不会在你的源代码中出现。只要你产生一个 non-heap object(非堆对象) 而没有为它命名，便诞生了一个临时对象。此等匿名对象通常发生于两种情况：一是当隐式类型转换(implicit type conversions)被施行起来以求函数调用能够成功；二是当函数返回对象的时候。</p><p>仅当通过传值(by value)方式传递对象或传递常量引用(reference-to-const)参数时，才会发生这些类型转换。当传递一个非常量引用(reference-to-non-const)参数对象，就不会发生。</p><p>C++语言禁止为**非常量引用(reference-to-non-const)**产生临时对象。</p><p>在这些优化策略中，最常见也最有用的就是所谓的“返回值优化(return value optimization)”。</p><p>临时对象可能很耗成本，所以你应该尽可能消除它们。然而更重要的是，如何训练出锐利的眼力，看出可能产生临时对象的地方。任何时候只要你看到一个 reference-to-const 参数，就极可能会有一个临时对象被产生出来绑定至该参数上。任何时候只要你看到函数返回一个对象，就会产生临时对象(并于稍后销毁)。</p><h3 id=条款20-协助完成返回值优化-rvo>条款20: 协助完成返回值优化 (RVO)</h3><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational20</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Rational20</span><span class=p>(</span><span class=kt>int</span> <span class=n>numerator</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>denominator</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=nf>numerator</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=nf>denominator</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>2</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Rational20</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational20</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Rational20</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 以某种方法返回对象，能让编译器消除临时对象的开销：这种技巧是返回constructor argument而不是直接返回对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>Rational20</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>numerator</span><span class=p>()</span> <span class=o>*</span> <span class=n>rhs</span><span class=p>.</span><span class=n>numerator</span><span class=p>(),</span> <span class=n>lhs</span><span class=p>.</span><span class=n>denominator</span><span class=p>()</span> <span class=o>*</span> <span class=n>rhs</span><span class=p>.</span><span class=n>denominator</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_20</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Rational20</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Rational20</span> <span class=n>b</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Rational20</span> <span class=n>c</span> <span class=o>=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>我们可以用某种特殊写法来撰写函数，使它在返回对象时，能够让编译器消除临时对象的成本。我们的伎俩是：<strong>返回所谓的 constructor arguments以取代对象。</strong></p><p>此特殊的优化行为——利用函数的 return 点消除一个局部临时对象（并可能用函数调用端的某对象取代）——不但广为人知而且很普遍地被实现出来。它甚至有个专属名称：return value optimization。</p><h3 id=条款21-通过重载避免隐式类型转换>条款21: 通过重载避免隐式类型转换</h3><div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>UPInt21</span> <span class=p>{</span> <span class=c1>// unlimited precision integers class
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>UPInt21</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=n>UPInt21</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>UPInt21</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>UPInt21</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>UPInt21</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=c1>// add UPInt21+UPInt21
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>UPInt21</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>UPInt21</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>UPInt21</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rhs</span><span class=p>)</span> <span class=c1>// add UPInt21+int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>UPInt21</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>UPInt21</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>int</span> <span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>UPInt21</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=c1>// add int+UPInt21
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>UPInt21</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_21</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>UPInt21</span> <span class=n>upi1</span><span class=p>,</span> <span class=n>upi2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>UPInt21</span> <span class=n>upi3</span> <span class=o>=</span> <span class=n>upi1</span> <span class=o>+</span> <span class=n>upi2</span><span class=p>;</span> <span class=c1>// 正确，没有由upi1或upi2生成临时对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>upi3</span> <span class=o>=</span> <span class=n>upi1</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// 正确,没有由upi1或10生成临时对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>upi3</span> <span class=o>=</span> <span class=mi>10</span> <span class=o>+</span> <span class=n>upi2</span><span class=p>;</span> <span class=c1>// 正确，没有由10或upi2生成临时对象
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// 注意：注释掉上面的operator+(UPInt21&amp;, int)和operator+(int, UPInt21&amp;)也正确，但是会通过临时对象把10转换为UPInt21
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在C++中有一条规则是每一个重载的operator必须带有一个用户定义类型(user-defined type)的参数。</p><p>利用重载避免临时对象的方法不只是用在operator函数上。</p><p>没有必要实现大量的重载函数，除非你有理由确信程序使用重载函数以后其整体效率会有显著的提高。</p><h3 id=条款22-考虑用运算符的赋值形式op取代其单独形式op>条款22: 考虑用运算符的赋值形式(op=)取代其单独形式(op)</h3><div class=highlight id=id-23><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational22</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Rational22</span><span class=p>(</span><span class=kt>int</span> <span class=n>numerator</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>denominator</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=n>Rational22</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>+=</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational22</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>Rational22</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>-=</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational22</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// operator+根据operator+=实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>Rational22</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational22</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Rational22</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>Rational22</span><span class=p>(</span><span class=n>lhs</span><span class=p>)</span> <span class=o>+=</span> <span class=n>rhs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// operator-根据operator-=实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>Rational22</span> <span class=k>operator</span><span class=o>-</span><span class=p>(</span><span class=k>const</span> <span class=n>Rational22</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Rational22</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>Rational22</span><span class=p>(</span><span class=n>lhs</span><span class=p>)</span> <span class=o>-=</span> <span class=n>rhs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>就C++来说，operator+、operator=和operator+=之间没有任何关系，因此如果你想让三个operator同时存在并具有你所期望的关系，就必须自己实现它们。同理，operator-, *, /, 等等也一样。</p><p>要确保操作符的复合形式（例如，operator+=）和其独身形式（例如，operator+）之间的自然关系能够存在，一个好方法就是以前者为基础实现后者（见条款 6）。</p><p>3 个与效率有关的情况值得注意:</p><ul><li>第一，一般而言，复合操作符比其对应的独身版本效率高，因为独身版本通常必须返回一个新对象，而我们必须因此负担一个临时对象的构造和析构成本（见条款 19和 20及条款 E23）。至于复合版本则是直接将结果写入其左端自变量，所以不需要产生一个临时对象来放置返回值。</li><li>第二，如果同时提供某个操作符的复合形式和独身形式，便允许你的客户在效率与便利性之间做取舍（虽然那是极其困难的抉择）。</li><li>第三、自古以来匿名对象总是比命名对象更容易被消除，所以当你面临命名对象或临时对象的抉择时，最好选择临时对象。它应该绝不会比其命名兄弟耗用更多成本，反倒是极有可能降低成本（尤其在搭配旧式编译器时）。</li></ul><h3 id=条款23-考虑使用其他程序库>条款23: 考虑使用其他程序库</h3><p>不同的程序库在效率、可扩展性、移植性、类型安全和其它一些领域上蕴含着不同的设计理念，通过变换使用给予性能更多考虑的程序库，你有时可以大幅度地提供软件的效率。</p><p>重点是，不同的程序库即使提供相似的机能，也往往表现出不同的性能取舍策略，所以一旦你找出程序的瓶颈（通过分析器，见条款16），你应该思考是否有可能因为改用另一个程序库而移除了那些瓶颈。</p><h3 id=条款24-理解虚拟函数多继承虚基类和rtti所需的代码>条款24: 理解虚拟函数、多继承、虚基类和RTTI所需的代码</h3><p>当调用一个虚拟函数时，被执行的代码必须与调用函数的对象的动态类型相一致；指向对象的指针或引用的类型是不重要的。大多数编译器是使用virtual table和virtual table pointers，通常被分别地称为vtbl和vptr。</p><p>一个vtbl通常是一个函数指针数组。(一些编译器使用链表来代替数组，但是基本方法是一样的)在程序中的每个类只要声明了虚函数或继承了虚函数，它就有自己的vtbl，并且类中vtbl的项目是指向虚函数实现体的指针。例如，如下这个类定义:</p><div class=highlight id=id-24><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>C1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>C1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=o>~</span><span class=n>C1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>f2</span><span class=p>(</span><span class=kt>char</span> <span class=n>c</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>f3</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>f4</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>C1 的 virtual table 数组看起来如下图所示：</p><p><img loading=lazy src=images/4-24-1.png srcset="images/4-24-1.png, images/4-24-1.png 1.5x, images/4-24-1.png 2x" sizes=auto data-title=images/4-24-1.png data-alt=images/4-24-1.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>vtbl 通常是一个由“函数指针”架构而成的数组。某些编译器会以链表（linked list）取代数组，但其基本策略相同。程序中的每一个class 凡声明（或继承）虚函数者，都有自己的一个 vtbl，而其中的条目（entries）就是该 class 的各个虚函数实现体的指针。</p><p>这份讨论带出虚函数的第一个成本：你必须为每个拥有虚函数的class耗费一个vtbl 空间，其大小视虚函数的个数（包括继承而来的）而定。类的vtbl的大小与类中声明的虚函数的数量成正比(包括从基类继承的虚函数)。每个类应该只有一个virtual table，所以virtual table所需的空间不会太大，但是如果你有大量的类或者在每个类中有大量的虚函数，你会发现vtbl会占用大量的地址空间。</p><p>Virtual tables 只是虚函数实现机构的一半而已。如果只有它，不能成气候。一旦有某种方法可以指示出每个对象相应于哪一个 vtbl，vtbl 才真的有用。而这正是virtual table pointer（vptr）的任务。
关于虚函数表的介绍参考：https://blog.csdn.net/fengbingchun/article/details/79592347</p><p>凡声明有虚函数的 class，其对象都含有一个隐藏的 data member，用来指向该class 的 vtbl。这个隐藏的 data member——所谓的vptr——被编译器加入对象内某个唯编译器才知道的位置。</p><p>此刻，只需注意到虚函数的第二个成本：你必须在每一个拥有虚函数的对象内付出“一个额外指针”的代价。</p><p>编译器必须产生代码，完成以下动作：
1.根据对象的 vptr 找出其 vtbl。这是一个简单的动作，因为编译器知道到对象的哪里去找出 vptr（毕竟那个位置正是编译器决定的）。成本只有一个偏移调整（offset adjustment，以便获得 vptr）和一个指针间接动作（以便获得 vtbl）。
2.找出被调用函数（本例为 f1）在 vtbl 内的对应指针。这也很简单，因为编译器为每个虚函数指定了一个独一无二的表格索引。本步骤的成本只是一个差移（offset）以求进入 vtbl 数组。
3.调用步骤 2所得指针所指向的函数。</p><p>一些原因导致现在的编译器一般总是忽略虚函数的inline指令。虚函数真正的运行时期成本发生在和 inlining 互动的时候。对所有实用目的而言，虚函数不应该 inlined。因为“inline”意味“在编译期，将调用端的调用动作被调用函数的函数本体取代”，而“virtual”则意味着“等待，直到运行时期才知道哪个函数被调用”。(这是因为”内联”是指”在编译期间用被调用的函数体本身来代替函数调用的指令”，但是虚函数的”虚”是指”直到运行时才能知道要调用的是哪一个函数”。) 当编译器面对某个调用动作，却无法知道哪个函数该被调用时，你就可以了解为什么它们没有能力将该函数调用加以 inlining了。这便是虚函数的第三个成本：你事实上等于放弃了 inlining。</p><p>运行时期类型辨识（runtime typeidentification，RTTI）的成本。RTTI 让我们得以在运行时期获得 objects 和 classes 的相关信息，所以一定得有某些地方用来存放那些信息才行——是的，它们被存放在类型为 type_info 的对象内。你可以利用 typeid 操作符取得某个class 相应的 type_info 对象。</p><p>C++规范书上说，只有当某种类型拥有至少一个虚函数，才保证我们能够检验该类型对象的动态类型。这使得 RTTI 相关信息听起来有点像一个 vtbl：面对一个 class，我们只需一份相关信息，而我们需要某种方法，让任何一个内含虚函数的对象都有能力取得其专属信息。RTTI 和vtbl 之间的这种平行关系并非偶发，RTTI 的设计理念是：根据 class 的 vtbl来实现。</p><p>关于typeid的使用参考：https://blog.csdn.net/fengbingchun/article/details/51866559</p><p>RTTI被设计为在类的vtbl基础上实现。</p><h2 id=五技术-techniquesidiomspatterns>五、技术 (Techniques，Idioms，Patterns)</h2><h3 id=条款25-将构造函数和非成员函数虚拟化>条款25: 将构造函数和非成员函数虚拟化</h3><p>由于它产生新对象，所以行为仿若 constructor，但它能够产生不同类型的对象，所以我们称它为一个 virtual constructor。所谓 virtualconstructor 是某种函数，视其获得的输入，可产生不同类型的对象。<strong>Virtual constructors 在许多情况下有用，其中之一就是从磁盘（或网络或磁带等）读取对象信息。</strong></p><p>有一种特别的 virtual constructor——所谓 virtual copyconstructor——也被广泛地运用。Virtual copy constructor 会返回一个指针，指向其调用者（某对象）的一个新副本。基于这种行为，virtual copy constructors 通常以 copySelf 或cloneSelf 命名，或者像下面一样命名为 clone。</p><p>当 derived class 重新定义其base class 的一个虚函数时，不再需要一定得声明与原本相同的返回类型。如果函数的返回类型是个指针（或reference），指向一个base class，那么 derived class 的函数可以返回一个指针（或reference），指向该 base class 的一个 derived class。</p><p>既然一个函数能够构造出不同类型的新对象是可以理解的，那么同样也存在这样的非成员函数，可以根据参数的不同动态类型而其行为特性也不同。</p><h3 id=条款26-限制某个类所能产生的对象数量>条款26: 限制某个类所能产生的对象数量</h3><p>每当即将产生一个对象，我们确知一件事情：会有一个 constructor被调用。“阻止某个 class 产出对象”的最简单方法就是将其constructors 声明为 private。</p><h3 id=条款27-要求或禁止对象产生于-heap之中>条款27: 要求（或禁止）对象产生于 heap之中</h3><p>所谓 abstract base class是一个不能够被实例化的 base class。也就是说它至少有一个纯虚函数。所谓 mixin（“mix in”）class则提供一组定义完好的能力，能够与其derived class所可能提供的其他任何能力（条款 E7）兼容。如此的 classes几乎总是abstract。我们于是可以形成一个所谓的 abstract mixin base class，用来为 derivedclasses提供“判断某指针是否以 operator new 分配出来”的能力。</p><h3 id=条款28-灵巧smart指针>条款28: 灵巧(smart)指针</h3><p>当你以 smart pointers 取代 C++的内建指针（亦即所谓的 dumbpointers），你将获得以下各种指针行为的控制权：</p><ul><li>构造和析构（Construction and Destruction）。你可以决定smart pointer 被产生以及被销毁时发生什么事。通常我们会给smart pointers 一个默认值 0，以避免“指针未获初始化”的头痛问题。某些 smart pointers 有责任删除它们所指的对象——当指向该对象的最后一个 smart pointer 被销毁时。这是消除资源泄漏问题的一大进步。</li><li>复制和赋值（Copying and Assignment）。当一个 smartpointer 被复制或涉及赋值动作时，你可以控制发生什么事。某些smart pointer 会希望在此时刻自动为其所指之物进行复制或赋值动作，也就是执行所谓的深复制（deep copy）。另一些 smartpointer则可能只希望指针本身被复制或赋值就好。还有一些则根本不允许复制和赋值。不论你希望什么样的行为，smart pointers 都可以让你如愿。</li><li>解引（Dereferencing）。当 client 解引（取用）smart pointer所指之物时，你有权决定发生什么事情。例如你可以利用 smartpointers 协助实现出条款 17所说的 lazy fetching 策略。</li></ul><p>Smart pointer的构造行为通常明确易解：确定一个目标物（通常是利用smart pointer的 constructor自变量），然后让 smart pointer内部的 dumb pointer指向它。如果尚未决定目标物，就将内部指针设为 0，或是发出一个错误消息（可能是抛出 exception）。</p><p>重点很简单：不要提供对 dumb pointers的隐式转换操作符，除非不得已。</p><p>大多数灵巧指针模板如下:</p><div class=highlight id=id-25><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 大多数灵巧指针模板
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SmartPtr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>SmartPtr</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>realPtr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 建立一个灵巧指针指向dumb pointer(内建指针)所指的对象，未初始化的指针，缺省值为0(null)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>SmartPtr</span><span class=p>(</span><span class=k>const</span> <span class=n>SmartPtr</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span> <span class=c1>// 拷贝一个灵巧指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>~</span><span class=n>SmartPtr</span><span class=p>();</span> <span class=c1>// 释放灵巧指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// make an assignment to a smart ptr
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>SmartPtr</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SmartPtr</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span><span class=o>*</span> <span class=k>operator</span><span class=o>-&gt;</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span> <span class=c1>// dereference一个灵巧指针以访问所指对象的成员
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span> <span class=c1>// dereference灵巧指针
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span><span class=o>*</span> <span class=n>pointee</span><span class=p>;</span> <span class=c1>// 灵巧指针所指的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>灵巧指针是一种外观和行为都被设计成与内建指针相类似的对象，不过它能提供更多的功能。它们有许多应用的领域，包括资源管理和重复代码任务的自动化。</p><p>在C++11中auto_ptr已经被废弃，用unique_ptr替代。</p><p>std::unique_ptr的使用参考：https://blog.csdn.net/fengbingchun/article/details/52203664</p><p>Ref:</br>[1]. <a href=https://hr-insist.github.io/C/More_Effective_C++%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ target=_blank rel="external nofollow noopener noreferrer">More Effective C++<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>[2]. <a href=https://zhuanlan.zhihu.com/p/368342605 target=_blank rel="external nofollow noopener noreferrer">《More Effective C++》读书笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>[3]. <a href=https://blog.csdn.net/fengbingchun/article/details/102990753 target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/fengbingchun/article/details/102990753<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-10-07 09:25:23">更新于 2023-10-07&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/f43a10a9b4079963a6d78279f6f805b045e519d1 rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) f43a10a9b4079963a6d78279f6f805b045e519d1: bug: modify effective c++ naming rules"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>f43a10a</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/more_effective_c-/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/More_Effective_C++/more_effective_c++.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-title="More Effective C++ 阅读笔记" data-hashtags="More Effective C++"><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-hashtag="More Effective C++"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/more_effective_c-/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-title="More Effective C++ 阅读笔记"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-title="More Effective C++ 阅读笔记"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/more-effective-c++/ class=post-tag>More Effective C++</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/effective_stl_38/ class=post-nav-item rel=prev title="Effective STL [38] | 把仿函数类设计为用于值传递"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Effective STL [38] | 把仿函数类设计为用于值传递</a>
<a href=/posts/effective_stl_part_two/ class=post-nav-item rel=next title="Effective STL 精读总结 [2] | vector 和 string">Effective STL 精读总结 [2] | vector 和 string<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.120.1">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> jianye',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>