<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>More Effective C++ 阅读笔记 - yejian's blog</title><meta name=author content="Jian YE"><meta name=author-link content="https://github.com/jianye0428"><meta name=description content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向（代表）另一个对象，但是也有可能它不指向（代表）任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta name=keywords content="More Effective C++"><meta itemprop=name content="More Effective C++ 阅读笔记"><meta itemprop=description content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向（代表）另一个对象，但是也有可能它不指向（代表）任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta itemprop=datePublished content="2023-09-06T19:40:01+08:00"><meta itemprop=dateModified content="2023-09-13T20:34:14+08:00"><meta itemprop=wordCount content="8840"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="More Effective C++,"><meta property="og:title" content="More Effective C++ 阅读笔记"><meta property="og:description" content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向（代表）另一个对象，但是也有可能它不指向（代表）任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta property="og:type" content="article"><meta property="og:url" content="https://jianye0428.github.io/posts/more_effective_c-/"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-06T19:40:01+08:00"><meta property="article:modified_time" content="2023-09-13T20:34:14+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="More Effective C++ 阅读笔记"><meta name=twitter:description content="一、 基础议题(Basics) 条款 1: 仔细区别 pointers和references 没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向（代表）另一个对象，但是也有可能它不指向（代表）任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 nul"><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/more_effective_c-/><link rel=prev href=https://jianye0428.github.io/posts/effective_stl_38/><link rel=next href=https://jianye0428.github.io/posts/parttwo/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"More Effective C++ 阅读笔记","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/more_effective_c-\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"More Effective C\u002b\u002b","wordcount":8840,"url":"https:\/\/jianye0428.github.io\/posts\/more_effective_c-\/","datePublished":"2023-09-06T19:40:01+08:00","dateModified":"2023-09-13T20:34:14+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=wide><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>More Effective C++ 阅读笔记</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-09-06 19:40:01"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-09-06>2023-09-06</time></span>&nbsp;<span title="更新于 2023-09-13 20:34:14"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-09-13>2023-09-13</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 8840 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 18 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="More Effective C++ 阅读笔记">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#一-基础议题basics>一、 基础议题(Basics)</a><ul><li><a href=#条款-1-仔细区别-pointers和references>条款 1: 仔细区别 pointers和references</a></li><li><a href=#条款-2-最好使用-c转型操作符>条款 2: 最好使用 C++转型操作符</a></li><li><a href=#条款-3-绝对不要以多态polymorphically方式处理数组>条款 3: 绝对不要以多态（polymorphically）方式处理数组</a></li><li><a href=#条款4-避免无用的缺省构造函数>条款4 避免无用的缺省构造函数</a></li></ul></li><li><a href=#二运算符操作符>二、运算符（操作符）</a><ul><li><a href=#条款5-谨慎定义类型转换函数>条款5: 谨慎定义类型转换函数</a></li><li><a href=#条款6-区别-incrementdecrement-操作符的前置和后置形式s>条款6: 区别 increment/decrement 操作符的前置和后置形式s</a></li><li><a href=#条款7-千万不要重载-和操作符>条款7: 千万不要重载&&，|| 和，操作符</a></li><li><a href=#条款8-了解各种不同意义的-new-和-delete>条款8: 了解各种不同意义的 new 和 delete</a></li></ul></li><li><a href=#三-异常>三、 异常</a><ul><li><a href=#条款9-利用-destructors-避免泄漏资源>条款9: 利用 destructors 避免泄漏资源</a></li><li><a href=#条款10-在-constructors-内阻止资源泄漏resource-leak>条款10. 在 constructors 内阻止资源泄漏（resource leak）</a></li><li><a href=#条款11-禁止异常exceptions流出destructors之外>条款11. 禁止异常（exceptions）流出destructors之外</a></li><li><a href=#条款12>条款12.</a></li></ul></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><h2 id=一-基础议题basics>一、 基础议题(Basics)</h2><h3 id=条款-1-仔细区别-pointers和references>条款 1: 仔细区别 pointers和references</h3><p>没有所谓的 null reference。一个 reference 必须总代表某个对象。所以如果你有一个变量，其目的是用来指向（代表）另一个对象，但是也有可能它不指向（代表）任何对象，那么你应该使用 pointer，因为你可以将 pointer设为 null。换个角度看，如果这个变量总是必须代表一个对象，也就是说如果你的设计并不允许这个变量为 null，那么你应该使用reference。</p><p>Pointers 和 references 之间的另一个重要差异就是，pointers 可以被重新赋值，指向另一个对象，reference 却总是指向（代表）它最初获得的那个对象。</p><p>一般而言，当你需要考虑“不指向任何对象”的可能性时，或是考虑“在不同时间指向不同对象”的能力时，你就应该采用 pointer。前一种情况你可以将 pointer设为 null，后一种情况你可以改变pointer 所指对象。而当你确定“总是会代表某个对象”，而且“一旦代表了该对象就不能够再改变”，那么你应该选用 reference。</p><p>当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references。任何其他时候，请采用 pointers。</p><p><strong>在任何情况下都不能使用指向空值的引用</strong>。一个引用必须总是指向某些对象。在C++里，引用应被初始化。</p><p>不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。
指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变。</p><p>关于引用的更多介绍参考: <a href=https://blog.csdn.net/fengbingchun/article/details/69820184 target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/fengbingchun/article/details/69820184<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printDouble</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span><span class=o>&amp;</span> <span class=n>rd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>rd</span><span class=p>;</span> <span class=c1>// 不需要测试rd,它肯定指向一个double值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printDouble</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span><span class=o>*</span> <span class=n>pd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>pd</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 检查是否为NULL
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;*</span><span class=n>pd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>pc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 设置指针为空值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>char</span><span class=o>&amp;</span> <span class=n>rc</span> <span class=o>=</span> <span class=o>*</span><span class=n>pc</span><span class=p>;</span> <span class=c1>// 让指针指向空值，这是非常有害的，结果将是不确定的
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//std::string&amp; rs; // 错误，引用必须被初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>(</span><span class=s>&#34;xyzzy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span> <span class=c1>// 正确,rs指向s
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>ps</span><span class=p>;</span> <span class=c1>// 未初始化的指针，合法但危险
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s1</span><span class=p>(</span><span class=s>&#34;Nancy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s2</span><span class=p>(</span><span class=s>&#34;Clancy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>s1</span><span class=p>;</span> <span class=c1>// rs引用s1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>ps</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s1</span><span class=p>;</span> <span class=c1>// ps指向s1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>rs</span> <span class=o>=</span> <span class=n>s2</span><span class=p>;</span> <span class=c1>// rs仍旧引用s1,但是s1的值现在是&#34;Clancy&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>ps</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s2</span><span class=p>;</span> <span class=c1>// ps现在指向s2,s1没有改变
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>v</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// 这个被赋值的目标对象就是操作符[]返回的值，如果操作符[]
</span></span></span><span class=line><span class=cl><span class=c1></span>		   <span class=c1>// 返回一个指针，那么后一个语句就得这样写: *v[5] = 10;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款-2-最好使用-c转型操作符>条款 2: 最好使用 C++转型操作符</h3><p>C++通过引进四个新的类型转换(cast)操作符克服了C风格类型转换的缺点(过于粗鲁，能允许你在任何类型之间进行转换；C风格的类型转换在程序语句中难以识别)，这四个操作符是: <code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>。</p><p>static_cast在功能上基本上与C风格的类型转换一样强大，含义也一样。它也有功能上限制。例如，不能用static_cast像用C 风格的类型转换一样把struct转换成int类型或者把double类型转换成指针类型，另外，static_cast不能从表达式中去除const属性，因为另一个新的类型转换操作符const_cast有这样的功能。</p><p>const_cast用于类型转换掉表达式的const或volatileness属性。如果你试图使用const_cast来完成修改constness或者volatileness属性之外的事情，你的类型转换将被拒绝。</p><p><strong>dynamic_cast</strong>被用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能用dynamic_cast把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功。失败的转换将返回空指针(当对指针进行类型转换时)或者抛出异常(当对引用进行类型转换时)。dynamic_cast在帮助你浏览继承层次上是有限制的，它不能被用来缺乏虚函数的类型上，也不能用它来转换掉constness。如你想在没有继承关系的类型中进行转换，你可能想到static_cast。如果是为了去除const，你总得用const_cast。</p><p>reinterpret_cast使用这个操作符的类型转换，其转换结果几乎都是执行期定义(implementation-defined)。因此，使用reinterpret_cast的代码很难移植。此操作符最普通的用途就是在函数指针之间进行转换。</p><p>关于类型转换更多介绍参考: <a href=https://blog.csdn.net/fengbingchun/article/details/51235498 target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/fengbingchun/article/details/51235498<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>func</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpecialWidget</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>func</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=n>SpecialWidget</span><span class=o>*</span> <span class=n>psw</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>updateViaRef</span><span class=p>(</span><span class=n>SpecialWidget</span><span class=o>&amp;</span> <span class=n>rsw</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>FuncPtr</span><span class=p>)();</span> <span class=c1>// FuncPtr是一个指向函数的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>doSomething</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>firstNumber</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>secondNumber</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>result1</span> <span class=o>=</span> <span class=p>((</span><span class=kt>double</span><span class=p>)</span><span class=n>firstNumber</span><span class=p>)</span> <span class=o>/</span> <span class=n>secondNumber</span><span class=p>;</span> <span class=c1>// C风格
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>double</span> <span class=n>result2</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>firstNumber</span><span class=p>)</span> <span class=o>/</span> <span class=n>secondNumber</span><span class=p>;</span> <span class=c1>// C++风格类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>SpecialWidget</span> <span class=n>sw</span><span class=p>;</span> <span class=c1>// sw是一个非const对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>const</span> <span class=n>SpecialWidget</span><span class=o>&amp;</span> <span class=n>csw</span> <span class=o>=</span> <span class=n>sw</span><span class=p>;</span> <span class=c1>// csw是sw的一个引用，它是一个const对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//update(&amp;csw); // 错误，不能传递一个const SpecialWidget*变量给一个处理SpecialWidget*类型变量的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>update</span><span class=p>(</span><span class=k>const_cast</span><span class=o>&lt;</span><span class=n>SpecialWidget</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>csw</span><span class=p>));</span> <span class=c1>// 正确，csw的const显示地转换掉(csw和sw两个变量值在update函数中能被更新)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>update</span><span class=p>((</span><span class=n>SpecialWidget</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>csw</span><span class=p>);</span> <span class=c1>// 同上，但用了一个更难识别的C风格的类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>*</span> <span class=n>pw</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SpecialWidget</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//update(pw); // 错误，pw的类型是Widget*，但是update函数处理的是SpecialWidget*类型
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//update(const_cast&lt;SpecialWidget*&gt;(pw)); // 错误，const_cast仅能被用在影响constness or volatileness的地方，不能用在向继承子类进行类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>*</span> <span class=n>pw2</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>update</span><span class=p>(</span><span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWidget</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>pw2</span><span class=p>));</span> <span class=c1>// 正确，传递给update函数一个指针是指向变量类型为SpecialWidget的pw2的指针， 如果pw2确实指向一个对象，否则传递过去的将是空指针
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>*</span> <span class=n>pw3</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SpecialWidget</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>updateViaRef</span><span class=p>(</span><span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWidget</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=n>pw3</span><span class=p>));</span> <span class=c1>// 正确，传递给updateViaRef函数SpecailWidget pw3指针，如果pw3确实指向了某个对象，否则将抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//double result3 = dynamic_cast&lt;double&gt;(firstNumber) / secondNumber; // 错误，没有继承关系
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>const</span> <span class=n>SpecialWidget</span> <span class=n>sw4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//update(dynamic_cast&lt;SpecialWidget*&gt;(&amp;sw4)); // 错误，dynamic_cast不能转换掉const
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>FuncPtr</span> <span class=n>funcPtrArray</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// funcPtrArray是一个能容纳10个FuncPtr指针的数组
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//funcPtrArray[0] = &amp;doSomething; // 错误，类型不匹配
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>funcPtrArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>FuncPtr</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>doSomething</span><span class=p>);</span> <span class=c1>// 转换函数指针的代码是不可移植的(C++不保证所有的函数指针都被用一样的方法表示)，在一些情况下这样的转换会产生不正确的结果，所以应该避免转换函数指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款-3-绝对不要以多态polymorphically方式处理数组>条款 3: 绝对不要以多态（polymorphically）方式处理数组</h3><p>C++允许你通过基类指针和引用来操作派生类数组。不过这根本就不是一个特性，因为这样的代码几乎从不如你所愿地那样运行。数组与多态不能用在一起。值得注意的是如果你不从一个具体类(concrete classes)(例如BST)派生出另一个具体类(例如BalancedBST)，那么你就不太可能犯这种使用多态性数组的错误。</p><p><strong>原因:</strong></p><ul><li>derived class 对象一般比base class对象小。所以当使用一个 base class数组存储derived class时，在访问 array[i] 时，会访问array+i*sizeof(base class)的地址，造成访问错误。</li><li>由base 指针删除一个derived class 数组，结果未定义。因为删除时，析构从最后一个开始，但是计算地址时跟tips1一样，造成访问错误。</li></ul><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BST</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=o>~</span><span class=n>BST</span><span class=p>()</span> <span class=p>{</span> <span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BST::~BST</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>score</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BalancedBST</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BST</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=o>~</span><span class=n>BalancedBST</span><span class=p>()</span> <span class=p>{</span> <span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BalancedBST::~BalancedBST</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// 如果增加此一个int成员，执行test_item_3会segmentation fault，注释掉此变量，运行正常
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_3</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BST size: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BST</span><span class=p>));</span> <span class=c1>// 16
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;BalancedBST size: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BalancedBST</span><span class=p>));</span> <span class=c1>// 24
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>BST</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BalancedBST</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=p>[]</span> <span class=n>p</span><span class=p>;</span> <span class=c1>// 如果sizeof(BST) != sizeof(BalancedBST)，则会segmentation fault
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款4-避免无用的缺省构造函数>条款4 避免无用的缺省构造函数</h3><p>构造函数能初始化对象，而<strong>缺省构造函数</strong>则可以不利用任何在建立对象时的外部数据就能初始化对象。有时这样的方法是不错的。例如一些行为特性与数字相仿的对象被初始化为空值或不确定的值也是合理的，还有比如链表、哈希表、图等等数据结构也可以被初始化为空容器。但不是所有的对象都属于上述类型，对于很多对象来说，不利用外部数据进行完全的初始化是不合理的。比如一个没有输入姓名的地址薄对象，就没有任何意义。</p><p>利用指针数组代替一个对象数组这种方法有两个缺点: 第一你必须删除数组里每个指针所指向的对象。如果忘了，就会发生内存泄漏。第二增加了内存分配量，因为正如你需要空间来容纳EquipmentPiece对象一样，你也需要空间来容纳指针。</p><p>对于类里没有定义缺省构造函数还会造成它们无法在许多基于模板(template-based)的容器类里使用。因为实例化一个模板时，模板的类型参数应该提供一个缺省构造函数。在多数情况下，通过仔细设计模板可以杜绝对缺省构造函数的需求。</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>EquipmentPiece</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>EquipmentPiece</span><span class=p>(</span><span class=kt>int</span> <span class=n>IDNumber</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test_item_4</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//EquipmentPiece bestPieces[10]; // 错误，没有正确调用EquipmentPiece构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//EquipmentPiece* bestPieces2 = new EquipmentPiece[10]; // 错误，与上面的问题一样
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ID1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>ID2</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>EquipmentPiece</span> <span class=n>bestPieces3</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID1</span><span class=p>),</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID2</span><span class=p>)</span> <span class=p>};</span> <span class=c1>// 正确，提供了构造函数的参数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// 利用指针数组来代替一个对象数组
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>typedef</span> <span class=n>EquipmentPiece</span><span class=o>*</span> <span class=n>PEP</span><span class=p>;</span> <span class=c1>// PEP指针指向一个EquipmentPiece对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>PEP</span> <span class=n>bestPieces4</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// 正确，没有调用构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>PEP</span><span class=o>*</span> <span class=n>bestPieces5</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PEP</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// 也正确
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 在指针数组里的每一个指针被重新赋值，以指向一个不同的EquipmentPiece对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>bestPieces5</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 为数组分配raw memory,可以避免浪费内存，使用placement new方法在内存中构造EquipmentPiece对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span><span class=o>*</span> <span class=n>rawMemory</span> <span class=o>=</span> <span class=k>operator</span> <span class=k>new</span><span class=p>[](</span><span class=mi>10</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>EquipmentPiece</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=c1>// make bestPieces6 point to it so it can be treated as an EquipmentPiece array
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>EquipmentPiece</span><span class=o>*</span> <span class=n>bestPieces6</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>EquipmentPiece</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>rawMemory</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// construct the EquipmentPiece objects in the memory使用&#34;placement new&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bestPieces6</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=n>EquipmentPiece</span><span class=p>(</span><span class=n>ID1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 以与构造bestPieces6对象相反的顺序解构它
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>9</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>bestPieces6</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=o>~</span><span class=n>EquipmentPiece</span><span class=p>();</span> <span class=c1>// 如果使用普通的数组删除方法，程序的运行将是不可预测的
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// deallocate the raw memory
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>delete</span> <span class=p>[]</span> <span class=n>rawMemory</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=二运算符操作符>二、运算符（操作符）</h2><h3 id=条款5-谨慎定义类型转换函数>条款5: 谨慎定义类型转换函数</h3><ol><li>C++ 允许内置数据类型之间(例如char和int，int和double等)进行隐式转换，对于内置类型之间的隐式转换有详细的规则，但不管怎样，这些都是语言提供的，既相对安全，我们又无法更改。</li></ol><p>对于自定义的类类型，隐式转换可以通过<strong>单参数构造函数(single-argument constructors)<strong>和</strong>隐式类型转换操作符</strong>来实现。所谓”单一自变量(单参数)指的是可以有多个参数，但除了第一个参数其他参数必须有默认实参)。所谓隐式类型转换操作符，是一个 member function: 关键词operator 之后加一个类型名称，例如: <code>operator double() const</code>;</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rational</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=kt>double</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span> <span class=c1>// 将Rational 转换为 double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这个函数会在以下情况被自动调用:</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Rational</span> <span class=nf>r</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>  <span class=c1>// r的值是 1/2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>d</span> <span class=o>=</span> <span class=mf>0.5</span> <span class=o>*</span> <span class=n>r</span><span class=p>;</span> <span class=c1>// 将r的值转换为double，然后执行运算。
</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>但是下面这个情况就会出问题: <code>std::cout &lt;&lt; r</code>;</li></ol><p>如果你忘了为 Rational 类重载一个 operator&#171;，那么按道理应该打印不成功。但是编译器面对上述动作，它会想尽办法（包括找出一系列可接受的隐式类型转换）让函数调用动作成功。此时编译器发现 只需调用 Rational::operator double， 将 r 转换为 double，就可以成功调用 std::cout &#171; r;，以浮点数的形式输出。</p><p>解决办法就是以功能对等的另一个函数取代类型转换操作符。即: 定义一个 doube asDouble() const;函数。虽然使用时有些许不便，但“可因为不再默默调用那些不打算调用的函数而获得弥补”。C++ 标准库中的 string 类从没有 string 到 char* 的隐式类型转换操作符而采用 c_str 函数可能就是这个原因。</p><ol start=3><li>拥有单个参数（或除第一个参数外都有默认值的多参数）构造函数的类，很容易被隐式类型转换，最好加上 explicit 防止隐式类型转换。</li></ol><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Array</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Array</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[](</span><span class=kt>int</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=k>const</span> <span class=n>Array</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Array</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Array</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span> <span class=n>b</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]){</span> <span class=c1>//想要写 a[i] == b[i]，但是这时候编译器并不会报错
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//  do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><code>if(a == b[i])</code> 并不会报错。因为编译器发现只要调用 <code>Array\ constructor</code>（需一个 int 作为自变量），就可以把 int 转为 <code>Array\ object</code>。就会产生类似这样的代码:</p><p><code>if( a == static_cast&lt;Array&lt;int> >(b[i]))</code> 将 <code>b[i]</code> 转为 <code>Array</code>。此时程序会正常运行，但是结果却不尽人意。</p><p>解决办法就是使用 C++ 特性: <font color=red>关键词 <code>explicit</code></font>。这个特性之所以被导入，就是为了解决隐式类型转换带来的问题。<code>explict Array(int size)</code>;</p><p>还有一种被称为 proxy classes 的方法:</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Array</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>ArraySize</span> <span class=p>{</span> <span class=c1>// 这个类是新的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  	<span class=n>ArraySize</span><span class=p>(</span><span class=kt>int</span> <span class=n>numElements</span><span class=p>)</span><span class=o>:</span><span class=n>theSize</span><span class=p>(</span><span class=n>numElements</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>  	<span class=kt>int</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>theSize</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  	<span class=kt>int</span> <span class=n>theSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>Array</span><span class=p>(</span><span class=kt>int</span> <span class=n>lowBound</span><span class=p>,</span> <span class=kt>int</span> <span class=n>highBound</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Array</span><span class=p>(</span><span class=n>ArraySize</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// 注意新的声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>这样写的代码在 Array\ a(10); 的时候，编译器会先通过类型转换将 int 转换成 ArraySize，然后再进行构造，虽然麻烦很多，效率也低了很多，但是在一定程度上可以避免隐式转换带来的问题。</p><p>对于自定义类型的类型转换，有一个规则: &ldquo;<strong>没有任何一个转换程序可以内含一个以上的‘用户定制转换行为’(亦即单自变量constructor亦即隐式类型转换操作符)</strong>"，也就是说，必要的时候编译器可以先进行内置类型之间的转换再调用带单自变量的构造函数或者先调用隐式类型转换操作符在进行内置类型之间的转换，但不可能连续进行两次用户定制的类型转换！</p><p>所以 此时 <code>if(a == b[i])</code> 就会报错。不能从 int 转换成 ArraySize，再从 ArraySize 转为 Array。</p><ol start=4><li>总结允许编译器执行隐式转换弊大于利，所以<strong>非必要不要提供转换函数</strong>！</li></ol><h3 id=条款6-区别-incrementdecrement-操作符的前置和后置形式s>条款6: 区别 increment/decrement 操作符的前置和后置形式s</h3><ol><li>由于 increment/decrement 操作符的前置和后置式都是一元运算符，没有参数。因此重载时通过在后置式中加一个 int 型参数(哑元参数)加以区分，当后置式被调用时，编译器自动在为该参数指定一个0值。</li></ol><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>UPInt</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>UPInt</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>++</span><span class=p>();</span>          <span class=c1>// 前置式++
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=n>UPInt</span> <span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>  <span class=c1>// 后置式++
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>UPInt</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>--</span><span class=p>();</span>          <span class=c1>// 前置式--
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=n>UPInt</span> <span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>  <span class=c1>// 前置式--
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>前置累加操作符和后置累加操作符实现:</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 前缀形式: 增加然后取回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>UPInt</span><span class=o>&amp;</span> <span class=n>UPInt</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=k>this</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 增加
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=c1>// 取回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// postfix form: fetch and increment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>UPInt</span> <span class=n>UPInt</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>UPInt</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>++</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 取回值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 增加
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>oldValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 返回被取回的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><strong>前置式返回 reference，后置式返回 const 对象！</strong></p><p>后置 operator++(int) 的叠加是不允许的，即: i++++。</p><p>原因有两个: 一是与内建类型行为不一致(内建类型支持前置叠加)；二是其效果跟调用一次 operator++(int) 效果一样，这是违反直觉的。另外，后置式操作符使用 operator++(int)，参数的唯一目的只是为了区别前置式和后置式而已，当函数被调用时，编译器传递一个0作为int参数的值传递给该函数。</p><ol start=2><li>处理用户定制类型时，应该尽可能使用前置式。</li><li>后置式increment 和decrement 操作符的实现应以其前置式兄弟为基础。如此一来你就只需维护前置式版本，因为后置式版本会自动调整为一致的行为。</li></ol><h3 id=条款7-千万不要重载-和操作符>条款7: 千万不要重载&&，|| 和，操作符</h3><p>C++ 对于“真假值表达式” 采用所谓的“短路” 评估方式（short-circuit evaluation）。意思是一旦该表达式的真价值确定，及时表达式中还以后部分尚未检验，整个评估工作仍然结束。</p><p>“函数调用”语义和所谓的“短路” 评估方式语义有两个重大的区别。第一，当函数调用动作被执行，所有参数值都必须评估完成，所以当我们调用 operator&&和 operator||时，两个参数都已评估完成。换句话说没有什么骤死式语义。第二，C++语言规范并未明确定义函数调用动作中各参数的评估顺序，所以没办法知道expression1 和 expression2 哪个会先被评估。这与骤死式评估法形成一个明确的对比，后者总是由左向右评估其自变量。</p><p>C++同样也有一些规则用来定义逗号操作符面对内建类型的行为。表达式如果内含逗号，那么逗号左侧会先被评估，然后逗号的右侧再被评估；最后，整个逗号表达式的结果以逗号右侧的值为代表。</p><p>你不能重载以下操作符:</p><table><thead><tr><th style=text-align:center><code>.</code></th><th style=text-align:center><code>.*</code></th><th style=text-align:center><code>::</code></th><th style=text-align:center><code>?:</code></th></tr></thead><tbody><tr><td style=text-align:center><code>new</code></td><td style=text-align:center><code>delete</code></td><td style=text-align:center><code>sizeof</code></td><td style=text-align:center><code>typeid</code></td></tr><tr><td style=text-align:center><code>static_cast</code></td><td style=text-align:center><code>dynamic_cast</code></td><td style=text-align:center><code>const_cast</code></td><td style=text-align:center><code>reinterpret_cast</code></td></tr></tbody></table><h3 id=条款8-了解各种不同意义的-new-和-delete>条款8: 了解各种不同意义的 new 和 delete</h3><ul><li><p><strong>new operator</strong>: new操作符，用于动态分配内存并进行初始化, 它的动作分为两方面。第一，它分配足够的内存，用来放置某类型的对象。以上例而言，它分配足够放置一个string 对象的内存。第二，它调用一个 constructor，为刚才分配的内存中的那个对象设定初值。;</p><ul><li>new operator，不能被重载</li><li>当你写出这样的代码：<div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>string</span> <span class=o>*</span><span class=n>ps</span> <span class=o>=</span> <span class=k>new</span> <span class=n>string</span><span class=p>(</span><span class=err>“</span><span class=n>Memory</span> <span class=n>Mangement</span><span class=err>”</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div>你所使用的 new 是所谓的 new operator。它的动作分为两个方面：1、分配足够的内存，用来放置某类型的对象；2、调用 constructor，为刚才的内存中的那个对象设定初值。</li></ul></li><li><p><strong>operator new</strong>: 标准库的函数，只分配内存不进行初始化(或者传递一个可用的内存地址)，可以自己进行重载，也可以主动调用。</p><ul><li>和 malloc 一样，operator new 的唯一任务就是分配内存。</li><li><code>void *rawMemory = operator new(sizeof(string));</code> 返回值类型是 void* ！！！</li><li>可以<strong>重载</strong> operator new，但是第一个参数类型必须总是 size_t。</li><li><code>string *ps = new string("Memory Mangement");</code>等价于<div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=n>rawMemory</span> <span class=o>=</span> <span class=k>operator</span> <span class=k>new</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>string</span><span class=p>));</span>   <span class=c1>// 取得原始内存，用来存放有一个string对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>call</span> <span class=n>string</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;Memory Mangement&#34;</span><span class=p>)</span> <span class=n>on</span> <span class=o>*</span><span class=n>memory</span><span class=p>;</span> <span class=c1>// 将内存中的对象初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=o>*</span><span class=n>ps</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>string</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>memory</span><span class=p>);</span> <span class=c1>// 让ps 指向新完成的对象
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><strong>placement new (定位new)</strong>: new operator的另外一种用法 ，在已分配的内存上构造对象;</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>注意: new operator是操作符，placement new是这个操作符的一种用法，而operator new是标准库中的函数，new operator调用了 operator new。</p><ol><li>将对象产生与 heap，请使用 new operator。它不但分配内存而且为该对象调用一个 constructor。</li><li>如果你只是打算分配内存，请调用 operator new，那就没有任何 constructor 会被调用。</li><li>如果你打算在 heap objects 产生时自己决定内存分配方式，请写一个自己的 operator new，并使用 new operator，它会自动调用你所写的 operator new。</li><li>如果你打算在已分配并拥有指针的内存中构造对象，请使用 placement new。</li></ol></div></div></div><h2 id=三-异常>三、 异常</h2><p>程序之所以在 exceptions 出现时仍有良好行为，不是因为碰巧如此，而是因为它们加入了 exceptions 的考虑。</p><p>exceptions 无法被忽略。如果一个函数利用“设定状态变量”的方式或是利用“返回错误码”的方式发出一个异常信号，无法保证此函数的调用者会检查那个变量或检验那个错误码。于是程序的执行可能会一直继续下去，远离错误发生地点。但是如果函数以抛出 exception 的方式发出异常信号，而该 exception 未被捕捉，程序的执行便会立刻中止。</p><p>如果你需要一个“绝对不会被忽略的”异常信号发射方法，而且发射后的 stack处理过程又能够确保局部对象的 destructors 被调用，那么你需要 C++exceptions。它是最简单的方法了。</p><h3 id=条款9-利用-destructors-避免泄漏资源>条款9: 利用 destructors 避免泄漏资源</h3><p>每当 new 一个新的对象，一定要确保成功 delete 它，否则就会造成内存泄漏。</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processAdoptions</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>(</span><span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    	<span class=n>ALA</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=n>readALA</span><span class=p>(</span><span class=n>dataSource</span><span class=p>);</span> <span class=c1>// new 新的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pa</span><span class=o>-&gt;</span><span class=n>processAdoption</span><span class=p>();</span> <span class=c1>// 处理事务
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>pa</span><span class=p>;</span> <span class=c1>// 删除pa指向的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>但是如果 <code>pa->processAdoption();</code>抛出异常，之后的所有语句都会被跳过，不再执行，这意味着 <code>deleta pa;</code>不会执行，造成内存泄漏。</p><p>解决方法1:</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processAdoptions</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>ALA</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=n>readALA</span><span class=p>(</span><span class=n>dataSource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pa</span><span class=o>-&gt;</span><span class=n>processAdoption</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span><span class=p>(...){</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>pa</span><span class=p>;</span> <span class=c1>//在抛出异常的时候避免泄露
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>throw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>pa</span><span class=p>;</span> <span class=c1>//在不抛出异常的时候避免泄
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>因为这种情况会需要删除两次pa，代码维护很麻烦，所以需要进行优化：</p><p>只要我们能够将 “一定得执行的清理代码” 移到 processAdoptions 函数的某个局部对象的 destructors 内即可。因为局部对象总是会在函数结束时被析构，不论函数如何结束。</p><p>如何把 delete 动作从 processAdoptions 函数移到函数内的某个局部对象的 destructor 内：以一个 “类似指针的对象（智能指针）”取代指针 pa。当这个类似指针的对象被（自动）销毁，我们可以令其 destructor 调用 delete。</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processAdoptions</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>dataSource</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>ALA</span><span class=o>&gt;</span> <span class=n>pa</span><span class=p>(</span><span class=n>readALA</span><span class=p>(</span><span class=n>dataSource</span><span class=p>));</span> <span class=c1>// 现在auto_ptr已被弃用，推荐使用 shared_ptr!!!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pa</span><span class=o>-&gt;</span><span class=n>processAdoption</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=条款10-在-constructors-内阻止资源泄漏resource-leak>条款10. 在 constructors 内阻止资源泄漏（resource leak）</h3><p>考虑下面的情况：</p><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::</span><span class=n>BookEntry</span><span class=p>()</span><span class=o>:</span><span class=n>theImage</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>theAudioClip</span><span class=p>(</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>theImage</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>theAudioClip</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AudioClip</span><span class=p>(</span><span class=n>audioClipFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::~</span><span class=n>BookEntry</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=n>theImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>theAudioClip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>如果 <code>theAudioClip = new AudioClip(audioClipFileName);</code> 有 exception 抛出，那么函数构造失败，destructor 自然不会被调用。但是 theImage 对象构造成功了，这就导致 BookEntry constructor 所分配的 Image object 还是泄漏了。</p><p>由于C++ 不自动清理那些 “构造期间抛出 exceptions” 的对象，所以你必须设计你的 constructor，使得它们能够自动清理。通常只需将所有可能的 exceptions 捕捉起来，执行某种清理工作，然后重新抛出 exception，使它继续传播出去即可。</p><p>解决办法一：</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::</span><span class=n>BookEntry</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=n>theImage</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    	<span class=n>theAudioClip</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AudioClip</span><span class=p>(</span><span class=n>audioClipFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span><span class=p>(...){</span> <span class=c1>// 在构造函数内捕捉异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=k>delete</span> <span class=n>theImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=k>delete</span> <span class=n>theAudioClip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=k>throw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>一个更好的解答是，接收条款9的忠告，将 theImage 和 theAudioClip 所指对象视为资源，交给局部对象来管理。 不论 theImage 和 theAudioClip 都是指向动态分配而得的对象，当指针本身停止活动，那些对象都应该被删除。</p><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BookEntry</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span><span class=p>......</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>Image</span><span class=o>&gt;</span> <span class=n>theImage</span><span class=p>;</span> <span class=c1>// 同样的，现在auto_ptr已被弃用，推荐使用 shared_ptr!!!
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>const</span> <span class=n>auto_ptr</span><span class=o>&lt;</span><span class=n>AudioClip</span><span class=o>&gt;</span> <span class=n>theAudioClip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>BookEntry</span><span class=o>::</span><span class=n>BookEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>imageFileName</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>audioClipFileName</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>theImage</span><span class=p>(</span><span class=n>imageFileName</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=o>?</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageFileName</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=n>theAudioClip</span><span class=p>(</span><span class=n>audioClipFileName</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=o>?</span> <span class=k>new</span> <span class=n>AudiaClip</span><span class=p>(</span><span class=n>audioClipFileName</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span></span></span></code></pre></td></tr></table></div></div><p>这样不仅解决了在 constructors 内阻止资源泄漏，而且还大幅简化 destructor。</p><p><code>BookEntry::~BookEntry(){} // 不需要做什么事！</code></p><h3 id=条款11-禁止异常exceptions流出destructors之外>条款11. 禁止异常（exceptions）流出destructors之外</h3><p>两种情况下 destructor 会被调用。第一种情况是当对象在正常状态下被销毁，也就是当它离开了它的生存空间（scope）或是被明确地删除；第二种情况是当对象被 exception 处理机制——也就是exception 传播过程中的 stack-unwinding（栈展开）机制——销毁。</p><p>因为如果控制权基于 exception 的因素离开 destructor，而此时正有另一个 exception 处于作用状态，C++会调用 terminate 函数。此函数的作为正如其名：将你的程序结束掉——它会立刻动手，甚至不等局部对象被销毁。</p><p>因此，有两个好理由支持我们“全力阻止exceptions传出 destructors之外”。第一，它可以避免 terminate函数在 exception传播过程的栈展开（stack-unwinding）机制中被调用；第二，它可以协助确保 destructors 完成其应该完成的所有事情。</p><p>如何避免exception传出destructor之外呢?</p><p><strong>在析构函数中使用<code>try{} catch(){}</code>, 并且在catch的<code>{}</code>中什么也不做。</strong></p><h3 id=条款12>条款12.</h3><p>Ref:</br>[1]. <a href=https://hr-insist.github.io/C/More_Effective_C++%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ target=_blank rel="external nofollow noopener noreferrer">More Effective C++<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>[2]. <a href=https://zhuanlan.zhihu.com/p/368342605 target=_blank rel="external nofollow noopener noreferrer">《More Effective C++》读书笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-09-13 20:34:14">更新于 2023-09-13&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/fe2b15270bfbd22061bc22588c76f36ef183d9bb rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) fe2b15270bfbd22061bc22588c76f36ef183d9bb: feat: add part two for effective stl"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>fe2b152</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/more_effective_c-/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/More_Effective_C++/more_effective_c++.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-title="More Effective C++ 阅读笔记" data-hashtags="More Effective C++"><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-hashtag="More Effective C++"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/more_effective_c-/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-title="More Effective C++ 阅读笔记"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/more_effective_c-/ data-title="More Effective C++ 阅读笔记"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/more-effective-c++/ class=post-tag>More Effective C++</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/effective_stl_38/ class=post-nav-item rel=prev title="Effective STL [38] | 把仿函数类设计为用于值传递"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Effective STL [38] | 把仿函数类设计为用于值传递</a>
<a href=/posts/parttwo/ class=post-nav-item rel=next title="Effective STL 精读总结 [2] | vector 和 string">Effective STL 精读总结 [2] | vector 和 string<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> jianye',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>