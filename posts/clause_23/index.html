<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Effective STL [23] | 考虑用有序vector代替关联容器 - yejian's blog</title><meta name=author content="Jian YE">
<meta name=author-link content="https://github.com/jianye0428"><meta name=description content="当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：set、multiset、map和multimap。 如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。 对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的set、map和它们的multi同事"><meta name=keywords content='Effective STL'><meta itemprop=name content="Effective STL [23] | 考虑用有序vector代替关联容器"><meta itemprop=description content="当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：set、multiset、map和multimap。 如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。 对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的set、map和它们的multi同事"><meta itemprop=datePublished content="2023-08-14T19:13:32+08:00"><meta itemprop=dateModified content="2023-08-15T07:43:06+08:00"><meta itemprop=wordCount content="4118"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="Effective STL,"><meta property="og:title" content="Effective STL [23] | 考虑用有序vector代替关联容器"><meta property="og:description" content="当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：set、multiset、map和multimap。 如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。 对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的set、map和它们的multi同事"><meta property="og:type" content="article"><meta property="og:url" content="https://jianye0428.github.io/posts/clause_23/"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-14T19:13:32+08:00"><meta property="article:modified_time" content="2023-08-15T07:43:06+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="Effective STL [23] | 考虑用有序vector代替关联容器"><meta name=twitter:description content="当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：set、multiset、map和multimap。 如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。 对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的set、map和它们的multi同事"><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/clause_23/><link rel=prev href=https://jianye0428.github.io/posts/clause_22/><link rel=next href=https://jianye0428.github.io/posts/clause_24/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Effective STL [23] | 考虑用有序vector代替关联容器","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/clause_23\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"Effective STL","wordcount":4118,"url":"https:\/\/jianye0428.github.io\/posts\/clause_23\/","datePublished":"2023-08-14T19:13:32+08:00","dateModified":"2023-08-15T07:43:06+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Effective STL [23] | 考虑用有序vector代替关联容器</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-08-14 19:13:32"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-08-14>2023-08-14</time></span>&nbsp;<span title="更新于 2023-08-15 07:43:06"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-08-15>2023-08-15</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 4118 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 9 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="Effective STL [23] | 考虑用有序vector代替关联容器">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#关联容器数据结构>关联容器数据结构</a></li><li><a href=#有序vector更高效>有序vector更高效</a></li><li><a href=#vector的缺点>vector的缺点</a></li><li><a href=#example>Example</a></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2023-08-15，文中内容可能已过时。</div></div></div><p>当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>。</p><p>如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。</p><p>对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的<code>set</code>、<code>map</code>和它们的<code>multi</code>同事。</p><p>即使你需要的就只是==对数时间==查找的保证，标准关联容器仍然可能不是你的最佳选择。和直觉相反，对于标准关联容器，所提供的性能也经常劣于本该比较次的<code>vector</code>。</p><h2 id=关联容器数据结构>关联容器数据结构</h2><p>标准关联容器的典型实现是<strong>平衡二叉查找树</strong>。</p><p>一个平衡二叉查找树是一个对<strong>插入</strong>、<strong>删除</strong>和<strong>查找</strong>的混合操作优化的数据结构。</p><p>换句话说，它被设计为应用于进行一些插入，然后一些查找，然后可能再进行一些插入，然后也许一些删除，然后再来一些查找，然后更多的插入或删除，然后更多的查找等。这个事件序列的关键特征是插入、删除和查找都是混合在一起的。</p><p>一般来说，没有办法预测对树的下一个操作是什么。</p><p><strong>使用数据结构的3阶段</strong></p><ol><li><strong>建立</strong>。通过插入很多元素建立一个新的数据结构。在这个阶段，几乎所有的操作都是插入和删除。几乎没有或根本没有查找。</li><li><strong>查找</strong>。在数据结构中查找指定的信息片。在这个阶段，几乎所有的操作都是查找。几乎没有或根本没有插入和删除。</li><li><strong>重组</strong>。修改数据结构的内容，通过删除所有现有数据和在原地插入新数据。从动作上说，这个阶段等价于阶段1。一旦这个阶段完成，应用程序返回阶段2。</li></ol><h2 id=有序vector更高效>有序vector更高效</h2><p>一个vector可能比一个关联容器能提供更高的性能（时间和空间上都是）。</p><p>但不是任意的<code>vector</code>都会，只有有序vector。因为只有有序容器才能正确地使用查找算法——<code>binary_search</code>、<code>lower_bound</code>、<code>equal_range</code>等。</p><p>Q: 为什么一个（有序的）vector的二分法查找比一个二叉树的二分法查找提供了更好的性能？</p><p>A: 其中的一个是<strong>大小问题</strong>，其中的一个是<strong>引用局部性问题</strong>。</p><p><strong>大小问题</strong></p><p>假设我们需要一个容器来容纳Widget对象，而且，因为查找速度对我们很重要，我们考虑一个Widget的关联容器和一个有序<code>vector&lt;Widget></code>。</p><p><strong>关联容器数据结构</strong></p><p>如果选择一个关联容器，我们几乎确定了要使用平衡二叉树。这样的树是由树节点组成，每个都不仅容纳了一个Widget，而且保存了一个该节点到左孩子的指针，一个到它右孩子的指针，和（典型的）一个到它父节点的指针。</p><p>这意味着<strong>在关联容器中用于存储一个Widget的空间开销至少会是三个指针</strong>。</p><p><strong>vector数据结构</strong></p><p>与之相对的是，当在vector中存储Widget并没有开销：简单地存储一个Widget。</p><p>当然，<strong>vector本身有开销</strong>，在vector结尾也可能有空的（保留）空间，但是每个vector开销是可以忽略的（通常是三个机器字，比如，三个指针或两个指针和一个int），而且如果必要的话，末尾空的空间可以通过“交换技巧”去掉。即使这个附加的空间没有去掉，也并不影响下面的分析，因为当查找时不会引用那段内存。</p><p><strong>内存大小</strong></p><p>假设我们的数据结构足够大，它们可以分成多个内存页面，但是vector比关联容器需要的页面要少。</p><p>因为vector不需要每个Widget的开销，而关联容器给每个Widget上附加了三个指针。</p><p>假设在你使用的系统上一个Widget的大小是12个字节，指针是4个字节，一个内存页面是4096（4K）字节。</p><p>忽略每个容器的开销，当用vector保存时，你可以在一页面上放置341个Widget $(4096\div12\approx341)$，但使用关联容器时你最多只能放170个 $4096\div(12+4\times3)\approx170)$。</p><p><strong>因此关联容器和vector比起来，你将会使用大约两倍的内存。</strong></p><p>如果你使用的环境可以用<strong>虚拟内存</strong>，就很可以容易地看出那会<strong>造成大量的页面错误，因此一个系统会因为大数据量而明显慢下来</strong>。</p><p><strong>引用局部性问题</strong></p><p>假设在二叉树中的节点都群集在一个相关的小内存页面集中，实际情况下关联容器很乐观的。</p><p><strong>大部分STL实现使用自定义内存管理器来达到这样的群集，但是如果你的STL实现没有改进树节点中的引用局部性，这些节点会分散在所有你的内存空间。那会导致更多的页面错误。</strong></p><p>即使使用了自定义群集内存管理器，关联容器也会导致很多页面错误，因为，不像连续内存容器，比如vector，<strong>基于节点的容器更难保证在容器的遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个。</strong></p><p><strong>当进行二分查找时那种内存组织方式（译注：遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个）正好是页面错误最少的。</strong></p><h2 id=vector的缺点>vector的缺点</h2><p><font color=red>有序vector的大缺点是必须保持有序！</font></p><p>因为vector中所有的元素都必须拷贝，所以：</p><ol><li><p>当一个新元素插入时，大于这个新元素的所有东西都必须向上移一位，非常昂贵；</p></li><li><p>如果vector必须重新分配它的内在内存，则会更昂贵；</p></li><li><p>如果一个元素从vector中被删除，所有大于它的元素都要向下移动。</p></li></ol><p>vector的插入和删除都很昂贵，但是关联容器的插入和删除则很轻量。</p><p>这就是为什么只有当你知道你的数据结构使用的时候查找几乎不和插入和删除混合时，使用有序vector代替关联容器才有意义。</p><p><strong>概要</strong></p><ol><li><p>在有序vector中存储数据很有可能比在标准关联容器中保存相同的数据消耗更少的内存；</p></li><li><p>当页面错误值得重视的时候，在有序vector中通过二分法查找可能比在一个标准关联容器中查找更快。</p></li></ol><h2 id=example>Example</h2><blockquote><p>vector代替set</p></blockquote><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl> <span class=c1>// 代替set&lt;Widget&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>vw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 结束建立阶段。（当模拟一个multiset时，你可能更喜欢用stable_sort 来代替；
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>vw</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vw</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 用于查找的值的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Widget</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span><span class=c1>// 开始查找阶段
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 通过binary_search查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>binary_search</span><span class=p>(</span><span class=n>vw</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vw</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>w</span><span class=p>))...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 通过lower_bound查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lower_bound</span><span class=p>(</span><span class=n>vw</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vw</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 条款19解释了“!(w &lt; *i)”测试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>vw</span><span class=p>.</span><span class=n>end</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>w</span> <span class=o>&lt;</span> <span class=o>*</span><span class=n>i</span><span class=p>))...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 通过equal_range查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pair</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=o>&gt;</span> <span class=n>range</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                       <span class=n>equal_range</span><span class=p>(</span><span class=n>vw</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vw</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>range</span><span class=p>.</span><span class=n>first</span> <span class=o>!=</span> <span class=n>range</span><span class=p>.</span><span class=n>second</span><span class=p>)...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span> <span class=c1>// 结束查找阶段，开始重组阶段
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 开始新的查找阶段...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>vw</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vw</span><span class=p>.</span><span class=n>end</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><p>里面最难的东西就是<strong>怎么在搜索算法中做出选择</strong>（比如，<code>binary_search</code>、<code>lower_bound</code>等）</p><blockquote><p>vector代替map或multimap</p></blockquote><p>当你决定用vector代替map或multimap时，事情会变得更有趣，因为<strong>vector必须容纳pair对象</strong>。</p><p>但是要注意，如果你声明一个map&lt;K, V>的对象（或者等价的multimap），保存在map中的元素类型是<code>pair&lt;const K, V></code>。</p><p>如果要用vector模拟<code>map</code>或者<code>multimap</code>，<strong>必须去掉const</strong>，因为当你对vector排序时，元素的值将会通过赋值移动，那意味着pair的两个组件都必须是可赋值的。</p><p>当使用vector来模拟map&lt;K, V>时，<strong>保存在vector中数据的类型将是<code>pair&lt;K, V></code></strong>，而不是<code>pair&lt;const K, V></code>。</p><p>map和multimap以顺序的方式保存他们的元素，但<strong>用于排序目的时它们只作用于元素的key部分</strong>（pair的第一个组件），所以当排序vector时你必须做一样的事情。</p><p>你需要为你的pair写一个自定义比较函数，因为<code>pair</code>的<code>operator&lt;</code>作用于pair的两个组件。</p><p><strong>2个比较函数来进行查找</strong></p><p>用来排序的比较函数将作用于两个pair对象，但是查找只用到key值。</p><p>必须传给用于查找的比较函数一个key类型的对象（要查找的值）和一个pair（存储在vector中的一个pair）——两个不同的类型。</p><p>还有一个附加的麻烦，你不会知道key还是pair是作为第一个实参传递的，所以你真的需要两个用于查找的比较函数：<strong>一个key值先传递，一个pair先传递</strong></p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>Data</span><span class=p>;</span> <span class=c1>// 在这个例子里&#34;map&#34;容纳的类型
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DataCompare</span> <span class=p>{</span> <span class=c1>// 用于比较的类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 用于排序的比较函数keyLess在下面
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=k>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>Data</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Data</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>keyLess</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>first</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 用于查找的比较函数（形式1）
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>Data</span><span class=o>&amp;</span> <span class=n>Ihs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Data</span><span class=o>::</span><span class=n>first_type</span><span class=o>&amp;</span> <span class=n>k</span><span class=p>)</span> <span class=k>const</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>keyLess</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 用于查找的比较函数（形式2）
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>Data</span><span class=o>::</span><span class=n>first_type</span><span class=o>&amp;</span> <span class=n>k</span><span class=p>,</span>  <span class=k>const</span> <span class=n>Data</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>keyLessfk</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>first</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// “真的”比较函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=n>keyLess</span><span class=p>(</span><span class=k>const</span> <span class=n>Data</span><span class=o>::</span><span class=n>first_type</span><span class=o>&amp;</span> <span class=n>k1</span><span class=p>,</span> <span class=k>const</span> <span class=n>Data</span><span class=o>::</span><span class=n>first_type</span><span class=o>&amp;</span> <span class=n>k2</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k1</span> <span class=o>&lt;</span> <span class=n>k2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>我们假设有序vector将模拟<code>map&lt;string, int></code>。</p><p>这段代码几乎是上面讨论的字面转换，除了存在成员函数<code>keyLess</code>。</p><p>那个函数的存在是用来<strong>保证几个不同的<code>operator()</code>函数之间的一致性</strong>。</p><p>每个这样的函数只是简单地比较两个key的值，所以我们把这个测试放在keyLess中并让operator()函数返回keyLess所做的事情，这比复制那个逻辑要好。</p><p>这个软件工程中绝妙的动作增强了<code>DataCompare</code>的可维护性，但<strong>有一个小缺点，它提供了有不同参数类型的operator()函数，这将导致函数对象无法适配。</strong></p><p>把有序vector用作map本质上和用作set一样。</p><p><strong>唯一大的区别是必须把DataCompare对象用作比较函数:</strong></p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 代替map&lt;string, int&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Data</span><span class=o>&gt;</span> <span class=n>vd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=c1>// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 结束建立阶段。（当模拟multimap时，你可能更喜欢用stable_sort来代替）；
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>vd</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vd</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>DataCompare</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 用于查找的值的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span> <span class=c1>// 开始查找阶段
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 通过binary_search查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>binary_search</span><span class=p>(</span><span class=n>vd</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vd</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>s</span><span class=p>,</span> <span class=n>DataCompare</span><span class=p>()))...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 再次通过lower_bound查找，
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Data</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lower_bound</span><span class=p>(</span><span class=n>vd</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vd</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>s</span><span class=p>,</span> <span class=n>DataCompare</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 条款45解释了“!DataCompare()(s, *i)”测试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>vd</span><span class=p>.</span><span class=n>end</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>DataCompare</span><span class=p>()(</span><span class=n>s</span><span class=p>,</span> <span class=o>*</span><span class=n>i</span><span class=p>))...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 通过equal_range查找
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pair</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Data</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Data</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=o>&gt;</span> <span class=n>range</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>equal_range</span><span class=p>(</span><span class=n>vd</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vd</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>s</span><span class=p>,</span> <span class=n>DataCompare</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>range</span><span class=p>.</span><span class=n>first</span> <span class=o>!=</span> <span class=n>range</span><span class=p>.</span><span class=n>second</span><span class=p>)...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span> <span class=c1>// 结束查找阶段，开始重组阶段
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 开始新的查找阶段...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>vd</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vd</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>DataCompare</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><p>正如你所见，一旦你写了DataCompare，东西都很好地依序排列了。</p><p>而一旦位置合适了，它们往往比相应的使用真的map的设计运行得更快而且使用更少内存。</p><p>如果你的程序不是按照阶段的方式操作数据结构，那么使用有序vector代替标准关联容器几乎可以确定是在浪费时间。</p></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-08-15 07:43:06">更新于 2023-08-15&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/728163725a43e1227457d325954e850f99d54bb4 rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) 728163725a43e1227457d325954e850f99d54bb4: feat: add clause 23 for effective stl"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>7281637</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/clause_23/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/Effective_STL/CLAUSE_23/index.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/clause_23/ data-title="Effective STL [23] | 考虑用有序vector代替关联容器" data-hashtags="Effective STL"><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/clause_23/ data-hashtag="Effective STL"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/clause_23/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/clause_23/ data-title="Effective STL [23] | 考虑用有序vector代替关联容器"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/clause_23/ data-title="Effective STL [23] | 考虑用有序vector代替关联容器"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/effective-stl/ class=post-tag>Effective STL</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/clause_22/ class=post-nav-item rel=prev title="Effective STL [22] | 避免原地修改set和multiset的键"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Effective STL [22] | 避免原地修改set和multiset的键</a>
<a href=/posts/clause_24/ class=post-nav-item rel=next title="Effective STL [24] | 当关乎效率时应该在map::operator[]和map-insert之间仔细选择">Effective STL [24] | 当关乎效率时应该在map::operator[]和map-insert之间仔细选择<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.123.4">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> jianye',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>