<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types - yejian's blog</title><meta name=author content="Jian YE">
<meta name=author-link content="https://github.com/jianye0428"><meta name=description content="内存模型基础 为了避免 race condition，线程就要规定执行顺序。一种方式是使用 mutex，后一线程必须等待前一线程解锁。第二种方式是使用原子操作来避免竞争访问同一内存位置 原子操作是不可分割的操作，要么做了要么没做，不存在做一半的状态。如果读取对象值的加载操作是原子的，那么对象上的所有修改操作也是原子"><meta name=keywords content='C++_Concurrency'><meta itemprop=name content="C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types"><meta itemprop=description content="内存模型基础 为了避免 race condition，线程就要规定执行顺序。一种方式是使用 mutex，后一线程必须等待前一线程解锁。第二种方式是使用原子操作来避免竞争访问同一内存位置 原子操作是不可分割的操作，要么做了要么没做，不存在做一半的状态。如果读取对象值的加载操作是原子的，那么对象上的所有修改操作也是原子"><meta itemprop=datePublished content="2023-11-18T19:09:50+08:00"><meta itemprop=dateModified content="2023-12-19T19:14:20+08:00"><meta itemprop=wordCount content="7296"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="C++_Concurrency"><meta property="og:url" content="https://jianye0428.github.io/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/"><meta property="og:site_name" content="yejian's blog"><meta property="og:title" content="C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types"><meta property="og:description" content="内存模型基础 为了避免 race condition，线程就要规定执行顺序。一种方式是使用 mutex，后一线程必须等待前一线程解锁。第二种方式是使用原子操作来避免竞争访问同一内存位置 原子操作是不可分割的操作，要么做了要么没做，不存在做一半的状态。如果读取对象值的加载操作是原子的，那么对象上的所有修改操作也是原子"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-18T19:09:50+08:00"><meta property="article:modified_time" content="2023-12-19T19:14:20+08:00"><meta property="article:tag" content="C++_Concurrency"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types"><meta name=twitter:description content="内存模型基础 为了避免 race condition，线程就要规定执行顺序。一种方式是使用 mutex，后一线程必须等待前一线程解锁。第二种方式是使用原子操作来避免竞争访问同一内存位置 原子操作是不可分割的操作，要么做了要么没做，不存在做一半的状态。如果读取对象值的加载操作是原子的，那么对象上的所有修改操作也是原子"><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/><link rel=prev href=https://jianye0428.github.io/posts/ch04_synchronizing_concurrent_operation/><link rel=next href=https://jianye0428.github.io/posts/deadlocks/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/ch05_cpp_memory_model_and_operations_on_atomic_types\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"C\u002b\u002b_Concurrency","wordcount":7296,"url":"https:\/\/jianye0428.github.io\/posts\/ch05_cpp_memory_model_and_operations_on_atomic_types\/","datePublished":"2023-11-18T19:09:50+08:00","dateModified":"2023-12-19T19:14:20+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=wide><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-11-18 19:09:50"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-11-18>2023-11-18</time></span>&nbsp;<span title="更新于 2023-12-19 19:14:20"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-12-19>2023-12-19</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 7296 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 15 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#内存模型基础>内存模型基础</a></li><li><a href=#原子操作和原子类型>原子操作和原子类型</a><ul><li><a href=#标准原子类型>标准原子类型</a></li><li><a href=#stdatomic_flaghttpsencppreferencecomwcppatomicatomic_flag><a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag>std::atomic_flag</a></a></li><li><a href=#其他原子类型>其他原子类型</a></li></ul></li><li><a href=#同步操作和强制排序enforced-ordering>同步操作和强制排序（enforced ordering）</a><ul><li><a href=#synchronizes-with>synchronizes-with</a></li><li><a href=#happens-beforehttpsencppreferencecomwcppatomicmemory_orderhappens-before><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before>happens-before</a></a></li><li><a href=#inter-thread-happens-beforehttpsencppreferencecomwcppatomicmemory_orderinter-thread_happens-before><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before>inter-thread happens-before</a></a></li><li><a href=#strongly-happens-beforehttpsencppreferencecomwcppatomicmemory_orderstrongly_happens-before><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before>strongly-happens-before</a></a></li><li><a href=#stdmemory_orderhttpsencppreferencecomwcppatomicmemory_order><a href=https://en.cppreference.com/w/cpp/atomic/memory_order>std::memory_order</a></a></li><li><a href=#relaxed-orderinghttpsencppreferencecomwcppatomicmemory_orderrelaxed_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering>Relaxed ordering</a></a></li><li><a href=#release-consume-orderinghttpsencppreferencecomwcppatomicmemory_orderrelease-consume_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Consume_ordering>Release-Consume ordering</a></a></li><li><a href=#release-acquire-orderinghttpsencppreferencecomwcppatomicmemory_orderrelease-acquire_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering>Release-Acquire ordering</a></a></li><li><a href=#sequentially-consistent-orderinghttpsencppreferencecomwcppatomicmemory_ordersequentially-consistent_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering>Sequentially-consistent ordering</a></a></li><li><a href=#stdatomic_thread_fencehttpsencppreferencecomwcppatomicatomic_thread_fence><a href=https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence>std::atomic_thread_fence</a></a></li></ul></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2023-12-19，文中内容可能已过时。</div></div></div><h2 id=内存模型基础>内存模型基础</h2><ul><li>为了避免 race condition，线程就要<mark>规定执行顺序</mark>。一种方式是使用 <strong>mutex</strong>，后一线程必须等待前一线程解锁。第二种方式是使用<strong>原子操作</strong>来避免竞争访问同一内存位置</li><li>原子操作是不可分割的操作，要么做了要么没做，不存在做一半的状态。如果读取对象值的加载操作是原子的，那么对象上的所有修改操作也是原子的，读取的要么是初始值，要么是某个修改完成后的存储值。因此，原子操作不存在修改过程中值被其他线程看到的情况，也就避免了竞争风险</li><li>每个对象从初始化开始都有一个修改顺序，这个顺序由来自所有线程对该对象的写操作组成。通常这个顺序在运行时会变动，但在任何给定的程序执行中，系统中所有线程都必须遵循此顺序</li><li>如果对象不是原子类型，就要通过同步来保证线程遵循每个变量的修改顺序。如果一个变量对于不同线程表现出不同的值序列，就会导致数据竞争和未定义行为。使用原子操作就可以把同步的责任抛给编译器</li></ul><h2 id=原子操作和原子类型>原子操作和原子类型</h2><h3 id=标准原子类型>标准原子类型</h3><ul><li>标准原子类型定义在 <a href=https://en.cppreference.com/w/cpp/header/atomic target=_blank rel="external nofollow noopener noreferrer">&lt;atomic><i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 中。也可以用 mutex 模拟原子操作，实际上标准原子类型可能就是这样实现的，它们都有一个 <a href=https://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free target=_blank rel="external nofollow noopener noreferrer">is_lock_free<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 函数，返回 true 说明该原子类型操作是无锁的，用的是原子指令，返回 false 则是用锁</li></ul><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>{}.</span><span class=n>is_lock_free</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=p>{}.</span><span class=n>is_lock_free</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><ul><li>原子操作的主要用处是替代 mutex 实现同步。如果原子操作内部是用 mutex 实现的，就不会有期望的性能提升，还不如直接用 mutex 来同步。C++17 中每个原子类型都有一个 <a href=https://en.cppreference.com/w/cpp/atomic/atomic/is_always_lock_free target=_blank rel="external nofollow noopener noreferrer">is_always_lock_free<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 成员变量，为 true 时表示该原子类型在此平台上 lock-free</li></ul><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>{}.</span><span class=n>is_always_lock_free</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><ul><li>C++17 之前可以用标准库为各个原子类型定义的 <a href=https://en.cppreference.com/w/c/atomic/ATOMIC_LOCK_FREE_consts target=_blank rel="external nofollow noopener noreferrer">ATOMIC_xxx_LOCK_FREE<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 宏来判断该类型是否无锁，值为 0 表示原子类型是有锁的，为 2 表示无锁，为 1 表示运行时才能确定</li></ul><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// LOCK-FREE PROPERTY
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define ATOMIC_BOOL_LOCK_FREE 2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_CHAR_LOCK_FREE 2
</span></span></span><span class=line><span class=cl><span class=cp>#ifdef __cpp_lib_char8_t
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_CHAR8_T_LOCK_FREE 2
</span></span></span><span class=line><span class=cl><span class=cp>#endif </span><span class=c1>// __cpp_lib_char8_t
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define ATOMIC_CHAR16_T_LOCK_FREE 2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_CHAR32_T_LOCK_FREE 2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_WCHAR_T_LOCK_FREE  2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_SHORT_LOCK_FREE  2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_INT_LOCK_FREE    2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_LONG_LOCK_FREE   2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_LLONG_LOCK_FREE  2
</span></span></span><span class=line><span class=cl><span class=cp>#define ATOMIC_POINTER_LOCK_FREE  2</span></span></span></code></pre></td></tr></table></div></div><ul><li>只有 <a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag target=_blank rel="external nofollow noopener noreferrer">std::atomic_flag<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 未提供 is_lock_free，该类型是一个简单的布尔标志，所有操作都保证 lock-free。基于 <a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag target=_blank rel="external nofollow noopener noreferrer">std::atomic_flag<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 就能实现一个简单的锁，并实现其他基础原子类型。其余原子类型可以通过特化 <a href=https://en.cppreference.com/w/cpp/atomic/atomic target=_blank rel="external nofollow noopener noreferrer">std::atomic<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 来实现，且可以有更完整的功能，但不保证 lock-free</li><li>标准库中为 <a href=https://en.cppreference.com/w/cpp/atomic/atomic target=_blank rel="external nofollow noopener noreferrer">std::atomic<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 对内置类型的特化定义了类型别名</li></ul><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_bool</span> <span class=o>=</span> <span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_char</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  <span class=c1>// namespace std
</span></span></span></code></pre></td></tr></table></div></div><ul><li>通常类型 <code>std::atomic&lt;T></code> 的别名就是 <code>atomic_T</code>，只有以下几种例外：signed 缩写为 s，unsigned 缩写为 u，long long 缩写为 llong</li></ul><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>std</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_schar</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>signed</span> <span class=kt>char</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_uchar</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_uint</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_ushort</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>short</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_ulong</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_llong</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>long</span> <span class=kt>long</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>atomic_ullong</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  <span class=c1>// namespace std
</span></span></span></code></pre></td></tr></table></div></div><ul><li>原子类型不允许由另一个原子类型拷贝赋值，因为拷贝赋值调用了两个对象，破坏了操作的原子性。但可以用对应的内置类型赋值</li></ul><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>T</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>T</span> <span class=n>desired</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>T</span> <span class=n>desired</span><span class=p>)</span> <span class=k>volatile</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>atomic</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>atomic</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>atomic</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>atomic</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>volatile</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><ul><li>此外 <a href=https://en.cppreference.com/w/cpp/atomic/atomic target=_blank rel="external nofollow noopener noreferrer">std::atomic<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 为支持赋值提供了成员函数</li></ul><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>store</span>     <span class=c1>// 替换当前值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>load</span>      <span class=c1>// 返回当前值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>exchange</span>  <span class=c1>// 替换值，并返回被替换前的值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 与期望值比较，不等则将期望值设为原子值并返回 false
</span></span></span><span class=line><span class=cl><span class=c1>// 相等则将原子值设为目标值并返回 true
</span></span></span><span class=line><span class=cl><span class=c1>// 在缺少 CAS（compare-and-exchange）指令的机器上，weak 版本在相等时可能替换失败并返回 false
</span></span></span><span class=line><span class=cl><span class=c1>// 因此 weak 版本通常要求循环，而 strong 版本返回 false 就能确保不相等
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>compare_exchange_weak</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>compare_exchange_strong</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>fetch_add</span>        <span class=c1>// 原子加法，返回相加前的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>fetch_sub</span>        <span class=c1>// 原子减法，返回相减前的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>fetch_and</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>fetch_or</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>fetch_xor</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>++</span>       <span class=c1>// 前自增等价于 fetch_add(1) + 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>  <span class=c1>// 后自增等价于 fetch_add(1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>--</span>       <span class=c1>// 前自减等价于 fetch_sub(1) - 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>--</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>  <span class=c1>// 后自减等价于 fetch_sub(1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>+=</span>       <span class=c1>// fetch_add(x) + x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>-=</span>       <span class=c1>// fetch_sub(x) - x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>&amp;=</span>       <span class=c1>// fetch_and(x) &amp; x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>|=</span>       <span class=c1>// fetch_or(x) | x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>^=</span>       <span class=c1>// fetch_xor(x) ^ x
</span></span></span></code></pre></td></tr></table></div></div><ul><li>这些成员函数有一个用来指定内存序的参数 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order target=_blank rel="external nofollow noopener noreferrer">std::memory_order<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>，后续会解释内存序的含义</li></ul><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=nc>memory_order</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>memory_order_relaxed</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>memory_order_consume</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>memory_order_acquire</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>memory_order_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>memory_order_acq_rel</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>memory_order_seq_cst</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>memory_order</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>store</span><span class=p>(</span><span class=n>T</span> <span class=n>desired</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order</span> <span class=n>order</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// store 的内存序只能是
</span></span></span><span class=line><span class=cl><span class=c1>// memory_order_relaxed、memory_order_release、memory_order_seq_cst
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>T</span> <span class=nf>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order</span> <span class=n>order</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// load 的内存序只能是
</span></span></span><span class=line><span class=cl><span class=c1>// memory_order_relaxed、memory_order_consume、memory_order_acquire、memory_order_seq_cst
</span></span></span></code></pre></td></tr></table></div></div><h3 id=stdatomic_flaghttpsencppreferencecomwcppatomicatomic_flag><a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag target=_blank rel="external nofollow noopener noreferrer">std::atomic_flag<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li><a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag target=_blank rel="external nofollow noopener noreferrer">std::atomic_flag<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 是一个原子的布尔类型，也是唯一保证 lock-free 的原子类型，只能用 <a href=https://en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT target=_blank rel="external nofollow noopener noreferrer">ATOMIC_FLAG_INIT<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 初始化为 false</li></ul><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic_flag</span> <span class=n>x</span> <span class=o>=</span> <span class=n>ATOMIC_FLAG_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>x</span><span class=p>.</span><span class=n>clear</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 将状态设为 false
</span></span></span><span class=line><span class=cl><span class=c1>// 不能为读操作语义：memory_order_consume、memory_order_acquire、memory_order_acq_rel
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=n>test_and_set</span><span class=p>();</span>  <span class=c1>// 将状态设为 true 且返回之前的值
</span></span></span></code></pre></td></tr></table></div></div><ul><li>用 <a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag target=_blank rel="external nofollow noopener noreferrer">std::atomic_flag<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 实现自旋锁</li></ul><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Spinlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>lock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>flag_</span><span class=p>.</span><span class=n>test_and_set</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>unlock</span><span class=p>()</span> <span class=p>{</span> <span class=n>flag_</span><span class=p>.</span><span class=n>clear</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic_flag</span> <span class=n>flag_</span> <span class=o>=</span> <span class=n>ATOMIC_FLAG_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Spinlock</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Output from thread &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kr>thread</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=其他原子类型>其他原子类型</h3><ul><li><a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag target=_blank rel="external nofollow noopener noreferrer">std::atomic_flag<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 功能过于局限，甚至无法像布尔类型一样使用，相比之下，<code>std::atomic&lt;bool></code> 更易用，它不保证 lock-free，可以用 <a href=https://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free target=_blank rel="external nofollow noopener noreferrer">is_lock_free<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 检验在当前平台上是否 lock-free</li></ul><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>  <span class=c1>// 读取 x 值返回给 y
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>                               <span class=c1>// x 写为 true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=n>exchange</span><span class=p>(</span><span class=nb>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=n>std</span><span class=o>::</span><span class=n>memory_order_acq_rel</span><span class=p>);</span>  <span class=c1>// x 用 false 替换，并返回旧值给 y
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>expected</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>                      <span class=c1>// 期望值
</span></span></span><span class=line><span class=cl><span class=c1>// 不等则将期望值设为 x 并返回 false，相等则将 x 设为目标值 true 并返回 true
</span></span></span><span class=line><span class=cl><span class=c1>// weak 版本在相等时也可能替换失败而返回 false，因此一般用于循环
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>x</span><span class=p>.</span><span class=n>compare_exchange_weak</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=nb>true</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>expected</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 对于只有两种值的 std::atomic&lt;bool&gt; 来说显得有些繁琐
</span></span></span><span class=line><span class=cl><span class=c1>// 但对其他原子类型来说，这个影响就大了
</span></span></span></code></pre></td></tr></table></div></div><ul><li>指针原子类型 <code>std::atomic&lt;T*></code> 也支持 <a href=https://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free target=_blank rel="external nofollow noopener noreferrer">is_lock_free<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/load target=_blank rel="external nofollow noopener noreferrer">load<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/store target=_blank rel="external nofollow noopener noreferrer">store<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/exchange target=_blank rel="external nofollow noopener noreferrer">exchange<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange target=_blank rel="external nofollow noopener noreferrer">compare_exchange_weak、compare_exchange_strong<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>，与 <code>std::atomic&lt;bool></code> 语义相同，只不过读取和返回的类型是 <code>T*</code> 而非 bool。此外指针原子类型还支持运算操作：<a href=https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add target=_blank rel="external nofollow noopener noreferrer">fetch_add<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub target=_blank rel="external nofollow noopener noreferrer">fetch_sub<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith target=_blank rel="external nofollow noopener noreferrer">++、&ndash;<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith2 target=_blank rel="external nofollow noopener noreferrer">+=、-=<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>A</span><span class=o>*&gt;</span> <span class=n>p</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>   <span class=c1>// p 为 &amp;a[0]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span><span class=o>*</span> <span class=n>x</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=n>fetch_add</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>  <span class=c1>// p 为 &amp;a[2]，并返回原始值 a[0]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>assert</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>-=</span> <span class=mi>1</span><span class=p>);</span>  <span class=c1>// p 为 &amp;a[1]，并返回给 x，相当于 x = p.fetch_sub(1) - 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>assert</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span></span></span></code></pre></td></tr></table></div></div><ul><li>整型原子类型（如 <code>std::atomic&lt;int></code>）在上述操作之外还支持 <a href=https://en.cppreference.com/w/cpp/atomic/atomic/fetch_or target=_blank rel="external nofollow noopener noreferrer">fetch_or<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/fetch_and target=_blank rel="external nofollow noopener noreferrer">fetch_and<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/fetch_xor target=_blank rel="external nofollow noopener noreferrer">fetch_xor<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith2 target=_blank rel="external nofollow noopener noreferrer">|=、&=、^=<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>i</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=p>.</span><span class=n>fetch_and</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>  <span class=c1>// 101 &amp; 011 = 001
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>assert</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=mi>5</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><ul><li>用整型原子类型实现 Spinlock</li></ul><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Spinlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>lock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>flag_</span><span class=p>.</span><span class=n>compare_exchange_weak</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>unlock</span><span class=p>()</span> <span class=p>{</span> <span class=n>flag_</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>flag_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ul><li>用整型原子类型实现 SharedSpinlock</li></ul><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SharedSpinlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>lock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>flag_</span><span class=p>.</span><span class=n>compare_exchange_weak</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>unlock</span><span class=p>()</span> <span class=p>{</span> <span class=n>flag_</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>lock_shared</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>flag_</span><span class=p>.</span><span class=n>compare_exchange_weak</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>           <span class=n>expected</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>expected</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>count_</span><span class=p>.</span><span class=n>fetch_add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>unlock_shared</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>count_</span><span class=p>.</span><span class=n>fetch_sub</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>flag_</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>flag_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>count_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ul><li>用整型原子类型实现 Barrier</li></ul><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Barrier</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>Barrier</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>n</span><span class=p>)</span> <span class=o>:</span> <span class=n>count_</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>spaces_</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>generation_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>wait</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>gen</span> <span class=o>=</span> <span class=n>generation_</span><span class=p>.</span><span class=n>load</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>--</span><span class=n>spaces_</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>spaces_</span> <span class=o>=</span> <span class=n>count_</span><span class=p>.</span><span class=n>load</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=o>++</span><span class=n>generation_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>generation_</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>==</span> <span class=n>gen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>yield</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>arrive</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>--</span><span class=n>count_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>--</span><span class=n>spaces_</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>spaces_</span> <span class=o>=</span> <span class=n>count_</span><span class=p>.</span><span class=n>load</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=o>++</span><span class=n>generation_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span> <span class=n>count_</span><span class=p>;</span>       <span class=c1>// 需要同步的线程数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span> <span class=n>spaces_</span><span class=p>;</span>      <span class=c1>// 剩余未到达 Barrier 的线程数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span> <span class=n>generation_</span><span class=p>;</span>  <span class=c1>// 所有线程到达 Barrier 的总次数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ul><li>如果原子类型是自定义类型，该自定义类型必须<a href=https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable target=_blank rel="external nofollow noopener noreferrer">可平凡复制（trivially copyable）<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>，也就意味着该类型不能有虚函数或虚基类。这可以用 <a href=https://en.cppreference.com/w/cpp/types/is_trivially_copyable target=_blank rel="external nofollow noopener noreferrer">is_trivially_copyable<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 检验</li></ul><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=n>f</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_trivially_copyable_v</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>;</span>                 <span class=c1>// 错误：A 不满足 trivially copyable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>v</span><span class=p>;</span>  <span class=c1>// 错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span>       <span class=c1>// 错误
</span></span></span></code></pre></td></tr></table></div></div><ul><li>自定义类型的原子类型不允许运算操作，只允许 <a href=https://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free target=_blank rel="external nofollow noopener noreferrer">is_lock_free<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/load target=_blank rel="external nofollow noopener noreferrer">load<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/store target=_blank rel="external nofollow noopener noreferrer">store<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/exchange target=_blank rel="external nofollow noopener noreferrer">exchange<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>、<a href=https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange target=_blank rel="external nofollow noopener noreferrer">compare_exchange_weak、compare_exchange_strong<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>，以及赋值操作和向自定义类型转换的操作</li><li>除了每个类型各自的成员函数，<a href=https://en.cppreference.com/w/cpp/atomic target=_blank rel="external nofollow noopener noreferrer">原子操作库<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>还提供了通用的自由函数，只不过函数名多了一个 <code>atomic_</code> 前缀，参数变为指针类型</li></ul><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>i</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic_load</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>  <span class=c1>// 等价于 i.load()
</span></span></span></code></pre></td></tr></table></div></div><ul><li>除 <a href=https://en.cppreference.com/w/cpp/atomic/atomic_is_lock_free target=_blank rel="external nofollow noopener noreferrer">std::atomic_is_lock_free<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 外，每个自由函数有一个 <code>_explicit</code> 后缀版本，<code>_explicit</code> 自由函数额外接受一个内存序参数</li></ul><div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>i</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic_load_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>  <span class=c1>// i.load(std::memory_order_acquire)
</span></span></span></code></pre></td></tr></table></div></div><ul><li>自由函数的设计主要考虑的是 C 语言没有引用而只能使用指针，<a href=https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange target=_blank rel="external nofollow noopener noreferrer">compare_exchange_weak、compare_exchange_strong<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 的第一个参数是引用，因此 <a href=https://en.cppreference.com/w/cpp/atomic/atomic_compare_exchange target=_blank rel="external nofollow noopener noreferrer">std::atomic_compare_exchange_weak、std::atomic_compare_exchange_strong<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 的参数用的是指针</li></ul><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>compare_exchange_weak</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>expected</span><span class=p>,</span> <span class=n>T</span> <span class=n>desired</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order</span> <span class=n>success</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>std</span><span class=o>::</span><span class=n>memory_order</span> <span class=n>failure</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>atomic_compare_exchange_weak</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;*</span> <span class=n>obj</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value_type</span><span class=o>*</span> <span class=n>expected</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value_type</span> <span class=n>desired</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>atomic_compare_exchange_weak_explicit</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;*</span> <span class=n>obj</span><span class=p>,</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value_type</span><span class=o>*</span> <span class=n>expected</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value_type</span> <span class=n>desired</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order</span> <span class=n>succ</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>memory_order</span> <span class=n>fail</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><ul><li><a href=https://en.cppreference.com/w/cpp/atomic/atomic_flag target=_blank rel="external nofollow noopener noreferrer">std::atomic_flag<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 对应的自由函数的前缀不是 <code>atomic_</code> 而是 <code>atomic_flag_</code>，但接受内存序参数的版本一样是 <code>_explicit</code> 后缀</li></ul><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic_flag</span> <span class=n>x</span> <span class=o>=</span> <span class=n>ATOMIC_FLAG_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>y</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic_flag_test_and_set_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic_flag_clear_explicit</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><ul><li>C++20 允许 <a href=https://en.cppreference.com/w/cpp/atomic/atomic target=_blank rel="external nofollow noopener noreferrer">std::atomic<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 的模板参数为 <a href=https://en.cppreference.com/w/cpp/memory/shared_ptr target=_blank rel="external nofollow noopener noreferrer">std::shared_ptr<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul><div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>x</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><h2 id=同步操作和强制排序enforced-ordering>同步操作和强制排序（enforced ordering）</h2><ul><li>两个线程分别读写数据，为了避免竞争，设置一个标记</li></ul><div class=highlight id=id-23><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>data_ready</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_thread</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>data_ready</span><span class=p>.</span><span class=n>load</span><span class=p>())</span> <span class=p>{</span>  <span class=c1>// 1 happens-before 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>milliseconds</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>  <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>write_thread</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>data</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>  <span class=c1>// 3 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>data_ready</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>      <span class=c1>// 4 inter-thread happens-before 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>std::atomic&lt;bool></code> 上的操作要求强制排序，该顺序由内存模型关系 happens-before 和 synchronizes-with 提供</li><li>happens-before 保证了 1 在 2 之前发生，3 在 4 之前发生，而 1 要求 4，所以 4 在 1 之前发生，最终顺序确定为 3412</li></ul><p><img loading=lazy src=images/4-1.png srcset="images/4-1.png, images/4-1.png 1.5x, images/4-1.png 2x" sizes=auto data-title=images/4-1.png data-alt=images/4-1.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><ul><li>如果没有强制排序，CPU 可能会调整指令顺序，如果顺序是 4123，读操作就会因为越界而出错</li></ul><h3 id=synchronizes-with>synchronizes-with</h3><ul><li>synchronizes-with 关系只存在于原子类型操作上，如果一个数据结构包含原子类型，这个数据结构上的操作（比如加锁）也可能提供 synchronizes-with 关系</li><li>变量 x 上，标记了内存序的原子写操作 W，和标记了内存序的原子读操作，如果两者存在 synchronizes-with 关系，表示读操作读取的是：W 写入的值，或 W 之后同一线程上原子写操作写入 x 的值，或任意线程上对 x 的一系列原子读改写操作（比如 fetch_add、compare_exchange_weak）的值</li><li>简单来说，如果线程 A 写入一个值，线程 B 读取该值，则 A synchronizes-with B</li></ul><h3 id=happens-beforehttpsencppreferencecomwcppatomicmemory_orderhappens-before><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 和 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 关系是程序操作顺序的基本构建块，它指定某个操作可以看到其他操作的结果。对单线程来说很简单，如果一个操作在另一个之前，就可以说前一个操作 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>（且 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>） 后一个操作</li><li>如果操作发生在同一语句中，一般不存在 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 关系，因为它们是无序的</li></ul><div class=highlight id=id-24><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>++</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=p>(</span><span class=n>g</span><span class=p>(),</span> <span class=n>g</span><span class=p>());</span>  <span class=c1>// 无序调用 g，可能是 21 也可能是 12
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 一般 C++ 默认使用 __cdecl 调用模式，参数从右往左入栈，就是21
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>前一条语句中的所有操作都 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 下一条语句中的所有操作</li></ul><h3 id=inter-thread-happens-beforehttpsencppreferencecomwcppatomicmemory_orderinter-thread_happens-before><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li>如果一个线程中的操作 A <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 另一个线程中的操作 B，则 A <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B</li><li>A <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B 包括以下情况<ul><li>A synchronizes-with B</li><li>A <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Dependency-ordered_before target=_blank rel="external nofollow noopener noreferrer">dependency-ordered-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B</li><li>A <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> X，X <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B</li><li>A <a href=https://en.cppreference.com/w/cpp/language/eval_order target=_blank rel="external nofollow noopener noreferrer">sequenced-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> X，X <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B</li><li>A synchronizes-with X，X <a href=https://en.cppreference.com/w/cpp/language/eval_order target=_blank rel="external nofollow noopener noreferrer">sequenced-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B</li></ul></li></ul><h3 id=strongly-happens-beforehttpsencppreferencecomwcppatomicmemory_orderstrongly_happens-before><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 关系大多数情况下和 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 一样，A <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B 包括以下情况<ul><li>A synchronizes-with B</li><li>A <a href=https://en.cppreference.com/w/cpp/language/eval_order target=_blank rel="external nofollow noopener noreferrer">sequenced-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> X，X <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B</li><li>A <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> X，X <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> B</li></ul></li><li>略微不同的是，<a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Inter-thread_happens-before target=_blank rel="external nofollow noopener noreferrer">inter-thread happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 关系可以用 memory_order_consume 标记，而 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Strongly_happens-before target=_blank rel="external nofollow noopener noreferrer">strongly-happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 不行。但大多数代码不应该使用 memory_order_consume，所以这点实际上影响不大</li></ul><h3 id=stdmemory_orderhttpsencppreferencecomwcppatomicmemory_order><a href=https://en.cppreference.com/w/cpp/atomic/memory_order target=_blank rel="external nofollow noopener noreferrer">std::memory_order<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><div class=highlight id=id-25><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=nc>memory_order</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>memory_order_relaxed</span><span class=p>,</span>  <span class=c1>// 无同步或顺序限制，只保证当前操作原子性
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>memory_order_consume</span><span class=p>,</span>  <span class=c1>// 标记读操作，依赖于该值的读写不能重排到此操作前
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>memory_order_acquire</span><span class=p>,</span>  <span class=c1>// 标记读操作，之后的读写不能重排到此操作前
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>memory_order_release</span><span class=p>,</span>  <span class=c1>// 标记写操作，之前的读写不能重排到此操作后
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>memory_order_acq_rel</span><span class=p>,</span>  <span class=c1>// 仅标记读改写操作，读操作相当于 acquire，写操作相当于 release
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>memory_order_seq_cst</span>   <span class=c1>// sequential consistency：顺序一致性，不允许重排，所有原子操作的默认选项
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>memory_order</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><h3 id=relaxed-orderinghttpsencppreferencecomwcppatomicmemory_orderrelaxed_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering target=_blank rel="external nofollow noopener noreferrer">Relaxed ordering<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li>标记为 memory_order_relaxed 的原子操作不是同步操作，不强制要求并发内存的访问顺序，只保证原子性和修改顺序一致性</li></ul><div class=highlight id=id-26><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>  <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>      <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>  <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>42</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>     <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 可能执行顺序为 4123，结果 i == 42, j == 42
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering target=_blank rel="external nofollow noopener noreferrer">Relaxed ordering<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 不允许循环依赖</li></ul><div class=highlight id=id-27><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>i</span> <span class=o>=</span> <span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>  <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>42</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>  <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>j</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>  <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=mi>42</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>42</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>  <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 结果不允许为i == 42, j == 42
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 因为要产生这个结果，1 依赖 4，4 依赖 3，3 依赖 2，2 依赖 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>典型使用场景是自增计数器，比如 <a href=https://en.cppreference.com/w/cpp/memory/shared_ptr target=_blank rel="external nofollow noopener noreferrer">std::shared_ptr<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 的引用计数器，它只要求原子性，不要求顺序和同步</li></ul><div class=highlight id=id-28><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>fetch_add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kr>thread</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span><span class=p>;</span>  <span class=c1>// 10000
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=release-consume-orderinghttpsencppreferencecomwcppatomicmemory_orderrelease-consume_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Consume_ordering target=_blank rel="external nofollow noopener noreferrer">Release-Consume ordering<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li>对于标记为 memory_order_consume 原子变量 x 的读操作 R，当前线程中依赖于 x 的读写不允许重排到 R 之前，其他线程中对依赖于 x 的变量写操作对当前线程可见</li><li>如果线程 A 对一个原子变量x的写操作为 memory_order_release，线程 B 对同一原子变量的读操作为 memory_order_consume，带来的副作用是，线程 A 中所有 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Dependency-ordered_before target=_blank rel="external nofollow noopener noreferrer">dependency-ordered-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 该写操作的其他写操作（non-atomic和relaxed atomic），在线程 B 的其他依赖于该变量的读操作中可见</li><li>典型使用场景是访问很少进行写操作的数据结构（比如路由表），以及以指针为中介的 publisher-subscriber 场景，即生产者发布一个指针给消费者访问信息，但生产者写入内存的其他内容不需要对消费者可见，这个场景的一个例子是 RCU（Read-Copy Update）。该顺序的规范正在修订中，并且暂时不鼓励使用 memory_order_consume</li></ul><div class=highlight id=id-29><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>producer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>i</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>consumer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span><span class=o>*</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>q</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_consume</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=o>*</span><span class=n>q</span> <span class=o>==</span> <span class=mi>42</span><span class=p>);</span>  <span class=c1>// 一定不出错：*q 带有 x 的依赖
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assert</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>42</span><span class=p>);</span>   <span class=c1>// 可能出错也可能不出错：i 不依赖于 x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>producer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>consumer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=release-acquire-orderinghttpsencppreferencecomwcppatomicmemory_orderrelease-acquire_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering target=_blank rel="external nofollow noopener noreferrer">Release-Acquire ordering<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li>对于标记为 memory_order_acquire 的读操作 R，当前线程的其他读写操作不允许重排到 R 之前，其他线程中在同一原子变量上所有的写操作在当前线程可见</li><li>如果线程 A 对一个原子变量的写操作 W 为 memory_order_release，线程 B 对同一原子变量的读操作为 memory_order_acquire，带来的副作用是，线程 A 中所有 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> W 的写操作（non-atomic 和 relaxed atomic）都在线程 B 中可见</li><li>典型使用场景是互斥锁，线程 A 的释放后被线程 B 获取，则 A 中释放锁之前发生在 critical section 的所有内容都在 B 中可见</li></ul><div class=highlight id=id-30><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>producer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>i</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>consumer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span><span class=o>*</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>q</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=o>*</span><span class=n>q</span> <span class=o>==</span> <span class=mi>42</span><span class=p>);</span>  <span class=c1>// 一定不出错
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assert</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>42</span><span class=p>);</span>   <span class=c1>// 一定不出错
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>producer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>consumer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>对于标记为 memory_order_release 的写操作 W，当前线程中的其他读写操作不允许重排到W之后，若其他线程 acquire 该原子变量，则当前线程所有 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Happens-before target=_blank rel="external nofollow noopener noreferrer">happens-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 的写操作在其他线程中可见，若其他线程 consume 该原子变量，则当前线程所有 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Dependency-ordered_before target=_blank rel="external nofollow noopener noreferrer">dependency-ordered-before<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> W 的其他写操作在其他线程中可见</li><li>对于标记为 memory_order_acq_rel 的读改写（read-modify-write）操作，相当于写操作是 memory_order_release，读操作是 memory_order_acquire，当前线程的读写不允许重排到这个写操作之前或之后，其他线程中 release 该原子变量的写操作在修改前可见，并且此修改对其他 acquire 该原子变量的线程可见</li><li><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering target=_blank rel="external nofollow noopener noreferrer">Release-Acquire ordering<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 并不表示 total ordering</li></ul><div class=highlight id=id-31><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>write_x</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 1 happens-before 3（由于 3 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>write_y</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 2 happens-before 5（由于 5 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_x_then_y</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 3 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_y_then_x</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 5 happens-before 6
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>write_x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>write_y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t3</span><span class=p>(</span><span class=n>read_x_then_y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t4</span><span class=p>(</span><span class=n>read_y_then_x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t3</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t4</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// z 可能为 0，134 y 为 false，256 x 为 false，但 12 之间没有关系
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=images/4-2.png srcset="images/4-2.png, images/4-2.png 1.5x, images/4-2.png 2x" sizes=auto data-title=images/4-2.png data-alt=images/4-2.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><ul><li>为了使两个写操作有序，将其放到一个线程里</li></ul><div class=highlight id=id-32><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>write_x_then_y</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>  <span class=c1>// 1 happens-before 2
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 2 happens-before 3（由于 3 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_y_then_x</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 3 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>write_x_then_y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>read_y_then_x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>z</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>  <span class=c1>// 顺序一定为 1234，z 一定不为 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>利用 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering target=_blank rel="external nofollow noopener noreferrer">Release-Acquire ordering<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a> 可以传递同步</li></ul><div class=highlight id=id-33><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// v[0]、v[1] 的设置没有先后顺序，但都 happens-before 1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>store</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 1 happens-before 2（由于 2 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 2：happens-before 3
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 3 happens-before 4（由于 4 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>h</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 4 happens-before v[0]、v[1] 的读取
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>使用读改写操作可以将上面的两个标记合并为一个</li></ul><div class=highlight id=id-34><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>store</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 1 happens-before 2（由于 2 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>x</span><span class=p>.</span><span class=n>compare_exchange_strong</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>memory_order_acq_rel</span><span class=p>))</span> <span class=p>{</span>  <span class=c1>// 2 happens-before 3（由于 3 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// x 为 1 时，将 x 替换为 2，返回 true
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// x 为 0 时，将 i 替换为 x，返回 false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 返回 false 时，x 未被替换，i 被替换为 0，因此将 i 重新设为 1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>h</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=sequentially-consistent-orderinghttpsencppreferencecomwcppatomicmemory_ordersequentially-consistent_ordering><a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering target=_blank rel="external nofollow noopener noreferrer">Sequentially-consistent ordering<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><ul><li>memory_order_seq_cst 是所有原子操作的默认选项，可以省略不写。对于标记为 memory_order_seq_cst 的操作，读操作相当于 memory_order_acquire，写操作相当于 memory_order_release，读改写操作相当于 memory_order_acq_rel，此外还附加一个单独的 total ordering，即所有线程对同一操作看到的顺序也是相同的。这是最简单直观的顺序，但由于要求全局的线程同步，因此也是开销最大的</li></ul><div class=highlight id=id-35><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 要么 1 happens-before 2，要么 2 happens-before 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>write_x</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>  <span class=c1>// 1 happens-before 3（由于 3 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>write_y</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>  <span class=c1>// 2 happens-before 5（由于 5 的循环）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_x_then_y</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>())</span> <span class=p>{</span>  <span class=c1>// 3 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>())</span> <span class=p>{</span>  <span class=c1>// 4 为 false 则 1 happens-before 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_y_then_x</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>())</span> <span class=p>{</span>  <span class=c1>// 5 happens-before 6
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>())</span> <span class=p>{</span>  <span class=c1>// 6 如果返回 false 则一定是 2 happens-before 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>write_x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>write_y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t3</span><span class=p>(</span><span class=n>read_x_then_y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t4</span><span class=p>(</span><span class=n>read_y_then_x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t3</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t4</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>z</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>  <span class=c1>// z 一定不为 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// z 可能为 1 或 2，12 之间必定存在 happens-before 关系
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=images/4-3.png srcset="images/4-3.png, images/4-3.png 1.5x, images/4-3.png 2x" sizes=auto data-title=images/4-3.png data-alt=images/4-3.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=stdatomic_thread_fencehttpsencppreferencecomwcppatomicatomic_thread_fence><a href=https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence target=_blank rel="external nofollow noopener noreferrer">std::atomic_thread_fence<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></h3><div class=highlight id=id-36><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>             <span class=c1>// 1 happens-before 2
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>atomic_thread_fence</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 2 synchronizes-with 3
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic_thread_fence</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>  <span class=c1>// 3 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>              <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>y</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>z</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>  <span class=c1>// 1 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>将 x 替换为非原子 bool 类型，行为也一样</li></ul><div class=highlight id=id-37><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>                                             <span class=c1>// 1 happens-before 2
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>atomic_thread_fence</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>  <span class=c1>// 2 synchronizes-with 3
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic_thread_fence</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>  <span class=c1>// 3 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span>                                              <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>++</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>y</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>z</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>  <span class=c1>// 1 happens-before 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-12-19 19:14:20">更新于 2023-12-19&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/e1ba01ab9b638d53c2ab7706fcd26e9b60301bd5 rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) e1ba01ab9b638d53c2ab7706fcd26e9b60301bd5: feat: add concurrency in action notes"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>e1ba01a</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/C++_Concurrency_in_Action/CH05_CPP_Memory_Model_and_Operations_on_Atomic_Types/index.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/ data-title="C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types" data-hashtags=C++_Concurrency><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/ data-hashtag=C++_Concurrency><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/ data-title="C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/ch05_cpp_memory_model_and_operations_on_atomic_types/ data-title="C++ Concurrency in Action [5] | CH05 C++ Memory Model and Operations on Atomic Types"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/c++_concurrency/ class=post-tag>C++_Concurrency</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/ch04_synchronizing_concurrent_operation/ class=post-nav-item rel=prev title="C++ Concurrency in Action [4] | CH04 Synchronizing concurrent operations"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>C++ Concurrency in Action [4] | CH04 Synchronizing concurrent operations</a>
<a href=/posts/deadlocks/ class=post-nav-item rel=next title="C++ Concurrency in Action | Dead Locks">C++ Concurrency in Action | Dead Locks<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=jianye0428/JianBlog data-repo-id=R_kgDOJ4kgoQ data-category=General data-category-id=DIC_kwDOJ4kgoc4CX7CO data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.125.3">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> jianye',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>