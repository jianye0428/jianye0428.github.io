<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Effective C++ (第3版) 精读总结 [1] - yejian's blog</title><meta name=author content="Jian YE"><meta name=author-link content="https://github.com/jianye0428"><meta name=description content="Lruihao's Note 李瑞豪的博客：探索、分享、记录自己在工作生活学习到一些东西。人知道得越多，就就会发现无知的越多。有更广袤世界可以探索，真是莫大的快乐啊！"><meta name=keywords content="Effective"><meta itemprop=name content="Effective C++ (第3版) 精读总结 [1]"><meta itemprop=description content><meta itemprop=datePublished content="2023-07-29T18:51:19+08:00"><meta itemprop=dateModified content="2023-07-30T19:12:34+08:00"><meta itemprop=wordCount content="6432"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="Effective,"><meta property="og:title" content="Effective C++ (第3版) 精读总结 [1]"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://jianye0428.github.io/posts/partone/"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-29T18:51:19+08:00"><meta property="article:modified_time" content="2023-07-30T19:12:34+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="Effective C++ (第3版) 精读总结 [1]"><meta name=twitter:description content><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/partone/><link rel=prev href=https://jianye0428.github.io/posts/clause_9/><link rel=next href=https://jianye0428.github.io/posts/clause_11/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Effective C++ (第3版) 精读总结 [1]","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/partone\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"Effective","wordcount":6432,"url":"https:\/\/jianye0428.github.io\/posts\/partone\/","datePublished":"2023-07-29T18:51:19+08:00","dateModified":"2023-07-30T19:12:34+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Effective C++ (第3版) 精读总结 [1]</span></h1><p class="single-subtitle animate__animated animate__fadeIn">改善程序与设计的55个具体做法(Rule01-12)</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-07-29 18:51:19"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-07-29>2023-07-29</time></span>&nbsp;<span title="更新于 2023-07-30 19:12:34"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-07-30>2023-07-30</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 6432 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 13 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="Effective C++ (第3版) 精读总结 [1]">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#ch1让自己习惯c>CH1.让自己习惯C++</a><ul><li><a href=#r01-视c为一个语言联邦>R01 视C++为一个语言联邦</a></li><li><a href=#r02-尽量以constenuminline替换define>R02 尽量以<code>const</code>,<code>enum</code>,<code>inline</code>替换<code>#define</code></a></li><li><a href=#r03-尽可能用const>R03 尽可能用const</a></li><li><a href=#r04-确定对象使用前先初始化>R04 确定对象使用前先初始化</a></li></ul></li><li><a href=#ch2构造析构赋值运算>CH2.构造/析构/赋值运算</a><ul><li><a href=#r05-了解c默认编写并调用哪些函数>R05 了解C++默认编写并调用哪些函数</a></li><li><a href=#r06-不想编译器的自动生成的函数明确拒绝>R06 不想编译器的自动生成的函数,明确拒绝</a></li><li><a href=#r07-为多态基类声明virtual析构函数>R07 为多态基类声明<code>virtual</code>析构函数</a></li><li><a href=#r08-别让异常逃离析构函数>R08 别让异常逃离析构函数</a></li><li><a href=#r09-绝不在构造和析构过程中调用virtual函数>R09 绝不在构造和析构过程中调用<code>virtual</code>函数</a></li><li><a href=#r10-令operator返回一个reference-to-this>R10 令<code>operator=</code>返回一个reference to *this</a></li></ul></li><li><a href=#r11-在operator中处理自我赋值>R11 在<code>operator=</code>中处理"自我赋值"</a><ul><li><a href=#r12-复制对象时别忘记其每一个成分>R12 复制对象时别忘记其每一个成分</a></li></ul></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><h1 id=序言>序言</h1><p>这本C++的经典之作，作者是大佬<code>Scott Meyers</code>👉<a href=https://www.aristeia.com/books.html target=_blank rel="external nofollow noopener noreferrer">大佬主页<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>，还写过其他几本影响深远的C++经典，例如<code>《Effective STL》</code>,<code>《More Effective C++》</code>,<code>《Effective Mordern C++》</code>,<code>《Overview of the New C++(C++11/14)》</code>等等。本人看的是中文版，侯捷老师翻译的，精读分析并实践推敲后，整理成博客记录下来。</p><blockquote><p>(Effective-C++总结系列分为四部分，本文为第一部分，涉及原书第1~2章，内容范围Rule01~12。为方便书写，Rule01简写为R01)。</p></blockquote><div class="details admonition Note"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本博客站点系列内容如下：</br>💡 <a href=https://jianye0428.github.io/posts/partone/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 Effective C++(第3版)精读总结(二)</br>💡 Effective C++(第3版)精读总结(三)</br>💡 Effective C++(第3版)精读总结(四)</br></div></div></div><h2 id=ch1让自己习惯c>CH1.让自己习惯C++</h2><h3 id=r01-视c为一个语言联邦>R01 视C++为一个语言联邦</h3><p>如今的C++已经是个多重范式(multiparadigm)语言，同时支持面向过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 要理解这么多特性，可以简单的归结为<code>四种次语言</code>(sublanguage)组成：</p><ul><li><strong>C语言：</strong><code>C++仍以C为基础</code>。C++是C的超集，区块 、语句、预处理、内置数据类型、数组、指针等全部来自于C语言；<ul><li>说到底 C++ 仍然以 C 为基础。区块、语句、预处理器、内置数据类型 、数组、指针等统统来自C，许多时候C++对问题的解决其实不过就是较高级的 C 解法，但当你C++内的 C 成分工作时，高效编程守则映照出 C 语言的局限：没有模板(template) ，没有异常(exceptions)，没有重载(overloading)……</li></ul></li><li><strong>Object-Oriented C++:</strong> 面向对象特性。这部分也就是 C with classes 所诉求的：classes(包括构造函数和析构函数)，封装(encapsulation)、继承(inheritance)、多态(polymorhpism)、virtual函数(动态绑定)……等等，这一部分是面向对象设计之古典守则在C++ 上的直接实施。</li><li>**Template C++:**C++的泛型(generic)编程的部分，也带来了黑魔法-模板元编程(TMP,Metaprogramming)；</li><li>**STL：**STL(Standard Temlate Library)即标准模板库，它是template程序库。封装了各类容器(container)、配置器(allocator)、迭代器(iterator)、算法以及常用对象。</li></ul><p><strong>总结:</strong>
C++高效编程守则视状况而变化，取决于你使用C++的哪一部分</p><h3 id=r02-尽量以constenuminline替换define>R02 尽量以<code>const</code>,<code>enum</code>,<code>inline</code>替换<code>#define</code></h3><ul><li><strong>对于宏定义的常量，建议用const常量或者枚举enum替换</strong>
这样做的好处是方便调试，因为宏报错就是个常数值，没有符号表；并且宏不具有封装性(宏的作用域是在编译时是其定义之事)。<div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 举例：MAX_DATA_COUNT在预处理阶段就会被替换，编译器不会见到它，所以一旦有相关报错，给的是100这个值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define MAX_DATA_COUNT   100
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>const</span>  <span class=kt>int</span> <span class=n>MAX_DATA_COUNT</span> <span class=o>=</span> <span class=mi>100</span> <span class=p>;</span><span class=c1>//常量只有一份，宏会导致多份常量值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Buffer</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span><span class=c1>//...类其他部分省略
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=k>const</span> <span class=kt>double</span> <span class=n>factor_</span> <span class=p>;</span><span class=c1>//static常量,类内声明
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=k>const</span> <span class=kt>int</span>  <span class=n>times_</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=c1>// int类型允许类内初始化,规范上还是建议拿到类外
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span>  <span class=kt>int</span> <span class=n>ArrLength</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=n>ArrLength</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>double</span> <span class=n>Buffer</span><span class=o>::</span><span class=n>factor_</span>  <span class=o>=</span> <span class=mf>0.1</span><span class=p>;</span><span class=c1>//类外初始化,一般写在实现文件*.cpp,*.cc中
</span></span></span></code></pre></td></tr></table></div></div>如果编译器不允许声明时"in-class初值设定",如果是整形常量，可以让枚举值来替代，而且<font color=red><code>枚举值不能被取地址</code></font>。</li><li><strong>对于宏定义的函数，建议用内联inline函数替换</strong>
宏函数没办法单行debug调试，而内联函数可以；
宏的写法即使小心翼翼的加好了括号，也可能造成意想不到的<font color=red><code>宏函数重复计算</code></font>的问题。<div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define  GET_MAX(a,b)   ((a)&gt;(b) ? (a) :(b))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>GET_MAX</span><span class=p>(</span><span class=o>++</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>);</span>    <span class=c1>// a累加二次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>GET_MAX</span><span class=p>(</span><span class=o>++</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=o>+</span><span class=mi>10</span><span class=p>);</span> <span class=c1>// a累加一次
</span></span></span><span class=line><span class=cl><span class=c1>// 定义个inline函数就不会有这个问题,(a,b)作为函数入参就只会计算一次
</span></span></span></code></pre></td></tr></table></div></div><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>上述情况，从纯C语言角度，想避免“宏函数重复计算”，其实还有个方法，就是使用GNU C 扩展的 typeof 或 GCC 的 <code>__auto_type</code> 关键字，详细可参考GCC官方文档页面。2者都适用于GCC和Clang，都不适用MSVC），示例如下：</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define  GET_MAX_ONCE(a,b) \
</span></span></span><span class=line><span class=cl><span class=cp>      ( {typeof(a) _a = (a);   \
</span></span></span><span class=line><span class=cl><span class=cp>         typeof(b) _b = (b);   \
</span></span></span><span class=line><span class=cl><span class=cp>         (_a) &gt; (_b) ? (_a) : (_b); } )</span></span></span></code></pre></td></tr></table></div></div><p>测试代码如下：</p><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span><span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=nf>GET_MAX</span><span class=p>(</span><span class=o>++</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=o>++</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, b = &#34;</span><span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, c = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>10</span> <span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=nf>GET_MAX_ONCE</span><span class=p>(</span><span class=o>++</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=o>++</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, b = &#34;</span><span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, c = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>测试代码输出：</p><div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>a</span> <span class=o>=</span> 11, <span class=nv>b</span> <span class=o>=</span> 22, <span class=nv>c</span> <span class=o>=</span> <span class=m>21</span>
</span></span><span class=line><span class=cl><span class=nv>a</span> <span class=o>=</span> 11, <span class=nv>b</span> <span class=o>=</span> 21, <span class=nv>c</span> <span class=o>=</span> <span class=m>20</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>🤔 <code>使用 __auto_type</code> 来取代时要赋初值，关键的 typeof 那行用法改为<code>__auto_type _a = (a);</code> 。
__auto_type 比 typeof 的优势之处在于面对变长数组(VLA)，只解析1次；以及面对嵌套宏定义时也是只严格解析一次。</p></blockquote></div></div></div></li></ul><h3 id=r03-尽可能用const>R03 尽可能用const</h3><p>说起const，先复习个面试高频题😁</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//类型char在哪里没关系，关键看const和*的相对位置：
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//const在*左边，指针所指物为常量;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//const在*右边，指针为常量；
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>p</span><span class=p>;</span> <span class=c1>// 指针p所指的字符串为常量，但是p可以修改
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>p</span><span class=p>;</span> <span class=c1>// 指针p是常量，指向的字符串可修改
</span></span></span></code></pre></td></tr></table></div></div><ul><li>const修饰函数返回值时的防御性
const修饰函数的返回值，可以避免一些错误，如下：<div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>Rational</span> <span class=k>operator</span><span class=o>*</span> <span class=p>(</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>lhs</span><span class=p>,</span><span class=k>const</span> <span class=n>Rational</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//存在Rational a,b,c;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>c</span><span class=p>)</span> <span class=c1>//例如手误 &#34;==&#34;打成了&#34;=&#34;，编译器会直接报错
</span></span></span></code></pre></td></tr></table></div></div></li><li>const成员函数的限制
const成员函数有2个好处：(1). 明确理解函数是否修改对象内容；(2). 使“操作const对象”成为可能。
可以通过const特性让对象自动调用正确的版本：<div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>TextBlock</span><span class=p>{</span><span class=c1>//...类其他部分省略
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>char</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[](</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>{</span> <span class=k>return</span> <span class=n>text</span><span class=p>[</span><span class=n>index</span><span class=p>];}</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[](</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>index</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>text</span><span class=p>[</span><span class=n>index</span><span class=p>];}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>text</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=k>const</span> <span class=n>TextBlock</span><span class=o>&amp;</span> <span class=n>ctb</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>ctb</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>;</span><span class=c1>//根据const特性，调用 const TextBlock::operator[]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div>思考：const成员函数不修改成员对象，那么，如果成员对象为指针<code>char *p</code>，仅修改<code>p</code>指向的内容，那它还是<code>const</code>成员函数吗？
实测：const成员函数是允许<code>p[2]= 'x'</code>这一操作的，但是不允许p++；<ul><li><code>bitwise-constness</code>(又称为physical constness)理念认为不是，不能更改任何对象内的任何一个bit。这种说法也有纰漏，const函数返回一个引用就失控了,外部可改；</li><li><code>logical-constness</code>理念则允许const成员函数修改成员变量的bits，但只有在客户端侦测不出的情况下;</li><li><code>const成员函数</code>如果一定要修改成员变量，成员变量使用 <code>mutable</code> 修饰即可.</li></ul></li><li>const与non-const的成员函数实现完全相同时
这种情况，如何去除代码冗余是个问题。不要封装出一个private函数然后一起调用，多了层调用。
正确做法👉 <code>使用转型,让non-const调用const成员函数</code>，如下为示例：</li></ul><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rawdata</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Rawdata</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>src</span><span class=p>)</span><span class=o>:</span><span class=n>p_</span><span class=p>(</span><span class=n>src</span><span class=p>),</span><span class=n>length_</span><span class=p>(</span><span class=n>strlen</span><span class=p>(</span><span class=n>src</span><span class=p>))</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>GetLength</span><span class=p>()</span><span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p_</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;a&#39;</span><span class=p>;</span><span class=c1>//为求简便,不作检查了。p_内容修改编译器是允许的.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>length_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetLength</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&amp;&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Rawdata</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>)).</span><span class=n>GetLength</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>length_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h3 id=r04-确定对象使用前先初始化>R04 确定对象使用前先初始化</h3><p>分清"赋值"和"初始化"，在类的构造函数体内使用等号"=&ldquo;赋值并非"初始化”。成员变量的初始化是在构造函数的<u>成员初始化列表</u>实现，效率更高。</p><p><code>C++初始化的次序:</code></p><ol><li>Base class总是早于Derived Class被初始化；</li><li>Class内的成员变量总是以声明次序被初始化；
举例: 下图中的代码初始化顺序为声明顺序"age_$\rightarrow$name_$\rightarrow$gender_ $\rightarrow$isVip_&rdquo;<div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl> <span class=k>class</span> <span class=nc>Customer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span> <span class=c1>//这里只是为了验证，如果是实际工程代码，建议初值列表尽量和声明顺序保持一致
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=n>Customer</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>gender</span><span class=p>,</span> <span class=kt>uint8_t</span> <span class=n>age</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isVip</span> <span class=o>=</span> <span class=nb>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=o>:</span><span class=n>isVip_</span><span class=p>(</span><span class=n>isVip</span><span class=p>),</span> <span class=n>gender_</span><span class=p>(</span><span class=n>gender</span><span class=p>),</span> <span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=n>age_</span><span class=p>(</span><span class=n>age</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>     <span class=kt>uint8_t</span> <span class=n>age_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>gender_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=kt>bool</span> <span class=n>isVip_</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>};</span></span></span></code></pre></td></tr></table></div></div><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><pre><code>💡：任何一个成员变量a的初始化流程：类内声明赋初值(C++11)-&gt;构造函数初始化列表-&gt;构造函数体内赋值.
</code></pre></div></div></div></li><li>函数体外static变量称为<code>non-local static</code>变量，这种变量可以在各自的编译单元正常工作，但C++无法保证初始化次序，当编译单元之间需要共享变量时，而该变量依赖non-local static，就可能会出问题。
<strong>解决办法</strong>是将这样的变量放回函数体内，成为local static，因为C++确保在函数被调用时一定会初始化这个static变量。</li></ol><h2 id=ch2构造析构赋值运算>CH2.构造/析构/赋值运算</h2><h3 id=r05-了解c默认编写并调用哪些函数>R05 了解C++默认编写并调用哪些函数</h3><p>编译器可以暗自为Class创建<code>default构造函数</code>，<code>copy构造函数(复制构造)</code>，<code>copy assigment(赋值构造)操作符</code>，以及<code>default析构函数</code>。</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>EmptyClass</span><span class=p>{};</span></span></span></code></pre></td></tr></table></div></div><p>等价于:</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>EmptyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>EmptyClass</span><span class=p>()</span> <span class=p>{}</span>        <span class=c1>// default构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>EmptyClass</span><span class=p>(</span><span class=k>const</span> <span class=n>EmptyClass</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{}</span><span class=c1>//copy构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>EmptyClass</span><span class=p>()</span> <span class=p>{}</span><span class=c1>//default析构函数，注意是non-virtual
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>EmptyClass</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>EmptyClass</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{}</span><span class=c1>//copy assignment操作符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>如果一个非空Class自行声明了构造函数，编译器就不再为它创建default构造函数;</p></li><li><p>如果一个Class内有引用变量或const变量，编译器不会为其生成copy-assignment函数，需要自己实现.</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>NameObject</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NameObject</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=o>:</span><span class=n>nameValue_</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=n>objectVal_</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>nameValue_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>objectVal_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span><span class=c1>//考虑以下应用代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>(</span><span class=s>&#34;Mike&#34;</span><span class=p>),</span> <span class=n>name2</span><span class=p>(</span><span class=s>&#34;Nicky&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>NameObject</span> <span class=nf>nObj</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=mi>22</span><span class=p>),</span> <span class=n>nObj2</span><span class=p>(</span><span class=n>name2</span><span class=p>,</span><span class=mi>33</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>nObj2</span> <span class=o>=</span> <span class=n>nObj</span><span class=p>;</span><span class=c1>//这一句会导致编译失败，因为引用不能指向2个对象，且const不可改
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=r06-不想编译器的自动生成的函数明确拒绝>R06 不想编译器的自动生成的函数,明确拒绝</h3><p>某些场景，类对象本身是认为独一无二的，比如描述人物性格的类Personality(可能不恰当)，不同的人性格不同，肯定是不希望能复制/赋值的。
如果不想编译器自动生成那几个函数，比如不想要复制构造或赋值构造，就明确在代码中禁止，也防止外部用户使用。</p><ul><li>技巧1：可以声明为private函数但是不给出实现，让编译器报错；</li><li>技巧2：可以设立基类Base，让复制构造和赋值构造都为private函数，让目标类继承于Base类。</li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>C++11针对此类情况，给予了delete关键字一个新功能，在成员函数后面新增"=delete"，即可显式地拒绝这个函数的生成和调用.举例如下:</p><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span> <span class=c1>// 拷贝构造
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>A</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span> <span class=c1>// 拷贝赋值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></div></div></div><h3 id=r07-为多态基类声明virtual析构函数>R07 为多态基类声明<code>virtual</code>析构函数</h3><ul><li>针对<code>Base* pBase= new DerivedObj()</code>，释放pBase时，如果Base基类的析构函数<code>None-Virtual</code>，则会导致Derived的析构函数不会被调用，造成<code>内存不完全释放</code>，即内存泄漏；</li><li>Non-Virtual的Class不要做基类；</li><li>如果不做基类，就不要声明析构函数为virtual函数，避免虚表为其分配vptr造成浪费；</li><li>如果想要抽象类，又暂时没有合适接口，可以让先虚析构成为纯虚函数，例如<div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>RawData</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>RawData</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 这里特殊的是，需要为这个纯虚函数提供定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>~</span><span class=n>RawData</span><span class=o>::</span><span class=n>RawData</span><span class=p>(){}</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=r08-别让异常逃离析构函数>R08 别让异常逃离析构函数</h3><ul><li><p>析构函数最好不要吐出异常</br>对于某个Widget类，如果析构函数抛出异常，那么<code>vector&lt;widget></code>析构时可能连续抛出多个异常以至于无法处理，直接导致提前程序结束或者未定义行为。</p></li><li><p>如果有某个函数可能会抛出异常，并需要对异常做出反应，应该提供一个非析构的函数来处理</br>注意，在析构中抛异常并吞下(catch后go-on-execute)，会掩盖错误，也不是个好办法;抛异常后catch住并std::abort()反而可以提前终结『未定义行为』。</p></li></ul><h3 id=r09-绝不在构造和析构过程中调用virtual函数>R09 绝不在构造和析构过程中调用<code>virtual</code>函数</h3><ul><li>在Derived-Class的Base-Class构造期间，对象的类型是Base-Class，而非Derived，即使<code>dynamic_cast</code>也是这样认为的，因为此时virtual函数不会下降到Derived-Class的阶层；换句话说==> “<code>在Base-Class构造期间，virtual函数不是virtual函数</code>”；</li><li>在析构的时候也是类似道理，也不要在析构函数中调用virtual函数，间接调用也不行(比如non-Virtual->virtual)；</li><li>那么替代方案是？</br>如果有这样一种情况，希望在子类构造时能调用父类的foo函数(下方logTransaction函数)，那么将foo改为non-Virtual函数，并且子类构造时调用父类构造函数，有参数时一并传过去；</li></ul><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Transaction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>explict</span> <span class=n>Transaction</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>,</span><span class=kt>int</span> <span class=n>id</span><span class=p>)</span><span class=o>:</span><span class=n>id_</span><span class=p>(</span><span class=n>id</span><span class=p>)</span> <span class=p>{</span> <span class=n>logTransaction</span><span class=p>(</span><span class=n>info</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>logTransaction</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>info</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span> <span class=p>}</span><span class=c1>//non-Virtual函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>id_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BuyTransaction</span> <span class=o>:</span><span class=k>public</span> <span class=n>Transaction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>  <span class=c1>//将log信息传递给 基类Transaction构造函数； 并初始化了基类成员
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BuyTransaction</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>info</span><span class=p>,</span> <span class=kt>int</span> <span class=n>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span><span class=n>Transaction</span><span class=p>(</span><span class=n>info</span><span class=p>,</span><span class=n>id</span><span class=p>)</span> <span class=p>{</span><span class=cm>/**/</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>上述代码中，如果有几个Base构造函数，就得写几个Derived构造函数传参。为了简化这一步骤， 在现代C++11，推出了继承构造函数(Inheriting Constructor)，子类可以一个都不用写，直接写一句using声明即可，使用<code>using BaseClass::BaseClass</code>的形式，如下👇</p><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BuyTransaction</span> <span class=o>:</span><span class=k>public</span> <span class=n>Transaction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>Transaction</span><span class=o>::</span><span class=n>Transaction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//其他
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></div></div></div><h3 id=r10-令operator返回一个reference-to-this>R10 令<code>operator=</code>返回一个reference to *this</h3><ul><li>关于赋值操作符<code>operator=</code>，主流做法是:<div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Widget</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>//... do some thing
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div>上述做法不局限于operator=，还有<code>operator += ,-=,*=,/=</code>等其他赋值运算符。</br>该主流协议/做法不是强制性的，只是个建议，因为这样可以允许<strong>连续赋值</strong>($x=y=z$的形式)。</br>该协议被内置类型，以及STL的类型(如string,vector,complex,shared_ptr)共同遵守。</br></li></ul><h2 id=r11-在operator中处理自我赋值>R11 在<code>operator=</code>中处理"自我赋值"</h2><p>一个对象赋值给自己，这种看起来有点傻的做法，有时候会比较难以发觉。比如：<code>a[i] = a[j]</code>，如果 $i$ 和 $j$ 相等，就是“自我赋值”的经典场景了。
所以，我们需要一个尽量完备的赋值操作符函数🤔。
考虑如下类<code>MapWidget</code>，内有数据裸指针<code>BitMap *pb_</code>，在赋值时同时考虑<strong>异常安全</strong>和 <strong>“自我赋值”</strong> 安全(认同测试保障自我赋值安全)，是一个相对不错的实现。但是，认同测试会降低运行效率，根据实际工程实践情况(自我赋值概率极低 )可以酌情去掉。</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BitMap</span> <span class=p>{</span><span class=cm>/*省略类声明&amp;实现*/</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MapWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>BitMap</span> <span class=o>*</span> <span class=n>pb_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>MapWidget</span><span class=p>(</span><span class=n>BitMap</span> <span class=o>*</span><span class=n>pb</span><span class=p>)</span> <span class=o>:</span><span class=n>pb_</span><span class=p>(</span><span class=n>pb</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>MapWidget</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>MapWidget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=c1>//这一句为认同测试(identity test)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>BitMap</span> <span class=o>*</span><span class=n>pOrig</span> <span class=o>=</span> <span class=n>pb_</span><span class=p>;</span><span class=c1>//不要一上来就delete，而是保存this-&gt;pb_
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pb_</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BitMap</span><span class=p>(</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>pb_</span><span class=p>);</span><span class=c1>//因为这一句可能抛异常
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>pOrig</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ul><li>Copy and Swap技术 上文中保障<strong>异常安全</strong>和 **“自我赋值”**安全的技术手段，另外一个办法，就是Copy and Swap技术。这个技术的关键在于“修改对象数据的副本，然后在一个不抛异常的函数中将修改的数据和原件置换 ”。<div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>MapWidget</span><span class=o>::</span><span class=n>Swap</span><span class=p>(</span><span class=n>MapWidget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>){</span><span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>pb_</span><span class=p>,</span><span class=n>pb_</span><span class=p>);}</span>
</span></span><span class=line><span class=cl><span class=n>MapWidget</span><span class=o>&amp;</span> <span class=n>MapWidget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>MapWidget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MapWidget</span> <span class=nf>temp</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Swap</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=r12-复制对象时别忘记其每一个成分>R12 复制对象时别忘记其每一个成分</h3><ul><li><p>编写类的Copying函数时需要做到2点
这里的Copying函数是指有copy属性的特殊函数==> copy构造函数和copy赋值操作符。</p><ol><li>复制所有Local成员变量
如果成员复制的时候有遗漏，编译器并不会有怨言，这就埋下了隐患。如果新增了成员，要对应修改Copying函数。</li><li>调用所有Base-Class内部的适当的Copy函数
具体代码的推荐实现 如下👇：</li></ol><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Customer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Customer</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>float</span> <span class=n>money</span><span class=p>)</span><span class=o>:</span><span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>),</span><span class=n>money_</span><span class=p>(</span><span class=n>money</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>money_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>VipCustomer</span> <span class=o>:</span><span class=k>public</span> <span class=n>Customer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>  <span class=c1>//注意：派生类要复制基类那部分的成员变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>Customer</span><span class=o>::</span><span class=n>Customer</span><span class=p>;</span> <span class=c1>//参考R09
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>VipCustomer</span><span class=p>(</span><span class=k>const</span> <span class=n>VipCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span><span class=n>priority_</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>priority_</span><span class=p>),</span><span class=n>Customer</span><span class=p>(</span><span class=n>rhs</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>    <span class=n>VipCustomer</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>VipCustomer</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Customer</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>priority_</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>priority_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setPriority</span><span class=p>(</span><span class=kt>int</span> <span class=n>priority</span><span class=p>)</span> <span class=p>{</span> <span class=n>priority_</span> <span class=o>=</span> <span class=n>priority</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>priority_</span><span class=p>;</span><span class=c1>//子类独有成员可以单独set函数赋值，或者构造函数初始化列表赋值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li><li><p>不要用一个Copying函数去实现另一个
令copy-assignment操作符调用copy构造函数是不合理的；反之，后者调用前者也是无意义的。 如果2者有大量的代码是相同的，可以剥离一个类内private类型的<code>init</code>函数出来，提供给上述2者调用。</p></li></ul><p>ref:</br>[1]. <a href=https://blog.csdn.net/cltcj/category_12098441.html target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>[2]. <a href=https://kissingfire123.github.io/2021/12/06_effective-c-%e4%b9%8b%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93%e4%b8%80/ target=_blank rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2021/12/06_effective-c-%e4%b9%8b%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93%e4%b8%80/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br></p></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-07-30 19:12:34">更新于 2023-07-30&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/161880f30863de2abe9c60a2698df4dd5880cacd rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) 161880f30863de2abe9c60a2698df4dd5880cacd: feat: add c++ effective part two"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>161880f</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/partone/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/Effective_C++/PartOne/index.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/partone/ data-title="Effective C++ (第3版) 精读总结 [1]" data-hashtags=Effective><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/partone/ data-hashtag=Effective><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/partone/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/partone/ data-title="Effective C++ (第3版) 精读总结 [1]"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/partone/ data-title="Effective C++ (第3版) 精读总结 [1]"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/effective/ class=post-tag>Effective</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/clause_9/ class=post-nav-item rel=prev title="Effective STL [9] | 在删除选项中仔细选择"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Effective STL [9] | 在删除选项中仔细选择</a>
<a href=/posts/clause_11/ class=post-nav-item rel=next title="Effective STL [11] | 理解自定义分配器的正确用法">Effective STL [11] | 理解自定义分配器的正确用法<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.116.1">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> 李瑞豪',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>