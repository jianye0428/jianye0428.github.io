# C++ 基础知识[二]


{{< admonition quote "quote" false >}}
c++ 八股文 第一部分
{{< /admonition >}}

<!--more-->


## 6 基础知识(六)

### 6.1 构造函数为什么不能定义为虚函数？ ⽽析构函数⼀般写成虚函数的原因 ？

构造函数不能声明为虚函数的原因是:
> 1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。</br>
> 2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。</br>

虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。（动态绑定是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本就不存在，它怎么动态绑定？）
编译器在调用基类的构造函数的时候并不知道你要构造的是一个基类的对象还是一个派生类的对象。

> 析构函数设为虚函数的作用:
解释：在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。（如果基类的析构函数不是虚函数，那么在delete 基类指针时，只调用基类的析构函数，不会调用派生类的析构函数，故派生类部分不会被析构。）

### 6.2 c/c++中register关键字（寄存器、缓存、内存）
[c/c++中register关键字（寄存器、缓存、内存）](https://blog.csdn.net/u012484779/article/details/117514000)

一般情况下，变量的值是存储在内存中的，CPU 每次使用数据都要从内存中读取。如果有一些变量使用非常频繁，从内存中读取就会消耗很多时间，例如 for 循环中的增量控制。

为了解决这个问题，可以将使用频繁的变量放在CPU的通用寄存器中，这样使用该变量时就不必访问内存，直接从寄存器中读取，大大提高程序的运行效率。

**寄存器、缓存、内存**

为了加深对 register 变量的理解，这里有必要讲一下CPU寄存器。

按照与CPU的远近来分，离CPU最近的是寄存器，然后是缓存，最后是内存。

寄存器是最贴近CPU的，而且CPU只在寄存器中进行存取。<font color=green>寄存的意思是暂时存放数据，不用每次都从内存中读取，它是一个临时的存放数据的空间</font>。

而寄存器的数据又来源于内存，于是 CPU <-- 寄存器 <-- 内存，这就是它们之间的信息交换。

<font color=red>那么为什么还需要缓存呢？</font>因为如果频繁地操作内存中同一地址上的数据会影响速度，于是就在寄存器和内存之间设置一个缓存，把使用频繁的数据暂时保存到缓存，如果寄存器需要读取内存中同一地址上的数据，就不用大老远地再去访问内存，直接从缓存中读取即可。

缓存的速度远高于内存，价格也是如此。

注意：缓存的容量是有限的，寄存器只能从缓存中读取到部分数据，对于使用不是很频繁的数据，会绕过缓存，直接到内存中读取。所以不是每次都能从缓存中得到数据，这就是缓存的命中率，能够从缓存中读取就命中，否则就没命中。

关于缓存的命中率又是一门学问，哪些数据保留在缓存，哪些数据不保留，都有复杂的算法。

注意：上面所说的CPU是指CPU核心，从市场上购买的CPU已是封装好的套件，附带了寄存器和缓存，插到主板上就可以用。

从经济和速度的综合考虑，缓存又被分为一级缓存、二级缓存和三级缓存，它们的存取速度和价格依次降低，容量依次增加。购买到的CPU一般会标出三级缓存的容量。

**register 变量**

寄存器的数量是有限的，通常是把使用最频繁的变量定义为 register 的。

关于寄存器变量有以下事项需要注意：
  - 为寄存器变量分配寄存器是动态完成的，因此，只有局部变量和形式参数才能定义为寄存器变量。
  - 局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。
  - 寄存器的长度一般和机器的字长一致，所以，只有较短的类型如int、char、short等才适合定义为寄存器变量，诸如double等较大的类型，不推荐将其定义为寄存器类型。
  - CPU的寄存器数目有限，因此，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的auto变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 register 关键字，也自动为其分配寄存器，无须由程序员来指定。

**c++中register**

在早期c语言编译器不会对代码进行优化，因此使用register关键字修饰变量是很好的补充，大大提高的速度。

register关键字请求让编译器将变量a直接放入寄存器里面，以提高读取速度，在C语言中register关键字修饰的变量不可以被取地址，但是c++中进行了优化。

c++中依然支持register关键字，但是c++编译器也有自己的优化方式，即某些变量不用register关键字进行修饰，编译器也会将多次连续使用的变量优化放入寄存器中，例如入for循环的循环变量i。

c++中也可以对register修饰的变量取地址，不过c++编译器发现程序中需要取register关键字修饰的变量的地址时，register关键字的声明将变得无效。

### 6.3 c/c++中进程和线程的区别

[c++多线程编程 -- 进程与线程区别](https://blog.csdn.net/weixin_43956732/article/details/109736126)
[c++面试-操作系统篇](https://zhuanlan.zhihu.com/p/616080301)
[面试必考 | 进程和线程的区别](https://zhuanlan.zhihu.com/p/114453309)

- 何为进程(process)?
  - **进程是一个应用程序被操作系统拉起来加载到内存之后从开始执行到执行结束的这样一个过程**。简单来说，进程是程序（应用程序，可执行文件）的一次执行。进程通常由程序、数据和进程控制块（PCB）组成。比如双击打开一个桌面应用软件就是开启了一个进程。

  - 传统的进程有两个基本属性：可拥有资源的独立单位；可独立调度和分配的基本单位。对于这句话我的理解是：进程可以获取操作系统分配的资源，如内存等；进程可以参与操作系统的调度，参与CPU的竞争，得到分配的时间片，获得处理机（CPU）运行。

  - 进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，因此在系统中开启的进程数不宜过多。比如你同时打开十几个应用软件试试，电脑肯定会卡死的。于是紧接着就引入了线程的概念。

- 何为线程(thread)?
  - 线程是进程中的一个实体，是被系统独立分配和调度的基本单位。也有说，线程是CPU可执行调度的最小单位。也就是说，进程本身并不能获取CPU时间，只有它的线程才可以。

  - 引入线程之后，将传统进程的两个基本属性分开了，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。我对这句话的理解是：线程参与操作系统的调度，参与CPU的竞争，得到分配的时间片，获得处理机（CPU）运行。而进程负责获取操作系统分配的资源，如内存。

  - 线程基本上不拥有资源，只拥有一点运行中必不可少的资源，它可与同属一个进程的其他线程共享进程所拥有的全部资源。

  - 线程具有许多传统进程所具有的特性，故称为“轻量型进程”。同一个进程中的多个线程可以并发执行。</br>
- 进程和线程的区别？
  - 线程分为<font color=red>用户级线程</font>和<font color=red>内核支持线程</font>两类，**用户级线程**不依赖于内核，该类线程的创建、撤销和切换都不利用系统调用来实现; **内核支持线程**依赖于内核，即无论是在用户进程中的线程，还是在系统中的线程，它们的创建、撤销和切换都利用系统调用来实现。

  - 但是，与线程不同的是，无论是系统进程还是用户进程，在进行切换时，都要依赖于内核中的进程(process)调度。因此，无论是什么进程都是与内核有关的，是在内核支持下进程切换的。尽管线程和进程表面上看起来相似，但是他们在本质上是不同的。

  - 根据操作系统中的知识，进程至少必须有一个线程，通常将此线程称为主线程。

  - <font color=red><u>进程要独立地占用系统资源（如内存），而同一进程的线程之间是共享资源的。进程本身并不能获取CPU时间，只有它的线程才可以。</u></font>
- 其他
  - 进程在创建、撤销和切换过程中，系统的时空开销非常大。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。例如可以在一个进程中设置多个线程，当一个线程受阻时，第二个线程可以继续运行，当第二个线程受阻时，第三个线程可以继续运行......。这样，对于拥有资源的基本单位（进程），不用频繁的切换，进一步提高了系统中各种程序的并发程度。


ref: </br>
[1].https://blog.csdn.net/qq_41803340/category_10405604.html

---

> 作者: [Jian YE](https://github.com/jianye0428)  
> URL: https://lruihao.cn/posts/basics_two/  

