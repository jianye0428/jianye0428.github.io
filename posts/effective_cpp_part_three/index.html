<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Effective C++ (第3版) 精读总结 [3] - yejian's blog</title><meta name=author content="Jian YE">
<meta name=author-link content="https://github.com/jianye0428"><meta name=description content><meta name=keywords content='Effective'><meta itemprop=name content="Effective C++ (第3版) 精读总结 [3]"><meta itemprop=datePublished content="2023-07-31T07:26:00+08:00"><meta itemprop=dateModified content="2023-10-07T09:25:23+08:00"><meta itemprop=wordCount content="14424"><meta itemprop=image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta itemprop=keywords content="Effective"><meta property="og:url" content="https://jianye0428.github.io/posts/effective_cpp_part_three/"><meta property="og:site_name" content="yejian's blog"><meta property="og:title" content="Effective C++ (第3版) 精读总结 [3]"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-31T07:26:00+08:00"><meta property="article:modified_time" content="2023-10-07T09:25:23+08:00"><meta property="article:tag" content="Effective"><meta property="og:image" content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jianye0428.github.io/images/favicon/jian_icon.png"><meta name=twitter:title content="Effective C++ (第3版) 精读总结 [3]"><meta name=application-name content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=apple-mobile-web-app-title content="菠菜阿九时代峰峻啊；数量可根据；"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/png href=/jian_icon.png><link rel=icon type=image/png sizes=32x32 href=/jian_icon.png><link rel=icon type=image/png sizes=16x16 href=/jian_icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jianye0428.github.io/posts/effective_cpp_part_three/><link rel=prev href=https://jianye0428.github.io/posts/effective_cpp_part_two/><link rel=next href=https://jianye0428.github.io/posts/effective_cpp_part_four/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Effective C++ (第3版) 精读总结 [3]","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jianye0428.github.io\/posts\/effective_cpp_part_three\/"},"image":["https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"],"genre":"posts","keywords":"Effective","wordcount":14424,"url":"https:\/\/jianye0428.github.io\/posts\/effective_cpp_part_three\/","datePublished":"2023-07-31T07:26:00+08:00","dateModified":"2023-10-07T09:25:23+08:00","publisher":{"@type":"Organization","name":"Jian YE","logo":"https:\/\/jianye0428.github.io\/images\/favicon\/jian_icon.png"},"author":{"@type":"Person","name":"Jian YE"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title="yejian's blog" data-alt="yejian's blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yejian's blog"><img loading=lazy src=/images/favicon/jian_icon.png srcset="/images/favicon/jian_icon.png, /images/favicon/jian_icon.png 1.5x, /images/favicon/jian_icon.png 2x" sizes=auto data-title=/images/favicon/jian_icon.png data-alt=/images/favicon/jian_icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Jian's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/projects/_index.zh-tw/ title=項目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的項目</a></li><li class=menu-item><a class=menu-link href=/projects/ title=项目><i class="fa-solid fa-laptop-code fa-fw fa-sm" aria-hidden=true></i> 我的项目</a></li></ul></li><li class=menu-item><a class=menu-link href=/pilot/><i class="fa-solid fa-user-tie fa-fw fa-sm" aria-hidden=true></i> 导航</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/jianye0428/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="container container-reverse"><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Effective C++ (第3版) 精读总结 [3]</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/jianye0428 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp" srcset="https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/75a41975a5281767bf6bdba838de4238?s=32&amp;d=mp 2x" sizes=auto data-title="Jian YE" data-alt="Jian YE" class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Jian YE</a></span>
<span class=post-category>收录于 <a href=/categories/c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C++</a></span></div><div class=post-meta-line><span title="发布于 2023-07-31 07:26:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-07-31>2023-07-31</time></span>&nbsp;<span title="更新于 2023-10-07 09:25:23"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-10-07>2023-10-07</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 14424 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 29 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="Effective C++ (第3版) 精读总结 [3]">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#ch5-实现>CH5. 实现</a><ul><li><a href=#r26-尽可能延后变量定义式的出现时间>R26 尽可能延后变量定义式的出现时间</a></li><li><a href=#r27-尽量少做转型动作>R27 尽量少做转型动作</a></li><li><a href=#r28-避免返回handles指向对象内部成分>R28 避免返回handles指向对象内部成分</a></li><li><a href=#r29-为异常安全而努力是值得的>R29 为“异常安全”而努力是值得的</a><ul><li><a href=#异常安全的3个等级>异常安全的3个等级</a></li><li><a href=#使用copy-and-swap保障异常安全>使用copy-and-swap保障异常安全</a></li><li><a href=#异常安全的连带影响side-effects>异常安全的连带影响(side effects)</a></li></ul></li><li><a href=#r30-透彻了解inline的里里外外>R30 透彻了解inline的里里外外</a></li><li><a href=#r31-将文件间的编译依赖关系降至最低>R31 将文件间的编译依赖关系降至最低</a></li></ul></li><li><a href=#ch6-继承与面向对象设计>CH6. 继承与面向对象设计</a><ul><li><a href=#r32-确定你的public继承塑造出is-a关系>R32 确定你的public继承塑造出is-a关系</a></li><li><a href=#r33-避免遮掩由继承得来的名称>R33 避免遮掩由继承得来的名称</a></li><li><a href=#r34-区分接口继承和实现继承>R34 区分接口继承和实现继承</a></li><li><a href=#r35-考虑virtual函数的替代选择>R35 考虑virtual函数的替代选择</a></li><li><a href=#r36-绝不重新定义继承而来的non-virtual函数>R36 绝不重新定义继承而来的non-virtual函数</a></li><li><a href=#r37-绝不重新定义继承而来的缺省入参值>R37 绝不重新定义继承而来的缺省入参值</a></li><li><a href=#r38-通过复合塑造出has-a或根据某物实现出>R38 通过复合塑造出has-a或"根据某物实现出”</a></li><li><a href=#r39-明智而审慎地使用private继承>R39 明智而审慎地使用private继承</a></li><li><a href=#r40-明智而审慎地使用多重继承>R40 明智而审慎地使用多重继承</a></li></ul></li></ul></nav></div></div><div class=content id=content data-end-flag=（完）><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2023-10-07，文中内容可能已过时。</div></div></div><h1 id=前言>前言</h1><blockquote><p>Effective-C++总结系列分为四部分，本文为第二部分，涉及原书第3~4章，内容范围Rule13~25。为方便书写，Rule13简写为R13。</p></blockquote><div class="details admonition Note"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>Effective-C++系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本博客站点系列内容如下：</br>💡 <a href=https://jianye0428.github.io/posts/partone/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/parttwo/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/partthree/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>💡 <a href=https://jianye0428.github.io/posts/partfour/ target=_blank rel="external nofollow noopener noreferrer">Effective C++(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br></div></div></div><p>由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人<code>开发经验</code>新增一些个人感悟👉<code>By the way</code>环节。</p><h2 id=ch5-实现>CH5. 实现</h2><h3 id=r26-尽可能延后变量定义式的出现时间>R26 尽可能延后变量定义式的出现时间</h3><ul><li>尽可能延后变量定义式的出现，可增加程序清晰度和效率<ol><li>定义后，在使用前就遭遇抛异常
这种情况，如果是定义了对象<code>ObjectA a</code>，便白白地浪费了对象a的构造和析构成本。</li><li>不只是延后变量定义到使用时，而是尽量延后到能给它初值时</li></ol><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encryptPassword</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>password</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>password</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>8</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>logic_error</span><span class=p>(</span><span class=s>&#34;Password is too short&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span><span class=c1>// 考虑1：在异常之后定义变量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>encrypted</span><span class=p>(</span><span class=n>password</span><span class=p>);</span><span class=c1>//考虑2：定义延后至变量能赋初值的时机
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>encrypt</span><span class=p>(</span><span class=n>encrypted</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>encrypted</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>思考变量定义<strong>是否</strong>该在循环内</li></ol><ul><li>方法A：定义于循环外<div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Widget</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>w</span> <span class=o>=</span> <span class=n>foo</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=c1>// other...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li>方法B：定义于循环内<div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=nf>w</span><span class=p>(</span><span class=n>foo</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=c1>// other...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><p><strong>究竟是A还是B方法好</strong>，取决于 <code>一个赋值成本</code>和<code>一组构造+析构</code>成本，这2者之间，如果是赋值成本低，那么A更好，否则B更好。</p><h3 id=r27-尽量少做转型动作>R27 尽量少做转型动作</h3><p>通常的转型是可能会这样写：函数风格的<code>int(expression)</code>或者C风格的(int)<code>expression</code>，这都被成为“旧式转型”。</p><ul><li><p>在C++中，有4种新式转型操作符：</p><ol><li><strong>const_cast (expression)</strong>
作用是移除变量的常量性(cast away the constness)，是唯一有此能力的操作符。</li><li><strong>dynamic_cast(expression)</strong>
作用是“安全向下转型”(safe downcasting)，决定某个对象是否属于某继承体系。耗费重大运行成本（原因：需要查询RTTI信息，而且不同编译器实现的方法和效率有所不同）。</li><li><strong>reinterpret_cast(expression)</strong>
执行低级转型，实际结果取决于编译器，移植性差。（比如int* 转为int）要清楚自己在做什么，慎用。</li><li><strong>static_cast(expression)</strong>
强迫隐式类型转换，代替C风格的"旧式转换"。也可以给变量加上const特性。</li></ol><p>新式转换的好处：很容易在代码找到“类型系统在何处转变或破坏”；对const特性的严控，让类型系统更健壮。</p></li><li><p>派生类里直接调用基类成员函数时，不要用转型</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpecialWindow</span><span class=o>:</span><span class=k>public</span> <span class=n>Window</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onResize</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Window</span><span class=o>::</span><span class=n>onResize</span><span class=p>();</span><span class=c1>//不要使用 static_cast&lt;Window&gt;(*this).onResize();
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li><li><p>关于dynamic_cast需要注意的</p><ol><li>如何替代和避免
一般是持有一个<code>Base *pBase</code>，但是指向的是DerivedObj，于是转型为pDerived</li></ol><ul><li>可以这样修改：
修改设计，窄化类型，持有一个pDerived即可；或者将想做的事放到虚函数中，利用多态去完成。</li></ul><ol start=2><li>避免串联
避免下方这样的代码，一连串的dynamic_cast：</li></ol><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Window</span><span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 定义子类 SpecialWindow1,SpecalWindow2,SpecialWindow3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Window</span><span class=o>*</span> <span class=n>winPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 省略winPtr的其他操作 ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=n>SpecialWindow1</span> <span class=o>*</span><span class=n>psw1</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWindow1</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>winPtr</span><span class=p>)){</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>  <span class=nf>if</span><span class=p>(</span><span class=n>SpecialWindow2</span> <span class=o>*</span><span class=n>psw2</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWindow2</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>winPtr</span><span class=p>)){</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>  <span class=nf>if</span><span class=p>(</span><span class=n>SpecialWindow3</span> <span class=o>*</span><span class=n>psw3</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>SpecialWindow3</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>winPtr</span><span class=p>)){</span> <span class=p>...</span> <span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这样的代码又大又慢，每次继承体系有所改变，代码就需要重新检阅判断。这样的代码应该用“基于virtual函数调用”取代它。</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>自 <strong>C++11</strong> 起，针对智能指针 shared_ptr 的转型，推出了另外 4 个模版函数：</p><ul><li><code>std::static_pointer_cast</code>
函数的原型声明为：<div class=highlight id=id-47><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=k>class</span> <span class=nc>U</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>static_pointer_cast</span><span class=p>(</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;</span> <span class=n>r</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div>含义以及应用场景与 <code>static_cast</code> 类似，比如子类型指针转为父类型：<div class=highlight id=id-48><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>basePtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>derivedPtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>basePtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>static_pointer_cast</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span><span class=p>(</span><span class=n>derivedPtr</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div>或许我们会有疑问，是否有必要用这个函数进行转型呢，如下实现不是一样的吗?<div class=highlight id=id-49><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>basePtr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Base</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>derivedPtr</span><span class=p>.</span><span class=n>get</span><span class=p>()));</span></span></span></code></pre></td></tr></table></div></div>🤔 当然不一样，static_cast&lt;T*>((U*)nullptr)是未定义行为，而且就语法描述上来看，哪个更简洁不言自明。
另外，自 C++20 起支持右值引用，也就是如下形式：<div class=highlight id=id-50><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span> <span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=k>class</span> <span class=nc>U</span> <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>static_pointer_cast</span><span class=p>(</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;&amp;&amp;</span> <span class=n>r</span> <span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></li><li><code>std::dynamic_pointer_cast</code>
含义以及应用场景与 dynamic_cast 类似，用法传参与 std::static_pointer_cast 类似，且自 C++20 起支持右值引用，不赘述。</li><li><code>std::const_pointer_cast：</code>与前 2 者类似，不赘述。</li><li><code>std::reinterpret_pointer_cast：</code>与前 3 者类似，不赘述。</li></ul></div></div></div><h3 id=r28-避免返回handles指向对象内部成分>R28 避免返回handles指向对象内部成分</h3><p>这里的<strong>handles（号码牌）包括</strong>指向对象内部的<strong>指针</strong>、<strong>迭代器</strong>、<strong>引用</strong>。</p><p>以下讲述当返回对象内部的handles时，存在的2个问题：</p><ul><li>可能会破坏封装性
考虑一个场景：public函数返回一个private成员的非const引用，就让外界有了修改private的机会，破坏了封装性。
此时，需要将非const引用改为const引用，只读属性。<div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Pixel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>float</span> <span class=n>r</span><span class=p>,</span><span class=n>g</span><span class=p>,</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Image</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>  <span class=c1>//注意：后面这const只保证成员变量vPixPtrs_不改
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Pixel</span><span class=o>&amp;</span> <span class=n>GetThePixel</span><span class=p>(</span><span class=kt>int</span> <span class=n>idx</span><span class=p>)</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>  <span class=n>vPixPtrs_</span><span class=p>[</span><span class=n>i</span><span class=p>];}</span><span class=c1>//隐患：其实外部调用者仍能直接修改Pixel的rgb值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 上一句的返回值应该改为 &#34;const Pixel&amp;&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Pixel</span><span class=o>&gt;&gt;</span> <span class=n>vPixPtrs_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li>可能会引起“空悬handles”
即使用const解决了封装性的问题，因为很容易出现**“handles比其所指对象更长寿”**，可能存在对象已析构，但handles还留存的问题。尤其是临时变量的析构，不太容易察觉。<div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SceneGraph</span><span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Image</span> <span class=nf>CaptureImage</span><span class=p>(</span><span class=k>const</span> <span class=n>SceneGraph</span><span class=o>&amp;</span> <span class=n>graph</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//那么调用方可能会这样使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SceneGraph</span> <span class=n>Grap</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//下面这句之后，Image临时对象被销毁，pPix指向一个不存在的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>Pixel</span> <span class=o>*</span><span class=n>pPix</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>CaptureImage</span><span class=p>(</span><span class=n>Grap</span><span class=p>).</span><span class=n>GetThePixel</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span></span></span></code></pre></td></tr></table></div></div>注意，CaptureImage的确能返回一个临时Image对象，能成功调用GetThePixel，但这句结束后，临时对象立马会被销毁，造成空悬现象，或叫虚吊(dangling) ！</li></ul><h3 id=r29-为异常安全而努力是值得的>R29 为“异常安全”而努力是值得的</h3><p>“<strong>异常安全</strong>”是指，当异常抛出时，代码依然能做到如下2点：</p><ol><li>不泄露任何资源
包括内存资源，锁资源。</li><li>不允许数据败坏
不会因为异常而导致空悬指针等未定义行为。</li></ol><p>考虑下方的示例代码，（如果<code>new Image</code>抛<code>std::bad_alloc</code>异常）则会同时违背了上述2条：</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mutex</span> <span class=n>mutex_</span><span class=p>;</span> <span class=c1>//互斥器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Image</span><span class=o>*</span> <span class=n>bgImage_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imageChangeCnt_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span><span class=c1>// 这个可以改为RAII的锁，来保证异常安全
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>bgImage_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>imageChangeCnt_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//这里new Image抛异常，导致无法解锁；且bgImage_指向资源已经释放，空悬指针
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bgImage_</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imageSrc_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h4 id=异常安全的3个等级>异常安全的3个等级</h4><p>异常安全的函数，有<strong>3个等级</strong>的异常安全保证，会满足<strong>三者之一</strong>：</p><ul><li><p><strong>基本承诺</strong>
如果异常被抛出，程序内的任何事务仍然保持在有效状态下，也没有任何数据败坏。比如上例中如果抛异常，会另外添加实现，使bgImage_持有某个默认图像，或保持原值，让程序继续有效运行。</p></li><li><p><strong>强烈保证</strong>
如果异常被抛出，程序状态不改变。这样的函数要么成功，要么退回到执行前的状态。</p><p>上述案例则应该会被修改成如下形式：</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Image</span><span class=o>&gt;</span> <span class=n>bgImage_</span><span class=p>;</span> <span class=c1>//RAII避免了异常发生时的资源泄漏和数据败坏
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//... 省略其他成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>CLock</span> <span class=nf>ml</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span><span class=c1>//RAII封装的Lock类，详细可参考 阅读总结(二)-Rule14
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bgImage_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imgSrc</span><span class=p>));</span><span class=c1>//若new失败，则不会reset
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>imageChangeCnt_</span><span class=p>;</span><span class=c1>//把事情做完再++count
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>不抛异常</strong>
在原书中，这个“No Throw”不是绝对不抛异常，而是一旦意外抛异常，就会调用unexpected函数进而abort（例如<code>int doSomething() throw();//空白的异常明细</code>）。</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>原书中例子的 <strong>throw()</strong> 在不同编译器表现不一致，现在已经 <strong>不推荐使用</strong>。</p><p>更详细资料可参考<a href=http://gotw.ca/publications/mill22.htm target=_blank rel="external nofollow noopener noreferrer">A Pragmatic Look at Exception Specifications<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>和<a href=https://stackoverflow.com/questions/88573/should-i-use-an-exception-specifier-in-c target=_blank rel="external nofollow noopener noreferrer">Should I use an exception specifier in C++<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><p>在C++11中，有了更可靠有效的关键字noexcept，使用也很简单，有操作符和异常提示符两种作用，下方展示简单用法：</p><div class=highlight id=id-51><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span> <span class=c1>// 函数 f() 不会抛出
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span> <span class=c1>// fp 指向可能会抛出的函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>g</span><span class=p>(</span><span class=kt>void</span> <span class=n>pfa</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>);</span>  <span class=c1>// g 接收指向不会抛出的函数的指针
</span></span></span><span class=line><span class=cl><span class=c1>// typedef int (*pf)() noexcept; // 错误
</span></span></span></code></pre></td></tr></table></div></div><p>更详细的<code>noexcept</code>介绍可以访问<a href=https://zh.cppreference.com/w/cpp/language/noexcept target=_blank rel="external nofollow noopener noreferrer">cppreference：noexcept操作符<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>和<a href=https://zh.cppreference.com/w/cpp/language/noexcept_spec target=_blank rel="external nofollow noopener noreferrer">cppreference：noexcept异常说明符<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p></div></div></div><h4 id=使用copy-and-swap保障异常安全>使用copy-and-swap保障异常安全</h4><p><code>copy-and-swap</code>技术：先拷贝一份想修改的对象，等修改彻底完成后（过程中不抛异常），再与原对象交换。</p><p>为了更形象展示这一过程，使用pIml手法对bgImage_封装一下：</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ImgPimpl</span><span class=p>{</span> <span class=c1>//选用struct而非Class：方便；最后被private成员形式使用，封装性不用担心
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Image</span><span class=o>&gt;</span> <span class=n>bgImage_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>imageChangeCnt_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么PrettyMenu类可以改为如下：</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrettyMenu</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mutex</span> <span class=n>mutex_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>ImgPimpl</span><span class=o>&gt;</span> <span class=n>pImpl_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>  <span class=c1>//构造略
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=n>PrettyMenu</span><span class=o>::</span><span class=n>changeBackground</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=o>&amp;</span> <span class=n>imgSrc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>;</span>   <span class=c1>//参考 阅读总结(二)-Rule25
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CLock</span> <span class=nf>ml</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_</span><span class=p>);</span><span class=c1>//RAII封装的Lock类，详细可参考总结(二)-Rule14
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>ImgPimpl</span><span class=o>&gt;</span> <span class=n>pNewCopy</span><span class=p>(</span><span class=k>new</span> <span class=n>ImgPimpl</span><span class=p>(</span><span class=o>*</span><span class=n>pImpl_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>pNewCopy</span><span class=o>-&gt;</span><span class=n>bgImage_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=k>new</span> <span class=n>Image</span><span class=p>(</span><span class=n>imgSrc</span><span class=p>));</span> <span class=c1>//修改副本
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>pNewCopy</span><span class=o>-&gt;</span><span class=n>imageChangeCnt_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>pImpl_</span><span class=p>,</span><span class=n>pNewCopy</span><span class=p>);</span><span class=c1>//改完之后swap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h4 id=异常安全的连带影响side-effects>异常安全的连带影响(side effects)</h4><p>函数提供的“异常安全保证等级”只<strong>取决于</strong>其调用的<strong>各个子函数的“最不安全者”</strong>。</p><p>考虑以下函数SomeFunc代码：</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>SomeFunc</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=c1>// 对local状态做一份副本
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>f2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>  <span class=c1>//将修改后的状态置换过来
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><strong><code>分析</code></strong>：显然copy-and-swap在尽力强烈保证异常安全，但是，f1或者f2的异常安全如果比较低，那么可能需要单独对f1，f2进行copy-and-swap，来尝试保证“强烈异常安全”；即使如此，如果f1能成功做了修改，但是f2修改失败了并回退，那么<strong>f1、f2整体</strong>看起来还是“<strong>改了一部分</strong>”。</p><p><strong><code>这也告诫我们</code></strong>，如果引入了异常不安全的旧代码，那么这种特性会波及其他代码。</p><p>就设计者而言，只能根据实际情况，尽可能保证“异常安全”，选择3个异常安全等级之一实施。</p><h3 id=r30-透彻了解inline的里里外外>R30 透彻了解inline的里里外外</h3><p><code>inline</code>是C++的关键字，表示内联函数。<code>直接在对应位置展开代码</code>，免去函数调用的开销，难以避免 “<strong>代码膨胀</strong>”问题。</p><p>使用inline时应该注意以下问题：</p><ul><li><p><strong>inline只是对编译器的申请</strong>
inline只是对编译器的申请/建议，不是强制命令，<strong>编译器有权利</strong> 对其认为不适合inline的函数<strong>拒绝</strong>inline。 （原书说：如果编译器拒绝，通常它会给出warning信息。实际本人实测VS2017没看到）
inline有2种申请方式 ：</p><ol><li>在函数定义 时使用关键字inline<strong>显式强调</strong></li><li>实现在Class内的成员函数或friend函数，属于<strong>隐式inline</strong></li></ol></li><li><p><strong>inline和Template没有任何必然联系</strong>
虽然有不少简短的Template函数是带有inline（例如下方的std::max），但不是必然为之，<strong>两者没有因果关系</strong>。</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>){</span> <span class=c1>//可以申请inline，但不是必须申请
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>b</span> <span class=p>:</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>编译器拒绝复杂函数进行inline</strong>
复杂函数的inline会带来较严重的“代码膨胀”问题，并且可能会更慢，因为增加了运行时的“额外换页”行为，降低了指令cache命中率。</p><ol><li>inline函数内不要出现循环或递归</li><li>虚函数也不适合做inline
因为inline是编译期间决定的事，而虚函数是运行时决定的事，两者就不是同一个场景的。</li><li>构造/析构函数也不适合做inline
编译器可能会在构造/析构函数内部做精妙复杂的异常处理；以及在继承体系下，Base类函数体到处inline膨胀。</li></ol></li><li><p><strong>以函数指针形式的调用通常不能inline</strong>
对绝大多数编译器而言，是否inline是compile阶段决定的事情，少数编译器放到了link阶段。</p><p>讨论大多数情况：需要在编译时得知inline的本体，而函数指针办不到，示例代码如下：</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{...}</span> <span class=c1>//假设编译器有意愿inline “对f的调用”
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span> <span class=n>pf</span><span class=p>)()</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span><span class=c1>//pf 执行f
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>();</span>     <span class=c1>//这个调用将被inlined，因为是个正常调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pf</span><span class=p>();</span>     <span class=c1>//这个很可能不被inlined
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>过度inline对调试和发布带来困难</strong>
inline是代码嵌入与展开，而非函数调用，所以某些编译器不支持inline的单步Debug（就像宏展开一样不支持调试）；另外，inline只要已修改，涉及调用它的代码全都要编译，如果是non-inline则可能只需要重新link即可。</p></li></ul><h3 id=r31-将文件间的编译依赖关系降至最低>R31 将文件间的编译依赖关系降至最低</h3><p>C++的Class定义式包括了成员变量，假设某成员变量是类对象<code>ClassObjA a</code>，如果<code>ClassObjA</code>类的内部实现发生了改变（哪怕这个<code>ClassObjA.h</code>内只在某处加了一个空格 ），那么include了<code>ClassObjA.h</code>的所有<code>.h</code>文件<code>.cpp</code>文件都会<strong>重新编译</strong>。</p><p>👆这就是由“<strong>编译依赖</strong>”关系带来的问题。</p><p>使用 <code>PIMPL</code> 手法(pointer to implementation)可以很好地分离声明和定义：</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//Person.h文件  不需要include &#34;PersonImpl.h&#34;和&#34;BirthDay.h&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>PersonImpl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BirthDay</span><span class=p>;</span><span class=c1>// 前置声明代替include
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span><span class=c1>// 构造函数这里放实现无所谓，因为是函数指针，不需知道PersonImpl本体实现
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Person</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>PersonImpl</span><span class=o>&gt;&amp;</span> <span class=n>pImpl</span><span class=p>);</span><span class=c1>//构造函数的实现也放到cpp里去
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=n>BirthDay</span><span class=o>&amp;</span> <span class=n>GetBirthDay</span><span class=p>();</span><span class=c1>// 注意：这里只声明，把实现部分放到cpp里
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>GetName</span><span class=p>();</span><span class=c1>//实现细节由pImpl_转发实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>PersonImpl</span><span class=o>&gt;</span> <span class=n>pImpl_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//Person.cpp文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;PersonImpl.h&#34;</span><span class=cp> </span><span class=c1>//在&#34;PersonImpl.h&#34;文件内include那个&#34;BirthDay.h&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;Person.h&#34;</span></span></span></code></pre></td></tr></table></div></div><p>注意：Impl用法，相关的头文件里不要放置任何函数实现代码 。
上述做法可以让使用Person类的客户不需要再关心PersonImpl以及BirthDay的实现细节了，做到了“接口与实现分离”，关键点在于把“定义的依赖性” 换成 $\Rightarrow$ “<strong>声明的依赖性</strong>”。
这里突出了如何<strong>最小化编译依赖性</strong>的本质：<code>让头文件尽可能自我满足</code>，如果不行，也要依赖于其他文件的声明式而非定义式。</p><p>具体到设计策略上，有以下几种做法：</p><ul><li><p>如果能用object references 或 object pointers完成任务，就别用objects
如果要定义某类型的objects，就要使用定义式，指针和应用则可以只用声明式。</p></li><li><p>尽量以class声明式替换class定义式
函数声明种的Class类型可以只用声明式，即使以by-object-value形式传值也是如此。</p></li><li><p>为声明式和定义式提供不同的文件
比如Date类，分为只包含声明式的"Datefwd.h"和包含定义式的"Date.h"，那么使用时用声明式头文件代替前置声明，在需要应用代码client.cpp里include定义式头文件。这种方式在标准库里采用较多，参考<iosfwd>和<sstream>,<fstream>,<streambuf>等。</p></li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><ul><li>C/C++可以使用编译器预处理指令<font color=red><code>#pragma message</code></font>，打印出该文件是否参与此次编译，以及参与编译时被哪个文件所依赖。<div class=highlight id=id-52><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//比如可以在 testEffective.h 文件内加上这句，就能在编译输出信息里看到打印信息，观察到依赖关系
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#pragma message(&#34;testEffective.h 参与重新编译&#34;)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//还可以用于测试某些宏是否真的生效，有时IDE的高亮显示不准确而令人生疑。
</span></span></span></code></pre></td></tr></table></div></div></li><li>关于头文件include的其他编写规范，可以参考：<a href=https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/# target=_blank rel="external nofollow noopener noreferrer">Google-C++风格指南：1.头文件<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul></div></div></div><p>使用 <font color><strong><code>Interface Class</code></strong></font> 也能做到接口和实现的真正分离：</p><p>这种方式常见于输出动态库给到客户使用，客户能见到接口定义和使用，但无法看到内部实现。</p><p>用法较为常见，不赘述，直接<strong>show-code</strong>：</p><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//VirtualPerson.h   //和 lib文件一起提供给到客户
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>VirtualPerson</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span> <span class=c1>//create的返回值还可以根据需求，换成RAII的智能指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=n>VirtualPerson</span> <span class=o>*</span> <span class=n>create</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>int</span> <span class=n>salary</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Level</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Salary</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>VirtualPerson</span><span class=p>();</span><span class=c1>// avoid memory leak
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//VirtualPerson.cpp  //源码不提供给客户，而是编译好的二进制 lib文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VirtualPerson</span><span class=o>*</span> <span class=n>VirtualPerson</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>int</span> <span class=n>salary</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>level</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//工厂方法，还可以生成其他子类
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=k>new</span> <span class=nf>Engineer</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>salary</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>VirtualPerson</span><span class=o>::~</span><span class=n>VirtualPerson</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Engineer.h  //Engineer也是参与编译到 lib文件中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Engineer</span><span class=o>:</span> <span class=k>public</span> <span class=n>VirtualPerson</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Engineer</span><span class=p>(</span><span class=kt>int</span> <span class=n>level</span><span class=p>,</span><span class=kt>int</span> <span class=n>salary</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Level</span><span class=p>()</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Salary</span><span class=p>()</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>level_</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>salary_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h2 id=ch6-继承与面向对象设计>CH6. 继承与面向对象设计</h2><h3 id=r32-确定你的public继承塑造出is-a关系>R32 确定你的public继承塑造出is-a关系</h3><p>原书标题：<strong>Make sure public inheritance models “is-a”</strong>. 侯捷老师翻译为“塑模”，我个人更愿意称为“塑造”。</p><ul><li><strong>“public继承”意味着is-a</strong>
is-a，即“是一种”，就是说，适用于Base Class身上的每一件事，也一定适用于Derived Class身上。</li></ul><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>面向设计对象的设计有著名的5大原则， SOLID 原则，每个字母分别代表一种原则：</p><ul><li>S–单一责任原则(SRP) –Single Responsibility Principle</li><li>O–开放封闭原则(OCP)– Open-Closed Principle</li><li>L–里式替换原则(LSP)– Liskov Substitution Principle</li><li>I –- 接口分离原则(ISP)–Interface Segregation Principle</li><li>D–-依赖倒置原则(DIP)– Dependency Inversion Principle</li></ul><p>更详细的叙述可以参考：<a href=https://cloud.tencent.com/developer/article/1503629 target=_blank rel="external nofollow noopener noreferrer">腾讯云：SOLID原则<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p></div></div></div><p>本节条款的中心思想即里氏替换原则：<strong>一个对象出现的地方都可以由其子类代替并且不会出错。</strong></p><p>继承关系有时候听起来很好理解，比如 <code>Class Student: public Person</code>理所应当，但有时也会导致误解。比如企鹅属于鸟类，但企鹅不会飞，那么基类<code>Bird::Fly</code>方法又当如何处理，下方满足设计意图：</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bird</span><span class=p>{</span>   <span class=c1>//... 不声明Fly()方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FylingBird</span><span class=o>:</span><span class=k>public</span> <span class=n>Bird</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span> <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Fly</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Penguin</span><span class=o>:</span> <span class=k>public</span> <span class=n>Bird</span><span class=p>{</span> <span class=c1>//... 不声明Fly()方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 注：如果Bird类以及子类都不考虑Fly()方法，那么Penguin直接继承于Bird即可
</span></span></span></code></pre></td></tr></table></div></div><p>还有另一种场景，父类和子类对于同一个方法的数据修改规则不同，导致了继承体系的缺陷。
比如<code>Class Square:public Rectangle</code> $\rightarrow$ 正方形继承于长方形，但是考虑这样一个<strong>类外方法</strong>:</p><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>makeBigger</span><span class=p>(</span><span class=n>Rectangle</span><span class=o>&amp;</span> <span class=n>r</span><span class=p>){</span>  <span class=c1>//普通非成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>oldHeight</span> <span class=o>=</span> <span class=n>r</span><span class=p>.</span><span class=n>height</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=p>.</span><span class=n>setWidth</span><span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>width</span><span class=p>()</span> <span class=o>+</span> <span class=mi>10</span><span class=p>);</span><span class=c1>//如果r是Squqre，可能内部自动就长宽一起变了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>height</span><span class=p>()</span> <span class=o>==</span> <span class=n>oldHeight</span><span class=p>);</span><span class=c1>//这个assert对于正方形就不合适了,贸然去除又违背设计本意
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>应对上述这样的情况，就需要修改设计或修改继承体系了。</p><h3 id=r33-避免遮掩由继承得来的名称>R33 避免遮掩由继承得来的名称</h3><p>首先，什么是名称的遮掩，通俗地说，是指由于作用域不同带来的变量名覆盖。考虑下方代码：</p><div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>someFunc</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>0.1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;x is&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// local作用域找到了x，直接覆盖全局的x，输出0.1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>那么如果将继承体系考虑进来呢：<strong>Derived的作用域会覆盖Base的作用域</strong>，包括virtual和non-virtual。考虑下方代码：</p><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>mf1</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>mf1</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base::mf1():x =&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>mf2</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base::mf2()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf3</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base::mf3()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf3</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base::mf3():x =&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span><span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>mf1</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived::mf1()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>mf3</span><span class=p>(){</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived::mf3()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>很明显存在名称遮掩的问题，Derived的mf1，mf3会遮掩子类的所有同名函数，测试结果如下：</p><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>();</span>      <span class=c1>//OK，输出: Derived::mf1()
</span></span></span><span class=line><span class=cl><span class=c1>//d.mf1(100);  编译报错，因为名称被遮掩
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf2</span><span class=p>();</span>      <span class=c1>//OK，输出: Base::mf2()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf3</span><span class=p>();</span>      <span class=c1>//OK，输出: Derived::mf3()
</span></span></span><span class=line><span class=cl><span class=c1>//d.mf3(300);  编译报错，同理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>Base</span><span class=o>::</span><span class=n>mf3</span><span class=p>(</span><span class=mi>300</span><span class=p>);</span> <span class=c1>//OK，输出: Base::mf3():x =300 . 但是不太建议这么写，丑！！
</span></span></span></code></pre></td></tr></table></div></div><ul><li>为解决上述问题，可以采用using声明式或转发函数<ol><li>using 声明式
可以使用using声明式，让Derived可以忽略名称遮掩，看到Base作用域内的函数。可以让上方代码的“编译报错”消失，正常调用d.mf1(100)和d.mf3(300)。<div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl> <span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span><span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span> <span class=c1>//修改本节内容中上方代码的Derived类的声明
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>mf1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>mf3</span><span class=p>;</span> <span class=c1>//这2个using使得Base类作用域内所有mf1,mf3函数都可见
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=c1>// ... 其他，略
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li>转发函数(forwarding function)
应用场景: 在private继承下，强调的是继承实现而非继承接口，如果想在子类的成员中调用父类函数，此时可以通过函数转发来实现。</li></ol><div class=highlight id=id-23><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>private</span> <span class=n>Base</span><span class=p>{</span> <span class=c1>//改写本节上方代码，注意，是私有继承
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>mf1</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=n>Base</span><span class=o>::</span><span class=n>mf1</span><span class=p>();</span> <span class=c1>//拿到了父类的函数实现
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// ... 该函数其他部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 应用代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>();</span>    <span class=c1>//调用成功，Derived::mf1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>d</span><span class=p>.</span><span class=n>mf1</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>  <span class=c1>//编译失败
</span></span></span></code></pre></td></tr></table></div></div>当然，public继承也能使用转发函数，写出<code>d.Base::mf3(300)</code>; 这样的代码。但是，一来public继承理应遵循"is-a"规则，using声明拿到所有被遮掩的接口；二来明显代码不美观。</li></ul><h3 id=r34-区分接口继承和实现继承>R34 区分接口继承和实现继承</h3><p>当一个子类Derived继承于父类Base，那么要时刻清楚，对于类中的成员函数，是想继承父类的接口，还是想继承父类的实现。</p><ul><li><p><strong>对于Public继承，接口总是会被继承</strong>
基于“<strong>is-a</strong>”的关系，作用于父类的任何事情也一定要适用于子类。</p></li><li><p><strong>声明纯虚函数(pure-virtual)的目的是让子类只继承函数接口</strong>
对于纯虚函数，子类必须重新实现该接口。注意，<code>父类可以选择性给出纯虚函数的实现</code>，但是一般不会给。</p></li><li><p><strong>隐患：从非纯虚函数(impure-virtual)同时继承接口和缺省实现</strong>
非纯虚函数，可以让子类选择是否重新实现该接口。那么，如果子类是有必要重写，但是<strong>忘记写了</strong>却默默用父类版本，便事与愿违了。
举例：父类Airplane有子类PlaneModelA、PlaneModelB、PlaneModelC，其中C型飞机不同于AB型，是新式飞机：</p><div class=highlight id=id-24><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Airport</span> <span class=p>{...};</span><span class=c1>//机场类，实现略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Airplane</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>);</span><span class=c1>//父类还会给出默认的fly实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PlaneModelA</span><span class=o>:</span> <span class=k>public</span> <span class=n>Airplane</span><span class=p>{</span> <span class=p>...</span> <span class=p>};</span> <span class=c1>// 不重写fly，继承父类的fly实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>PlaneModelB</span><span class=o>:</span> <span class=k>public</span> <span class=n>Airplane</span><span class=p>{</span> <span class=p>...</span> <span class=p>};</span> <span class=c1>// B和A一样
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>PlaneModelC</span><span class=o>:</span> <span class=k>public</span> <span class=n>Airplane</span><span class=p>{</span> <span class=p>...</span> <span class=p>};</span> <span class=c1>//新型飞机，本来要重写fly，结果忘了
</span></span></span></code></pre></td></tr></table></div></div><p>那么这个<code>隐患该如何解决</code>呢，也就是说，在实现C型飞机类时别忘了fly方法？
核心思想是“<strong>切断virtual函数接口和其默认实现之间的连接</strong>”。</p><ol><li>方法1：设置fly为纯虚函数，并新增一个defaultyFly方法
注意细节：defaultFly方法要设置为protected属性的non-virtual函数，代码如下：<div class=highlight id=id-25><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Airplane</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=c1>// 父类不给出实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>defaultFly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>){</span> <span class=p>...</span> <span class=p>}</span><span class=c1>//默认的fly实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PlaneModelA</span><span class=o>:</span> <span class=k>public</span> <span class=n>Airplane</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>   <span class=c1>//纯虚接口,子类必须给出实现
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>fly</span><span class=p>(</span><span class=k>const</span> <span class=n>Airport</span><span class=o>&amp;</span> <span class=n>destination</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>defaultFly</span><span class=p>(</span><span class=n>destination</span><span class=p>);</span> <span class=c1>//调用父类的缺省实现
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span><span class=c1>//PlaneModelB 和 PlaneModelA 类似,略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>PlaneModelC</span><span class=o>:</span> <span class=k>public</span> <span class=n>Airplane</span><span class=p>{</span> <span class=p>...};</span><span class=c1>// 重写fly方法
</span></span></span></code></pre></td></tr></table></div></div>这样写还有个好处：fly()和defaultFly()享有不同的保护级别。</li><li>方法2： 父类的默认实现塞到纯虚接口fly中
这样就不需要定义defaultFly方法了，因为子类必须实现fly方法，对于A 型、B型飞机，子类fly()转发一次父类的fly()即可，C类飞机实现新式的fly()。缺点是让原本在defaultFly内的实现内容暴露在外了(指public属性)。<div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><pre><code>  个人认为，这方法2还有个缺点：它让虚基类的纯虚接口承载了接口实现，不够纯粹(比如需要输出给到客户，应该只继承接口)。
</code></pre></div></div></div></li></ol></li><li><p><strong>non-virtual函数具体指定接口继承和强制性实现继承</strong>
如果成员函数是non-virtual，表示它不打算在子类中有不同的行为，或者说，不变性凌驾于特异性。对应地，绝不应该在子类中重写non-virtual函数。</p></li></ul><h3 id=r35-考虑virtual函数的替代选择>R35 考虑virtual函数的替代选择</h3><p>假设这样一个场景：设计一款游戏，不同人物以不同方式计算生命值，那么$\Longrightarrow$ 设计继承体系，子类共同继承父类的public-virtual方法healthValue()，子类各自重新实现healthValue()接口。</p><p>😄很好，中规中矩，那么，有没有其他方式呢？</p><ul><li><p><strong><code>NVI手法(non-virtual interface)实现Template Method模式</code></strong>
思路就是父类定义个non-virtual的public方法healthValue()，调用virtual的private方法healthValueImpl。子类直接重写healthValueImpl，达到类似模版方法设计模式的效果。
父类<code>GameCharacter</code>设计如下：</p><div class=highlight id=id-26><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span><span class=p>{</span><span class=c1>//构造函数和虚析构均略去
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>healthValue</span><span class=p>()</span><span class=k>const</span><span class=p>{</span> <span class=c1>//ps:方便展示，而写在了头文件里，成了inline
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span> <span class=s>&#34;Do prepare works...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span><span class=c1>//事前，如加锁,写log,验证条件等
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>retVal</span> <span class=o>=</span> <span class=n>healthValueImpl</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>Do post works...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span><span class=c1>//事后,如解锁,更新数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>retVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>healthValueImpl</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>val</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;default caculate process... GetValue:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>val</span><span class=p>;</span><span class=c1>//随后进行计算，过程略
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>子类<code>GoodGuy</code>和<code>BadGuy</code>设计如下：</p><div class=highlight id=id-27><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>GoodGuy</span><span class=o>:</span><span class=k>public</span> <span class=n>GameCharacter</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>healthValueImpl</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>60</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;goodGuy caculate ... GetValue: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span><span class=c1>//过程略
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BadGuy</span><span class=o>:</span><span class=k>public</span> <span class=n>GameCharacter</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>healthValueImpl</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>80</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;badGuy caculate ... GetValue: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span><span class=c1>//过程略
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>应用端代码如下：</p><div class=highlight id=id-28><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>GameCharacter</span><span class=o>&gt;</span> <span class=n>pGood</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>GoodGuy</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>pGood</span><span class=o>-&gt;</span><span class=n>healthValue</span><span class=p>();</span> <span class=c1>//得到60
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>GameCharacter</span><span class=o>&gt;</span> <span class=n>pBad</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>BadGuy</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>pBad</span><span class=o>-&gt;</span><span class=n>healthValue</span><span class=p>();</span><span class=c1>//得到80
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong><code>用函数指针实现Strategy模式</code></strong>
主体思想是添加一个函数指针为private成员变量pFunc，这个函数通过外部传入，从而实现不同的行为。</p><div class=highlight id=id-29><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span><span class=p>;</span><span class=c1>//forward declaration
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>defaultHealthCalc</span><span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>);</span><span class=c1>//默认算法实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>GameCharacter</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>HealthCalcFunc</span><span class=p>)(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=nf>GameCharacter</span><span class=p>(</span><span class=n>HealthCalcFunc</span> <span class=n>hcf</span> <span class=o>=</span> <span class=n>defaultHealthCalc</span><span class=p>)</span><span class=o>:</span><span class=n>calcFunc_</span><span class=p>(</span><span class=n>hcf</span><span class=p>){}</span><span class=c1>//传入函数指针,自定义实现
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=nf>healthValue</span><span class=p>()</span><span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>calcFunc_</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>HealthCalcFunc</span> <span class=n>calcFunc_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>这个设计有2个有趣的<strong>设计弹性</strong>：</p><ol><li>即使同一个人物类型的不同实体，允许拥有不同的生命值计算方法；</li><li>某个人物对象的生命值计算方法，在其生命期内可以任意修改，只要添加一个set方法即可；</li></ol></li><li><p><strong><code>用std::function实现Strategy模式</code></strong>
private成员变量由上文的函数指针替换成std::function对象，相当于是<code>指向函数的泛化指针</code>。就<code>更具设计弹性</code>了。std::function可以传入函数指针、仿函数、std::bind函数对象。GameCharacter的类实现修改为：</p><div class=highlight id=id-30><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameCharacter</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>int</span> <span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span><span class=p>)</span><span class=o>&gt;</span>  <span class=n>healthCalcFunc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>GameCharacter</span><span class=p>(</span><span class=n>healthCalcFunc</span> <span class=n>hcf</span> <span class=o>=</span> <span class=n>defaultHealthCalc</span><span class=p>)</span><span class=o>:</span><span class=n>healthValueImpl_</span><span class=p>(</span><span class=n>hcf</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>healthValue</span><span class=p>()</span><span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span> <span class=s>&#34;Do prepare works...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>retVal</span> <span class=o>=</span> <span class=n>healthValueImpl_</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=c1>// 这里改了
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>Do post works...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>retVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>healthCalcFunc</span> <span class=n>healthValueImpl_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ol><li>传入函数指针</li></ol><div class=highlight id=id-31><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl> <span class=n>gameChashort</span> <span class=nf>quickHurtHealthCalc</span><span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter2</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>);</span><span class=c1>//返回值不是int,可隐式转换;实现略去
</span></span></span><span class=line><span class=cl><span class=c1>//应用端代码如下：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>GameCharacter</span> <span class=nf>quickGuy</span><span class=p>(</span><span class=n>quickHurtHealthCalc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>quickGuy</span><span class=p>.</span><span class=n>healthValue</span><span class=p>();</span><span class=c1>//内部调用quickHurtHealthCalc
</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>传入仿函数
仿函数：即函数对象，而且重载了operator() 。</li></ol><div class=highlight id=id-32><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>HealthCalculator</span><span class=p>{</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>GameCharacter2</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>)</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>180</span><span class=p>;</span><span class=c1>//省略实现
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//应用端代码如下：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>GameCharacter</span> <span class=nf>functorGuy</span><span class=p>(</span> <span class=p>(</span><span class=n>HealthCalculator</span><span class=p>())</span> <span class=p>);</span><span class=c1>//用括号将仿函数括起来
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>functorGuy</span><span class=p>.</span><span class=n>healthValue</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>传入<code>std::bind</code>函数对象
std::bind是函数对象模板，接收一个函数指针f和若干函数入参得到fObj，调用fObj等同于调用带参数的f。本例代码如下：</li></ol><div class=highlight id=id-33><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>GameLevel</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span> <span class=c1>//用类内函数作为函数指针f
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>float</span> <span class=n>health</span><span class=p>(</span><span class=k>const</span> <span class=n>GameCharacter</span><span class=o>&amp;</span> <span class=n>gc</span><span class=p>)</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mf>20.3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//应用端代码如下：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>GameLevel</span>  <span class=n>curLevel</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>GameCharacter</span> <span class=nf>levelGuy</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bind</span><span class=p>(</span><span class=o>&amp;</span><span class=n>GameLevel</span><span class=o>::</span><span class=n>health</span><span class=p>,</span> <span class=n>curLevel</span><span class=p>,</span><span class=n>std</span><span class=o>::</span><span class=n>placeholders</span><span class=o>::</span><span class=n>_1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>levelGuy</span><span class=p>.</span><span class=n>healthValue</span><span class=p>();</span><span class=c1>//内部调用等价于curLevel.health(leveGuy);
</span></span></span></code></pre></td></tr></table></div></div><div class="details admonition Note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>By the way<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><pre><code>其实这里传入C++11新增的Lambda表达式作为std::function也是可以的，而且更方便，示例代码如下：
```c++
GameCharacter  lamGuy([&amp;](const GameCharacter&amp; gc){
 std::cout&lt;&lt; &quot;value is &quot; &lt;&lt; 75 &lt;&lt; std::endl;//具体计算略
   return 75;
   });
lamGuy.healthValue();
```
关于Strategy设计模式更多参考：
  - [Strategy设计模式-原理讲解](https://refactoringguru.cn/design-patterns/strategy)
  - [Strategy设计模式-C++代码参考](https://refactoringguru.cn/design-patterns/strategy/cpp/example)
</code></pre></div></div></div></li></ul><h3 id=r36-绝不重新定义继承而来的non-virtual函数>R36 绝不重新定义继承而来的non-virtual函数</h3><ul><li><p>由于名称遮掩，不要重新定义继承而来的non-virtual函数
看个反例：</p><div class=highlight id=id-34><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>mf</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;B::mf()&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span><span class=o>:</span> <span class=k>public</span> <span class=n>B</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>mf</span><span class=p>(){</span><span class=c1>//重新定义mf()，违反了Rule33
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;D::mf()&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么看这样的应用代码：</p><div class=highlight id=id-35><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>D</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>D</span><span class=o>*</span> <span class=n>pD</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>B</span><span class=o>*</span> <span class=n>pB</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=p>.</span><span class=n>mf</span><span class=p>();</span>    <span class=c1>// 输出 D::mf()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pD</span> <span class=o>-&gt;</span> <span class=n>mf</span><span class=p>();</span><span class=c1>// 输出 D::mf()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pB</span> <span class=o>-&gt;</span> <span class=n>mf</span><span class=p>();</span><span class=c1>// 输出 B::mf()
</span></span></span></code></pre></td></tr></table></div></div><p>这就很诡异了！都通过对象d调用成员函数mf，调用结果应该相同。</p><p>另外一点，出于public继承的“<strong>is-a</strong>”特性，这样重新定义non-virtual函数也是<strong>对"is-a"的严重违背</strong>。</p></li></ul><h3 id=r37-绝不重新定义继承而来的缺省入参值>R37 绝不重新定义继承而来的缺省入参值</h3><p>这里说的缺省入参，指的是函数入参的默认值，在重写带有缺省入参的virtual函数时，不要修改那个默认参数的默认值。</p><p>原因：virtual函数为<code>动态绑定</code>特性，而缺省参数值是<code>静态绑定</code>特性。修改后会造成一些令人费解的现象。</p><p>请看下方反面教材：</p><div class=highlight id=id-36><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>Color</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RED</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span><span class=n>GREEN</span> <span class=p>,</span><span class=n>BLUE</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>  <span class=c1>// ：父类默认入参是RED
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>draw</span><span class=p>(</span><span class=n>Color</span> <span class=n>col</span> <span class=o>=</span> <span class=n>Color</span><span class=o>::</span><span class=n>RED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Shape:col is &#34;</span> <span class=o>&lt;&lt;</span> <span class=kt>int</span><span class=p>(</span><span class=n>col</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rectangle</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span><span class=p>{</span> <span class=c1>// ：子类类修改默认入参为GREEN
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>draw</span><span class=p>(</span><span class=n>Color</span> <span class=n>col</span> <span class=o>=</span> <span class=n>Color</span><span class=o>::</span><span class=n>GREEN</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Rectangle:col is &#34;</span> <span class=o>&lt;&lt;</span> <span class=kt>int</span><span class=p>(</span><span class=n>col</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>那么当出现典型应用场景<code>Base* pB=new Derived</code>时，就会造成“父类子类各出一半力”的情形：</p><div class=highlight id=id-37><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Shape</span> <span class=o>*</span><span class=n>pRec</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Rectangle</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>pRec</span><span class=o>-&gt;</span><span class=n>draw</span><span class=p>();</span> <span class=c1>// 输出：Rectangle:col is 0  （0是RED）
</span></span></span></code></pre></td></tr></table></div></div><p>结果确实调用子类draw，但是默认入参取的是基类的 RED，而非子类的GREEN。
那怎么修改合适呢，都带默认参数，且子类父类相同？带来一个<strong>耦合问题</strong>，如果父类改了，所有子类都得改。
正如Rule35提到的NVI(non-virtual interface)手法，此处便是绝佳的应用场景$\Longrightarrow$ draw方法改为默认参数的non-virtual，把virtual函数放到private里去，代码修改如下：</p><div class=highlight id=id-38><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>   <span class=c1>//子类继承该默认入参的non-virtual接口，别重写
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=n>draw</span><span class=p>(</span><span class=n>Color</span> <span class=n>col</span> <span class=o>=</span> <span class=n>Color</span><span class=o>::</span><span class=n>RED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>drawImpl</span><span class=p>(</span><span class=n>col</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span> <span class=c1>//纯虚函数是强制子类重写，看具体情况，impure-virtual也行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>drawImpl</span><span class=p>(</span><span class=n>Color</span> <span class=n>col</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=c1>//子类重写这个drawImpl
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><h3 id=r38-通过复合塑造出has-a或根据某物实现出>R38 通过复合塑造出has-a或"根据某物实现出”</h3><p>原书标题：<code>Model “has-a” or “is-implemented-in-terms-of” through composition</code>，同Rule32，侯捷老师翻译为“塑模”。</p><p>复合关系（composition）是一种常见的类关系，当某种类型的对象内含有它种类型的对象时，便是此种关系。</p><p>复合关系分为2种：<code>"has-a"</code> 和 <code>“is-implemented-in-terms-of"</code>。</p><ul><li>“<code>has-a</code>”关系：
指的是<strong>应用域</strong>部分，不参与内的具体各项实现。是一种单纯的完备对象的包含关系，比如Person类有Address、PhoneNumber、Job等类型的成员变量，又或是Image类有Buffer、Mutexx、SearchTree等类型的成员。</li><li>“<code>is-implemented-in-terms-of</code>“关系：
指的是<strong>实现域</strong>部分，参与类的各类实现，比如数据结构的设计中，想用现有的 std::list来实现Set类，这样可能效率不高(通常更具效率的实现是采用平衡查找树 )，但是可行。
📌：此处不能让Set以public继承于std::list，因为list允许重复元素，而Set不行，不满足“is-a”关系。
正确实现部分代码示例如下：<div class=highlight id=id-39><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Set</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>contains</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>item</span><span class=p>)</span><span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>find</span><span class=p>(</span><span class=n>rep_</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span><span class=n>rep_</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span><span class=n>item</span><span class=p>)</span> <span class=o>!=</span> <span class=n>rep_</span><span class=p>.</span><span class=n>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>item</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>contains</span><span class=p>(</span><span class=n>item</span><span class=p>))</span> <span class=n>rep_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>remove</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>item</span><span class=p>);</span><span class=c1>// 实现略
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>  <span class=c1>// 实现略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>rep_</span><span class=p>;</span> <span class=c1>//用来表述Set的数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=r39-明智而审慎地使用private继承>R39 明智而审慎地使用private继承</h3><p>“明智而审慎”的意思是👉当考虑了其他方案对比后，仍然觉得private继承是最合适的，才使用它。</p><p>首先明确private继承的2个特性：</p><ol><li>编译器不会自动将一个derived-class对象隐式转换为base-class对象(函数入参时)；</li><li>继承而来的成员，在derived-class中都会变成private属性；</li></ol><p>private继承的意义：意味着<strong>implemented-in-terms-of</strong>，在类关系设计上没有太大意义，只看重软件实现。</p><p>考虑以下使用private的2个应用场景：</p><ul><li><p><strong>derived-class想继承base-class的某public接口实现，但又想隐藏此接口</strong>
考虑如下应用场景：对于一个已知的类Widget，想用另一个已知的计时类Timer辅助性能分析，在尽量小改动已有代码的情况下，如何启用Timer？
private继承做法：让Widget类private继承于Timer，重写父类Timer的onTick函数。
具体代码如下：</p><div class=highlight id=id-40><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Timer</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>Timer</span><span class=p>(</span><span class=kt>int</span> <span class=n>tickFrequency</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onTick</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span><span class=c1>//定时器滴答一次，自动被调用一次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span><span class=o>:</span><span class=k>private</span> <span class=n>Timer</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span> <span class=c1>// private继承而来的所有成员都是private属性
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onTick</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span><span class=c1>//查看并记录Widget数据，资源等
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>该问题除了上方的private继承，能不能用其他方案替代private继承呢？
👉👉“public继承+复合”替代private继承：在Widget内部嵌套定义private属性的新类WidgetTimer:private Timer，即可同样启用Timer且隐藏了Timer。代码如下：</p><div class=highlight id=id-41><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>WidgetTimer</span><span class=o>:</span><span class=k>public</span> <span class=n>Timer</span><span class=p>{</span><span class=c1>// 类内嵌套定义
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>virtual</span> <span class=kt>void</span> <span class=n>onTick</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>WidgetTimer</span> <span class=n>wTimer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>⭐⭐ WidgetTimer也可以不定义在Widget类内,类内只放WidgetTimer* 和WidgetTimer的前置声明，完全解耦合，<strong>降低编译依赖性</strong>。而这样的设计自由度是单纯的private继承不具备的。</p></li><li><p><strong>空白基类最优化(EBO,empty base optimization)</strong>
⚡值得一提：空类(Empty Class)是指不含non-static数据成员和virtual-func的类。
空类的size会被C++强制要求至少为1，通常是用1个char占位。如果让Empty-Class作为数据成员，因为内存对齐而导致Derived-Class浪费内存。
示例代码 👇：</p><div class=highlight id=id-42><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Empty</span> <span class=p>{</span> <span class=c1>// 空类，1字节. 不含non-static数据，不含virtual
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>privteFoo</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;private non-virtual.&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=kt>char</span><span class=o>*</span>  <span class=n>pChar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=nf>void</span><span class=p>(</span><span class=o>*</span><span class=n>pFuncReadData</span><span class=p>)(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>url</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>enum</span> <span class=k>class</span> <span class=nc>clolr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>red</span><span class=p>,</span><span class=n>green</span><span class=p>,</span><span class=n>blue</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;public non-virtual!&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>int</span> <span class=n>count</span> <span class=p>;</span><span class=c1>//static 数据也不属于class实体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HoldsIntsAndEmpty</span> <span class=p>{</span> <span class=c1>//内存对齐后12字节
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>x_</span><span class=p>;</span>   <span class=c1>// 4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Empty</span> <span class=n>e_</span><span class=p>;</span> <span class=c1>// 1字节
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>y_</span><span class=p>;</span>   <span class=c1>// 4字节
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HoldsInts</span><span class=o>:</span><span class=k>private</span> <span class=n>Empty</span> <span class=p>{</span><span class=c1>//使用EBO,类大小8字节
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>x_</span><span class=p>;</span><span class=c1>//4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>y_</span><span class=p>;</span><span class=c1>//4字节
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>EBO优化可以减少Derived-Class的内存大小，注意EBO只适用于单继承。</p></li></ul><h3 id=r40-明智而审慎地使用多重继承>R40 明智而审慎地使用多重继承</h3><p>多重继承(multiple inheritance)是指继承一个以上的父类。但是这些父类应该避免拥有共同的祖父类，会形成比较麻烦的“菱形继承”(或者叫钻石继承)。</p><ul><li><p><strong>多重继承的成本以及副作用</strong>
上面说“菱形继承”比较麻烦，主要原因是如果祖父类如果拥有某个成员变量x，那么2个父类分别public形式继承了x，到了目标子类就有了2份x。
解决问题的办法是<strong>虚继承</strong>(virtual inheritance)，如此，上述子类只有一份x。为保证虚继承的正确性，编译器在背后需要付出更多代价，可能造成子类内存更大或运行速度更慢。
👉如果存在菱形继承，那么祖父类尽量不要持有数据成员。
虚继承示例代码如下：</p><div class=highlight id=id-43><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>File</span><span class=p>{...};</span>  <span class=c1>//祖父类最好不要持有non-static数据成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>InputFile</span><span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>File</span><span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>OutputFile</span><span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>File</span><span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>IOFile</span><span class=o>:</span><span class=k>public</span> <span class=n>InputFile</span><span class=p>,</span><span class=k>public</span> <span class=n>OutputFile</span><span class=p>{...};</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>应用场景：public继承接口+private继承实现</strong>
思考这样的应用场景，PersonBase类是虚基类，RealPerson是目标子类（需要继承接口），但是获取name和birthDate信息的函数在另一个PersonInfo类都有了现成的实现（只需要简单修改该实现）。</p><p>两者结合后，即让RealPerson类public继承于PersonBase，private继承于PersonInfo。</p><div class=highlight id=id-44><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>PersonBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>PersonBase</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PersonInfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span>  <span class=o>~</span><span class=n>PersonInfo</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>PersonInfo</span><span class=p>(</span><span class=kt>int</span> <span class=n>pID</span><span class=p>)</span><span class=o>:</span><span class=n>id_</span><span class=p>(</span><span class=n>pID</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>theName</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=kt>char</span> <span class=n>value</span><span class=p>[</span><span class=mi>1024</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>exampleName</span> <span class=o>=</span> <span class=s>&#34;Luka&#34;</span><span class=p>;</span><span class=c1>// 计算过程略,用固定字符串替代
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>valueDelimLeft</span><span class=p>());</span>   <span class=c1>// 获取左界定符
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>strcat</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>exampleName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>strcat</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>valueDelimRight</span><span class=p>());</span><span class=c1>// 获取右界定符
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>theBirthDate</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;1990-1-1&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>valueDelimLeft</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;[&#34;</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>valueDelimRight</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;]&#34;</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>id_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>多重继承的代码为👇:</p><div class=highlight id=id-45><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>RealPerson</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PersonBase</span><span class=p>,</span> <span class=k>private</span> <span class=n>PersonInfo</span> <span class=p>{</span><span class=c1>//多重继承
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>RealPerson</span><span class=p>(</span><span class=kt>int</span> <span class=n>pID</span><span class=p>)</span> <span class=o>:</span><span class=n>PersonInfo</span><span class=p>(</span><span class=n>pID</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 委托构造
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span> <span class=c1>//实现必要的虚基类Person的pure-virtual成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>PersonInfo</span><span class=o>::</span><span class=n>theName</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>birthDate</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>PersonInfo</span><span class=o>::</span><span class=n>theBirthDate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>valueDelimLeft</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>;</span> <span class=p>};</span><span class=c1>//重写界定符函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>valueDelimRight</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>最后应用端代码：</p><div class=highlight id=id-46><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>RealPerson</span> <span class=nf>rPerson</span><span class=p>(</span><span class=mi>613</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>rPerson</span><span class=p>.</span><span class=n>name</span><span class=p>();</span> <span class=c1>//输出Luka ,而不是[Luka]
</span></span></span></code></pre></td></tr></table></div></div><p>可以看到，多重继承体系完美解决该问题。</p></li></ul><p>回到本节开头，明智和审慎的意思是👉即使多重继承可以用单继承方案替代解决，思考后，如果多重继承依然是最简洁、最易维护、最合理的做法，那就选择它。</p><p>ref:</br>[1]. <a href=https://blog.csdn.net/cltcj/category_12098441.html target=_blank rel="external nofollow noopener noreferrer">https://blog.csdn.net/cltcj/category_12098441.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br>[2]. <a href=https://kissingfire123.github.io/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/ target=_blank rel="external nofollow noopener noreferrer">https://kissingfire123.github.io/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></br></p></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Jian YE 支付宝" data-alt="Jian YE 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Jian YE 微信" data-alt="Jian YE 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-10-07 09:25:23">更新于 2023-10-07&nbsp;<a class=git-hash href=https://github.com/jianye0428/JianBlog/commit/f43a10a9b4079963a6d78279f6f805b045e519d1 rel="external nofollow noopener noreferrer" target=_blank title="commit by yejian(18817571704@163.com) f43a10a9b4079963a6d78279f6f805b045e519d1: bug: modify effective c++ naming rules"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>f43a10a</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/effective_cpp_part_three/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/jianye0428/JianBlog/edit/docs/content/posts/C++/Effective_C++/Effective_CPP_Part_Three/index.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://jianye0428.github.io/posts/effective_cpp_part_three/ data-title="Effective C++ (第3版) 精读总结 [3]" data-hashtags=Effective><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://jianye0428.github.io/posts/effective_cpp_part_three/ data-hashtag=Effective><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://jianye0428.github.io/posts/effective_cpp_part_three/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://jianye0428.github.io/posts/effective_cpp_part_three/ data-title="Effective C++ (第3版) 精读总结 [3]"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://jianye0428.github.io/posts/effective_cpp_part_three/ data-title="Effective C++ (第3版) 精读总结 [3]"><i data-svg-src=/lib/simple-icons/icons/baidu.min.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/effective/ class=post-tag>Effective</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/effective_cpp_part_two/ class=post-nav-item rel=prev title="Effective C++ (第3版) 精读总结 [2]"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Effective C++ (第3版) 精读总结 [2]</a>
<a href=/posts/effective_cpp_part_four/ class=post-nav-item rel=next title="Effective C++ (第3版) 精读总结 [4]">Effective C++ (第3版) 精读总结 [4]<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.126.1">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/jianye0428 target=_blank rel="external nofollow noopener noreferrer">Jian YE</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics order-first"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/jianye0428/JianBlog title="在 GitHub 上查看程式碼，訂閱請點 Watch" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"MTJNHU0JVB",algoliaIndex:"index",algoliaSearchKey:"5486225134d99f43826da401ee9bad57",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-05-28T20:01:01+08:00",twemoji:!0,watermark:{appendto:".wrapper>main",colspacing:30,content:'<img style="height: 0.85rem;" src="/images/favicon/jian_icon.png" alt="logo" /> jianye',enable:!0,fontfamily:"MMT_LRH,沐目体",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>