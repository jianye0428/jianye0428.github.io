[{"categories":["C++"],"content":"拷贝对象是STL的方式 当一个对象进入一个容器，它已经不是你添加（insert或push_back等）的那个对象了，进入容器的是你指定的对象的拷贝； 当从容器中取出一个对象时，所得到的也不是容器里的对象； 如果从vector、string或deque中插入或删除了什么，现有的容器元素会移动（拷贝） 如果使用了任何排序算法：next_permutation或者previous_permutation； remove、unique或它们的同类； rotate或reverse等，对象会移动（拷贝） 拷进去，拷出来。这就是STL的方式. 因为拷贝，还解决了一个 double free 的 bug点击查看 ","date":"2023-07-24","objectID":"/posts/clause_3/:1:0","tags":["STL"],"title":"Effective STL [3] | 使容器里对象的拷贝操作轻量而正确","uri":"/posts/clause_3/"},{"categories":["C++"],"content":"How Copy? 如何完成拷贝 Notice 通过拷贝构造函数和拷贝复制操作符完成！ 一个对象通过使用它的拷贝成员函数来拷贝，特别是它的拷贝构造函数和它的拷贝赋值操作符。 对于用户自定义类，比如Widget，这些函数传统上是这么声明的： class Widget { public: ... Widget(const Widget\u0026); // 拷贝构造函数 Widget\u0026 operator=(const Widget\u0026); // 拷贝赋值操作符 ... }; 如果你自己没有声明这些函数，你的编译器始终会为你声明它们。 拷贝内建类型（比如int、指针等）也始终是通过简单地拷贝他们的内在比特来完成的。（请参考《Effective C++》中，条款11和27专注于这些函数的行为。） ","date":"2023-07-24","objectID":"/posts/clause_3/:2:0","tags":["STL"],"title":"Effective STL [3] | 使容器里对象的拷贝操作轻量而正确","uri":"/posts/clause_3/"},{"categories":["C++"],"content":"拷贝带来的问题 性能瓶颈 拷贝会导致把对象放进容器也会被证明为是一个性能瓶颈。 容器中移动越多的东西，你就会在拷贝上浪费越多的内存和时钟周期。 切片分割 当然由于继承的存在，拷贝会导致分割。 如果以基类对象建立一个容器，而你试图插入派生类对象，那么当对象（通过基类的拷贝构造函数）拷入容器的时候对象的派生部分会被删除： vector\u003cWidget\u003e randy; class SpecialWidget: public Widget {...}; // SpecialWidget从上面的Widget派生 SpecialWidget sw; randy.push_back(sw); // sw被当作基类对象拷入randy，当拷贝时它的特殊部分丢失了 分割问题暗示了把一个派生类对象插入基类对象的容器几乎总是错的。 如果你希望结果对象表现为派生类对象，比如，调用派生类的虚函数等，总是错的。 ","date":"2023-07-24","objectID":"/posts/clause_3/:3:0","tags":["STL"],"title":"Effective STL [3] | 使容器里对象的拷贝操作轻量而正确","uri":"/posts/clause_3/"},{"categories":["C++"],"content":"解决 一个使拷贝更高效、正确而且对分割问题免疫的简单的方式是建立指针的容器而不是对象的容器。 也就是说，不是建立一个Widget的容器，建立一个Widget*的容器。 拷贝指针很快，它总是严密地做你希望的（指针拷贝比特），而且当指针拷贝时没有分割，就是int类型的地址。 但是一定要记得在销毁容器的时候，使用delete 销毁里面保存的每个指针。而且一定要定义对象的深拷贝构造函数和深拷贝拷贝赋值操作符，否则delete 的时候会报错。 ","date":"2023-07-24","objectID":"/posts/clause_3/:4:0","tags":["STL"],"title":"Effective STL [3] | 使容器里对象的拷贝操作轻量而正确","uri":"/posts/clause_3/"},{"categories":["C++"],"content":"和数组对比，STL容器更文明 STL容器只建立（通过拷贝）你需要的个数的对象，而且它们只在你指定的时候做。 STL进行了大量拷贝，但它通常设计为避免不必要的对象拷贝，实际上，它也被实现为避免不必要的对象拷贝。 数组在声明的时候，会默认先构造好每个元素；STL容器可以实现动态扩展 Widget randy[maxNumWidgets]; // 建立一个大小为maxNumWidgets的Widgets数组 // 默认构造每个元素 即使只使用其中的一些或者我们立刻使用从某个地方获取（比如，一个文件）的值覆盖每个默认构造的值，这也得构造maxNumWidgets个Widget对象。 使用STL来代替数组，你可以使用一个可以在需要的时候增长的vector，就是动态数组的概念： vector\u003cWidget\u003e randy; // 建立一个0个Widget对象的vector // 需要的时候可以扩展 建立一个可以足够包含maxNumWidgets个Widget的空vector，但不去构造Widget，需要时再构造： vector\u003cWidget\u003e randy; randy.reserve(maxNumWidgets); // reserve的详细信息请参见条款14 即便需要知道STL容器使用了拷贝，但是别忘了一个事实：比起数组它们仍然是一个进步。 ","date":"2023-07-24","objectID":"/posts/clause_3/:5:0","tags":["STL"],"title":"Effective STL [3] | 使容器里对象的拷贝操作轻量而正确","uri":"/posts/clause_3/"},{"categories":["C++"],"content":"STL 容器特点 STL是建立在泛化之上的 数组泛化为容器，参数化了所包含的对象的类型 函数泛化为算法，参数化了所用的迭代器的类型 指针泛化为迭代器，参数化了所指向的对象的类型 独立的容器类型泛化为序列或关联容器，而且类似的容器拥有类似的功能。 标准的内存相邻容器都提供随机访问迭代器，标准的基于节点的容器都提供双向迭代器。 序列容器支持push_front或push_back，但关联容器不支持。关联容器提供对数时间复杂度的lower_bound、upper_bound和equal_range成员函数，但序列容器却没有。 举例: 标准序列容器: vector、string、deque 和 list 标准关联容器: set、multiset、map 和 multimap ","date":"2023-07-20","objectID":"/posts/clause_2/:1:0","tags":["STL"],"title":"Effective STL [2] | 小心对“容器无关代码”的幻想","uri":"/posts/clause_2/"},{"categories":["C++"],"content":"推行自己的容器 很多人会试图在他们的软件中泛化容器的不同，而不是针对容器的特殊性编程，他们会想在vector 中使用 deque 或者 list的特性，这往往会带来麻烦。 比如： 只有序列容器支持push_front或push_back，只有关联容器支持count和lower_bound 即便是 insert和erase这样的操作在名称和语义上也有差别 当把对象插入序列容器中，该对象会保留在你放置的位置上; 当你把对象插入到一个关联容器中，容器会按照排列顺序把对象移到它应该在的位置; 在序列容器上用一个迭代器作为参数调用 erase，会返回一个新的迭代器；在关联容器上什么都不返回。 容器能力的交集 如果你想写一个可以用在常用序列容器上的代码—— 包含vector, deque和list。你必须使用它们能力的交集来编写。 但要考虑几点： deque和list不支持reserve或capacity list不支持operator[]操作，且受限于双向迭代器的性能 不能使用需要随机访问迭代器的算法，包括sort，stable_sort，partial_sort和nth_element 如果想支持vector的规则，则不能使用push_front和pop_front vector和deque都会使splice和成员函数方式的sort失败 因为deque::insert会使所有迭代器失效，而且因为缺少capacity，vector::insert也必须假设使所有指针和引用失效，而deque是唯一一个在迭代器失效的情况下, 指针和引用仍然有效的东西 不能把容器里的数据传递给C风格的界面，只有vector支持这么做 不能用bool作为保存的对象来实例化你的容器，因为vector 并非总表现为一个vector，实际上它并没有真正保存bool值。 不能期望享受到list的常数时间复杂度的插入和删除，vector和deque的插入和删除操作是线性时间复杂度的 所以，真正开发时，如果都考虑到上面几点，那想开发的容器只剩下一个\"泛化的序列容器\"，但是你不能调用reserve、capacity、operator[]、push_front、pop_front、splice或任何需要随机访问迭代器的算法；调用insert和erase会有线性时间复杂度而且会使所有迭代器、指针和引用失效；而且不能兼容C风格的界面，不能存储bool。 如果你放弃了序列容器，把代码改为只能和不同的关联容器配合，这情况并没有什么改善。 要同时兼容set和map几乎是不可能的，因为set保存单个对象，而map保存对象对。 甚至要同时兼容set和multiset（或map和multimap）也是很难的。 set/map的insert成员函数只返回一个值，和他们的multi兄弟的返回类型不同，而且你必须避免对一个保存在容器中的值的拷贝份数作出任何假设。 对于map和multimap，你必须避免使用operator[]，因为这个成员函数只存在于map中。 ","date":"2023-07-20","objectID":"/posts/clause_2/:2:0","tags":["STL"],"title":"Effective STL [2] | 小心对“容器无关代码”的幻想","uri":"/posts/clause_2/"},{"categories":["C++"],"content":"封装 如果想改变容器类型，就使用封装。 Method 1: typedef 一种最简单的方法是通过自由地对容器和迭代器类型使用typedef class Widget {...}; vector\u003cWidget\u003e vw; Widget bestWidget; ... // 给bestWidget一个值 vector\u003cWidget\u003e::iterator i = // 寻找和bestWidget相等的Widget find(vw.begin(), vw.end(), bestWidget); 可以简化上述写法 class Widget { ... }; typedef vector\u003cWidget\u003e WidgetContainer; typedef WidgetContainer::iterator WCIterator; WidgetContainer cw; Widget bestWidget; ... WCIterator i = find(cw.begin(), cw.end(), bestWidg 如果需要加上用户的allocator，也特别方便。（一个不影响对迭代器/指针/参考的失效规则的改变） class Widget { ... }; template\u003ctypename T\u003e // 关于为什么这里需要一个template SpecialAllocator { ... }; // 请参见条款10 typedef vector\u003cWidget, SpecialAllocator\u003cWidget\u003e \u003e WidgetContainer; typedef WidgetContainer::iterator WCIterator; WidgetContainer cw; // 仍然能用 Widget bestWidget; ... WCIterator i = find(cw.begin(), cw.end(), bestWidget); // 仍然能用 typedef只是其它类型的同义字，所以它提供的的封装是纯的词法（译注：不像#define是在预编译阶段替换的）。typedef并不能阻止用户使用（或依赖）任何他们不应该用的（或依赖的）。 Method 2: class 要限制如果用一个容器类型替换了另一个容器可能需要修改的代码，就需要在类中隐藏那个容器，而且要通过类的接口限制容器特殊信息可见性的数量。 比如需要隐藏 真实的容器 list 建立客户列表： class CustomerList { private: typedef list\u003cCustomer\u003e CustomerContainer; typedef CustomerContainer::iterator CCIterator; CustomerContainer customers; public: // 通过这个接口 ... // 限制list特殊信息的可见性 }; 如果使用过程中，你发现从列表的中部插入和删除客户并不像你想象的那么频繁，仅仅需要快速确定客户列表顶部的20%——一个为nth_element算法量身定做的任务。 但nth_element需要随机访问迭代器，不能兼容list。 在这种情况下，你的客户\"list\"可能更应该用\"vector\"或\"deque\"来实现 当你决定作这种更改的时候，你仍然必须检查每个CustomerList的成员函数和每个友元，看看他们受影响的程度（根据性能和迭代器/指针/引用失效的情况等等）。 但如果你做好了对CustomerList地实现细节做好封装的话，那对CustomerList的客户的影响将会很小。 ","date":"2023-07-20","objectID":"/posts/clause_2/:3:0","tags":["STL"],"title":"Effective STL [2] | 小心对“容器无关代码”的幻想","uri":"/posts/clause_2/"},{"categories":["C++"],"content":" quote 选择容器需要注意的几个方面 ","date":"2023-07-19","objectID":"/posts/clause_1/:0:0","tags":["STL"],"title":"Effective STL [1] | 仔细选择你的容器","uri":"/posts/clause_1/"},{"categories":["C++"],"content":"迭代器 输入迭代器 每个迭代位置只能被读1次的只读迭代器，通常表现为 istream_iterator 输出迭代器 每个迭代位置只能被写1次的只写迭代器，通常表现为 ostream_iterator 前向迭代器 有输入和输出迭代器的能力，可以反复读写1个位置，不支持 operator–，可以高效地向前移动任意次数 散列容器的一种设计可以产生前向迭代器； 单链表容器也提供前向迭代器 双向迭代器 像前向迭代器一样，后退很容易。标准关联容器都提供双向迭代器，list也有 随机访问迭代器 可以做双向迭代器一样的事情，但也提供“迭代器算术”，即迭代器有一步向前或向后跳的能力。 vector、string 和 deque 都提供随机访问迭代器。 指针数组的指针可以作为数组的随机访问迭代器。 ","date":"2023-07-19","objectID":"/posts/clause_1/:1:0","tags":["STL"],"title":"Effective STL [1] | 仔细选择你的容器","uri":"/posts/clause_1/"},{"categories":["C++"],"content":"容器 STL有迭代器、算法和函数对象，但对于大多数C++程序员，容器是最突出的。 它们比数组更强大更灵活，可以动态增长（也常是缩减），可以管理属于它们自己的内存，可以跟踪它们拥有的对象数目，可以限制它们支持操作的算法复杂度等等。 分类 类别 说明 标准STL序列容器 vector、string、deque和list 标准STL关联容器 set、multiset、map和multimap 非标准序列容器slist和rope slist是一个单向链表，rope本质上是一个重型字符串。(“绳子(rope)“是重型的\"线(string)”) 非标准关联容器 hash_set、hash_multiset、hash_map和hash_multimap vector 可以作为string的替代品 vector作为标准关联容器的替代品 有时候vector可以在时间和空间上都表现得比标准关联容器好 标准非STL容器 包括数组、bitset、valarray、stack、queue和priority_queue 。值得注意的是，数组可以和STL算法配合，因为指针可以当作数组的迭代器使用 vector、list和deque提供给程序员不同的复杂度，因此应该这么用： vector是一种可以默认使用的序列类型 当很频繁地对序列中部进行插入和删除时应该用list 当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构 连续内存容器和基于节点的容器的区别 连续内存容器（也叫做基于数组的容器） 在一个或多个（动态分配）的内存块中保存它们的元素。 如果一个新元素被查入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提供空间或者填充原来被删除的元素所占的空间。 这种移动影响了效率和异常安全。 标准的连续内存容器是vector、string和deque。 非标准的rope也是连续内存容器。 基于节点的容器 在每个内存块（动态分配）中只保存一个元素。 容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。 所以当有东西插入或删除时，元素值不需要移动。 表现为链表的容器——比如list和slist——是基于节点的，所有的标准关联容器也是（它们的典型实现是平衡树）。 非标准的散列容器使用不同的基于节点的实现。 ","date":"2023-07-19","objectID":"/posts/clause_1/:2:0","tags":["STL"],"title":"Effective STL [1] | 仔细选择你的容器","uri":"/posts/clause_1/"},{"categories":["C++"],"content":"如何选择容器? 你需要“可以在容器的任意位置插入一个新元素”的能力吗？ 如果是，你需要序列容器，关联容器做不到。 你关心元素在容器中的顺序吗？ 如果不，散列容器就是可行的选择。否则，你要避免使用散列容器。 必须使用标准C++中的容器吗? 如果是，就可以除去散列容器、slist和rope。 你需要哪一类迭代器？ 如果必须是随机访问迭代器，在技术上你就只能限于vector、deque和string，但你也可能会考虑rope。 如果需要双向迭代器，你就用不了slist 和散列容器的一般实现。 当插入或者删除数据时，是否非常在意容器内现有元素的移动？ 如果是，你就必须放弃连续内存容器。 容器中的数据的内存布局需要兼容C吗？ 如果是，你就只能用vector。 查找速度很重要吗？ 如果是，你就应该看看散列容器，排序的vector和标准的关联容器——大概是这个顺序。 你介意如果容器的底层使用了引用计数吗？ 如果是，你就得避开string，因为很多string的实现是用引用计数。 你也不能用rope，因为权威的rope实现是基于引用计数的。 于是你得重新审核你的string，你可以考虑使用vector 你需要插入和删除的事务性语义吗？也就是说，你需要有可靠地回退插入和删除的能力吗？ 如果是，你就需要使用基于节点的容器。 如果你需要多元素插入（比如，以范围的方式）的事务性语义，你就应该选择list，因为list是唯一提供多元素插入事务性语义的标准容器。 事务性语义对于有兴趣写异常安全代码的程序员来说非常重要。（事务性语义也可以在连续内存容器上实现，但会有一个性能开销，而且代码不那么直观） 你要把迭代器、指针和引用的失效次数减到最少吗？ 如果是，你就应该使用基于节点的容器，因为在这些容器上进行插入和删除不会使迭代器、指针和引用失效（除非它们指向你删除的元素）。 一般来说，在连续内存容器上插入和删除会使所有指向容器的迭代器、指针和引用失效。 你需要具有以下特性的序列容器吗：1） 可以使用随机访问迭代器；2） 只要没有删除而且插入只发生在容器结尾，指针和引用的数据就不会失效？ 这个一个非常特殊的情况，但如果你遇到这种情况，deque就是你梦想的容器。 有趣的是，当插入只在容器结尾时，deque的迭代器也可能会失效，deque是**唯一一个“在迭代器失效时不会使它的指针和引用失效”**的标准STL容器。 ","date":"2023-07-19","objectID":"/posts/clause_1/:3:0","tags":["STL"],"title":"Effective STL [1] | 仔细选择你的容器","uri":"/posts/clause_1/"},{"categories":["C++"],"content":"结语 当面对容器时，STL给了你很多选项。如果你的视线超越了STL的范围，那就会有更多的选项。在选择一个容器前，要保证考虑了所有你的选项。 ","date":"2023-07-19","objectID":"/posts/clause_1/:4:0","tags":["STL"],"title":"Effective STL [1] | 仔细选择你的容器","uri":"/posts/clause_1/"},{"categories":["Prediction"],"content":"ref link: [1] https://blog.csdn.net/qq_41897558/article/details/120087113 [2] https://zhuanlan.zhihu.com/p/355131328 ref code: [1]https://github.com/xk-huang/yet-another-vectornet [2]https://github.com/DQSSSSS/VectorNet ","date":"2023-07-16","objectID":"/posts/vectornet/:0:0","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"Novel Highlights (1) 使用矢量化的高精地图以及障碍物的历史轨迹，从而避免有损渲染以及ConvNet编码(计算开销比较大)。 (2) 设计子图网络以及全局图网络，建模低阶以及高阶交互 (3) auxiliary task 提高网络性能 ","date":"2023-07-16","objectID":"/posts/vectornet/:1:0","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"VecotorNet 网络介绍 ","date":"2023-07-16","objectID":"/posts/vectornet/:2:0","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"轨迹和地图的向量表示 Representing trajectories and HD maps lane可以表示为splines，人行道可以表示为一个很多个点组成的polygon，stop sign标记可以表示为单一个点。 对于agent来说，他们的轨迹也是一种splines。 这些元素都可以向量表示。 对于地图的特征：选择一个start point和朝向，等间距均匀采样关键点，并于相邻的关键点相连为向量 对于agent轨迹，按照0.1s sample关键点，并将它们连接成向量。 通过向量化的过程，可以得到折线polylines，这个polylines和轨迹、地图标注之间是一一对应的。如果给定的时空间隔足够小，得到的这些折线就与原始地图和轨迹十分接近。 我们将属于折线 $P_j$​ 的每一个向量$v_i$看出图中的一个节点，节点特征如下: $$v_i = [d_i^s, d_i^e, a_i, j]$$ 其中前两个vector分别是vector的start point和end point的坐标，可以是(x,y)或者(x,y,z)三维的形式 第三个向量则是attribute属性的特征，比如object的类型，轨迹的时间戳，道路的特征，道路限速等 最后一个是障碍物id，表示 $v_i$ ​属于 $P_j$ ","date":"2023-07-16","objectID":"/posts/vectornet/:2:1","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"Polyline 子图构建 对于一个Polyline P, 它的节点有 ${v_1,v_2,…,v_p}$， 可以定义一个子图网络： $$v_i^{l+1} = \\varphi_{rel}(g_{enc}(v_i^{(l)}), \\varphi({g_{enc}(v_j^{(l)})}))$$ $v_i^{(l)}$​ 代表第i个节点第L层的节点特征。 $g_{enc}(\\cdot)$代表节点的变换，实践中采用MLP来实现。 $\\varphi_{agg}(\\cdot)$代表特征聚合，用来从相邻的节点来获取信息，实践中采用的是max_pooling。 $\\varphi_{rel}(\\cdot)$代表vi和周围节点的关系，实践中采用的是concate的操作。 最后经过多层的堆叠，来获取整个Polyline级别的特征： $$P = \\varphi_{agg}(v_i^{L_p})$$ 这里， $φ_{agg}(⋅)$也是max pooling操作. ","date":"2023-07-16","objectID":"/posts/vectornet/:2:2","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"全局图的高阶交互 Global graph for high-order interactions 经过上面的子图进行低阶模型建模后，现在有了polyline级别节点的特征${p_1,p_2,…,p_P}$. 为了建立高阶的交互，需要建立一个global的交互图，详见论文图2的第3个子图。 $$P_i^{l+1} = GNN(p^l_i, A)$$ $p_i^l$​代表polyline节点的集合 A代表邻接矩阵，实践中采用全链接 $GNN(⋅)$代表一层的GNN网络，实践中采用的是self attention layer： $$GNN(P) = softmax(P_Q P_K^T)P_V$$ 其中，P是node的feature matrix， $P_Q$,$P_k$,$P_v$ ​则是它的线性投影。 经过了全局的网络之后，就生成了节点的特征$P^{L_t}_i$，其中Lt是全局GNN网络的层数。然后将$P^{(L_t)}_i$放入decoder进行轨迹的生成: $$v_i^{future} = \\varphi_{traj}(P_i^{L_t})$$ 论文中，decoder $φ_{traj}(⋅)$ 使用的是MLP，当然也可以用MultiPath中anchor-based的方法或者variational RNNs 来进行多模态轨迹预测。 ","date":"2023-07-16","objectID":"/posts/vectornet/:2:3","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"辅助任务训练 auxiliary graph completion task 为了让全局交互图能更好地捕捉不同轨迹和地图元素之间的交互信息，论文还提出了一个辅助的任务：在训练过程中，随机mask掉一些节点的特征，然后尝试去还原被掩盖的节点特征: $$\\hat{P}i = \\varphi{node}(P_i^{L_t})$$ 这里节点的decoder $φ_{node}(⋅)$ 也是一个MLP，只在训练的时候使用,在inference过程中不使用。 ","date":"2023-07-16","objectID":"/posts/vectornet/:2:4","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"损失函数 Loss Function 多任务训练目标， multi-task training task: $$\\mathcal{L} = \\mathcal{L_{traj}} + \\alpha \\mathcal{L_{node}}$$ $L_{traj}​$: negative Gaussian log-likelihood loss $L_{node}$​: 是预测的节点和被掩盖节点的huber损失函数 其中， negative Gaussian Log Likelihood 损失函数为: $$L(x, y) = -\\log P(y) = - \\log P(y|\\mu(x), \\sum(x))$$ where, $$p(y) = p(y∣μ,Σ)=1(2π)n/2∣Σ∣1/2exp−12(y−μ)⊤Σ−1(y−μ)$$ Huber 损失函数为: $$ L(Y|f(x))= \\begin{cases} \\frac{1}{2} (Y-f(x))^2, \u0026 |Y-f(x)|\u003c= \\delta \\\\ \\delta |Y-f(x)| - \\frac{1}{2}\\delta^2, \u0026 |Y-f(x)| \u003e \\delta \\end{cases} $$ ","date":"2023-07-16","objectID":"/posts/vectornet/:2:5","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"整理 VectorNet数据处理部分: 对actor的处理: 输入: 取轨迹点，每两个轨迹点构建vector, 形式为(x1, x2, y1, y2), 其他特征(object type, timestamp, track_id) 对lane node的处理: 输入: 针对lane segment 的点，求polyline，原则上求lane segment的左右边界的点的向量(x_start, x_end, y_start, y_end, turn_direction, traffic_control, is_intersection, lane_id) 网络部分: 构建subgraphnet: 针对每一个polyline，通过mlp和maxpool构构建subgraphnet 构建globalgraphnet: 以每个polyline作为graph node，构建全局图网络，采用全链接，通过自注意力机制$GNN(P) = softmax(P_Q, P_K)^T(P_V)$ 轨迹生成: 将全局网络的节点特征，通过mlp进行轨迹生成。 ","date":"2023-07-16","objectID":"/posts/vectornet/:3:0","tags":["draft"],"title":"VectorNet 论文解读","uri":"/posts/vectornet/"},{"categories":["Prediction"],"content":"Overview paper link:https://arxiv.org/pdf/2202.04488.pdf ","date":"2023-07-16","objectID":"/posts/crat_pred/:1:0","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"论文概览 文章提出了一种结合Crystal Graph Convolutional Neural Network和Multi-Head Self-Attention Mechanism对交通agent处理的方式 在argoverse数据集上进行验证，实现了map-free预测模型的SOTA效果; 相比较于其他模型，模型参数更少。 证明: 可以通过 Self-Attention Mechanism 学习到交通参与者之间的交互关系。 ","date":"2023-07-16","objectID":"/posts/crat_pred/:2:0","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"网络结构 数据处理: 以argoverse2数据为例，取前50帧数据，两两作差值，取49组位移向量数据为输入 首先用EncoderLSTM作为encoder 再将每一个agent作为node，通过Crystal Graph Convolutional Neural Network构建图神经网络 通过Multi-Head Self-Attention学习node之间的交互关系 ","date":"2023-07-16","objectID":"/posts/crat_pred/:3:0","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"实现原理 ","date":"2023-07-16","objectID":"/posts/crat_pred/:4:0","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"Input Encoder 输入编码器 输入数据为过去5秒的离散位移: $$s_i^t = (\\Delta{\\tau_i^t} || b_i^t)$$ 其中， $\\Delta \\tau_i^t = \\tau_i^{t-1}$. ","date":"2023-07-16","objectID":"/posts/crat_pred/:4:1","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"Interaction Module 交互模块 ","date":"2023-07-16","objectID":"/posts/crat_pred/:4:2","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"Output Decoder 输出编码器 ","date":"2023-07-16","objectID":"/posts/crat_pred/:4:3","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"Training 训练过程 ","date":"2023-07-16","objectID":"/posts/crat_pred/:4:4","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"代码实现结构 数据处理结构 input = dict() input['argo_id'] = list() input['city'] = list() input['past_trajs'] = list() input['fut_trajs'] = list() input['gt'] = list() input['displ'] = list() input['centers'] = list() input['origin'] = list() input['rotation'] = list() 29 + 32 = 61 argo_id: [‘01d7deae-31e9-4657-843f-c30009b09f1c’, ‘01ca1736-ec51-41aa-8c73-3338c574a83a’] city: [‘austin’, ‘austin’] past_trajs: torch.Size([29, 50, 3]) torch.Size([32, 50, 3]) fut_trajs: torch.Size([29, 60, 3]) torch.Size([32, 60, 3]) gt: torch.Size([29, 60, 2]) torch.Size([32, 60, 2]) displ: torch.Size([29, 49, 3]) torch.Size([32, 49, 3]) centers: torch.Size([29, 2]) torch.Size([32, 2]) origin: torch.Size([2]) torch.Size([2]) rotation: torch.Size([2, 2]) torch.Size([2, 2]) 网络输入输出结构详解 In Inference with two sample data: displ_cat: 61 x 49 x 3 centers_cat: 61 x 2 agents_per_sample: [32, 29] ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:0","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"encoder_lstm input: displ_cat(61 x 49 x 3), agents_per_sample [32,29] $\\downarrow$ input_size = 3; hidden_size = 128; num_layers = 1 $\\downarrow$lstm_hidden_state = torch.randn(num_layers, lstm_in.shape[0], hidden_size) = torch.randn(1, 61, 128) $\\downarrow$lstm_cell_state = torch.randn(num_layers, lstm_in.shape[0], hidden_size) = torch.randn(1, 61, 128) $\\downarrow$lstm_out, lstm_hidden = self.lstm(lstm_in, lstm_hidden) =\u003e lstm((61, 49, 3), (torch((1, 61, 128)), torch(1, 61, 128))) $\\downarrow$ lstm_out(61 x 49 x 128) output: lstm_out[:,-1,:](61 x 128) ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:1","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"agent_gnn input: out_encoder_lstm(61 x 128), centers_cat (61 x 2) agents_per_sample [32,29] $\\downarrow$ x = gnn_in =\u003e (61 x 128) $\\downarrow$ edge_index = build_fully_connected_edge_idx(agents_per_sample).to(gnn_in.device) =\u003e (2, 1804) 1804 = (29 x 29-1) + (32 x (32-1)) $\\downarrow$ $\\downarrow$ edge_attr = build_edge_attr(edge_index, centers).to(gnn_in.device) =\u003e (1804, 2) $\\downarrow$ x = F.relu(self.gcn1(x, edge_index, edge_attr)) =\u003e (61 x 128) output: gnn_out = F.relu(self.gcn2(x, edge_index, edge_attr)) =\u003e (61 x 128) $$\\mathbf{x}^{\\prime}i = \\mathbf{x}i + \\sum{j \\in \\mathcal{N}(i)} \\sigma \\left( \\mathbf{z}{i,j} \\mathbf{W}_f + \\mathbf{b}f \\right) \\odot g \\left( \\mathbf{z}{i,j} \\mathbf{W}_s + \\mathbf{b}_s \\right)$$ ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:2","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"multihead_self_attention input: out_agent_gnn (61 x 128) agents_per_sample[32,29] $\\downarrow$ max_agents = max(agents_per_sample) =\u003e 32 $\\downarrow$ padded_att_in = torch.zeros((len(agents_per_sample), max_agents, self.latent_size), device=att_in[0].device) =\u003e torch: (2 x 32 x 128) $\\downarrow$ mask = torch.arange(max_agents) \u003c torch.tensor(agents_per_sample)[:, None] \u0026\u0026 padded_att_in[mask] = att_in =\u003e torch: (2 x 32 x 128) $\\downarrow$ padded_att_in_swapped = torch.swapaxes(padded_att_in, 0, 1) =\u003e torch: (32, 2, 128) $\\downarrow$ padded_att_in_swapped, _ = self.multihead_attention(padded_att_in_swapped, padded_att_in_swapped, padded_att_in_swapped, key_padding_mask=mask_inverted) =\u003e torch: (32, 2, 128) $\\downarrow$ padded_att_in_reswapped = torch.swapaxes(padded_att_in_swapped, 0, 1) =\u003e torch: (2, 32, 128) $\\downarrow$ att_out_batch = [x[0:agents_per_sample[i]] for i, x in enumerate(padded_att_in_reswapped)] =\u003e list: 2 output: att_out_batch =\u003e list: 2 for each with shape (29, 128) and (32, 128) ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:3","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"torch.stack() input: out_self_attention: list: 2 for each with shape (29, 128) and (32, 128) $\\downarrow$ out_self_attention = torch.stack([x[0] for x in out_self_attention]) output: out_self_attention: torch: (2, 128) ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:4","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"PredictionNet(out_self_attention) ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:5","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"decoder_residual input: out_self_attention(torch: (2, 128)) frozen = False $\\downarrow$ [condition: frozen = False] sample_wise_out.append(PredictionNet(out_self_attention)) =\u003e torch: (2, 120) $\\downarrow$ decoder_out = torch.stack(sample_wise_out) =\u003e torch: (1, 2, 120) $\\downarrow$ decoder_out = torch.swapaxes(decoder_out, 0, 1) =\u003e torch: (2, 1, 120) output: decoder_out =\u003e torch: (2, 1, 120) ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:6","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"out = out_linear.view(len(displ), 1, -1, self.config[’num_preds’], 2) input: decoder_out: torch: (2, 1, 120) $\\downarrow$ out = out_linear.view(len(displ), 1, -1, self.config[’num_preds’], 2) =\u003e torch: (2, 1, 1, 60, 2) output: out =\u003e torch: (2, 1, 1, 60, 2) ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:7","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"将预测轨迹转换到全局坐标 for i in range(len(out)): out[i] = torch.matmul(out[i], rotation[i]) + origin[i].view( 1, 1, 1, -1 ) ","date":"2023-07-16","objectID":"/posts/crat_pred/:5:8","tags":["draft"],"title":"CRAT-Prediction","uri":"/posts/crat_pred/"},{"categories":["Prediction"],"content":"TNT: Target-driveN Trajectory Prediction **ref link:** https://zhuanlan.zhihu.com/p/435953928 https://blog.csdn.net/weixin_40633696/article/details/124542807?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-2-124542807-blog-122758833.pc_relevant_vip_default\u0026spm=1001.2101.3001.4242.2\u0026utm_relevant_index=5 ","date":"2023-07-16","objectID":"/posts/densetnt_tnt/:1:0","tags":["draft"],"title":"DenseTNT and TNT 论文解读","uri":"/posts/densetnt_tnt/"},{"categories":["Prediction"],"content":"概览 在预测车辆的轨迹时, 需要尽可能考虑到车辆不同的情况，即不同的模态，如前行或左转，并预测出对应的概率。 模态的定义是比较模糊的，例如，有不同的速度前行，左转可以以不同的转弯角度实现。为了能够更加通用且精确地定义每条轨迹的模态，我们直接将每条轨迹的模态定义在每条轨迹的终点上。这里的一个重要假设是，轨迹的模态基本由终点所决定，当终点确定后，轨迹的形状也大体确定了。这样我们就把轨迹预测变成了终点预测问题，极大地简化了问题的复杂度。 TNT的预测方式: 首先预测轨迹的终点，然后基于这个终点补充完整条轨迹。 TNT 基于终点的轨迹预测流程图: TNT使用VectorNet对高精地图和车辆信息进行编码，得到要预测的车辆的全局特征，以用于接下来的解码，从而完成轨迹预测： (1). 终点预测: 为每个Anchor预测一个偏移，得到终点，这些Anchor从道路的中心线上采样得到; (2). 轨迹补全: 基于上一步预测的终点将整条轨迹补充完整; (3). 轨迹打分和筛选: 根据场景特征，为每条轨迹进行打分，并筛选出最有可能的若干条轨迹。 ","date":"2023-07-16","objectID":"/posts/densetnt_tnt/:1:1","tags":["draft"],"title":"DenseTNT and TNT 论文解读","uri":"/posts/densetnt_tnt/"},{"categories":["Prediction"],"content":"TNT 实现 原理 给定一个单个障碍物的观测状态序列 $S_P = [s_{-T^{’}+1}, s_{-T^{’}+2}, …, s_0]$。我们的目标是预测它的未来状态 $S_F = [s_1, s_2, …, s_T]$ 到某个固定时间步 T。自然地，障碍物与由其它障碍物和场景元素组成的环境交互作为背景: $C_P​=[c_{-T′+1}​,c_{-T′+2}​,…,c_0​]$。为简洁起见，我们记 $X = (s_P, c_P)$，因此我们想捕捉的整体概率分布是 $p(S_F|X)$ 。 实际上， $p(S_F|X)$ 可以是高度多模态的。例如，车辆驶近十字路口时可能左转、直行或改变车道。直观上，未来状态的不确定性可以被分解为两部分：目标或者意图的不确定性，比如左右转的决定；以及控制的不确定性，比如转弯时需要的细粒度运动。因此，我们可以通过对目标设定条件，然后将其边缘化，从而对概率分布进行分解： $$p(S_F​∣X)=∫_{τ∈τ(C_P​)}​p(τ∣X)p(S_F​∣τ,X)d_τ​, \\tag{1}$$ 其中 $\\tau(C_P)$ 表示取决于观察到的背景 $C_P$ ​的合理目标空间。 在这个公式下，我们的主要见解是，对于轨迹预测等应用，通过正确设计目标空间 $\\tau τ ( C_P )$（如目标位置），目标分布 $ p(\\tau|X)$ 可以很好地捕捉意图不确定性。一旦目标确定，我们会进一步证明控制不确定性（如轨迹）可以通过简单的单模态分布可靠地建模。我们用一组离散位置来模拟目标空间 $\\tau{C_P}$，将 $p(\\tau|X)$ 的估计主要转化为一个分类任务。与隐变分模型相比，我们的模型以明确的目标分布的形式提供了更好的可解释性，并且在设计目标空间 $\\tau{C_P}$ 时可以自然地结合专家知识（如道路拓扑）。 我们的整体框架有三个概念阶段。第一阶段是障碍物意图预测，其目标是用基于观察背景 $X$ 的目标空间 $\\tau$ 的离散集合对意图不确定性进行建模，并且输出目标分布 $p(\\tau|X)$ 。第二个阶段是障碍物条件运动估计，它用单模态分布对从初始状态到目标可能的未来运动进行建模。前两个阶段产生了以下概率预测 $p(S_F|X) = \\sum_{\\tau\\in\\tau(C_P)}p(\\tau|X)p(S_F|\\tau, X)$。 许多下游应用，例如实时行为预测，需要一小组具有代表性的未来预测，而不是所有可能未来的完整分布。我们的最终阶段，评分和选择，就是为此目的量身定制的。我们从所有代表性预测上学习一个评分函数 $\\phi(S_F)$，并选择一个最终的多样化预测集。 场景编码VectorNet 建模场景背景是轨迹预测的第一步，以获取车辆-道路和车辆-车辆之间的交互。TNT可以使用任何合适的背景编码器：当高清地图可用时，我们使用最优秀的层次图神经网络 VectorNet 对背景进行编码。具体来说，使用多段线来抽象出高清地图元素 $C_P$(车道，交通标志) 和代理轨迹 $S_P$​；采用子图（subgraph）网络对多段线进行编码，多段线包含可变数量的向量；然后使用全局图（global graph）对多段线之间的交互进行建模。输出是每个建模代理的全局背景特征 $X$。如果场景背景只在自上而下的图像形式中可用，则使用卷积网络作为背景编码器。 目标预测 在我们的公式中，目标 $\\tau$ 被定义为一个预测目标可能在固定时间范围 $T$ 上的位置 $(x,y)$ 。在第一步目标预测阶段，我们的目的是提供一个预测目标的未来目标的分布 $p( \\tau ∣ X )$ 。我们通过一组$N$个离散的、带有连续偏移的量化位置来建模潜在的未来目标： $\\tau ={\\tau^n}={(x^n,y^n)+(\\Delta x^n,\\Delta y^n)}^N_{n=1}$​。然后这个目标上分布可以通过一个离散-连续分解来建模： $$p(τ^n∣X)=π(τ^n∣X)⋅N(Δx^n∣v^x_n​(X))⋅N(Δ_y^n∣v_y^n​(X)),\\tag{2}$$ 中 $\\pi(\\tau^n|X)=\\frac{e^{f(\\tau^n,X)}}{\\sum_{\\tau^{’}}e^{f(\\tau^{’},X)}}$ 是在位置选择 $(x^n,y^n)$上的离散分布。术语 $N(·|v(·))$ 表示一个广义正态分布，其中我们选择Huber作为距离函数。我们将均值表示为 $v(·)$并假设单位方差。 可训练函数 $f(·)$ 和 $v(·)$ 由一个2层的多层感知机(MLP)实现，目标坐标 $(x^k,y^k)$ 和场景背景特征 $X$ 作为输入。它们预测目标位置上的离散分布及其最可能的偏移量。这一阶段的训练损失函数由以下公式给出： $$L_{S1}​=L_{cls​}(π,u)+L_{offset}​(v_x​,v_y​,Δx^u,Δy^u),\\tag{3}$$ 其中 $L_{cls}$ 是交叉熵损失， $L_{offset}$​ 是 Huber 损失；$u$ 是离真实位置最近的目标，并且 $\\Delta x^u,\\Delta y^u$ 是 $u$ 相对于真值的空间偏移量。 离散目标空间的选择在不同应用中是灵活的，如图3所示。在车辆轨迹预测问题中，我们从高清地图里均匀地采样车道中心线上的点并且将他们作为目标候选点(标记为黄色菱形)，假设车辆从未远离车道线；对于行人，我们在代理周围生成了一个虚拟网格并将网格点作为目标候选点。对每个候选目标，TNT目标预测器生成了一个 $(\\pi,\\Delta x, \\Delta y)$ 的元组；回归后的目标以橙色五角星标记。与直接回归相比，将未来建模成一组离散目标的最显著的优势在于，它不受模态平均的影响，模态平均是阻止多模态预测的主要因素。 基于目标的运动估计 在第二阶段，我们将给定目标轨迹的可能性建模为 $p(S_F|\\tau,X)=\\prod^T_{t=1}p(s_t|\\tau,X)$，同样采用了广义正态分布。这里有两个假设。首先，未来时间步是条件独立的，这使得我们的模型通过避免顺序预测提高了计算效率。其次，我们正在作出有力但合理的假设，即给定目标的轨迹分布是单模态(正态)的。对于短的时间范围来说，这当然是正确的；对于更长的时间范围，可以在(中间)目标预测和运动估计之间迭代，以便假设仍然成立。 这一阶段使用2层的MLP实现。它将背景特征 X 和目标位置 $\\tau$ 作为输入，并且每个目标输出一条最可能的轨迹 $[\\hat{s_1},…,\\hat{s_T}] [s1​^​,…,sT​^​]$。由于它以第一阶段的预测目标为条件，为了实现平滑的学习过程，我们在训练时采用teacher forcing Technique[36]，将真实位置 $(x^n,y^n)$ 作为目标。该阶段的损失项是预测状态 $\\hat{s_t}$​ 和真值 $s_t$​ 之间的距离： $$L_{S2}​ = \\sum_{t=1}^{T}​L_{reg}​(\\hat{s},s_t​),\\tag{4}$$ 其中， $L_{reg}$​ 作为每一步坐标偏移的 Huber 损失来实现。 轨迹评分和选择 我们的最终阶段估计未来完整轨迹 S F S_F SF​ 的可能性。这和第二阶段不同，第二阶段分解时间步和目标，也和第一阶段不同，第一阶段只知道目标，但没有完整的轨迹——例如，一个目标可能被估计有很高的可能性，但到达该目标完整轨迹的可能性可能不是。 我们使用最大熵模型对第二阶段的所有 M 条轨迹进行评分: $$\\phi (S_F | X) = \\frac{e^{g(S_F, X)}}{{\\sum}_{m=1}^{M} e^{g(S_F^m, X)}}​$$, 其中 $g(·)$ 被建模为一个2层的 MLP。这一阶段训练的损失项是预测分数和真值分数之间的交叉熵， $$L_{S3} = L_{CE}(\\phi (S_F | X), \\psi(S_F))$$ 其中每个预测轨迹的真值评分由预测轨迹到真值轨迹的距离 $\\psi(S_F)=\\frac{exp(-D(S,S_{GT})/\\alpha)}{\\sum_{s^{’}}exp(-D(S^{’},S_{GT})/\\alpha)}$ 定义，其中 $D(·)$ 单位为米， $\\alpha$ 是温度。距离度量定义为 $D(S^i,S^j)=max(||s^i_1-s^j_1||^2_2,…,||s^i_t-s^j_t||^2_2)$。 为了从已评分的 $M$ 个轨迹获得最终一小组 $K$ 个预测轨迹，我们实现了一个轨迹选择算法来排除近似重复的轨迹。我们首先根据他们的分数对轨迹进行降序排列，并且贪婪地选择轨迹； 如果一个轨迹距离所有的选择轨迹都足够远，我们也会选择它，否则排除它。这里使用的距离度量和评分过程相同。这个过程的灵感来源于通常应用于计算机视觉问题（如目标检测）的非极大值抑制算法。 训练和推理细节 上述的 TNT 公式产生全监督的端到端训练，具有损失函数 $$L = \\lambda_1 L_{S1} + \\lambda_2 L_{S2} + \\lambda_3 L_{S3}$$ 其中，选择 $\\lambda_1,\\lambda_2,\\lambda_3$ 来平衡训练过程。 在推理时，TNT 的工作原理如下： (1) 工作场景编码； (2) 采样 N 个候选目标作为目标预测器的输入，取由 $\\pi(\\tau|X)$ 估计的前 M 个目标； (3) 从运动估计模型 $p(S_F|\\tau,X)$ 中获取 M 个目标","date":"2023-07-16","objectID":"/posts/densetnt_tnt/:1:2","tags":["draft"],"title":"DenseTNT and TNT 论文解读","uri":"/posts/densetnt_tnt/"},{"categories":["Prediction"],"content":"DenseTNT: ref link: https://blog.csdn.net/weixin_39397852/article/details/122764880 ","date":"2023-07-16","objectID":"/posts/densetnt_tnt/:2:0","tags":["draft"],"title":"DenseTNT and TNT 论文解读","uri":"/posts/densetnt_tnt/"},{"categories":["Prediction"],"content":"Comparison between DenseTNT and TNT TNT(左图)是根据lane定义一些anchor，再regress和classify获得最终的位置，之后还要通过NMS的筛选法选出最后的轨迹。 DenseTNT(右图)是通过密集地采点避免了定义anchor，同时也避免了使用NMS等规则来筛选轨迹。 意图预测中非常重要的一个问题是ground truth只有一个，而对于多意图的预测来说，多个方向的预测都是允许的，这导致了label中有很多都是无效的，因为gt只包含了一个意图下的结果。此处设计了一个offline的model来提供多个意图下的label。这个model使用了一个优化算法从goal的分布里取出了一个set作为online model的label。 ","date":"2023-07-16","objectID":"/posts/densetnt_tnt/:2:1","tags":["draft"],"title":"DenseTNT and TNT 论文解读","uri":"/posts/densetnt_tnt/"},{"categories":["Prediction"],"content":"Method 具体实现方法 sparse context encoding – VectorNet 本文使用VectorNet来提取地图的feature。(没有的高精地图的话也可使用CNN) Dense goal probability estimation TNT对于一个goal只预测一条轨迹的概率是有问题的：一个goal只有一条预测(可能通向这个goal的别的预测概率很高)，一个goal获取的feature不够丰富(goal附近的点的信息也用上会更好)。 我们使用了dense goal encoder。它以一定的采样频率获取了地图上在道路上的所有点。然后预测了这些密集点的概率分布。 Lane Scoring 在论文实现中，可以用point scoring代替，效果更好。目的在与选出距离final pos(gt)更近的点。 为了减少需要sample的点，我们先预测goal落在不同lane上的概率，这样能过滤掉明显不在candidate lane附近的点，提升运算速度。 这是一个二分类问题。因此使用了二分类的交叉熵计算loss。对于label，使用离gt的goal最近的lane作为1，别的lane为0。对于别的lane $l$，假设gt的goal是$y_{gt}$​，定义一个distance $$d(l,y_{gt}) = min(||l_1 - y_{gt}||^2, ||l_2 - y_{gt}||^2, …, ||l_t - y_{gt}||^2,)$$ 直觉上就是gt的goal到这条lane的最短距离的平方。 Probability Estimation 获得概率分布的做法是self-attention。首先agent的feature经过两次MLP。然后把goal的feature $F$作为需要query的变量，从地图上所有元素 (lane，agent)的feature中去查找索引对应的键和值。目的就是建立goal的feature与地图上所有元素的联系。直观上，这一步是把agent的未来状态(goal)表示成由历史的信息作为变量的函数，这个函数采用的是self-attention的做法。 轨迹目标点(goals)和道路的局部信息可以用以下注意力机制表示: $$\\mathbf{Q} = \\mathbf{FW}^{\\mathbf{Q}}, \\mathbf{K} = \\mathbf{LW}^{\\mathbf{K}}, \\mathbf{V}=\\mathbf{LW}^{\\mathbf{V}}$$ $$\\mathbf{A}(\\mathbf{Q},\\mathbf{K},\\mathbf{V}) = softmax(\\frac{\\mathbf{QK^\\top}}{\\sqrt{d_k}})\\mathbf{V}$$ where $\\mathbf{W}^Q, \\mathbf{W}^{K}, \\mathbf{W}^{V} \\in \\mathbb{R}^{d_h \\times d_k}$ are the matrices for linear projection, $d_k$ is the dimension of query / key / value vectors, and $\\mathbf{F}, \\mathbf{F}$ are feature matrices of the dense goal candidates and all map elements (i.e., lanes or agents), respectively. 这一步之后的结果是goal新的feature $\\mathbf{F}$。再通过两次MLP，即下图中的 $g(.)$.用softmax中的方法获得每个goal的概率。将所有goal在地图上表示出来的话就是一个概率分布heatmap。 $$\\phi_i = \\frac{\\exp(g(\\mathbf{F}i))}{\\sum{n=1}^{N}\\exp(g(\\mathbf{F}_n))}$$ 对于Loss的计算，离gt的goal最近的goal的label定为1，其余都为0.采取二分类交叉熵的算法。 $$\\mathcal{L}\\text{goal} = \\mathcal{L}{\\text{CE}}(\\phi, \\psi)$$ Goal Set Prediction 对于多意图的预测，在TNT中，预先设定好target，采用NMS(non-maximum suppression)(靠的近或概率低的过滤掉)。而DenseTNT的上一步获得是heatmap，因此不能简单使用NMS，因为用于筛选的阈值比较难定。这是因为TNT中采用的是从高到低排序概率，而DenseTNT中的概率分布是针对于整个鸟瞰图的，一旦意图的可能性变多了，平均分布到每一个意图的概率就低了(对于概率分布，所有的点的概率加起来需要为1)。 heatmap，输出是goal set，这个有点像目标检测的框生成。但和目标检测不同，对于一个输入，我们的label只有一个，即gt。这样的话可能会有别的意图的结果在训练中被忽略。为此，设计了一个offline model来制造这些label。它和online model的区别就在这一步中。没有使用goal set predictor而是采用了优化算法。 Offline Optimization 上一步heatmap的输出，实际上是对于地图上众多goal每个点的一个函数。设定 $C={c_1,c_2,…,c_m}$ 为所有dense goal的candidate，heatmap就把 $C$ 映射到一个0到1的集合，写成 $h(c_i)$ ，这也是每个goal的概率。 接下来定义一个目标函数: $$E[d(\\hat{y}, Y)] = \\sum^m_{i=1}h(c_i)d(\\hat{y}, c_i)$$ 其中，$d(\\hat{y}, c_i) = \\mathop{\\min}\\limits_{y_i \\in \\hat{y}}||y_j - y_{c_i}||$ 从直观上讲，目标是有M个goal（大池子），要从中选取K个靠谱的goal（小池子）。 $d$ 是针对于大池子的，对于大池子里所有candidate都有一个 $d$。这每个candidate都与小池子中的goal计算距离，取最近的作为 d d d，即寻找小池子中离candidate最近的点。对于所有的 $d$，用概率加权计算期望。总体的话在收敛情况，大池子中的所有goal到距离自己最近的小池子中的goal乘上概率加权应当达到最小。以下是这个优化算法的实现。 翻译成中文： 初始化K个goal，从M个goal的大池子里随机选 小池子里的每个goal做随机扰动，变为别的goal 计算原来的和现在的小池子的d的期望e和e’ 如果现在的小池子d的期望更小，则使用现在的小池子。否则以1%的概率采用现在的小池子。（避免局部最优） 不停循环2-4直到步数达到阈值（或时间太长） 优化算法之后得到的就是全局最优的选中的小池子。这个小池子里的结果能作为训练online模型的伪label。 Goal Set Predictor (online) 模型采用了encode+decode的办法。encoder部分是一层self-attention加上max pooling，decoder部分是2层MLP，输入是heatmap，输出是2K+1个值，分别对应K个2维坐标（goal set）和一个当前goal set的confidence。 考虑到heatmap的概率分布比较散，可以采用N头同时运算。即N个goal set predictor输出N个2K+1的值，从当中选取confidence最高的那个goal set预测。为了运算效率的提升，这N头使用相同的self-attention层，但是不同的2个MLP。 在训练过程中，采用了offline模型的伪label作为监督。上述offline中讲到的初始选定的小池子，在这里采用的是online模型的K个goal的set的预测。然后经过L次随机扰动（即不停随机选取邻居点，L=100），选取当中expected error（offline里的期望项）最小的那个set作为伪label。 标记 $\\dot{y}$ ​为预测结果， $\\hat{y}$ ​为伪label，则loss的计算如下。即一一对应后的L1距离之和。 $$\\mathcal{L_{set}(\\dot{y}, \\hat{y})} = \\sum_{i=1}^{k}\\mathcal{L}_{\\text{reg}}(\\dot{y}, \\hat{y})$$ 再考虑到采用了N头预测，这部分的loss将采用二分类的交叉熵。其中 $\\mu$ 为所有head的confidence，$\\nu$ 为label，只有expected error最低的label为1，别的为0。 $$\\mathcal{L}\\text{head} = \\mathcal{L}{\\text{CE}}(\\mu, \\nu)$$ Trajectory Completion 这一步和TNT做法类似。类似于dense goal encoding（2层MLP后过self-attention）最后过2层MLP来decode得到整条预测轨迹的state。采用teacher forcing技巧（因为只有一条gt）训练时只用gt的goal来算这条预测轨迹。Loss的算法和TNT一样，用的是点点之间的Huber loss。 $$\\mathcal{L}{\\text{completion}}","date":"2023-07-16","objectID":"/posts/densetnt_tnt/:2:2","tags":["draft"],"title":"DenseTNT and TNT 论文解读","uri":"/posts/densetnt_tnt/"},{"categories":["Prediction"],"content":"paper link: https://arxiv.org/abs/2007.13732 PPT: https://www.cs.toronto.edu/~byang/slides/LaneGCN.pdf ","date":"2023-07-16","objectID":"/posts/lanegcn/:0:0","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"Architechture Lane Graph + Actor Map: construct lane graph from vectorized map data to preserve the map structure and can avoid information loss 构建矢量化地图信息，避免地图信息丢失 LaneGCN: extends graph convolutions with multiple adjacency matrices and along-lane dilation to capture complex topology and long range dependencies of the lane graph. exploit a fusion network consisting of four types of interactions: actor-to-lane, lane-to-actor, actor-to-actor, lane-to-lane. present both actors and lanes as nodes in the graph and use a 1D CNN and LaneGCN to extract the features for the actor and lane nodes respectively, and then exploit spatial attention and another LaneGCN to model four types of interactions. Difference between VectorNet and LaneGCN: VecotrNet uses vanilla graph networks with undirected full connections; LaneGCN uses connected lane graph folllowing the map topology and propose task specific multi-type and dilated graph operators. VectorNet uses polyline-level nodes for interactions; LaneGCN uses polyline segments as map nodes to capture higher resolution. ","date":"2023-07-16","objectID":"/posts/lanegcn/:1:0","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"Lane Graph Representations for Motion Forecasting ","date":"2023-07-16","objectID":"/posts/lanegcn/:2:0","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"ActorNet: Extracting Traffic Participant Representations Each Trajctory is represented as a sequence of displacement ${ \\bigtriangleup{p_{-(T-1)},…,\\bigtriangleup{p_{-1}}, \\bigtriangleup{p_0}}}$, where $\\bigtriangleup{p_t}$ is the 2D displacement from time step $t-1$ to t, and T is the trajectory size. For trajectories with sizes smaller than $T$ , we pad them with zeros. We add a binary $1 × T$ mask to indicate if the element at each step is padded or not and concatenate it with the trajectory tensor, resulting in an input tensor of size $3 × T$. 1D CNN is used to process the trajectory input for its effectiveness in extracting multi-scale features and efficiency in parallel computing. The output of ActorNet is a temporal feature map, whose element at $t = 0$ is used as the actor feature. The network has 3 groups/scales of 1D convolutions. Each group consists of 2 residual blocks, with the stride of the first block as 2. We then use a Feature Pyramid Network (FPN) to fuse the multi-scale features, and apply another residual block to obtain the output tensor. For all layers, the convolution kernel size is 3 and the number of output channels is 128. Layer normalization and the Rectified Linear Unit (ReLU) are used after each convolution. ","date":"2023-07-16","objectID":"/posts/lanegcn/:2:1","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"MapNet: Extracting Structured Map Representation General Architecture: part 1: building a lane graph from vectorized map data; part 2: applying our novel LaneGCN to the lane graph to output the map features. Map Data: In this paper, we adopt a simple form of vectorized map data as our representation of HD maps. Specifically, the map data is represented as a set of lanes and their connectivity. Each lane contains a centerline, i.e., a sequence of 2D BEV points, which are arranged following the lane direction (see Fig. 3, top). For any two lanes which are directly reachable, 4 types of connections are given: predecessor, successor, left neighbour and right neighbour. Lane Graph Construction: first define a lane node as the straight line segment formed by any two consecutive points (grey circles in Fig. 3) of the centerline. The location of a lane node is the averaged coordinates of its two end points. Following the connections between lane centerlines, we also derive 4 connectivity types for the lane nodes, i.e., predecessor, successor, left neighbour and right neighbour. We denote the lane nodes with $V ∈ \\mathbb R^{N ×2}$ , where $N$ is the number of lane nodes and the $i$-th row of $V$ is the BEV coordinates of the $i$-th node. We represent the connectivity with 4 adjacency matrices ${\\lbrace A_i \\rbrace}_{i \\in {pre,suc,left,right}}$ , with $A_i \\in \\mathbb R^{N ×N}$. We denote $A_{i,jk}$, as the element in the $j$-th row and $k$-th column of $A_i$. Then $A_{i,jk} = 1$ if node $k$ is an $i$-type neighbor of node $j$. LaneConv Operator: Node Feature: Each lane node corresponds to a straight line segment of a centerline. To encode all the lane node information, we need to take into account both the shape (size and orientation) and the location (the coordinates of the center) of the corresponding line segment. We parameterize the node feature as follows, $$x_i = MLP_{shape} (v_{i}^{end} - v_{i}^{start}) + MLP_{loc}(v_i) $$ where $MLP$ indicates a multi-layer perceptron and the two subscripts refer to shape and location, respectively. $v_i$ is the location of the i-th lane node, i.e., the center between two end points, $v_i^{start}$ and $v_i^{end}$ are the BEV coordinates of the node $i’s$ starting and ending points, and $x_i$ is the $i$-th row of the node feature matrix $X$, denoting the input feature of the $i$-th lane node. LaneConv: To aggregate the topology information of the lane graph at a larger scale, we design the following LaneConv operator: $$Y = XW_0 + \\sum_{i\\in{pre, suc, left, right}}A_iXW_i,\\tag{2}$$ where $A_i$ and $W_i$ are the adjacency and the weight matrices corresponding to the $i$-th connection type respectively. Since we order the lane nodes from the start to the end of the lane, $A_{suc}$ and $A_{pre}$ are matrices obtained by shifting the identity matrix (diagnal 1) one step towards upper right (non-zero superdiagonal) and lower left (non-zero subdiagonal). $A_{suc}$ and $A_{pre}$ can propagate information from the forward and backward neighbours whereas $A_{left}$ and $A_{right}$ allow information to flow from the cross-lane neighbours. It is not hard to see that our LaneConv builds on top of the general graph convolution and encodes more geometric (e.g., connection type/direction) information. As shown in our experiments this improves over the vanilla graph convolution. Dilated LaneConv: Functionality: The model needs to capture the long range dependency along the lane direction for accurate prediction. the k-dilation LaneConv operator is defined as follows: $$Y = XW_0 + A_{pre}^k XW_{pre,k} + A_{suc}^k X W_{suc,k} \\tag{3}$$ where $A_{pre}^k$ is the $k$-th matrix power of $A_{pre}$. This allows us to directly propagate information along the lane for $k$ steps, with $k$ a hyperparameter. Since $A_{pre}^k$ is highly sparse, one can efficiently compute it using sparse matrix multiplication. Note that the dilated LaneConv is only used for predecessor and successor, as the long range dependency is mostly a","date":"2023-07-16","objectID":"/posts/lanegcn/:2:2","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"Fusion Net Four types fusion modules: A2L: introduces real-time traffic information to lane nodes, such as blockage or usage of the lanes. L2L: updates lane node features by propagating the traffic information over the lane graph. -\u003e LaneGCN L2A: fuses updated map features with real-time traffic information back to the actors. A2A: handles the interactions between actors and produces the output actor features, which are then used by the prediction header for motion forecasting. We implement L2L using another LaneGCN, which has the same architecture as the one used in our MapNet (see Section 3.2). In the following we describe the other three modules in detail. We exploit a spatial attention layer for A2L, L2A and A2A. The attention layer applies to each of the three modules in the same way. Taking A2L as an example, given an actor node i, we aggregate the features from its context lane nodes j as follows: $$y_i = x_i W_0 + \\sum_j \\phi (concat(x_i, \\Delta_{i,j}, x_j)W_1)W_2, \\tag{5}$$ with $x_i$ the feature of the $i$-th node, $W$ a weight matrix, $\\phi$ the compositon of layer notmalization and RelU, and $\\Delta_{ij} = MLP(v_j - v_i)$, where $v$ denotes the node location. ","date":"2023-07-16","objectID":"/posts/lanegcn/:2:3","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"Prediction Header Take after-fusion actor features as input, a multi-modal prediction header outputs the final motion forecasting. For each actor, it predicts $K$ possible future trajectories and their confidence scores. The header has two branches, a regression branch to predict the trajectory of each mode and a classification branch to predict the confidence score of each mode. For the m-th actor, we apply a residual block and a linear layer in the regression branch to regress the K sequences of BEV coordinates: $$O_{m,reg} = \\lbrace (p_{m,1}^k, p_{m,2}^k, …, p_{m,T}^k) \\rbrace _{k\\in[0,K-1]}$$ where $p_{m,i}^k$ is the predicted $m$-th actor’s BEV coordinates of the $k$-th mode at the $i$-th time step. For the classification branch, we apply an MLP to $p^k_{m,T} − p_{m,0}$ to get $K$ distance embeddings. We then concatenate each distance embedding with the actor feature, apply a residual block and a linear layer to output $K$ confidence scores, $O_{m,cls} = (c_{m,0}, c_{m,1}, …, c_{m,K−1})$. ","date":"2023-07-16","objectID":"/posts/lanegcn/:2:4","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"Learning use the sum of classification and regreesion losses to train the model: $$ L = L_{cls} + \\alpha L_{reg},$$ where $\\alpha = 1.0$. For classification, we use the max-margin loss: $$L_{cls} = \\frac{1}{M(K-1)}\\sum_{m=1}^M \\sum_{k \\neq \\hat{k}} \\max(0, c_{m,k} + \\epsilon - c_{m, \\hat{k}}) \\tag{6}$$ where $\\epsilon$ is the margin and $M$ is the total number of actors. For regression, we apply the smooth $l1$ loss on all predicted time steps: $$L_{reg} = \\frac{1}{MT} \\sum_{m=1}^M \\sum_{t=1}^T reg(p_{m,y}^{\\hat{k}} - p_{m,t}^*) \\tag{7}$$ where $p_t^*$ is the ground truth BEV coordinates at time step $t$, $reg(x) = \\sum\\limits_i d(x_i)$, $x_i$ is the $i$-th element of $x$, and $d(x_i)$ is the smooth $\\ell1$ loss defined as: $$d(x_i) = \\begin{cases} 0.5x_i^2 \u0026\\text{if} ||x|| \u003c 1, \\ ||x_i|| - 0.5 \u0026 \\text{otherwise,} \\end{cases} \\tag{8}$$ where $||x_i||$ denotes the $\\ell1$ norm of $x_i$. ","date":"2023-07-16","objectID":"/posts/lanegcn/:2:5","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":" Neural Network Layout ","date":"2023-07-16","objectID":"/posts/lanegcn/:2:6","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["Prediction"],"content":"Data Process And Network Construction 以官方的2645.csv数据集为例子 agent node: data['city']:城市名称 data['trajs'] = [agt_traj] + ctx_trajs:轨迹点，(agent + context vehicles) data['steps'] = [agt_step] + ctx_steps:在原始数据中的位置 data['feats'] = feats: (13 X 20 X 3) 前20预测轨迹 + 一维是否存在点 data['ctrs'] = ctrs: (13 X 2) 中心点 data['orig'] = orig: AGENT 当前点坐标 data['theta'] = theta: AGENT 偏转角 data['rot'] = rot: (2 X 2) 旋转矩阵 data['gt_preds'] = gt_preds:(13 X 30 X 2) 后30帧真实轨迹 data['has_preds'] = has_preds: (13 X 30) 标识后30帧轨迹是否存在 lane node: graph['ctrs'] = np.concatenate(ctrs, 0): lane node的中心点坐标 graph['num_nodes'] = num_nodes: lane node的数量 graph['feats'] = np.concatenate(feats, 0): lane node 方向向量 graph['turn'] = np.concatenate(turn, 0): lane node 转向标识 graph['control'] = np.concatenate(control, 0): lane node 的 has_traffic_control 标识 graph['intersect'] = np.concatenate(intersect, 0): lane node 的 is_intersection 标识 graph['pre'] = [pre]: pre[‘u’] 和 pre[‘v’], v 是 u 的pre， 这里表述的是lane node之间的关系 graph['suc'] = [suc]: suc[‘u’] 和 suc[‘v’], v 是 u 的suc， 这里表述的是lane node之间的关系 graph['lane_idcs'] = lane_idcs: lane node index 0 0 0 ... 0 1 1 1 ... 1 ... 83 83 83 ... 83 graph['pre_pairs'] = pre_pairs: pair 表述的是lane之间的关系 graph['suc_pairs'] = suc_pairs: pair 表述的是lane之间的关系 graph['left_pairs'] = left_pairs: pair 表述的是lane之间的关系 graph['right_pairs'] = right_pairs: pair 表述的是lane之间的关系 对于pre['u']和pre['v'], v 是 u 的 pre 对于suc['u']和suc['v'], v 是 u 的 suc 对于left['u']和left['v'], v 是 u 的 left 对于right['u']和right['v'], v 是 u 的 right Net结构 ActorNet input: M x 3 x 20 output: M x 128 x 20 解释: MapNet: 把 v 按照 u 加到center上 input: N x 4 output: N x 128 A2M input: N x 128 output: N x 128 M2M input: N x 128 output: N x 128 M2A input: N x 128 output: M x 128 A2A input: N x 128 output: N x 128 Prediction Header: input M x 128 MLP Regression MLP Classification ref link: https://zhuanlan.zhihu.com/p/447129428 ","date":"2023-07-16","objectID":"/posts/lanegcn/:2:7","tags":["draft"],"title":"LaneGCN 论文解读","uri":"/posts/lanegcn/"},{"categories":["draft"],"content":"paper link: https://arxiv.org/abs/2012.11717 论文解读参考: [1] https://zhuanlan.zhihu.com/p/434650863 [2] https://www.gushiciku.cn/pl/amod ","date":"2023-07-16","objectID":"/posts/social_nce/:0:0","tags":["draft"],"title":"Social_NCE 论文解读","uri":"/posts/social_nce/"},{"categories":["draft"],"content":"Issue to solve and its Solution Due to the ill-distributed training Data, it’s difficult to capture the notion of the “negative” examples like collision. Solution: Modeling the negative samples through self-supervision: a social contrastive loss: regularizes the extracted motion representation by discerning the ground-truth positive events from synthetic negative ones; Construct negative samples based on prior knowledge of rare but dangerous circumstances. a social sampling strategy (informed): construct the positive event from the ground-truth location of the primary agent and the negative events from the regions of other neighbors. given that one location cannot be occupied by multiple agents at the same time. ","date":"2023-07-16","objectID":"/posts/social_nce/:1:0","tags":["draft"],"title":"Social_NCE 论文解读","uri":"/posts/social_nce/"},{"categories":["draft"],"content":"Method: Contrastive Learning + Social NCE ","date":"2023-07-16","objectID":"/posts/social_nce/:2:0","tags":["draft"],"title":"Social_NCE 论文解读","uri":"/posts/social_nce/"},{"categories":["draft"],"content":"Contrastive Representation Learning Functionality: Representation Learning: to learn a parametric function that maps the raw data into a feature space to extract abstract and useful information for downstream tasks. NCE(Noise Contrastive Estimation): to train encoder $$\\mathcal{L_{NCE}} = -\\log \\frac{\\exp(sim(q,k^+)/\\tau)}{\\sum_{n=0}^N \\exp(sim(q,k_n)/ \\tau)}$$ where the encoded query $q$ is brought close to one positive key $k_0 = k^+$ and pushed apart from $N$ negative keys ${ k_1, k_2, … , k_N}$, $\\tau$ is a temperature hyperparameter, and $sim(u,v) = u^{\\mathsf{T}}v/(||u||||v||)$ is the cosine similarity between two feature vectors. ","date":"2023-07-16","objectID":"/posts/social_nce/:2:1","tags":["draft"],"title":"Social_NCE 论文解读","uri":"/posts/social_nce/"},{"categories":["draft"],"content":"Social NCE Social NCE Description: 智能体 $i$ 在时刻 $t$ 上的位置记为 $s^i_t=(x^i_t,y^i_t)$ 。那么 $M$ 个智能体的联合状态记为 $s_t = { s_t^1, …, s^M_t}$ 。给定一个历史观测序列 ${s_1, s_2, …, s_t}$ ，任务是预测所有智能体未来直至 $T$ 时刻的轨迹 ${s_{t+1}, …, s_T}$，许多最近的预测模型被设计为编码器 - 解码器神经网络，其中运动编码器 $f(\\cdot)$ 首先提取与 $i$ 相关的紧密表示 $h_t^i$ ，然后解码器 $g(\\cdot)$ 随后推测出其未来的轨迹 $\\hat{s}^i_{t+1,T}$ : $$h^i_t = f(s_{1:t}, i), $$ $$\\hat{s}^i_{t+1:T} = g(h^i_t)$$ 为了多智能体之间的社交互动，$f(\\cdot)$通常包含两个子模块：一个序列建模模块 $f_S(\\cdot)$ 用于编码每个单独的序列，以及一个交互模块 $f_I(\\cdot)$ 用于在多智能体之间共享信息： $$z^i_t = f_S(h^i_{t-1}, s^i_t),$$ $$h^i_t = f_I(z_t, i)$$ 其中， $z^i_t$ 是给定智能体 $i$ 在时间 $t$ 观察其自身状态的潜在表示， $z_t = {z^1_t,…,z^M_t}$ 。很多方法已经探索了各种架构，并验证了其准确性。尽管如此，它们的鲁棒性仍然是一个悬而未决的问题。 最近的几项工作表明，现有模型预测的轨迹通常会输出社会不可接受的解决方案（例如，碰撞），表明缺乏关于社会准则的常识。 query: embedding of history observations $q = \\psi(h^i_t)$, where $\\psi(\\cdot)$ is an MLP projection head; key: embedding of a future event $k = \\phi(s^i_{s+\\delta t}, \\delta t)$, where $\\phi(\\cdot)$ is an event encoder modeled by an MLP, $s_{t+\\delta t}^i$ is a sampled spatial location and $\\delta_t \u003e 0$ is the sampling horizon. tuning $\\delta_t \\in \\Lambda$, e.g. $\\Lambda = {1,…,4}$, then future events in the next few step can be taken in account simultaneously. Nevertheless, when $\\delta_t$ is a fixed value, then $\\phi(\\cdot)$ can be simplified as a location encoder, i.e., $\\phi(s^i_{t+\\delta t})$. 给定一个场景，包括感兴趣的主智体（蓝色）和附近多个相邻智体（灰色），Social-NCE 损失鼓励在嵌入空间中提取的运动表示，接近未来的正样本事件，并远离可能导致碰撞或不适的合成负样本事件. Social NCE的损失函数如下: $$\\mathcal{L_{SocialNCE}} = -\\log\\frac{\\exp(\\psi(h^i_t)\\cdot\\phi(s^{i,+}{t+\\delta t}, \\delta t)/\\tau)}{\\sum{\\delta t\\in\\Lambda}\\sum_{n=0}^{N}\\exp(\\psi(h^i_t)\\cdot\\phi(s^{i,n}_{t+\\delta t}, \\delta t)/\\tau))}$$ 最终的训练损失函数为Social-NCE和传统任务损失项之和，即轨迹预测的mean squared error (MSE) 或者negative log-likelihood (NLL)： $$\\mathcal{L}(f,g,\\psi, \\phi) = \\mathcal{L}{task}(f,g) + \\lambda \\mathcal{L}{SocialNCE}(f, \\psi, \\phi)$$ 其中，$\\lambda$ 为超参数，控制SocialNCE损失函数的重要程度。 ","date":"2023-07-16","objectID":"/posts/social_nce/:2:2","tags":["draft"],"title":"Social_NCE 论文解读","uri":"/posts/social_nce/"},{"categories":["draft"],"content":"sampling strategy in multi-agent context 采样策略 在其他智能体附近寻求更多信息的负样本: $$s^{i,n-}{t+\\delta t} = s^{j}{t+\\delta t} + \\bigtriangleup{s_p} + \\epsilon$$ 其中， $j\\in{1,2,…,M} \\backslash i$ 是其他agent的index, $\\bigtriangleup{s_p}$ 是适合社交距离的局部位移。 对于positive sample, 对该agent周围直接采样获得: $$s^{i,n-}{t+\\delta t} = s^{i}{t+\\delta t} + \\epsilon$$ ","date":"2023-07-16","objectID":"/posts/social_nce/:2:3","tags":["draft"],"title":"Social_NCE 论文解读","uri":"/posts/social_nce/"},{"categories":["Prediction"],"content":"paper link: https://arxiv.org/abs/2002.11927?from=leiphonecolumn_paperreview0323 ","date":"2023-07-16","objectID":"/posts/social_stgcnn/:0:0","tags":["draft"],"title":"Social_STGCNN 论文解读","uri":"/posts/social_stgcnn/"},{"categories":["Prediction"],"content":"网络结构 特点: Social STGCNN不同于其他方法只是聚合各种学习的行人状态，而是对行人交互做图建模。其中提出一种kernel function把行人社交交互嵌入一个adjacency matrix。 代码显示，图建模一般在数据前处理完成。 ","date":"2023-07-16","objectID":"/posts/social_stgcnn/:1:0","tags":["draft"],"title":"Social_STGCNN 论文解读","uri":"/posts/social_stgcnn/"},{"categories":["Prediction"],"content":"Model Description 两部分：时空图卷积神经网络ST-GCNN、时间外推器TXP-CNN。 ST-GCNN对行人轨迹的图表示进行时空卷积操作以提取特征。这些特征是观察到的行人轨迹历史的紧凑表示。 TXP-CNN将这些特征作为输入，并预测所有行人作为一个整体的未来轨迹。我们使用时间外推器的名字是因为TXP-CNN期望通过卷积运算外推未来的轨迹。 给定T帧，构造表示 $G=(V,A)$ 的时空图. 然后，$G$ 通过时空图卷积神经网络(ST-GCNNs)转发，创建一个时空嵌入。 之后，TXP-CNNs 预测了未来的轨迹。 $P$ 是行人位置的维数，$N$ 是行人的数目，$T$ 是时间步长, $\\hat{P}$是来自ST-GCNN的嵌入的维数. (1) Graph Representation of Pedestrian Trajectories 我们首先构造一组空间图 $G_t$，表示每个时间步长 $t$ 在场景中行人的相对位置，$G_t = (V_t, E_t)$ 。 $V_t$是图 $G_t$ 的顶点集，观察到的位置 $(x^i_t，y^i_t)$ 是顶点 $v^i_t$ 的属性; $E_t$ 是边集，如果顶点 $v^i_t$ 和顶点 $v^j_t$ 相连 $e^{ij}_t = 1$ ，否则 $=0$。 为了建模两个节点之间相互影响的强度，我们附加了一个值$a^{ij}_t$, 它是由每个$ e^{ij}_t$ 的某种核函数计算得到。$a^{ij}_t$ 被组织为带权邻接矩阵$A_t$。 $a^{ij}_{sim,t}$是要在邻接矩阵$A_t$中使用的内核函数。 定义为: $$\\begin{equation} a^{ij}_{sim,t}= \\left { \\begin{aligned} 1/||v^i_t - v^j_t||_2 , ||v^i_t - v^j_t||_1\\neq0 \\ 0, Otherwise \\end{aligned} \\right. \\end{equation}$$ (2) Graph Convolution Neural Network 对于在二维网格地图或特征地图上定义的卷积运算，定义如下: $$z^{(l+1)} = \\sigma(\\sum_{h=1}^{k}\\sum_{\\omega=1}^{k}(p(z^{(l)},h, \\omega) \\cdot \\boldsymbol{W}^{(l)}(h, \\omega))$$ 其中，$k$是内核大小，$p(.)$ 是采样函数，其聚集以$z$为中心的邻居的信息， $\\sigma$ 是激活函数。${l}$表示神经网络层。 图卷积定义如下: $$v^{i(l+1)} =\\sigma (\\frac{1}{\\Omega}\\sum_{v^{j(l)}\\in B(v^{j(l)})}p(v^{i(l)}, v^{j(l)}) \\cdot \\boldsymbol{W}(v^{i(l)}, v^{j(l)}))$$ 其中$\\frac{1}{\\Omega}$ 是正则化项，$B(v^i) = { v^j|d(v^i,v^j)≤D }$是顶点的邻居集，而$d(v^i,v^j)$表示连接$v^i$和$v^j$的最短距离， $\\Omega$是邻居集的基数。 (3) Spatio-Temporal Graph Convolution Neural Network(ST-GCNNs) 通过定义一个新的图G，其属性是$G_t$属性的集合，ST-GCNN将空间图卷积扩展到时空图卷积。 $G$结合了行人轨迹的时空信息。值得注意的是，$G_1，…，G_T$的拓扑结构是相同的，而当t变化时，不同的属性被分配给$v^i_t$。 因此，我们将$G$定义为$(V,E)$，其中$V={v_i|i\\in { 1，…，N }}$ 和 $E={e_{ij}|i，j，{1，…，N}}$。 顶点$v_i$在G中的属性是$v^i_t$的集合，$∀t∈{0，…，T}$。 另外， 加权邻接矩阵A对应于$G$ 是${ A_1，…，A_T}$的集合。 我们将ST-GCNN产生的嵌入表示为 $\\overline{V}$. (4) Time-Extrapolator Convolution Neural Network (TXP-CNN) ST-GCNN的功能是从输入图中提取时空节点嵌入。然而，我们的目标是预测行人未来的进一步位置。 TXP-CNN直接作用于图嵌入 $\\overline{V}$ 的时间维度，并将其扩展为预测的必要条件。 由于TXP-CNN依赖于特征空间的卷积运算，因此与递归单元相比，它的参数较小。需要注意的一个特性是， TXP-CNN层不是置换不变的，因为在TXP-CNN之前，图嵌入的变化会导致不同的结果。Other than this, if the order of pedestrians is permutated starting from the input to Social-STGCNN then the predictions are invariant. ","date":"2023-07-16","objectID":"/posts/social_stgcnn/:1:1","tags":["draft"],"title":"Social_STGCNN 论文解读","uri":"/posts/social_stgcnn/"},{"categories":["Prediction"],"content":"model(Social STGCNN) Implementation Adjacency Matrix Normalization $$ A_t = \\Lambda_t^{-\\frac{1}{2}}\\hat{A}\\Lambda_t^{-\\frac{1}{2}}$$ where $\\hat{A_t} = A_t + I$ and $\\Lambda_t$ is the diagonal node degree matric of $\\hat{A_t}$. We use $\\hat{A}$ and $\\Lambda$ to denote the stack of $\\hat{A_t}$ and $\\Lambda_t$ repectively. The normalization of adjacency is essential for the graph CNN to work properly. STGCNN Network Mechanism $$f(V^{l}, A) = \\sigma(\\Lambda_t^{-\\frac{1}{2}}\\hat{A}\\Lambda_t^{-\\frac{1}{2}}V^{(l)}W^{(l)})$$ where, $V^{(l)}$ denotes the stack of $V^{(l)}_t$, and $W^{(l)}$ denotes the trainable parameters. ","date":"2023-07-16","objectID":"/posts/social_stgcnn/:1:2","tags":["draft"],"title":"Social_STGCNN 论文解读","uri":"/posts/social_stgcnn/"},{"categories":["Prediction"],"content":"Data Processing 数据处理以及图构建 obs_traj - 前8帧观察轨迹(绝对坐标) pred_traj_gt - 后12帧预测轨迹(ground truth)(绝对坐标) obs_traj_rel - 前8帧观察轨迹(相对坐标) pred_traj_gt_rel - 后12帧预测轨迹(ground truth)(相对坐标) non_linear_ped - 非线性轨迹 (剔除) loss_mask V_obs - graph nodes A_obs - graph Adjacency Matrix V_tr - 预测轨迹 graph nodes A_tr - 预测轨迹 graph Adjacency Matrix ","date":"2023-07-16","objectID":"/posts/social_stgcnn/:2:0","tags":["draft"],"title":"Social_STGCNN 论文解读","uri":"/posts/social_stgcnn/"},{"categories":["C++"],"content":"C++ STL (Standard Template Library) 总结 C++ STL 容器是使用频率超高的基础设施，只有了解各个容器的底层原理，才能得心应手地用好不同的容器，做到用最合适的容器干最合适的事情。 本文旨在对 C++ 标准模板库的 array, vector, deque, list, forward_list, queue, priority_queue, stack, map, multimap, set, multi_set, unordered_map, unordered_multimap, unordered_set, unordered_multiset 共十六类容器进行系统的对比分析，重点关注各个容器的底层原理与性能特点。本文唯一参考资料为C++官方文档，若有其它参考则会指明出处。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:0","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"1. array Container properties: Sequence | Contiguous storage | Fixed-size aggregate 容器属性：顺序容器（支持随机访问），连续内存空间，固定大小；//连续内存 类模板头：template \u003c class T, size_t N \u003e class array; array 即数组，其大小固定，所有的元素严格按照内存地址线性排列，array 并不维护元素之外的任何多余数据，甚至也不会维护一个size这样的变量，这保证了它在存储性能上和C++语法中的数组符号[]无异。尽管其它大部分标准容器都可以通过 std::allocator 来动态的分配和回收内存空间，但 Array 并不支持这样做。 Array 和其它标准容器一个很重要的不同是：对两个 array 执行 swap 操作意味着真的会对相应 range 内的元素一一置换，因此其时间花销正比于置换规模；但同时，对两个 array 执行 swap 操作不会改变两个容器各自的迭代器的依附属性，这是由 array 的 swap 操作不交换内存地址决定的。 Array 的另一个特性是：不同于其它容器，array 可以被当作 std::tuple 使用，因为 array 的头文件重载了get()以及tuple_size()和tuple_element()函数（注意这些函数非 array 的成员函数，而是外部函数）。 最后需要注意，虽然 array 和 C++语法中的[]符号无限接近，但两者是两个存在，array 毕竟是标准模板库的一员，是一个class，因此支持 begin(), end(), front(), back(), at(), empty(), data(), fill(), swap(), ... 等等标准接口，而[]是真正的最朴素的数组。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:1","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"2. vector Container properties: Sequence | Dynamic array | Allocator-aware 容器属性：顺序容器（支持随机访问），动态调整大小，使用内存分配器动态管理内存；//连续内存 类模板头：template \u003c class T, class Alloc = allocator \u003e class vector; 一句话来说，vector 就是能够动态调整大小的 array。和 array 一样，vector 使用连续内存空间来保存元素，这意味着其元素可以用普通指针的++和--操作来访问；不同于 array 的是，其存储空间可以自动调整。 在底层上，vector 使用动态分配的 array，当现有空间无法满足增长需求时，会重新分配（reallocate）一个更大的 array 并把所有元素移动过去，因此，vector 的 reallocate 是一个很耗时的处理。所以，每次 reallocate 时都会预留多余的空间，以满足潜在的增长需求，也就是说，vector的capacity()通常会大于size()。vector 什么时候做 reallocate，reallocate 多少多余空间，是有具体策略的，按下不表。总体来说，vector 比 array 多了一些内存消耗，以换取更灵活的内存管理。 和其它的动态顺序容器（deque, list, forward_list）相比，vector 在元素访问上效率最高，在尾部增删元素的效率也相对最高。如果调用者有在尾部以外的地方增删元素的需求，vector 则不如其它容器，并且迭代器的一致性也较差（have less consistent iterators and references than lists and forward_lists）。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:2","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"3. queue 容器属性：容器适配器(adapter)，先进先出型容器（FIFO）；//C++设计模式之适配器模式 template \u003cclass T, class Container = deque \u003e class queue; queue（普通队列）是一个专为 FIFO 设计的容器适配器，也即只能从一端插入、从另一端删除；所谓容器适配器，是指它本身只是一个封装层，必须依赖指定的底层容器（通过模板参数中的class Container指定）才能实现具体功能。 **容器适配器(Adapter)**实际上是C++设计模式的一种 – 称为 Adapter 模式（适配器模式），Adapter 模式的目的是将第三方库提供的接口做一个封装和转化，使其适配自己工程中预留的接口，或者适应自己工程的调用风格。换句话说，Adapter 模式的目的是将被调用类（如第三方库）的接口转化为希望的接口。 回到正题，queue 可以接纳任何一个至少支持下列接口的容器作为底层容器： empty(); size(); front(); back(); push_back(); pop_front(). 在标准模板库容器中，deque 和 list 满足上述要求，当然用户也可以自定义一个满足上述要求的容器。通过模板参数可以看出，默认情况下，queue 使用 deque 作为底层容器。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:3","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"4. deque Container properties: Sequence | Dynamic array | Allocator-aware 容器属性：顺序容器（支持随机访问），动态调整大小，使用内存分配器动态管理内存；//分段连续内存 类模板头：template \u003c class T, class Alloc = allocator \u003e class deque; deque（读作\"deck\"）是 double-ended queue 的缩写，是一个可以在首尾两端进行动态增删的顺序容器。 不同的库对 deque 的实现可能不同，但大体上都是某种形式的动态 array，且都支持随机访问。deque 的功能和 vector 比较接近，但 deque 额外支持在头部动态增删元素。和 vector 不一样的是，deque 不保证存储区域一定是连续的! 因此用指向元素的普通指针做++和--操作是非常危险的行为。 从底层机理上能更透彻地理解 deque 的特点：vector 使用的是单一的 array，deque 则会使用很多个离散的 array 来组织数据「the elements of a deque can be scattered in different chunks of storage」！如果说 vector 是连续的，deque 则是分段连续。deque 会维护不同 array 之间的关联信息，使用户无需关心分段这个事实。这样做的好处是很明显的：deque 在 reallocate 时，只需新增/释放两端的 storage chunk 即可，无需移动已有数据（vector 的弊端），极大提升了效率，尤其在数据规模很大时，优势明显。 相比于 vector 和 list，deque 并不适合遍历！因为每次访问元素时，deque 底层都要检查是否触达了内存片段的边界，造成了额外的开销！deque 的核心优势是在双端都支持高效的增删操作，程序员选择使用 deque 时需要有双端操作的明确理由。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:4","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"5. priority_queue 容器属性：容器适配器，严格弱序（Strict Weak Ordering），优先级队列； template \u003cclass T, class Container = vector, class Compare = less \u003e class priority_queue; 和 queue 类似，priority_queue（术语叫作优先级队列）也只是一个容器适配器，需要指定底层容器才能实例化，参见模板参数中的class Container形参。priority_queue 的核心特点在于其严格弱序特性（strict weak ordering）：也即 priority_queue 保证容器中的第一个元素始终是所有元素中最大的！为此，用户在实例化一个 priority_queue 时，必须为元素类型（class T）重载\u003c运算符，以用于元素排序！ priority_queue 的原理可以用一个大顶堆来解释：priority_queue 在内部维护一个基于二叉树的大顶堆数据结构，在这个数据结构中，最大的元素始终位于堆顶部，且只有堆顶部的元素（max heap element）才能被访问和获取，大顶堆的具体原理可参见任何一本数据结构书籍。 为了支持这种工作原理，priority_queue 对底层容器也是有要求的，priority_queue 的底层容器必须支持随机访问和至少以下接口： empty(); size(); front(); push_back(); pop_back(). 标准模板库中的 vector 和 deque 能够满足上述需求，默认情况下，priority_queue 使用 vector 作为底层容器。 某种程度上来说，priority_queue 默认在 vector 上使用堆算法将 vector 中元素构造成大顶堆的结构，因此 priority_queue 就是堆 ，所有需要用到堆的位置，都可以考虑使用 priority_queue。priority_queue 默认是大顶堆，用户也可以通过自定义模板参数中的 class Compare 来实现一个小顶堆。 相比于 queue（普通队列）的先进先出FIFO，priority_queue 实现了最高优先级先出。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:5","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"6. list Container properties: Sequence | Doubly-linked list | Allocator-aware 容器属性：顺序容器（可顺序访问，但不支持随机访问），双链表，使用内存分配器动态管理内存；//离散内存 类模板头：template \u003c class T, class Alloc = allocator \u003e class list; list 是一种支持在任意位置都可以快速地插入和删除元素的容器，且支持双向遍历。list 容器能够做到这些的原因在于其底层结构是双链表，双链表允许把各个元素都保存在彼此不相干的内存地址上，但每个元素都会与前后相邻元素关联。 和其它的顺序容器（array, vector, deque）相比，list 的最大优势在于支持在任意位置插入、删除和移动元素，对 list 来说，在哪个位置进行操作并没有区别。list 在部分算法（如 sorting）中的效率可能优于其它顺序容器。 list 的主要缺点是不支持元素的随机访问！如果我们想要访问某个元素，则必须从一个已知元素（如 begin 或 end）开始朝一个方向遍历，直至到达要访问的元素。此外，list 还要消耗更多的内存空间，用于保存各个元素的关联信息。 [另说] list 对内存空间的使用效率并不高，一方面元素内存地址是离散的而非连续，另一方面，list 需要保存额外的关联信息。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:6","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"7. forward_list Container properties: Sequence | Linked list | Allocator-aware 容器属性：顺序容器（可顺序访问，但不支持随机访问），单链表，使用内存分配器动态管理内存； 类模板头：template \u003c class T, class Alloc = allocator \u003e class list; forward_list 也是一种支持在任意位置快速插入和删除元素的容器，forward_list 相比于 list 的核心区别是它是一个单链表，因此, 每个元素只会与相邻的下一个元素关联！由于关联信息少了一半，因此 forward_list 占用的内存空间更小，且插入和删除的效率稍稍高于 list。作为代价，forward_list 只能单向遍历。 相比于其它顺序容器（array, vector, deque），forward_list 的优缺点和 list 基本相同。 既然已经有了 list，为什么 C++ STL 又设计了 forward_list 这一容器呢？设计 forward_list 的目的是为了达到不输于任何一个C风格手写链表的极值效率！为此，forward_list 是一个最小链表设计，它甚至没有size()接口，因为内部维护一个size变量会降低增删元素的效率。如果想要获取 forward_list 的 size，一个通常的做法是，用 std::distance 计算 begin 到 end 的距离得出 size。一句话总结：list 兼顾了接口丰富性牺牲了效率，而 forward_list 舍弃了不必要的接口只为追求极致效率。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:7","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"8. stack 容器属性：容器适配器，后进先出型容器（LIFO）； template \u003cclass T, class Container = deque \u003e class stack; stack（栈）是一个专为 LIFO 设计的容器适配器，也即只能从一端插入和删除；作为适配器，需要指定底层容器才能实例化，参见模板参数中的class Container形参。 stack 的特点是后进先出（一端进出），不允许遍历；任何时候外界只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。stack 需要底层容器能够在一端增删元素，这一端也即 stack 的“栈顶”；stack 可以接纳任何一个至少支持下列接口的容器作为底层容器： empty(); size(); back(); push_back(); pop_back() 在标准模板库容器中，vector、deque 和 list 满足上述要求，当然用户也可以自定义一个满足上述要求的容器。通过模板参数可以看出，默认情况下，stack 使用 deque 作为底层容器。 stack 容器应用广泛，例如，编辑器中的 undo （撤销操作）机制就是用栈来记录连续的操作。stack 的设计场景和自助餐馆中堆叠的盘子、摞起来的一堆书类似。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:8","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"9. map Container properties: Associative | Ordered | Map | Unique keys | Allocator-aware 容器属性：关联容器，有序，元素类型\u003ckey, value\u003e，key是唯一的，使用内存分配器动态管理内存 ； template \u003c class Key, // map::key_type class T, // map::mapped_type class Compare = less, // map::key_compare class Alloc = allocator\u003cpair\u003cconst Key,T\u003e \u003e // map::allocator_type class map; map 是一个关联型容器，其元素类型是由 key 和 value 组成的 std::pair，实际上 map 中元素的数据类型正是 typedef pair\u003cconst Key, T\u003e value_type;，这就看的很清楚了。 所谓关联容器，是指对所有元素的检索都是通过元素的 key 进行的（而非元素的内存地址），map 通过底层的「红黑树」数据结构来将所有的元素按照 key 的相对大小进行排序，所实现的排序效果也是严格弱序特性（strict weak ordering），为此，开发者需要重载 key 的\u003c运算符或者模板参数中的 class Compare。所提到的红黑树是一种自平衡二叉搜索树，它衍生自B树，这里推荐两篇文章（记一次腾讯面试：有了二叉查找树、平衡树（AVL）为啥还需要红黑树？，图解：什么是红黑树？）作为更深入的参考。 大体来说，map 访问元素的速度要稍慢于下文的 unordered_map，这是因为虽然都叫“map”，但两者的底层机制完全不一样。但是，相比于后者，map 支持在一个子集合上进行直接迭代器访问，原因在于 map 中的元素是被有序组织的。 最后，map 也支持通过operator[]的方式来直接访问 value。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:9","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"10. multimap Container properties: Associative | Ordered | Map | Multiple equivalent keys | Allocator-aware 容器属性: 关联容器，有序，元素类型\u003ckey, value\u003e，允许不同元素key相同，使用内存分配器管理内存； template \u003c class Key, // map::key_type class T, // map::mapped_type class Compare = less, // map::key_compare class Alloc = allocator\u003cpair\u003cconst Key,T\u003e \u003e // map::allocator_type class map; map 中不允许出现 key 相同的两个元素，但 multimap 则可以这样做！ multimap 与 map 底层原理完全一样，都是使用「红黑树」对元素数据按 key 的比较关系，进行快速的插入、删除和检索操作；所不同的是 multimap 允许将具有相同 key 的不同元素插入容器（这个不同体现了 multimap 对红黑树的使用方式的差异）。在 multimap 容器中，元素的 key 与元素 value 的映射关系，是一对多的，因此，multimap 是多重映射容器。 注意，在向 multimap 中新增元素时，multimap 只会判断 key 是否相同，而完全不会判断 value 是否相同！这意味着如果相同的 \u003ckey, value\u003e 插入了多次，multimap 会对它们悉数保存！ 在使用中，我们可以通过迭代器配合 lower_bound() 和 upper_bound() 来访问一个 key 对应的所有 value，也可以使用equal_range()来访问一个 key 对应的所有 value，也可以通过find()配合count()来访问一个 key 对应的所有 value，个人认为前两种方法使用起来更方便一点。 下文中将要提到的 multiset 之于 set 类似于这里的 multimap 之于 map。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:10","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"11. set Container properties: Associative | Ordered | Set | Unique keys | Allocator-aware 容器属性：关联容器，有序，元素自身即key，元素有唯一性，使用内存分配器动态管理内存； template \u003c class T, // set::key_type/value_type class Compare = less, // set::key_compare/value_compare class Alloc = allocator // set::allocator_type class set; set 是一个关联型容器，和 map 一样，它的底层结构是「红黑树」，但和 map 不一样的是，set 是直接保存 value 的，或者说，set 中的 value 就是 key。 set 中的元素必须是唯一的，不允许出现重复的元素，且元素不可更改，但可以自由插入或者删除。 由于底层是红黑树，所以 set 中的元素也是严格弱序（strict weak ordering）排序的，因此支持用迭代器做范围访问（迭代器自加自减）。 实际使用中，set 和 map 是近亲，性能相似，他们的差别是元素的 value 本身是否也作为 key 来标识自己。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:11","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"12. multi_set Container properties: Associative | Ordered | Set | Multiple equivalent keys | Allocator-aware 容器属性：关联容器，有序，元素自身即key，允许不同元素值相同，使用内存分配器动态管理内存 ； template \u003c class T, // multiset::key_type/value_type class Compare = less, // multiset::key_compare/value_compare class Alloc = allocator \u003e // multiset::allocator_type class multiset; multiset 之于 set 就如同 multimap 之于 map： multiset 和 set 底层都是红黑树，multiset 相比于 set 支持保存多个相同的元素； multimap 和 map 底层都是红黑树，multimap 相比于 map 支持保存多个key相同的元素。 鉴于以上近亲关系，multiset 的性能特点与其它三者相似，不再赘述。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:12","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"13. unordered_map Container properties: Associative | Unordered | Map | Unique keys | Allocator-aware 容器属性：关联容器，无序，元素类型\u003ckey, value\u003e，key是唯一的，使用内存分配器动态管理内存 ； template \u003c class Key, // unordered_map::key_type class T, // unordered_map::mapped_type class Hash = hash, // unordered_map::hasher class Pred = equal_to, // unordered_map::key_equal class Alloc = allocator\u003c pair\u003cconst Key,T\u003e \u003e // unordered_map::allocator_type class unordered_map; unordered_map 和 map 一样，都是关联容器，以键值对儿 \u003ckey, value\u003e 作为元素进行存储；但是，除此之外，两者可以说是完全不一样！ 这是由底层的数据结构决定的，map 以红黑树作为底层结构组织数据，而 unordered_map 以哈希表(hash table)作为底层数据结构来组织数据，这造成了两点重要影响： 1. unordered_map 不支持排序，在使用迭代器做范围访问时（迭代器自加自减）效率更低； 2. 但 unordered_map 直接访问元素的速度更快（尤其在规模很大时），因为它通过直接计算 key 的哈希值来访问元素，是O(1)复杂度！ 网络上有对 map VS unordered_map 效率对比的测试，通常 map 增删元素的效率更高，unordered_map 访问元素的效率更高，可以参见这篇文章。另外，unordered_map 内存占用更高，因为底层的哈希表需要预分配足量的空间。 综上，unordered_map 更适用于增删操作不多，但需要频繁访问，且内存资源充足的场合。 比如在机器人领域的SLAM技术中，可以选择 unordered_map 来维护体素形式的 local map？ 当然 deque 应该也是不错的选择。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:13","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"14. unordered_multimap Container properties: Associative | Unordered | Map | Multiple equivalent keys | Allocator-aware 容器属性：关联容器，无序，元素类型\u003ckey, value\u003e，允许不同元素key相同，使用内存分配器管理内存 ； template \u003c class Key, // unordered_multimap::key_type class T, // unordered_multimap::mapped_type class Hash = hash, // unordered_multimap::hasher class Pred = equal_to, // unordered_multimap::key_equal class Alloc = allocator\u003c pair\u003cconst Key,T\u003e \u003e // unordered_multimap::allocator_type class unordered_multimap; unordered_multimap 是对 unordered_map 的拓展，唯一区别在于 unordered_multimap 允许不同元素的 key 相同，但两者无论是在底层结构还是在容器特性上都是相通的，仅仅是对底层哈希表的使用方式稍有不同。 在 unordered_multimap 中想要访问同一个 key 下对应的所有元素的话，可以使用equal_range()轻松做到；当然，也可以使用find()和count()配合的方式来访问。 unordered_multimap 的容器特性参见 unordered_map，不再赘述。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:14","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"15. unordered_set Container properties: Associative | Unordered | Set | Unique keys | Allocator-aware 容器属性：关联容器，无序，元素自身即key，元素有唯一性，使用内存分配器动态管理内存 ； template \u003c class Key, // unordered_set::key_type/value_type class Hash = hash, // unordered_set::hasher class Pred = equal_to, // unordered_set::key_equal class Alloc = allocator // unordered_set::allocator_type class unordered_set; 所有unordered_XXX类容器的特点都是以哈希表作为底层结构；所有 XXX_set 类容器的特点都是「元素自身也作为key」来标识自己。我们在把两类特性叠加到一起，就得到了 unordered_set。 在 unordered_set 中，元素自身同时也作为 key 使用；既然是作为 key 使用，那么元素就不能被更改，也即 unordered_set 中的元素都是 constant 的，但我们可以自由的插入和删除元素，这也是所有XXX_set类容器的性质。既然底层结构是哈希表，意味着 unordered_set 中的元素是无序的，不能按照大小排序，这也是所有unordered_XXX类容器的性质。 和所有的unordered_XXX类容器一样： 1. unordered_set 直接用迭代器做范围访问时（迭代器自加自减）效率更低，低于 set； 2. 但 unordered_set 直接访问元素的速度更快（尤其在规模很大时），因为它通过直接计算 key 的哈希值来访问元素，是O(1)复杂度！ ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:15","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"16. unordered_multiset Container properties: Associative | Unordered | Set | Multiple equivalent keys | Allocator-aware 容器属性：关联容器，无序，元素自身即key，允许不同元素值相同，使用内存分配器动态管理内存 ； template \u003c class Key, // unordered_multiset::key_type/value_type class Hash = hash, // unordered_multiset::hasher class Pred = equal_to, // unordered_multiset::key_equal class Alloc = allocator // unordered_multiset::allocator_type class unordered_multiset; unordered_multiset，顾名思义，就是集齐了“哈希表为底层结构”，“元素自身即key”，“允许不同元素值相同”这三个特性的容器，是对 unordered_set 的简单拓展。 unordered_multiset 的效率特性与所有基于哈希表的容器相似，参见 unordered_set，不再赘述。 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:16","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["C++"],"content":"17. pair \u0026\u0026 tuple template \u003cclass… Types\u003e class tuple; template \u003cclass T1, class T2\u003e struct pair; std::pair 和 std::tuple 并不是stl容器库中的容器，不过鉴于经常用到，就顺便整理一下。先从 tuple 说起，pair 相当于 tuple 的特例。 tuple 叫作元组，它可以把一组类型相同或不同的元素组合到一起，且元素的数量不限。tuple 的底层原理与 stl 中的容器完全不同，但在功能上，tuple 是对容器的有效补充，因为所有的容器都只能组合相同类型的元素，但tuple 可以组合任意不同类型的元素。在使用上，可以用std::make_tuple()来构造 tuple 对象，可以用std::get()来获取 tuple 对象的某个元素，注意std::get()返回的是 tuple 对象中某个元素的索引，因此是可以用作左值的！此外，也可以用std::tie()打包一组变量来作为左值接受 tuple 对象的赋值。 tuple 的底层原理大概是一个层层继承的类，详情可以参考这篇文章，写的非常透彻。 pair 可以看作是把 tuple 的 size 限制为 2 的一个特例，pair 只能把一对儿元素组合到一起。在使用上，可以用std::make_pair()来直接构建 pair 对象，可以用std::get\u003c0\u003e()和std::get\u003c1\u003e()来分别获取 pair 对象的两个元素，但更方便的做法是直接访问 pair 类型的两个数据成员pair对象.first和pair对象.second来访问元素 reference: [1]. https://zhuanlan.zhihu.com/p/542115773 ","date":"2023-07-16","objectID":"/posts/datastructrue/:1:17","tags":["draft"],"title":"C++ STL Containers","uri":"/posts/datastructrue/"},{"categories":["Algorithm"],"content":"Runebook www.doc4dev.com ","date":"2023-07-16","objectID":"/posts/treenode/:0:0","tags":["draft"],"title":"TreeNode 二叉树","uri":"/posts/treenode/"},{"categories":["Algorithm"],"content":"深度优先遍历 前序遍历：中左右 5 4 1 2 6 7 8 中序遍历：左中右 1 4 2 5 7 6 8 后序遍历：左右中 1 2 4 7 8 6 5 二叉树的定义 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; ","date":"2023-07-16","objectID":"/posts/treenode/:1:0","tags":["draft"],"title":"TreeNode 二叉树","uri":"/posts/treenode/"},{"categories":["Algorithm"],"content":"前序遍历 递归法 class Solution { public: void traversal(TreeNode* cur, vector\u003cint\u003e\u0026 vec) { if (cur == nullptr) return; vec.push_back(cur-\u003eval); traversal(root-\u003eleft, vec); traversal(root-\u003eright, vec); } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; traversal(root, vec); return res; } }; 迭代法 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { stack\u003cTreeNode*\u003e st; vector\u003cint\u003e res; if (root == nullptr) return res; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); res.push_back(node-\u003eval); if (node-\u003eright) st.push(node-\u003eright); if (node-\u003eleft) st.push(node-\u003eleft); } return res; } }; ","date":"2023-07-16","objectID":"/posts/treenode/:1:1","tags":["draft"],"title":"TreeNode 二叉树","uri":"/posts/treenode/"},{"categories":["Algorithm"],"content":"中序遍历 递归法 class Solution { public: void traversal(TreeNode* cur, vector\u003cint\u003e\u0026 vec) { if (cur == nullptr) return; traversal(root-\u003eleft, vec); vec.push_back(cur-\u003eval); traversal(root-\u003eright, vec); } vector\u003cint\u003e inorderTraversal(TreeNode* root) { vector\u003cint\u003e res; traversal(root, vec); return res; } }; 迭代法 // 中序遍历 class Solution { public: vector\u003cint\u003e inorderTraversal(TreeNode* root) { stack\u003cTreeNode*\u003e st; vector\u003cint\u003e res; if (root == nullptr) return; TreeNode* cur = root; while (!cur || !st.empty()) { if (cur != nullptr) { st.push(cur); cur = cur-\u003eleft; // 左 } else { cur = st.top(); st.pop(); res.push_back(cur-\u003eval); cur = cur-\u003eright; } } return res; } }; ","date":"2023-07-16","objectID":"/posts/treenode/:1:2","tags":["draft"],"title":"TreeNode 二叉树","uri":"/posts/treenode/"},{"categories":["Algorithm"],"content":"后序遍历 递归法 class Solution { public: void traversal(TreeNode* cur, vector\u003cint\u003e\u0026 vec) { if (cur == nullptr) return; traversal(root-\u003eleft, vec); traversal(root-\u003eright, vec); vec.push_back(cur-\u003eval); } vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e res; traversal(root, vec); return res; } }; 迭代法 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e res; if (!root) return res; stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); res.push(node-\u003eval); if (node-\u003eleft) st.push(node-\u003eleft); if (node-\u003eright) st.push(node-\u003eright); } reverse(res.begin(), res.end()); return res; } }; ","date":"2023-07-16","objectID":"/posts/treenode/:1:3","tags":["draft"],"title":"TreeNode 二叉树","uri":"/posts/treenode/"},{"categories":["Algorithm"],"content":"二叉树的统一迭代法 迭代法前序遍历 // 中左右 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; stack\u003cTreeNode*\u003e st; if (root) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node) { st.pop(); if (node-\u003eright) st.push(node-\u003eright); if (node-\u003eleft) st.push(node-\u003eleft); st.push(node); st.push(nullptr); } else { st.pop(); node = st.top(); st.pop(); res.push_back(node-\u003eval); } } return res; } }; 迭代法中序遍历 //左中右 class Solution { public: vector\u003cint\u003e inorderTraversal(TreeNode* root) { vector\u003cint\u003e res; stack\u003cTreeNode*\u003e st; if (root != nullptr) st.push(root); while(!st.empty()) { TreeNode* node = st.top(); if (node != nullptr) { st.pop(); //将该节点弹出，避免重复操作 if (node-\u003eright) st.push(node-\u003eright); st.push(node); st.push(nullptr); if (node-\u003eleft) st.push(node-\u003eleft); } else { st.pop(); node = st.top(); st.pop(); res.push_back(node-\u003eval); } } return res; } }; 迭代法后序遍历 // 左右中 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e res; stack\u003cTreeNode*\u003e st; if (root) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node) { st.pop(); st.push(node); st.push(nullptr); if (node-\u003eright) st.push(node-\u003eright); if (node-\u003eleft) st.push(node-\u003eleft); } else { st.pop(); node = st.top(); st.pop(); res.push_back(node-\u003eval); } } return res; } }; ","date":"2023-07-16","objectID":"/posts/treenode/:2:0","tags":["draft"],"title":"TreeNode 二叉树","uri":"/posts/treenode/"},{"categories":["Algorithm"],"content":"广度优先遍历 (层序遍历) 递归法 class Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { queue\u003cTreeNode*\u003e que; if (root) que.push(root); vector\u003cvector\u003cint\u003e\u003e ans; while (!que.empty()) { int size = que.size(); vector\u003cint\u003e vec; for (int i = 0; i \u003c size; ++i) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-\u003eval); if (node-\u003eleft) que.push(node-\u003eleft); if (node-\u003eright) que.push(node-\u003eright); } ans.push_back(vec); } return ans; } }; 迭代法 class Solution { public: void order(TreeNode* cur, vector\u003cvector\u003cint\u003e\u003e\u0026 res, int depth) { if (cur == nullptr) return; if (res.size() == depth) res.push_back(vector\u003cint\u003e()); res[depth].push_back(cur-\u003eval); order(cur-\u003eleft, res, depth + 1); order(cur-\u003eright, res, depth + 1); } vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) { vector\u003cvector\u003cint\u003e\u003e res; int depth = 0; order(root, res, depth); return res; } }; ","date":"2023-07-16","objectID":"/posts/treenode/:3:0","tags":["draft"],"title":"TreeNode 二叉树","uri":"/posts/treenode/"},{"categories":["Algorithm"],"content":"Sorting Algotithms Collection Quick Sort 快速排序 void quick_sort(vector\u003cint\u003e\u0026 nums, int l, int r) { if (l + 1 \u003e= r) { return; } int first = l, last = r - 1, key = nums[first]; while (first \u003c last) { while (first \u003c last \u0026\u0026 nums[last] \u003e= key) { --last; } nums[first] = nums[last]; while (first \u003c last \u0026\u0026 nums[first] \u003c= key) { ++first; } nums[last] = nums[first]; } nums[first] = key; quick_sort(nums, l, first); quick_sort(nums, first + 1, r); } Merge Sort 归并排序 void merge_sort(vector\u003cint\u003e\u0026 nums, int l, int r, vector\u003cint\u003e\u0026 temp) { if (l + 1 \u003e= r) { return; } // divide int m = l + (r - l) / 2; merge_sort(nums, l, m, temp); merge_sort(nums, m, r, temp); // conquer int p = l, q = m, i = l; while (q \u003c m || q \u003c r\u003e) { if (q \u003e= r || q \u003c r) { if (q \u003e= r || (p \u003c m \u0026\u0026 nums[p] \u003c= nums[q])) { temp[i++] = nums[p++]; } else { temp[i++] = nums[q++]; } } } for (int i = l; i \u003c r; ++i) { nums[i] = temp[i]; } } Insertion Sort 插入排序 void insertion_sort(vector\u003cint\u003e\u0026 nums, int n) { for (int i = 0; i \u003c n; ++i) { for (int j = i; j \u003e 0 \u0026\u0026 nums[j] \u003c nums[j-1]; --j) { swap(nums[j], nums[j-1]); } } } Bubble Sort 冒泡排序 void bubble_sort(vector\u003cint\u003e\u0026 nums, int n) { bool swapped; for (int i = 1; i \u003c n; ++i) { swapped = false; for (int j = 1; j \u003c n - i + 1; ++j) { if (nums[j] \u003c nums[j-1]) { swap(nums[j], nums[j-1]); swapped = true; } } if (!swapped) { break; } } } Selection Sort 选择排序 void selection_sort(vector\u003cint\u003e\u0026 nums, int n) { int mid; for (int i = 0; i \u003c n - 1; ++i) { mid = i; for (int j = i + 1; j \u003c n; ++j) { mid = j; } } swap(nums[mid], nums[i]); } ","date":"2023-07-16","objectID":"/posts/sortingalgo/:0:1","tags":["draft"],"title":"Sorting Algorithms","uri":"/posts/sortingalgo/"},{"categories":["Algorithm"],"content":"ref: dp: https://juejin.cn/post/6844903993429196813 knapsack problem: https://blog.csdn.net/qq_38410730/article/details/81667885 完全背包问题: https://www.cnblogs.com/darkerg/p/15464987.html ","date":"2023-07-16","objectID":"/posts/knapsack/:0:0","tags":["draft"],"title":"KnapSack Problem","uri":"/posts/knapsack/"},{"categories":["Algorithm"],"content":"KnapSack 背包问题 Definiton 定义 背包问题是一种组合优化的NP完全问题:有N个物品和容量为W的背包，每个物品都有自己的体积w和价值v， 求拿哪些物品可以使得背包所装下的物品的总价值最大。如果限定每种物品只能选择0个或者1个，则称问题为0-1背包问题;如果不限定每种物品的数量，则问题称为无界背包问题和或者完全背包问题。 0-1 背包问题 以 0-1 背包问题为例。我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，如果我们不将物品 i 放入背包，那么 dp[i][j] = dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i-1 个物品时的最大价值；如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为 O(NW)。 int knapsack(vector\u003cint\u003e\u0026 weights, vector\u003cint\u003e\u0026 values, int N, int W) { vector\u003cvector\u003cint\u003e\u003e dp(N+1, vector\u003cint\u003e (W+1, 0)); for (int i = 1; i \u003c=N; ++i) { int w = weight[i-1], v = values[i-1]; for (int j = 1; j \u003c= W; ++j) { if (j \u003e= w) { dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v); } else { dp[i][j] = dp[i-1][j]; } } } return dp[N][W]; } 空间压缩: int knapsack(vector\u003cint\u003e\u0026 weights, vector\u003cint\u003e\u0026 values, int N, int W) { vector\u003cint\u003e dp(W+1, 0); for (int i = 1; i \u003c= N; ++i) { int w = weights[i-1], v = values[i-1]; for (j = W; j \u003e= w; ++j) { dp[j] = max(dp[j], dp[j-w] + v); } } return dp[W]; } 完全背包问题 完全背包问题中，一个物品可以拿多次。对于拿多个物品的情况，我们只需考虑 dp[2][3] 即可，即 dp[2][5] = max(dp[1][5], dp[2][3] + 3)。这样，我们 就得到了完全背包问题的状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)，其与 0-1背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。 int knapsack(vector\u003cint\u003e\u0026 weights, vector\u003cint\u003e\u0026 values, int N, int W) { vector\u003cvector\u003cint\u003e\u003e dp(N+1, vector\u003cint\u003e(W+1, 0)); for (int i = 1; i \u003c= N; ++i) { int w = weights[i-1], v = values[i-1]; for (int j = 1; j \u003c= W; ++j) { if (j \u003e= w) { dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v); } else { dp[i][j] = dp[i-1][j]; } } } return dp[N][W]; } 空间压缩: int knapsack(vector\u003cint\u003e\u0026 weights, vector\u003cint\u003e\u0026 values, int N, int W) { vector\u003cint\u003e dp(W+1, 0); for (int i = 1; i \u003c= N; ++i) { int w = weights[i-1], v = values[i-1]; for (int j = w; j \u003c= W; ++j) { dp[j] = max(dp[j], dp[j-w] + v); } } return dp[W]; } ","date":"2023-07-16","objectID":"/posts/knapsack/:0:1","tags":["draft"],"title":"KnapSack Problem","uri":"/posts/knapsack/"},{"categories":["ML"],"content":"最大似然估计（Maximum likelihood estimation, 简称MLE）和最大后验概率估计（Maximum a posteriori estimation, 简称MAP）是很常用的两种参数估计方法，如果不理解这两种方法的思路，很容易弄混它们。下文将详细说明MLE和MAP的思路与区别。 但别急，我们先从概率和统计的区别讲起。 概率和统计是一个东西吗？ 概率(probabilty)和统计(statistics)看似两个相近的概念，其实研究的问题刚好相反。 概率研究的问题是，已知一个模型和参数，怎么去预测这个模型产生的结果的特性(例如均值，方差，协方差等等)。 举个例子，我想研究怎么养猪(模型是猪)，我选好了想养的品种、喂养方式、猪棚的设计等等(选择参数)，我想知道我养出来的猪大概能有多肥，肉质怎么样(预测结果)。 统计研究的问题则相反。统计是，有一堆数据，要利用这堆数据去预测模型和参数。仍以猪为例。现在我买到了一堆肉，通过观察和判断，我确定这是猪肉(这就确定了模型。在实际研究中，也是通过观察数据推测模型是／像高斯分布的、指数分布的、拉普拉斯分布的等等)，然后，可以进一步研究，判定这猪的品种、这是圈养猪还是跑山猪还是网易猪，等等(推测模型参数)。 一句话总结：概率是已知模型和参数，推数据。统计是已知数据，推模型和参数。 显然，本文解释的MLE和MAP都是统计领域的问题。它们都是用来推测参数的方法。为什么会存在着两种不同方法呢？ 这需要理解贝叶斯思想。我们来看看贝叶斯公式。 贝叶斯公式到底在说什么？ 学习机器学习和模式识别的人一定都听过贝叶斯公式(Bayes’ Theorem)： 式[1] $P(A|B)=\\frac{P(B|A)P(A)}{P(B)}$ 贝叶斯公式看起来很简单，无非是倒了倒条件概率和联合概率的公式。 把B展开，可以写成: 式[2] $P(A|B)=\\frac{P(B|A)P(A)}{P(B|A)P(A) + P(B|\\sim A)P(\\sim A)}$ 这个式子就很有意思了。 想想这个情况。一辆汽车(或者电瓶车)的警报响了，你通常是什么反应？有小偷？撞车了？ 不。。 你通常什么反应都没有。因为汽车警报响一响实在是太正常了！每天都要发生好多次。本来，汽车警报设置的功能是，出现了异常情况，需要人关注。然而，由于虚警实在是太多，人们渐渐不相信警报的功能了。 贝叶斯公式就是在描述，你有多大把握能相信一件证据？（how much you can trust the evidence） 我们假设响警报的目的就是想说汽车被砸了。把$A$计作“汽车被砸了”，$B$计作“警报响了”，带进贝叶斯公式里看。我们想求等式左边发生$A∣B$的概率，这是在说警报响了，汽车也确实被砸了。汽车被砸**引起(trigger)**警报响，即B∣A。但是，也有可能是汽车被小孩子皮球踢了一下、被行人碰了一下等其他原因(统统计作$\\sim A$)，其他原因引起汽车警报响了，即 $B|\\sim A$。那么，现在突然听见警报响了，这时汽车已经被砸了的概率是多少呢(这即是说，警报响这个证据有了，多大把握能相信它确实是在报警说汽车被砸了)想一想，应当这样来计算。用警报响起、汽车也被砸了这事件的数量，除以响警报事件的数量(这即[式1])。进一步展开，即警报响起、汽车也被砸了的事件的数量，除以警报响起、汽车被砸了的事件数量加上警报响起、汽车没被砸的事件数量(这即[式2])。 再思考[式2]。想让$P(A∣B)=1$，即警报响了，汽车一定被砸了，该怎么做呢？让$P(B|\\sim A)P(\\sim A) = 0$即 可 。很容易想清楚，假若让$P(\\sim A)=0$,即杜绝了汽车被球踢、被行人碰到等等其他所有情况，那自然，警报响了，只剩下一种可能——汽车被砸了。这即是提高了响警报这个证据的说服力。 **从这个角度总结贝叶斯公式：做判断的时候，要考虑所有的因素。**老板骂你，不一定是你把什么工作搞砸了，可能只是他今天出门前和太太吵了一架。 再思考[式2]。观察【式2】右边的分子，$P(B∣A)$为汽车被砸后响警报的概率。姑且认为这是1吧。但是，若$P(A)$很小，即汽车被砸的概率本身就很小，则$P(B∣A)P(A)$仍然很小，即【式2】右边分子仍然很小，$P(A|B)$还是大不起来。 这里，$​P(A)$ 即是常说的先验概率，如果A的先验概率很小，就算$P(B∣A)$较大，可能A的后验概率$P(A∣B)$还是不会大(假设$P(B∣\\sim A)P(\\sim A)$不变的情况下)。 从这个角度思考贝叶斯公式：一个本来就难以发生的事情，就算出现某个证据和他强烈相关，也要谨慎。证据很可能来自别的虽然不是很相关，但发生概率较高的事情。 似然函数 似然(likelihood)这个词其实和概率(probability)是差不多的意思，Colins字典这么解释:The likelihood of something happening is how likely it is to happen. 你把likelihood换成probability，这解释也读得通。但是在统计里面，似然函数和概率函数却是两个不同的概念(其实也很相近就是了)。 对于这个函数: $$P(x|\\theta)$$ 输入有两个: $x$表示某一个具体的数据；$\\theta$表示模型的参数。 如果$\\theta$是已知确定的，$x$是变量，这个函数叫做概率函数(probability function)，它描述对于不同的样本点x，其出现概率是多少。 如果$x$是已知确定的，$\\theta$是变量，这个函数叫做似然函数(likelihood function), 它描述对于不同的模型参数，出现$x$这个样本点的概率是多少。 最大似然估计(MLE) 假设有一个造币厂生产某种硬币，现在我们拿到了一枚这种硬币，想试试这硬币是不是均匀的。即想知道抛这枚硬币，正反面出现的概率（记为$\\theta$）各是多少？ 这是一个统计问题，回想一下，解决统计问题需要什么？ 数据！ 于是我们拿这枚硬币抛了10次，得到的数据($x_0$)是：反正正正正反正正正反。我们想求的正面概率$\\theta$是模型参数，而抛硬币模型我们可以假设是二项分布。 那么，出现实验结果$x_0$(即反正正正正反正正正反)的似然函数是多少呢？ $$f(x_0 ,\\theta) = (1-\\theta)\\times\\theta\\times\\theta\\times\\theta\\times\\theta\\times(1-\\theta)\\times\\theta\\times\\theta\\times\\theta\\times(1-\\theta) = \\theta ^ 7(1 - \\theta)^3 = f(\\theta)$$ ​ 注意，这是个只关于$\\theta$的函数。而最大似然估计，顾名思义，就是要最大化这个函数。我们可以画出$f(\\theta)$的图像： 可以看出，在$\\theta = 0.7$时，似然函数取得最大值。 这样，我们已经完成了对$\\theta$的最大似然估计。即，抛10次硬币，发现7次硬币正面向上，最大似然估计认为正面向上的概率是0.7。（ummm…这非常直观合理，对吧？） 且慢，一些人可能会说，硬币一般都是均匀的啊！ 就算你做实验发现结果是“反正正正正反正正正反”，我也不信$\\theta = 0.7$。 这里就包含了贝叶斯学派的思想了——要考虑先验概率。 为此，引入了最大后验概率估计。 最大后验概率估计(MAP) 最大似然估计是求参数$\\theta$, 使似然函数$P(x_0 | \\theta)$最 大 。 最大后验概率估计则是想求$\\theta$使$P(x_0|\\theta)$ 最大。求得的$\\theta$不单单让似然函数大，不单单让似然函数大，$\\theta$自己出现的先验概率也得大。(这有点像正则化里加惩罚项的思想，不过正则化里是利用加法，而MAP里是利用乘法). MAP其实是在最大化$P(\\theta|x_0) = \\frac{P(x_0|\\theta)P(\\theta)}{P(x_0)}$，不过因为$x_0$是确定的(即投出的“反正正正正反正正正反”)，$P(x_0)$是一个已知值，所以去掉了分母$P(x_0)$(假设“投10次硬币”是一次实验，实验做了1000次，“反正正正正反正正正反”出现了n次，则$P(x_0) = n/1000$)。总之，这是一个可以由数据集得到的值）。最大化$P(\\theta | x_0)$的意义也很明确，$x_0$已经出现了，要求$\\theta$取什么值使$P(\\theta | x_0)$最大。顺带一提，$P(\\theta | x_0)$, ​即后验概率，这就是“最大后验概率估计”名字的由来。 对于投硬币的例子来看，我们认为（”先验地知道“$\\theta$取0.5的概率很大，取其他值的概率小一些。我们用一个高斯分布来具体描述我们掌握的这个先验知识，例如假设$P(\\theta)$为均值0.5，方差0.1的高斯函数，如下图： 则$P(x_0 | \\theta)$的函数图像为： 注意，此时函数取最大值时，θ \\thetaθ取值已向左偏移，不再是0.7。实际上，在$\\theta = 0.558$时函数取得了最大值。即，用最大后验概率估计，得到$\\theta = 0.558$ 最后，那要怎样才能说服一个贝叶斯派相信$\\theta = 0.7$呢？你得多做点实验。。 如果做了1000次实验，其中700次都是正面向上，这时似然函数为: 如果仍然假","date":"2023-07-16","objectID":"/posts/mleandmap/:0:0","tags":["MLE"],"title":"详解最大似然估计(MLE)、最大后验概率估计(MAP)，以及贝叶斯公式的理解","uri":"/posts/mleandmap/"},{"categories":["Memo"],"content":"Linux系统各系统文件夹下的区别 首先，usr 指 Unix System Resource，而不是User。 通常， /usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变。 /usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件。 如果两个目录下有相同的可执行程序，谁优先执行受到PATH环境变量的影响，比如我的一台服务器的PATH变量为。 echo $PATH 这里/usr/local/bin优先于/usr/bin, 一般都是如此。 /lib是内核级的, /usr/lib是系统级的, /usr/local/lib是用户级的. / - 对你的电脑来说, 有且只有一个根目录。所有的东西都是从这里开始。举个例子: 当你在终端里输入\"/home\"，你其实是在告诉电脑，先从/(根目录)开始，再进入到home目录。 /lib/ — 包含许多被/bin/和/sbin/中的程序使用的库文件。目录/usr/lib/中含有更多用于用户程序的库文件。/lib目录下放置的是/bin和/sbin目录下程序所需的库文件。/lib目录下的文件的名称遵循下面的格式： libc.so.* ld* 仅仅被/usr目录下的程序所使用的共享库不必放到/lib目录下。只有/bin和/sbin下的程序所需要的库有必要放到/lib目录下。实际上，libm.so.*类型的库文件如果被是/bin和/sbin所需要的，也可以放到/usr/lib下。 /bin/ — 用来贮存用户命令。目录 /usr/bin 也被用来贮存用户命令。 /sbin/ — 许多系统命令(例如 shutdown)的贮存位置。目录/usr/sbin中也包括了许多系统命令。 /root/ — 根用户(超级用户)的主目录。 /mnt/ — 该目录中通常包括系统引导后被挂载的文件系统的挂载点。譬如，默认的光盘挂载点是/mnt/cdrom/. /boot/ — 包括内核和其它系统启动期间使用的文件。 /lost+found/ — 被fsck用来放置零散文件(没有名称的文件)。 /lib/ — 包含许多被/bin/和/sbin/中的程序使用的库文件。目录/usr/lib/中含有更多用于用户程序的库文件。 /dev/ — 贮存设备文件。 /etc/ — 包含许多配置文件和目录。系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 /var/ — 用于贮存variable(或不断改变的)文件，例如日志文件和打印机假脱机文件。 /usr/ — 包括与系统用户直接有关的文件和目录，例如应用程序及支持它们的库文件。在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具拉等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序; /usr/share用于存放一些共享的数据，比如音乐文件或者图标等等;/usr/lib目录用于存放那些不能直接运行的，但却是许多程序运行所必需的一些函数库文件。 /proc/ — 一个虚拟的文件系统(不是实际贮存在磁盘上的)，它包括被某些程序使用的系统信息。 /initrd/ — 用来在计算机启动时挂载 initrd.img 映像文件的目录以及载入所需设备模块的目录。 警告: 不要删除/initrd/目录。如果你删除了该目录后再重新引导Red Hat Linux时，你将无法引导你的计算机。 /tmp/ — 用户和程序的临时目录。/tmp给予所有系统用户读写权。**这是让一般使用者或者是正在执行的程序暂时放置档案的地方。**这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 /home/ — 用户主目录的默认位置。 /opt/ — 可选文件和程序的贮存目录。该目录主要被第三方开发者用来简易地安装和卸装他们的软件包。这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 /usr/local/ - 这里主要存放那些手动安装的软件，即apt或者apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。 /media/ - 有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘(包括U盘)、CD/DVD驱动器等等。 ","date":"2023-07-16","objectID":"/posts/filesystem/:0:0","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"/usr/local/ 和 /usr/share/ 区别 /usr/local - 这个目录一般是用来存放用户自编译安装软件的存放目录; 一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。这个目录下面有子目录。 /usr/share - 系统共用的东西存放地，比如/usr/share/fonts是字体目录，/usr/share/doc和/usr/share/man帮助文件。 /var/log - 系统日志存放，分析日志要看这个目录的东西; /var/spool - 打印机、邮件、代理服务器等脱机目录。 Linux Command Notes ","date":"2023-07-16","objectID":"/posts/filesystem/:1:0","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"查找文件的命令:find/locate/whereis/which/type/grep ","date":"2023-07-16","objectID":"/posts/filesystem/:2:0","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"find find命令准确，但速度非常慢，它可以查找任何类型的文件 使用格式 find [指定目录] [指定条件] [指定动作] 参数说明: [指定目录]： 所要搜索的目录及其所有子目录。默认为当前目录 [指定条件]： 所要搜索的文件的特征 -name：按文件名来查找文件 -user：按照文件的属主来查找文件 -group：按照文件所属的组来查找文件 -perm：按照文件权限来查找文件 -prune：不在当前指定目录中查找 [指定动作]： 对搜索结果进行特定的处理 -print：将匹配的文件输出到标准输出 -exec：对匹配的文件执行该参数所给出的shell命令 -ok：和-exec的作用相同，在执行每一个命令之前，让用户来确定是否执行 find命令不加任何参数时，表示搜索路径为当前目录及其子目录，默认的动作为-print，即不过滤任何结果，也就是说输出所有的文件 使用示例: - 递归搜索当前目录中，所有以file开头的文件 shell find . -name 'file*' - 递归搜索当前目录中，所有以file开头的文件，并显示它们的详细信息 shell find . -name 'file*' -ls ","date":"2023-07-16","objectID":"/posts/filesystem/:2:1","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"locate locate命令可以说是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/locatedb，这个数据库中含有本地所有文件信息. Linux自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库. 使用格式: locate [参数] \u003c文件名\u003e 使用示例: 搜索etc目录下所有以file开头的文件 locate /etc/file 搜索用户主目录下，所有以f开头的文件，并且忽略大小写 locate -i ~/f ","date":"2023-07-16","objectID":"/posts/filesystem/:2:2","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"whereis whereis命令只能搜索特定格式的文件 使用格式 whereis [参数] \u003c文件名\u003e 可搜索文集类型 二进制文件(-b) 源代码文件(-s) 说明文件(-m) 如果省略参数，则返回所有信息 使用示例: 找出名为find的文件位置 whereis find ","date":"2023-07-16","objectID":"/posts/filesystem/:2:3","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"which which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果, 也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 使用格式 which \u003c命令\u003e 使用实例: 查找find命令的位置 which find ","date":"2023-07-16","objectID":"/posts/filesystem/:2:4","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"type type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的; 如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。 使用格式 type \u003c命令\u003e 使用实例: 查看cd命令是否为shell自带的命令 type cd 查看grep是否为外部命令 type grep ","date":"2023-07-16","objectID":"/posts/filesystem/:2:5","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"grep grep命令用于查找拥有特殊字段的文件。 语法 grep [-abcEFGhHilLnqrsvVwxy][-A\u003c显示行数\u003e][-B\u003c显示列数\u003e][-C\u003c显示列数\u003e][-d\u003c进行动作\u003e][-e\u003c范本样式\u003e][-f\u003c范本文件\u003e][--help][范本样式][文件或目录...] 参数: -a 或 –text : 不要忽略二进制的数据。 -A\u003c显示行数\u003e 或 –after-context=\u003c显示行数\u003e : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B\u003c显示行数\u003e 或 –before-context=\u003c显示行数\u003e : 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c 或 –count : 计算符合样式的列数。 -C\u003c显示行数\u003e 或 –context=\u003c显示行数\u003e或-\u003c显示行数\u003e : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d \u003c动作\u003e 或 –directories=\u003c动作\u003e : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e\u003c范本样式\u003e 或 –regexp=\u003c范本样式\u003e : 指定字符串做为查找文件内容的样式。 -E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。 -f\u003c规则文件\u003e 或 –file=\u003c规则文件\u003e : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F 或 –fixed-regexp : 将样式视为固定字符串的列表。 -G 或 –basic-regexp : 将样式视为普通的表示法来使用。 -h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。 -i 或 –ignore-case : 忽略字符大小写的差别。 -l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。 -L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。 -n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。 -o 或 –only-matching : 只显示匹配PATTERN 部分。 -q 或 –quiet或–silent : 不显示任何信息。 -r 或 –recursive : 此参数的效果和指定\"-d recurse\"参数相同。 -s 或 –no-messages : 不显示错误信息。 -v 或 –invert-match : 显示不包含匹配文本的所有行。 -V 或 –version : 显示版本信息。 -w 或 –word-regexp : 只显示全字符合的列。 -x –line-regexp : 只显示全列符合的列。 -y : 此参数的效果和指定\"-i\"参数相同。 示例: # 查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串\"update\"的文件，并打印出该字符串所在行的内容 grep -r update /etc/acpi # 查看符合条件的日志条目。 grep -n '2019-10-24 00:01:11' *.log # 只匹配文本文件，不匹配二进制文件的命令 grep -srn \"parameter\" . --binary-files=without-match ","date":"2023-07-16","objectID":"/posts/filesystem/:2:6","tags":["Linux"],"title":"Linux Filysystem","uri":"/posts/filesystem/"},{"categories":["Memo"],"content":"VIM 8.2 安装 ","date":"2023-07-16","objectID":"/posts/installation/:0:0","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"1. Install Python3.9 from source Update the packages list and install the packages necessary to build Python sudo apt update \u0026\u0026 sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev wget libbz2-dev Download the latest release’s source code from the Python download page using wget wegt https://www.python.org/ftp/python/3.9.0/Python-3.9.1.tgz Switch to the Python source directory and execute the configure script which performs a number of checks to make sure all of the dependencies on your system are present cd Python-3.9.1 ./configure --enable-optimizations --with-lto --enable-shared --prefix=/usr/local/python39 make -j8 When the build process is complete, install the Python binaries by typing sudo make altinstall Do not use the standard make install as it will overwrite the default system python3 binary. copy the dynamic library to usr/lib/x86_64-linux-gnu/libpython3.9.so.1.0 sudo cp /usr/local/python39/lib/libpython3.9.so.1.0 /usr/lib/x86_64-linux-gnu/ the command can slove the error: error while loading shared libraries: libpython3.9.so.1.0: cannot open shared object file: No such file or directory make the soft link to set python39 as default python3 sudo ln -sf /usr/local/python39/bin/python3.9 /usr/bin/python3 sudo ln -s /usr/local/python39/bin/python3.9 /usr/bin/python3.9 using update-alternatives to switch different python version list all the python versions sudo update-alternatives --list python3 display python3 sudo update-alternatives --display python3 set different number for different version sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 1 sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.9 2 show different mode and select number to switch another mode sudo update-alternatives --config python3 ","date":"2023-07-16","objectID":"/posts/installation/:1:0","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"2. 源码安装cmake ","date":"2023-07-16","objectID":"/posts/installation/:2:0","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"2.1 download the cmake source code download source code wget https://github.com/Kitware/CMake/releases/download/v3.23.1/cmake-3.23.1.tar.gz ","date":"2023-07-16","objectID":"/posts/installation/:2:1","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"2.2 extract the source code directory and run the command to install extraction and configuration cd cmake-2.23.0 ./bootstrap //需要的话也可以指定安装目录，例如--prefix=/usr/local/cmake make \u0026\u0026 sudo make install ","date":"2023-07-16","objectID":"/posts/installation/:2:2","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"2.3 create soft link and set cmake as default set cmake as default sudo ln -s /usr/local/bin/cmake /usr/bin/cmake ","date":"2023-07-16","objectID":"/posts/installation/:2:3","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"3. 首先从github下载源码vim 8.2 ","date":"2023-07-16","objectID":"/posts/installation/:3:0","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"3.1 源码安装vim8.2 run the following command to downlaod source code of VIM from github git clone git clone https://github.com/vim/vim.git cd vim git pull cd src/ sudo make distclean # 如果您以前构建国vim cofigure the installation file ./configure --with-features=huge --enable-multibyte --enable-python3interp=dynamic --with-python3-config-dir=/usr/lib/python3.10/config-3.10-x86_64-linux-gnu/ --enable-cscope --enable-gui=auto --enable-gtk2-check --enable-fontset --enable-largefile --disable-netbeans --with-compiledby=\"18817571704@163.com\" --enable-fail-if-missing --prefix=/usr/local/vim82 sudo make sudo make install enable clipboard then you can copy the content from system clipboard to vim sudo apt-get install vim-gtk3 卸载vim 使用以下命令重置编译操作 sudo make distclean 使用以下命令，可以卸载命令 sudo make uninstall ","date":"2023-07-16","objectID":"/posts/installation/:3:1","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"3.2 安装vim-plug以及插件 安装vim-plug: curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 安装主题gruvbox to fix error: Cannot find color scheme ‘gruvbox’ mkdir ~/.vim/colors/ cp ~/.vim/plugged/gruvbox/gruvbox.vim ~/.vim/colors/ 安装YCM(YouCompleteMe) 根据~/.vimrc按装YCM cd ~/.vim/plugged/YouCompleteMe/ ./install.py --clang-completer 安装ctags sudo apt-get install exuberant-ctags 其他主题直接编辑:PlugInstall进行安装 ","date":"2023-07-16","objectID":"/posts/installation/:3:2","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"3.2 reference 参考链接: [1] https://github.com/ycm-core/YouCompleteMe/wiki/Building-Vim-from-source [2] https://wizardforcel.gitbooks.io/use-vim-as-ide/content/0.html ","date":"2023-07-16","objectID":"/posts/installation/:3:3","tags":["vim"],"title":"Vim Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"zsh说明 zsh是一个Linux下强大的shell, 由于大多数Linux产品安装以及默认使用bash shell, 但是丝毫不影响极客们对zsh的热衷, 几乎每一款Linux产品都包含有zsh，通常可以用apt-get、urpmi或yum等包管理器进行安装. zsh是bash的增强版，其实zsh和bash是两个不同的概念，zsh更加强大。 通常zsh配置起来非常麻烦，且相当的复杂，所以oh-my-zsh是为了简化zsh的配置而开发的，因此oh-my-zsh算是zsh的配置. ","date":"2023-07-16","objectID":"/posts/installation/:1:0","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"准备 查看当前系统用shell版本 echo $SHELL 查看系统自带哪些shell cat /etc/shells ","date":"2023-07-16","objectID":"/posts/installation/:2:0","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"安装zsh 通过命令行安装zsh sudo apt install zsh ","date":"2023-07-16","objectID":"/posts/installation/:3:0","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"zsh配置 将zsh设置为默认的shell chsh -s /bin/zsh 然后重启电脑 reboot ","date":"2023-07-16","objectID":"/posts/installation/:4:0","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"安装oh-my-zsh及其个性化配置 ","date":"2023-07-16","objectID":"/posts/installation/:5:0","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"安装oh-my-zsh 执行以下命令安装oh-my-zsh sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 或者 sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" ","date":"2023-07-16","objectID":"/posts/installation/:5:1","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"主题配置 打开配置文件~/.zshrc 输入: ZSH_THEME=\"xxf\" xxf.zsh-theme文件下载地址: xxf.zsh-theme文件下载 下载之后将文件拷贝到以下路径: /home/username/.oh-my-zsh/themes/ ","date":"2023-07-16","objectID":"/posts/installation/:5:2","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"插件 安装自动补全插件incr 首先，下载incr插件到本地 cd ~/.oh-my-zsh/plugins/ mkdir incr \u0026\u0026 cd incr wget http://mimosa-pudica.net/src/incr-0.2.zsh 编辑~/.zshrc文件，添加以下内容: source ~/.oh-my-zsh/plugins/incr/incr*.zsh 然后，source一下: source ~/.zshrc 直接使用默认插件 在~/.zshrc文件中添加插件: plugins=(git extract z) 安装autojump插件 通过命令行安装autojump sudo apt install autojump 在~/.zshrc文件中编辑: . /usr/share/autojump/autojump.sh 然后，source一下: source ~/.zshrc 安装zsh-syntax-highlighting语法高亮插件 从gihub下载源码并放在~/.oh-my-zsh/plugins/文件夹下: cd ~/.oh-my-zsh/plugins/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 在~/.zshrc文件中编辑: source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 然后，source一下: source ~/.zshrc 安装zsh-autosuggestions语法历史记录插件 从gihub下载源码并放在~/.oh-my-zsh/plugins/文件夹下: cd ~/.oh-my-zsh/plugins/ git clone git@github.com:zsh-users/zsh-autosuggestions.git 在~/.zshrc文件中编辑: source ~/.oh-my-zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh 然后，source一下: source ~/.zshrc ","date":"2023-07-16","objectID":"/posts/installation/:5:3","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"其他 设置更新日期 在~/.zshrc文件中编： exprot UPDATE_ZSH_DAYS=13 禁止自动更新 DISABLE_AUTO_UPDATE=\"true\" 手动更新oh-my-zsh upgrade_oh_my_zsh 卸载oh-my-zsh uninstall_on_my_zsh zsh ","date":"2023-07-16","objectID":"/posts/installation/:5:4","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"从bash到zsh的切换 直接执行zsh和oh-my-zsh的安装以及配置，并且在~/.zshrc文件中添加: source ~/.bashrc ","date":"2023-07-16","objectID":"/posts/installation/:5:5","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Memo"],"content":"zsh 快捷键 快捷键 ⌃ + u: 清空当前行 ⌃ + a: 移动到行首 ⌃ + e: 移动到行尾 ⌃ + f: 向前移动 ⌃ + b: 向后移动 ⌃ + p: 上一条命令 ⌃ + n: 下一条命令 ⌃ + r: 搜索历史命令 ⌃ + y: 召回最近用命令删除的文字 ⌃ + h: 删除光标之前的字符 ⌃ + d: 删除光标所指的字符 ⌃ + w: 删除光标之前的单词 ⌃ + k: 删除从光标到行尾的内容 ⌃ + t: 交换光标和之前的字符 ","date":"2023-07-16","objectID":"/posts/installation/:6:0","tags":["Zsh"],"title":"Zsh Installation","uri":"/posts/installation/"},{"categories":["Git"],"content":" 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage, 或 index。一般存放在 “.git 目录下” 下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录。git，这个不算工作区，而是 Git 的版本库。 ","date":"2023-07-16","objectID":"/posts/introduction/:0:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"介绍 https://git-scm.com/ 先通过几张图片来大致了解一下 Git 的工作原理吧！ 文章开头的流程图已经简单明了地说明了 Git 常用操作的工作流程，下图换种风格再展示一次： 提到 Git 就会联想到 github, 下图从 Git 的角度简单说明了一些 Github 常用操作的关系： 下面这个图则展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 \"index\" 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 HEAD 指针：每个 git 仓库有且仅有一个 HEAD 指针，它通常指向當前某个活動的本地分支指针（最初本地仓库 master)。也可以是某个提交记录、某个 tag，但这会让其处于 detached HEAD（游离头）状态，此状态下的所有提交都无效。 图中我们可以看出此时 \"HEAD\" 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的objects标识的区域为 Git 的对象库，实际位于 \".git/objects\" 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 \"git add\"命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 \"git reset HEAD\" 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 \"git rm --cached \u003cfile\u003e\" 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 \"git checkout .\" 或者 \"git checkout -- \u003cfile\u003e\" 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 \"git checkout HEAD .\" 或者 \"git checkout HEAD \u003cfile\u003e\" 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 ","date":"2023-07-16","objectID":"/posts/introduction/:1:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"Git 配置 git config --global --list #查看全局配置 git config --local --list #查看本项目配置 # 第一次使用 git 的时候，需要设置用户信息和用户邮箱，用于辨识提交者身份 git config --global user.name \"用户名\" git config --global user.email \"邮箱\" git config --global alias.cm commit git config --global alias.br branch # 配置指令别名简写 git config --global credential.helper store # 输入一次账号密码后第二次就会记住账号密码 git config --global core.ignorecase false # 关闭忽略大小写 git config --system core.longpaths true # 配置长路径 git config --global http.sslVerify false # 禁用 SSL 验证 git config --global core.protectNTFS false # 关闭 NTFS 文件保护 git config --global url.\"https://\".insteadOf git:// # git:// 报错 ","date":"2023-07-16","objectID":"/posts/introduction/:2:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"基本操作 git init ## 把当前的目录变成可以用 git 进行版本控制的 git 仓库，生成隐藏。git 文件。 git add XX ## 把 xx 文件添加到暂存区去。 git add –A ## git add --all 的缩写，添加全部到暂存区 git add –u ## 把文件的删除和修改添加到暂存区（不包括新增） git add . ## 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区 git commit -m \"message\" ## 从暂存区提交到本地仓库 git commit -a -m \"message\" ## 相当于省略 git add，但是无法提交新增的文件 git push origin master ## Git 会把 master 分支推送到远程库对应的远程分支上 Tips Commit Message 内容尽量规范！ 当某一次提交后，突然想起漏提交了文件，或不小心提交了不满意的代码时， 可以使用git commit --amend -m \"message\"指令。它可以在不增加一个新的 commit-id 的情况下将新修改的代码追加到前一次的 commit-id 中。提交之后 message 也将被本次的 message 覆盖，所以还需要再次添加上次的 message。 ","date":"2023-07-16","objectID":"/posts/introduction/:2:1","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"push git push origin branch-name git push –u origin master git push origin --delete branch-name ## 删除远程分支 把当前 master 分支推送到远程库；-u表示记住分支和地址，下次使用git push即可。 ","date":"2023-07-16","objectID":"/posts/introduction/:2:2","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"remote git remote add origin reposityUrl ## 关联一个远程库 git remote ## 查看远程库的信息 git remote –v ## 查看远程库的详细信息 ","date":"2023-07-16","objectID":"/posts/introduction/:2:3","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"clone git clone reposityUrl ## 从远程库中克隆 git clone -b branchName reposityUrl ## 克隆指定分支 ","date":"2023-07-16","objectID":"/posts/introduction/:2:4","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"pull git pull 从远程仓库拉下来到本地库然后合并相当于git fetch+git merge。 一般 push 前先拉去最新版本，避免代码冲突，如果有冲突需要解决了冲突才能提交。 import repositories 同步更新 git pull 原链接 git push origin master ","date":"2023-07-16","objectID":"/posts/introduction/:2:5","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"fetch git fetch ## 从远程库抓下最新版本，但是不合并 fetch 是从远程库到本地库，但是未在工作区，需要git merge ","date":"2023-07-16","objectID":"/posts/introduction/:2:6","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"merge git merge dev ## 在当前的分支上合并 dev 分支 分支合并也是在本地完成 (从本地库到工作区)，新的分支只有在合并后才允许被删除。 如果分支合并是出现冲突需要解决了冲突才能合并，使用git status查看冲突文件。 ","date":"2023-07-16","objectID":"/posts/introduction/:2:7","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"branch,checkout git branch ## 查看当前所有的分支 git branch name ## 创建分支 git branch –r ## 看远程所有分支 git branch –a ## 查看本地远程分支 git branch –d name ## 删除分支 git checkout name ## 切换分支 git checkout –b name ## 创建并切换到 name 分支上 git checkout -- file git checkout -- file相当于取消对文档的修改，将最新的本地版本库的本文件复制覆盖它。（比较危险！） ","date":"2023-07-16","objectID":"/posts/introduction/:2:8","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"reflog,log git log ## 显示所有提交过的版本信息：commit id，提交者，日期 git reflog ## 查看历史记录的 commit id Tips 想看到自己的操作记录，则可以使用 log 与 reflog，它两个的区别如下： git log命令可以显示所有提交过的版本信息； 如果感觉太繁琐，可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息。 git reflog可以查看所有分支的所有操作记录。（包括已经被删除的 commit 记录和 reset 的操作） ","date":"2023-07-16","objectID":"/posts/introduction/:2:9","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"reset git reset --hard HEAD^ git reset --hard HEAD~ ## 回退到上一个版本 git reset --hard HEAD~100 ## 回退到 100 个版本 git reset head -- file ## 不加 file 则全部退回 git reset file ## 将本地仓库的当前版本退回至暂存区，相当于取消暂存 版本退回是从本地仓库到暂存区，如果已经提交远程库，此时的版本是低于最新的版本的会拒绝提交， 需要用git push -f origin master强制提交。 特别提醒 如果你git reset --hard HEAD^+git push -f origin master执行完，github 中的记录和本地文件都会回到退回的状态。简单来说就是一修改了一天的 bug, 完工后，你这一套操作直接打回原形。别慌（实际内心慌的一麻皮。） 通过git log -g命令来找到需要恢复的信息对应的 commitid，可以通过提交的时间和记录来辨别， 找到执行reset --hard之前的那个 commit 对应的 commit-id 通过git branch recover_branch commit-id来建立一个新的分支 这样，就把到 commitid 为止的代码、各种提交记录等信息都恢复到了 recover_branch 分支上了。 ","date":"2023-07-16","objectID":"/posts/introduction/:2:10","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"status git status 查看你的文件在暂存区和工作目录的状态，默认是较为详细的显示，并提示你可以用何种命令完成你接下来可能要做的事情。 git status -s 较为简单的输出当前的状态，如： $ git status -s M README.md D hello.rb ?? world.java 你可以看到，在简短输出中，有两栏。第一栏是暂存区的，第二栏则是工作目录的。这里表示： README.md 在暂存区中的状态是 modify hello.rb 在工作目录中的状态是 delete world.java 还未添加到版本控制。 ","date":"2023-07-16","objectID":"/posts/introduction/:2:11","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"diff git diff XX ## 查看 XX 文件修改了哪些内容 git diff ## 工作目录和暂存区 git diff --cached ## 暂存区和本地仓库 git diff HEAD ## 工作目录和本地仓库 git diff --stat ## 显示信息摘要 ","date":"2023-07-16","objectID":"/posts/introduction/:2:12","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"rm, mv git rm ## 将文件从暂存区和工作目录删除，-f 为强制删除 git rm filename ## 删除文件 git rm –r dirname ## 删除文件夹 –r 表示递归所有子目录 git rm --cached \u003cpath\u003e ## 将文件从暂存区中删除 git mv \u003cold_path\u003e \u003cnew_path\u003e git rm用来删除文件、目录。git mv命令用于移动或重命名一个文件、目录。 比如删除 photos 文件，本地删除后，远程仓库还会有，所以 git rm -r photos git commit -m \"删除相册\" git push ","date":"2023-07-16","objectID":"/posts/introduction/:2:13","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"submodule git submodule add ## 添加子模组 git submodule init ## 子模组初始化 git submodule update ## 子模组更新 git submodule -help Note 当一个远程库有子模组时，直接 clone 子模组只是一个空文件夹，需要进入子模组的空文件夹init和update才行。 或者使用递归克隆git clone --recursive 远程库 子模组更新后，父模组必须更新，因为需要更新 commit id。 ","date":"2023-07-16","objectID":"/posts/introduction/:2:14","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"tag git tag v1.0 git tag -a v1.0 ## 给最新一次提交打标签 git tag -a \u003ctagname\u003e -m \"标签\" ## 指定标签信息命令 git show \u003ctagname\u003e ## 显示标签信息 git tag ## 查看版本打的 Tag git tag -d v1.0 ## 删除本地标签 git push origin :refs/tags/v1.0 ## 删除远程标签 $ git push [remote] [tag] ## 提交指定 tag $ git push [remote] --tags ## 提交所有 tag Note 当你执行git tag -a命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交 85fc7e7（最后一行），但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * d5e9fc2 (HEAD -\u003e master) Merge branch 'change_site' |\\ | * 7774248 (change_site) changed the runoob.php * | c68142b 修改代码 |/ * c1501a2 removed test.txt、add runoob.php * 3e92c19 add test.txt * 3b58100 (tag: v0.9) 第一次版本提交 ","date":"2023-07-16","objectID":"/posts/introduction/:2:15","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"stash git stash ## 把当前的工作隐藏起来，等以后恢复现场后继续工作 git stash list ## 查看所有被隐藏的文件列表 ","date":"2023-07-16","objectID":"/posts/introduction/:2:16","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"gitk gitk ## git 自带 GUI gitk --all ","date":"2023-07-16","objectID":"/posts/introduction/:2:17","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"github,gitea 等平台 issue 的常用标签 bug 描述的问题是一个 bug enhancement 功能增强，没有 feature 也可以指 New feature or request feature 新功能 duplicate 问题重复 invalid 可用的，不是 bug question 疑问，需要进一步的信息 wontfix 不会修复此问题 help-wanted 需要帮助 good first issue Good for newcomers 更多标签 ","date":"2023-07-16","objectID":"/posts/introduction/:3:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"license ","date":"2023-07-16","objectID":"/posts/introduction/:4:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"其他 常用 Git 命令清单 github 上 fork 了别人的项目后，再同步更新别人的提交 Gearn Git Branching ","date":"2023-07-16","objectID":"/posts/introduction/:5:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/introduction/"},{"categories":["Git"],"content":"git command record as my cheatsheet ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:0","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"1. git rebase ref: https://git-scm.com/docs/git-rebase 用法一:git rebase \u003cbranch-name\u003e 将topic分支的base由E改为master A---B---C topic / D---E---F---G master 运行: git rebase master git rebase master topic 结果: A'--B'--C' topic / D---E---F---G master if upstream branch already has a change like below: A---B---C topic / D---E---A'---F master then run the command git rebase master, you will get following result: B'---C' topic / D---E---A'---F master 用法二:git rebase --onto assume topic is based on next, and next is based on master o---o---o---o---o master \\ o---o---o---o---o next \\ o---o---o topic run the command below: git rebase --onto master next topic then we get the result below: o---o---o---o---o master | \\ | o'--o'--o' topic \\ o---o---o---o---o next Another example: A range of commits could also be removed with rebase. If we have the following situation: E---F---G---H---I---J topicA then the command git rebase --onto topicA~5 topicA~3 topicA would result in the removal of commits F and G: E---H'---I'---J' topicA 用法三:git rebase -i \u003ccommit_id\u003e \u003ccommit_id\u003e $\\mathbb{\\rightarrow}$ 将多个commit合并为一个。 # 执行git log，得到以下commit_ids \u003e\u003e\u003e21fd585 \u003e\u003e\u003e45j3483 \u003e\u003e\u003e9i8975d \u003e\u003e\u003e73c20ec 目标: 将21fd585、45j3483、9i8975d rebase 到 73c20ec git rebase -i 73c20ec 21fd585 得到: pick pick pick pick 改为 pick squash squash squash 最后，编辑commit内容， 得到 \u003e\u003e\u003eb8bec33 # 此处为新的commit \u003e\u003e\u003e73c20ec 推送到remote: git push -f origin master ref: https://www.bilibili.com/video/BV15h411f74h/ https://blog.csdn.net/weixin_45953517/article/details/114362752 https://blog.csdn.net/weixin_44691608/article/details/118740059#t7 遇到detached HEAD的解决办法 git branch b1 git checkout master git merge b1 git push origin master git branch -d b1 ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:1","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"2. git cherrypick 将指定的提交用于其他分支 例如: a - b - c - d Master \\ e - f - g Feature run the command below and apply commit(f) to master git checkout master git cherry-pick f get the result a - b - c - d - f Master \\ e - f - g Feature 转移多个提交 # 将 A 和 B 两个提交应用到当前分支 git cherry-pick \u003cHashA\u003e \u003cHashB\u003e 或者 # 该命令可以转移从 A 到 B 的所有提交,它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。 git cherry-pick A..B # 使用上面的命令，提交 A 将不会包含在 Cherry pick 中， 如果要包含提交 A，可以使用下面的语法。 git cherry-pick A^..B ref:https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:2","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"3. git submodule 将一个repo添加为submodule git submodule add https://github.com/chaconinc/DbConnector 克隆含有子模块的项目 git clone https://github.com/chaconinc/MainProject #此时包含子模块目录，但是其中没有任何文件 cd MainProject cd DbConnector/ # 此时有DbConnector目录，但是文件夹是空的 git submodule init # 用来初始化本地配置文件 git submodule update # 从该项目中抓取并检出父项目中列出的合适的提交 或者 git clone --recurse-submodules https://github.com/chaconinc/MainProject 或者已经克隆了项目，但是忘记--recurse-submodule, 则使用 git submodule update --init --recursive ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:3","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"4. 拉取远程分支到本地 拉取某一个远程的分支，并在创建相应的本地分支名称 git fetch origin remote-branch-name git checkout -b local-branch-name origin/remote-branch-name ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:4","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"5. git tag 用git tag打标签 git tag -a v1.0 git tag -a v0 85fc7e7 #追加标签 git clone 按照tag拉取代码 # git clone --branch [tags标签] [git地址] git clone -b v5.2.0 --depth=1 http://gitlab地址 ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:5","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"6. git stash git stash:隐藏修改 git stash # 隐藏修改 git stash save \"stash-name\" #给每一个stash取名字 git stash pop # 恢复隐藏的修改 git stash list # 列出所有的隐藏 git stash apply [number] # 指定恢复使用哪一个隐藏修改 git stash drop # 移除某一项修改 git stash clear # 删除所有隐藏的修改 git stash show # 查看隐藏的修改 git stash show -p git stash show --patch # 查看特定的stash的diff ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:6","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"7. 代码回退: git reset/git revert ref:https://blog.csdn.net/weixin_35082950/article/details/113629326 本地分支版本回退的方法 git reflog # 找回要回退的版本的commit_id git reset --hard \u003ccommit_id\u003e 自己的远程分支版本回退的方法 # 如果你的错误提交已经推送到自己的远程分支了，那么就需要回滚远程分支了。 # 1. 首先要回退本地分支： git reflog git reset --hard \u003ccommit_id\u003e # 2. 强制推送到远程分支 git push -f 公共远程分支版本回退的问题 一个显而易见的问题：如果你回退公共远程分支，把别人的提交给丢掉了怎么办？ 假设你的远程master分支情况是这样的: A1–A2–B1 # 其中A、B分别代表两个人，A1、A2、B1代表各自的提交。并且所有人的本地分支都已经更新到最新版本，和远程分支一致。 这个时候你发现A2这次提交有错误，你用reset回滚远程分支master到A1，那么理想状态是你的队友一拉代码git pull，他们的master分支也回滚了，然而现实却是，你的队友会看到下面的提示： $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits) nothing to commit, working directory clean 也就是说，你的队友的分支并没有主动回退，而是比远程分支超前了两次提交，因为远程分支回退了嘛。 git revert HEAD #撤销最近一次提交 git revert HEAD~1 #撤销上上次的提交，注意：数字从0开始 git revert 0ffaacc #撤销0ffaacc这次提交 git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。 但是，要注意以下几点： 1、revert 是撤销一次提交，所以后面的commit id是你需要回滚到的版本的前一次提交。 2、使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的。 3、使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。 4、如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了。 git revert 命令的好处就是不会丢掉别人的提交，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了。 revert 合并代码，解决冲突 使用revert命令，如果不是撤销的最近一次提交，那么一定会有冲突，如下所示： 全部清空 第一次提交 解决冲突很简单，因为我们只想回到某次提交，因此需要把当前最新的代码去掉即可，也就是HEAD标记的代码: \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD 全部清空 第一次提交 ======= 把上面部分代码去掉就可以了，然后再提交一次代码就可以解决冲突了。 ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:7","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"8. git branch 将本地分支与远程分支关联: git branch --set-upstream=origin/remote_branch your_branch ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:8","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"9. git commit git commit --amend: 提交小修改但是不增加commit_id: git add . git commmit --amend # 此除可以修改commit message git push origin master ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:9","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"10. git pull 示例: git pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e Examples： 取回origin主机的next分支，与本地的master分支合并 git pull origin next:master 远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。 git pull origin next 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名 git pull origin 如果当前分支只有一个追踪分支，连远程主机名都可以省略 git pull ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:10","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Git"],"content":"11. git clone ","date":"2023-07-16","objectID":"/posts/gitnotes1/:1:11","tags":["draft"],"title":"Git Command Notes","uri":"/posts/gitnotes1/"},{"categories":["Pandas"],"content":"Pandas Notes ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:0:0","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"Input/Output pd.read_csv(filepath): 读取csv文件 ref: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html?highlight=read_csv pd.read_pickle():读取pickle数据 import pandas pandas.read_pickle(filepath_or_buffer, compression='infer', storage_options=None) ref: https://pandas.pydata.org/docs/reference/api/pandas.read_pickle.html Parameters: filepath_or_buffer: 文件名或者文件路径 字符串、路径对象(实现 os.PathLike[str] )或 file-like 对象实现二进制 readlines() 函数。 compression: str or dict, default ‘infer’ 用于on-disk 数据的即时解压缩。如果 ‘infer’ 和 ‘filepath_or_buffer’ 是 path-like，则从以下扩展名检测压缩：“.gz”、“.bz2”、“.zip”、“.xz”或“.zst”(否则不压缩)。如果使用‘zip’，ZIP 文件必须只包含一个要读入的数据文件。设置为None 不解压缩。也可以是键 ‘method’ 设置为 {'zip' , 'gzip' , 'bz2' , 'zstd' } 之一的字典，其他键值对分别转发到 zipfile.ZipFile , gzip.GzipFile , bz2.BZ2File 或 zstandard.ZstdDecompressor 。例如，可以使用自定义压缩字典为 Zstandard 解压缩传递以下内容：compression={‘method’: ‘zstd’, ‘dict_data’: my_compression_dict}。 storage_options: dict, optional 对特定存储连接有意义的额外选项，例如主机、端口、用户名、密码等。对于 HTTP(S) URL，键值对作为标头选项转发到 urllib。对于其他 URL(例如以 “s3://” 和 “gcs://” 开头)，键值对被转发到fsspec 。有关详细信息，请参阅fsspec和urllib。 ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:1:0","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"General functions 通用函数 ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:2:0","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"Series ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:3:0","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"DataFrame DataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。 ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:4:0","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"Constructor DataFrame[data, index, columns, dtype, copy]: 构造一个DataFrame对象 ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:4:1","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"Attributes and underlying data DataFrame.index: 行标签(行信息)-\u003e第0列的信息 DataFrame.columns: 列标签(列信息)-\u003e 第0行的信息 DataFrame.dtypes: 返回DataFrame的数据类型 DataFrame.info([verbose, buf, max_cols, ...]): 返回df的信息 DataFrame.select_dtypes([include, exclude]): 返回DataFrame中根据columns筛选的部分数据 DataFrame.values: 以numpy数组的形式返回数据 DataFrame.axes: 返回一个list，其中是df的axes DataFrame.ndim: 返回int，代表axes/array的数量 DataFrame.shape: 返回tuple, 代表df维度 DataFrame.memory_usage([index, deep]): 返回数据内存使用情况 DataFrame.empty: 判断df是否为空 DataFrame.set_flags(*[, copy, ...]): 返回带有更新标记的df DataFrame.set_flags(*, copy=False, allows_duplicate_labels=None) 参数：allows_duplicate_labels：布尔型，可选。返回的对象是否允许重复标签。 返回：Series或DataFrame, 与调用者相同的类型。 注意：此方法返回一个新对象，该对象是与输入数据相同的视图。改变输入或输出值将反映在另一个中。此方法旨在用于方法链中。“Flags” 与 “metadata” 不同。标志反映了 pandas 对象(Series 或 DataFrame)的属性。元数据是 index 据集的属性，应存储在 DataFrame.attrs 中。 demo: \u003e\u003e\u003e df = pd.DataFrame({\"A\":[1, 2]}) \u003e\u003e\u003e df.flags.allows_duplicate_labels True \u003e\u003e\u003e df2 = df.set_flags(allows_duplicate_labels=False) \u003e\u003e\u003e df2.flags.allows_duplicate_labels False DataFrame.groupby(): ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:4:2","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"Conversion DataFrame.astype(dtype[,copy, errors]):数据类型转换 DataFrame.convert_dtypes([infer_objects, ...]):根据现存数据推断pd.NA数据类型 DataFrame.infer_objects():根据现有数据大部分数据推断类型 DataFrame.copy([deep]):深度拷贝 demo s = pd.Series([1,2], index=[\"a\",\"b\"]) deep = s.copy()# 深拷贝 shallow = s.copy(deep=False) # 浅拷贝 DataFrame.bool():判断数据是ture还是false，只针对单个元素对象 ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:4:3","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Pandas"],"content":"Indexing，iteration DataFrame.head([n]): return the first n rows DataFrame.at[4,'B']: 用标签取值(行名为4，列名为B的值) DataFrame.iat[1,2]: 用行列的整数取值(第1行,第二列的值) DataFrame.loc['cobra':'viper', 'max_speed']: 取行名为’cobra’至’viper’, 列名为’max_speed’的值 DataFrame.iloc: 通过行列的值取值 df.iloc[0]:取第0行，所有列的值，返回series类型 df.iloc[[0]]:取得第0行，所有列的值，返回df类型 df.iloc[[0,1]]:取得第0行和第1行的所有列的值 df.iloc[:3]:取得第0，1，2行的值 df.iloc[[True, False, True]]: 用True/False标记要取的行 df.iloc[lambda x:x.index % 2 == 0]: 用lambda标记要取的行 df.iloc[0,1]:取得第0行，第1列的值 df.iloc[[0,2],[1,3]]: 取得第0行，第2行，第1列，第3列的值 df.iloc[1:3, 0:3]: 取得第1行，第2行，第0列，第1列，第2列的值 df.iloc[:, [True,False,True,False]]:取所有的行，用True/False取相应的列 df.iloc[:,lambda df:[0,2]]: 取所有的行，取第0列，第2列 df.insert(loc, column, value, allow_duplicates=False):插入相应的列 loc:(int), 列的位置 column: 列的名字，一般类型为string value: 列数据的值 df.drop():删除固定的行或者列 df.drop_duplicates(subset, keep, inplace=False,ignore_index=False):删除重复的行或者列 subset: 根据某一列的值，删除行数据 keep: 设置保留第一次出现的数据或者最后一次出现的数据 ","date":"2023-07-15","objectID":"/posts/pandasnotes1/:4:4","tags":["draft"],"title":"Pandas Notes 1","uri":"/posts/pandasnotes1/"},{"categories":["Python"],"content":"python文件相关 ","date":"2023-07-15","objectID":"/posts/pythonnotes1/:1:0","tags":["draft"],"title":"Python Notes 1","uri":"/posts/pythonnotes1/"},{"categories":["Python"],"content":"os.path模块 os.path.exists(): 判断当前目录以及文件是否存在 os.path.mkdir(): 若目录或文件不存在，则创建 import os # 目录 dirs = '/Users/joseph/work/python/' if not os.path.exists(dirs): os.makedirs(dirs) # 文件 filename = '/Users/joseph/work/python/poem.txt' if not os.path.exists(filename): os.system(r\"touch {}\".format(path))#调用系统命令行来创建文件 os.listdir()： 用于返回指定的文件夹包含的文件或文件夹的名字的列表 # 打开文件 path = \"/var/www/html/\" # 如果目录名字为中文 需要转码处理 path = unicode(path,'utf-8') dirs = os.listdir(path) # 输出所有文件和文件夹 for file in dirs: print(file) os.path.join(): 路径拼接 import os path = \"/home\" # Join various path components print(os.path.join(path, \"User/Desktop\", \"file.txt\")) # /home/User/Desktop/file.txt path = \"User/Documents\" # Join various path components print(os.path.join(path, \"/home\", \"file.txt\")) # /home/file.txt # In above example '/home' # represents an absolute path # so all previous components i.e User / Documents # are thrown away and joining continues # from the absolute path component i.e / home. print(os.path.join(path, \"Downloads\", \"file.txt\", \"/home\")) # /home # In above example '/User' and '/home' # both represents an absolute path # but '/home' is the last value # so all previous components before '/home' # will be discarded and joining will # continue from '/home' os.path.abspath(path): 返回绝对路径 os.path.basename(path): 返回文件名 os.path.commonprefix(list): 返回list(多个路径)中，所有path共有的最长的路径 os.path.dirname(path): 返回文件路径 os.path.expanduser(path): 把path中包含的\"~“和”~user\"转换成用户目录 os.path.expandvars(path): 根据环境变量的值替换path中包含的 “$name” 和 “${name}” os.path.getatime(path): 返回最近访问时间(浮点型秒数) os.path.getmtime(path): 返回最近文件修改时间 os.path.getctime(path): 返回文件 path 创建时间 os.path.getsize(path): 返回文件大小，如果文件不存在就返回错误 os.path.isfile(path): 判断路径是否为文件 os.path.isdir(path): 判断路径是否为目录 os.path.islink(path): 判断路径是否为链接 os.path.ismount(path): 判断路径是否为挂载点 os.path.normcase(path): 转换path的大小写和斜杠 os.path.normpath(path): 规范path字符串形式 os.path.realpath(path): 返回path的真实路径 os.path.relpath(path[, start]): 从start开始计算相对路径 os.path.samefile(path1, path2): 判断目录或文件是否相同 os.path.sameopenfile(fp1, fp2): 判断fp1和fp2是否指向同一文件 os.path.samestat(stat1, stat2): 判断stat tuple stat1和stat2是否指向同一个文件 os.path.split(path): 把路径分割成 dirname 和 basename，返回一个元组 os.path.splitdrive(path): 一般用在 windows 下，返回驱动器名和路径组成的元组 os.path.splitext(path): 分割路径，返回路径名和文件扩展名的元组 os.path.splitunc(path): 把路径分割为加载点与文件 os.path.walk(path, visit, arg): 遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数 os.walk(path,topdown=True,onerror=None): 函数返回一个元组，含有三个元素。这三个元素分别是：每次遍历的路径名、路径下子目录列表、目录下文件列表。 path = 'xxx/xxx' for root, dirs, files in os.walk(path): print(root) # path以及path下的目录 print(dirs) # path下的文件夹 print(files) # path下每个文件夹中的文件 区别：os.path.walk()与os.walk()产生的文件名列表并不相同.os.walk()产生目录树下的目录路径和文件路径，而os.path.walk()只产生文件路径（是子目录与文件的混合列表）。 ref: https://www.cnblogs.com/zmlctt/p/4222621.html os.path.supports_unicode_filenames: 设置是否支持unicode路径名 ","date":"2023-07-15","objectID":"/posts/pythonnotes1/:1:1","tags":["draft"],"title":"Python Notes 1","uri":"/posts/pythonnotes1/"},{"categories":["draft"],"content":"ref: [1] https://chenllliang.github.io/2020/02/04/dataloader/ [2] https://blog.csdn.net/zyq12345678/article/details/90268668 [3] https://cloud.tencent.com/developer/article/1877393 ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:0:0","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"Dataset PyTorch为我们提供的两个Dataset和DataLoader类分别负责可被Pytorch使用的数据集的创建以及向训练传递数据的任务。如果想个性化自己的数据集或者数据传递方式，也可以自己重写子类。 Dataset是DataLoader实例化的一个参数，所以这篇文章会先从Dataset的源代码讲起，然后讲到DataLoader，关注主要函数，少细枝末节，目的是使大家学会自定义自己的数据集。 ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:1:0","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"什么时候使用Dataset CIFAR10是CV训练中经常使用到的一个数据集，在PyTorch中CIFAR10是一个写好的Dataset，我们使用时只需以下代码： data = datasets.CIFAR10(\"./data/\", transform=transform, train=True, download=True) datasets.CIFAR10就是一个Datasets子类，data是这个类的一个实例。 我们有的时候需要用自己在一个文件夹中的数据作为数据集，这个时候，我们可以使用ImageFolder这个方便的API。 FaceDataset = datasets.ImageFolder('./data', transform=img_transform) ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:1:1","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"如何定义一个自己的数据集合 torch.utils.data.dataset 是一个表示数据集的抽象类。任何自定义的数据集都需要继承这个类并覆写相关方法。 所谓数据集，其实就是一个负责处理索引(index)到样本(sample)映射的一个类(class)。 Pytorch提供两种数据集： Map式数据集 Iterable式数据集 Map式数据集 一个Map式的数据集必须要重写__getitem__(self, index), len(self) 两个内建方法，用来表示从索引到样本的映射(Map). 这样一个数据集dataset，举个例子，当使用dataset[idx]命令时，可以在你的硬盘中读取你的数据集中第idx张图片以及其标签（如果有的话）;len(dataset)则会返回这个数据集的容量。 例子-1： 自己实验中写的一个例子：这里我们的图片文件储存在“./data/faces/”文件夹下，图片的名字并不是从1开始，而是从final_train_tag_dict.txt这个文件保存的字典中读取，label信息也是用这个文件中读取。大家可以照着上面的注释阅读这段代码。 from torch.utils import data import numpy as np from PIL import Image class face_dataset(data.Dataset): def __init__(self): self.file_path = './data/faces/' f=open(\"final_train_tag_dict.txt\",\"r\") self.label_dict=eval(f.read()) f.close() def __getitem__(self,index): label = list(self.label_dict.values())[index-1] img_id = list(self.label_dict.keys())[index-1] img_path = self.file_path+str(img_id)+\".jpg\" img = np.array(Image.open(img_path)) return img,label def __len__(self): return len(self.label_dict) 下面我们看一下官方MNIST数据集的例子 class MNIST(data.Dataset): \"\"\"`MNIST \u003chttp://yann.lecun.com/exdb/mnist/\u003e`_ Dataset. Args: root (string): Root directory of dataset where ``processed/training.pt`` and ``processed/test.pt`` exist. train (bool, optional): If True, creates dataset from ``training.pt``, otherwise from ``test.pt``. download (bool, optional): If true, downloads the dataset from the internet and puts it in root directory. If dataset is already downloaded, it is not downloaded again. transform (callable, optional): A function/transform that takes in an PIL image and returns a transformed version. E.g, ``transforms.RandomCrop`` target_transform (callable, optional): A function/transform that takes in the target and transforms it. \"\"\" urls = [ 'http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz', ] raw_folder = 'raw' processed_folder = 'processed' training_file = 'training.pt' test_file = 'test.pt' classes = ['0 - zero', '1 - one', '2 - two', '3 - three', '4 - four', '5 - five', '6 - six', '7 - seven', '8 - eight', '9 - nine'] class_to_idx = {_class: i for i, _class in enumerate(classes)} @property def targets(self): if self.train: return self.train_labels else: return self.test_labels def __init__(self, root, train=True, transform=None, target_transform=None, download=False): self.root = os.path.expanduser(root) self.transform = transform self.target_transform = target_transform self.train = train # training set or test set if download: self.download() if not self._check_exists(): raise RuntimeError('Dataset not found.' + ' You can use download=True to download it') if self.train: self.train_data, self.train_labels = torch.load( os.path.join(self.root, self.processed_folder, self.training_file)) else: self.test_data, self.test_labels = torch.load( os.path.join(self.root, self.processed_folder, self.test_file)) def __getitem__(self, index): \"\"\" Args: index (int): Index Returns: tuple: (image, target) where target is index of the target class. \"\"\" if self.train: img, target = self.train_data[index], self.train_labels[index] else: img, target = self.test_data[index], self.test_labels[index] # doing this so that it is consistent with all other datasets # to return a PIL Image img = Image.fromarray(img.numpy(), mode='L') if self.transform is not None: img = self.transform(img) if self.target_transform is not None: target = self.target_transform(target) return img, target def __len__(self): if self.train: return len(self.train_data) else: return len(self.test_data) def _check_exists(self): return os.path.exists(os.path.join(self.root, self.processed_folder, self.training_file)) and \\ os.path.exists(os.path.join(self.root, self.processed_folder, self.test_file)) def download(self): \"\"\"Download the MNIST data if it doesn't exist in processed_folder already.\"\"\" from s","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:1:2","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"Iterable数据集 一个Iterable（迭代）式数据集是抽象类data.IterableDataset的子类，并且覆写了__iter__方法成为一个迭代器。这种数据集主要用于数据大小未知，或者以流的形式的输入，本地文件不固定的情况，需要以迭代的方式来获取样本索引。 关于迭代器与生成器的知识可以参见博主的另一篇文章Python迭代器与生成器介绍及在Pytorch源码中应用[https://chenllliang.github.io/2020/02/06/PyIter/]。 ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:1:3","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"DataLoader Data loader. Combines a dataset and a sampler, and provides an iterable over the given dataset. –PyTorch Documents 一般来说PyTorch中深度学习训练的流程是这样的： 创建Dateset Dataset传递给DataLoader DataLoader迭代产生训练数据提供给模型 对应的一般都会有这三部分代码 # 创建Dateset(可以自定义) dataset = face_dataset # Dataset部分自定义过的face_dataset # Dataset传递给DataLoader dataloader = torch.utils.data.DataLoader(dataset,batch_size=64,shuffle=False,num_workers=8) # DataLoader迭代产生训练数据提供给模型 for i in range(epoch): for index,(img,label) in enumerate(dataloader): pass 到这里应该就PyTorch的数据集和数据传递机制应该就比较清晰明了了。Dataset负责建立索引到样本的映射，DataLoader负责以特定的方式从数据集中迭代的产生 一个个batch的样本集合。在enumerate过程中实际上是dataloader按照其参数sampler规定的策略调用了其dataset的getitem方法。 ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:2:0","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"参数介绍 先看一下实例化一个DataLoader所需的参数，我们只关注几个重点即可。 DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=None, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None) 参数介绍: dataset (Dataset) – 定义好的Map式或者Iterable式数据集。 batch_size (python:int, optional) – 一个batch含有多少样本 (default: 1)。 shuffle (bool, optional) – 每一个epoch的batch样本是相同还是随机 (default: False)。 sampler (Sampler, optional) – 决定数据集中采样的方法. 如果有，则shuffle参数必须为False。 batch_sampler (Sampler, optional) – 和 sampler 类似，但是一次返回的是一个batch内所有样本的index。和 batch_size, shuffle, sampler, and drop_last 三个参数互斥。 num_workers (python:int, optional) – 多少个子程序同时工作来获取数据，多线程。 (default: 0) collate_fn (callable, optional) – 合并样本列表以形成小批量。 pin_memory (bool, optional) – 如果为True，数据加载器在返回前将张量复制到CUDA固定内存中。 drop_last (bool, optional) – 如果数据集大小不能被batch_size整除，设置为True可删除最后一个不完整的批处理。如果设为False并且数据集的大小不能被batch_size整除，则最后一个batch将更小。(default: False) timeout (numeric, optional) – 如果是正数，表明等待从worker进程中收集一个batch等待的时间，若超出设定的时间还没有收集到，那就不收集这个内容了。这个numeric应总是大于等于0。 (default: 0) worker_init_fn (callable, optional) – 每个worker初始化函数 (default: None) dataset 没什么好说的，很重要，需要按照前面所说的两种dataset定义好，完成相关函数的重写。 batch_size 也没啥好说的，就是训练的一个批次的样本数。 shuffle 表示每一个epoch中训练样本的顺序是否相同，一般True。 ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:3:0","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"采样器 sampler 重点参数，采样器，是一个迭代器。PyTorch提供了多种采样器，用户也可以自定义采样器。 所有sampler都是继承 torch.utils.data.sampler.Sampler这个抽象类。 关于迭代器的基础知识在博主这篇文章中可以找到Python迭代器与生成器介绍及在Pytorch源码中应用。[] class Sampler(object): # \"\"\"Base class for all Samplers. # Every Sampler subclass has to provide an __iter__ method, providing a way # to iterate over indices of dataset elements, and a __len__ method that # returns the length of the returned iterators. # \"\"\" # 一个 迭代器 基类 def __init__(self, data_source): pass def __iter__(self): raise NotImplementedError def __len__(self): raise NotImplementedError PyTorch自带的Sampler SequentialSampler RandomSampler SubsetRandomSampler WeightedRandomSampler SequentialSampler 很好理解就是顺序采样器。 其原理是首先在初始化的时候拿到数据集data_source，之后在__iter__方法中首先得到一个和data_source一样长度的range可迭代器。每次只会返回一个索引值。 class SequentialSampler(Sampler): # r\"\"\"Samples elements sequentially, always in the same order. # Arguments: # data_source (Dataset): dataset to sample from # \"\"\" # 产生顺序 迭代器 def __init__(self, data_source): self.data_source = data_source def __iter__(self): return iter(range(len(self.data_source))) def __len__(self): return len(self.data_source) 参数作用: data_source: 同上 num_sampler: 指定采样的数量，默认是所有。 replacement: 若为True，则表示可以重复采样，即同一个样本可以重复采样，这样可能导致有的样本采样不到。所以此时我们可以设置num_samples来增加采样数量使得每个样本都可能被采样到。 class RandomSampler(Sampler): # r\"\"\"Samples elements randomly. If without replacement, then sample from a shuffled dataset. # If with replacement, then user can specify ``num_samples`` to draw. # Arguments: # data_source (Dataset): dataset to sample from # num_samples (int): number of samples to draw, default=len(dataset) # replacement (bool): samples are drawn with replacement if ``True``, default=False # \"\"\" def __init__(self, data_source, replacement=False, num_samples=None): self.data_source = data_source self.replacement = replacement self.num_samples = num_samples if self.num_samples is not None and replacement is False: raise ValueError(\"With replacement=False, num_samples should not be specified, \" \"since a random permute will be performed.\") if self.num_samples is None: self.num_samples = len(self.data_source) if not isinstance(self.num_samples, int) or self.num_samples \u003c= 0: raise ValueError(\"num_samples should be a positive integeral \" \"value, but got num_samples={}\".format(self.num_samples)) if not isinstance(self.replacement, bool): raise ValueError(\"replacement should be a boolean value, but got \" \"replacement={}\".format(self.replacement)) def __iter__(self): n = len(self.data_source) if self.replacement: return iter(torch.randint(high=n, size=(self.num_samples,), dtype=torch.int64).tolist()) return iter(torch.randperm(n).tolist()) def __len__(self): return len(self.data_source) 这个采样器常见的使用场景是将训练集划分成训练集和验证集: class SubsetRandomSampler(Sampler): # r\"\"\"Samples elements randomly from a given list of indices, without replacement. # Arguments: # indices (sequence): a sequence of indices # \"\"\" def __init__(self, indices): self.indices = indices def __iter__(self): return (self.indices[i] for i in torch.randperm(len(self.indices))) def __len__(self): return len(self.indices) batch_sampler 前面的采样器每次都只返回一个索引，但是我们在训练时是对批量的数据进行训练，而这个工作就需要BatchSampler来做。也就是说BatchSampler的作用就是将前面的Sampler采样得到的索引值进行合并，当数量等于一个batch大小后就将这一批的索引值返回。 class BatchSampler(Sampler): # Wraps another sampler to yield a mini-batch of indices. # Args: # sampler (Sampler): Base sampler. # batch_size (int): Size of mini-batch. # drop_last (bool): If ``True``, the sampler will drop the last batch if # its size would be less than ``batch_size`` # Example: # \u003e\u003e\u003e list(BatchSampler(SequentialSampler(range(10)), batch_size=3, drop_last=False)) # [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]] # \u003e\u003e\u003e list(BatchSampler(SequentialSampler(range(10)), batch_size=3, drop_last=True)) # [[0, 1, 2], [3, 4, 5], [6, 7, 8]] # 批次采样 def __init__(self, sampler, batch_size, drop_last): if not isinstance(sampler, Sampler): raise ValueError(\"sampler should be an instance of \" \"torch.utils.data.Sampler, but got sampler={}\" .format(sampler)) if","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:3:1","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"多线程 num_workers 参数表示同时参与数据读取的线程数量，多线程技术可以加快数据读取，提供GPU/CPU利用率。 未来会出一篇文章讲一讲PyTorch多线程实现的原理。 ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:3:2","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"DataLoader 和 Dataset 简单举例 # construct dataset import torch from torch.utils.data import Dataset,DataLoader class MyDataset(Dataset): def __init__(self): self.data = torch.tensor([[1,2,3],[2,3,4],[3,4,5],[4,5,6]]) self.label = torch.LongTensor([1,1,0,0]) def __getitem__(self,index): return self.data[index],self.label[index] def __len__(self): return len(self.data) # dataloader mydataloader = DataLoader(dataset=mydataset, batch_size = 2, shuffle=True) for i, (data, label) in enumerate(mydataloader): print(data, label) ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:3:3","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"DEMO1 - MLP’s Dataset and DataLoader dim_output = 2 class TrainValidDataset(Dataset): ''' Args: - root_dir (string): Directory containing all folders with different dates, each folder containing .cruise.h5 data files. ''' def __init__(self, list_of_files): self.list_of_files_ = list_of_files self.data_size_until_this_file_ = [] self.dataset_size = 0 for file in self.list_of_files_: with h5py.File(file, 'r') as h5_file: data_size = h5_file[list(h5_file.keys())[0]].shape[0] self.dataset_size += data_size self.data_size_until_this_file_.append(self.dataset_size) print ('Total size of dataset: {}'.format(self.data_size_until_this_file_)) def __len__(self): return self.dataset_size def __getitem__(self, index): bin_idx = self.FindBin(index, 0, len( self.data_size_until_this_file_)-1) with h5py.File(self.list_of_files_[bin_idx], 'r') as h5_file: idx_offset = self.data_size_until_this_file_[bin_idx] - \\ h5_file[list(h5_file.keys())[0]].shape[0] data = h5_file[list(h5_file.keys())[0]][index-idx_offset] label = data[-dim_output:] label[0] = (label[0] \u003e 0.0).astype(float) return data[:-dim_output], label # Binary search to expedite the data-loading process. def FindBin(self, index, start, end): if (start == end): return start mid = int((start+end)/2.0) if (self.data_size_until_this_file_[mid] \u003c= index): return self.FindBin(index, mid+1, end) else: return self.FindBin(index, start, mid) # search all the files in the directory def getListOfFiles(dirName): listOfFiles = os.listdir(dirName) allFiles = list() for entry in listOfFiles: fullPath = os.path.join(dirName, entry) if os.path.isdir(fullPath): allFiles = allFiles + getListOfFiles(fullPath) else: allFiles.append(fullPath) return allFiles if __name__ == '__main__': list_of_training_files = getListOfFiles('data') train_dataset = TrainValidDataset(list_of_training_files) myDataLoader = DataLoader(dataset=train_dataset, batch_size=2, drop_last=True, shuffle=True) for i, (data, label) in enumerate(myDataLoader): print(data.shape) ","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:4:0","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["draft"],"content":"DEMO2 - LaneGCN’s Dataset and DataLoader dataset description: class ArgoDataset(Dataset): def __init__(self, split, config, train=True): self.config = config self.train = train if 'preprocess' in config and config['preprocess']: if train: self.split = np.load(self.config['preprocess_train'], allow_pickle=True) else: self.split = np.load(self.config['preprocess_val'], allow_pickle=True) else: self.avl = ArgoverseForecastingLoader(split) self.avl.seq_list = sorted(self.avl.seq_list) self.am = ArgoverseMap() if 'raster' in config and config['raster']: #TODO: DELETE self.map_query = MapQuery(config['map_scale']) def __getitem__(self, idx): if 'preprocess' in self.config and self.config['preprocess']: data = self.split[idx] if self.train and self.config['rot_aug']: new_data = dict() for key in ['city', 'orig', 'gt_preds', 'has_preds']: if key in data: new_data[key] = ref_copy(data[key]) dt = np.random.rand() * self.config['rot_size']#np.pi * 2.0 theta = data['theta'] + dt new_data['theta'] = theta new_data['rot'] = np.asarray([ [np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]], np.float32) rot = np.asarray([ [np.cos(-dt), -np.sin(-dt)], [np.sin(-dt), np.cos(-dt)]], np.float32) new_data['feats'] = data['feats'].copy() new_data['feats'][:, :, :2] = np.matmul(new_data['feats'][:, :, :2], rot) new_data['ctrs'] = np.matmul(data['ctrs'], rot) graph = dict() for key in ['num_nodes', 'turn', 'control', 'intersect', 'pre', 'suc', 'lane_idcs', 'left_pairs', 'right_pairs', 'left', 'right']: graph[key] = ref_copy(data['graph'][key]) graph['ctrs'] = np.matmul(data['graph']['ctrs'], rot) graph['feats'] = np.matmul(data['graph']['feats'], rot) new_data['graph'] = graph data = new_data else: new_data = dict() for key in ['city', 'orig', 'gt_preds', 'has_preds', 'theta', 'rot', 'feats', 'ctrs', 'graph']: if key in data: new_data[key] = ref_copy(data[key]) data = new_data if 'raster' in self.config and self.config['raster']: data.pop('graph') x_min, x_max, y_min, y_max = self.config['pred_range'] cx, cy = data['orig'] region = [cx + x_min, cx + x_max, cy + y_min, cy + y_max] raster = self.map_query.query(region, data['theta'], data['city']) data['raster'] = raster return data data = self.read_argo_data(idx) data = self.get_obj_feats(data) data['idx'] = idx if 'raster' in self.config and self.config['raster']: x_min, x_max, y_min, y_max = self.config['pred_range'] cx, cy = data['orig'] region = [cx + x_min, cx + x_max, cy + y_min, cy + y_max] raster = self.map_query.query(region, data['theta'], data['city']) data['raster'] = raster return data data['graph'] = self.get_lane_graph(data) return data def __len__(self): if 'preprocess' in self.config and self.config['preprocess']: return len(self.split) else: return len(self.avl) def read_argo_data(self, idx): city = copy.deepcopy(self.avl[idx].city) \"\"\"TIMESTAMP,TRACK_ID,OBJECT_TYPE,X,Y,CITY_NAME\"\"\" df = copy.deepcopy(self.avl[idx].seq_df) agt_ts = np.sort(np.unique(df['TIMESTAMP'].values)) mapping = dict() for i, ts in enumerate(agt_ts): mapping[ts] = i trajs = np.concatenate(( df.X.to_numpy().reshape(-1, 1), df.Y.to_numpy().reshape(-1, 1)), 1) steps = [mapping[x] for x in df['TIMESTAMP'].values] steps = np.asarray(steps, np.int64) objs = df.groupby(['TRACK_ID', 'OBJECT_TYPE']).groups keys = list(objs.keys()) obj_type = [x[1] for x in keys] agt_idx = obj_type.index('AGENT') idcs = objs[keys[agt_idx]] agt_traj = trajs[idcs] agt_step = steps[idcs] del keys[agt_idx] ctx_trajs, ctx_steps = [], [] for key in keys: idcs = objs[key] ctx_trajs.append(trajs[idcs]) ctx_steps.append(steps[idcs]) data = dict() data['city'] = city data['trajs'] = [agt_traj] + ctx_trajs data['steps'] = [agt_step] + ctx_steps return data def get_obj_feats(self, data): orig = data['trajs'][0][19].copy().astype(np.float32) if self.train and self.config['rot_aug']: theta = np.random.rand() * np.pi * 2.0 else: pre = data['trajs'][0][18] - orig theta = np.pi - np.arctan2(pre[1], pre[0]) rot = np.asarray([ [np.cos(theta), -np","date":"2023-07-15","objectID":"/posts/datasetanddataloader/:5:0","tags":["draft"],"title":"PyTorch Dataset And DataLoader","uri":"/posts/datasetanddataloader/"},{"categories":["PyTorch"],"content":"Torch 基本函数 ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:1:0","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"1. torch.einsum() torch.einsum(equation, *operands)-\u003eTensor:爱因斯坦求和 ref1: 算子部署: https://blog.csdn.net/HW140701/article/details/120654252 ref2: 例子: https://zhuanlan.zhihu.com/p/361209187 三条基本规则: 规则一: equation 箭头左边，在不同输入之间重复出现的索引表示，把输入张量沿着该维度做乘法操作，比如还是以上面矩阵乘法为例， “ik,kj-\u003eij”，k 在输入中重复出现，所以就是把 a 和 b 沿着 k 这个维度作相乘操作； 规则二: 只出现在 equation 箭头左边的索引，表示中间计算结果需要在这个维度上求和，也就是上面提到的求和索引； 规则三: equation 箭头右边的索引顺序可以是任意的，比如上面的 “ik,kj-\u003eij” 如果写成 “ik,kj-\u003eji”，那么就是返回输出结果的转置，用户只需要定义好索引的顺序，转置操作会在 einsum 内部完成 特殊规则: equation 可以不写包括箭头在内的右边部分，那么在这种情况下，输出张量的维度会根据默认规则推导。就是把输入中只出现一次的索引取出来，然后按字母表顺序排列，比如上面的矩阵乘法 “ik,kj-\u003eij” 也可以简化为 “ik,kj”，根据默认规则，输出就是 “ij” 与原来一样； equation 中支持 “…” 省略号，用于表示用户并不关心的索引。比如只对一个高维张量的最后两维做转置可以这么写： a = torch.randn(2,3,5,7,9) # i = 7, j = 9 b = torch.einsum('...ij-\u003e...ji', [a]) ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:1:1","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"2. torch.permute()/torch.transpose() torch.permute(dim0, dim1, dim2):用于调换不同维度的顺序 torch.transpose(input, dim0, dim1):交换矩阵的两个维度 ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:1:2","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"3. torch.rand() torch.rand(dim0, dim1):生成dim0 x dim1的tensor ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:1:3","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"4. torch.size()/torch.shape torch.size():返回tensor的size torch.shape:返回tensor的size ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:1:4","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"5. torch.tensordot() ref: tensordot()和einsum()的区别: https://blog.csdn.net/Eric_1993/article/details/105670381 torch.tensordot(tensor1， tensor2， axes=([dim1,dim2],[dim0, dim1])): 将axes指定的子数组进行点乘, axes 指定具体的维度. ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:1:5","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"6. torch.transpose() torch.transpose(tensor, dim0, dim2) —\u003e Tensor:在dim0和dim1方向上转置 ###7. torch.index_add_() Tensor.index_add_(dim, index, source, *, alpha=1) → Tensor demo: \u003e\u003e\u003e x = torch.ones(5, 3) \u003e\u003e\u003e t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float) \u003e\u003e\u003e index = torch.tensor([0, 4, 2]) \u003e\u003e\u003e x.index_add_(0, index, t) tensor([[ 2., 3., 4.], [ 1., 1., 1.], [ 8., 9., 10.], [ 1., 1., 1.], [ 5., 6., 7.]]) \u003e\u003e\u003e x.index_add_(0, index, t, alpha=-1) tensor([[ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]]) ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:1:6","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"Torch NN Module import torch from torch import nn from torch import functional as F ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:2:0","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"1. nn.Conv1d() torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', device=None, dtype=None) Shape: - Input: $(N, C_{in}, L_{in})$ or $(C_{in}, L_{in})$ - Output: $(N, C_{in}, L_{in})$ or $(C_{in}, L_{in})$, where $$L_{out} = \\frac{L_{in} + 2 \\cdot \\text{padding} - \\text{dilation} \\cdot (\\text{kernel_size} - 1) - 1}{stride}$$ Demo: m = nn.Conv1d(16, 33, 3, stride=2) input = torch.randn(20, 16, 50) # B x C x H or N x C x L output = m(input) print(output.shape) # torch.Size([20, 33, 24]) ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:2:1","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"2. nn.Conv2d() torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', device=None, dtype=None) Shape: Input: $(N, C_{\\text in}, H_{\\text in}, W_{\\text in})$ or $(C_{\\text in}, H_{\\text in}, W_{\\text in})$ - Output: $(N, C_{\\text out}, H_{\\text out}, W_{\\text out})$ or $(C_{\\text out}, H_{\\text out}, W_{\\text out})$, where $$ H_{out} = \\frac{H_{in} + 2 \\cdot \\text{padding[0]} - \\text{dilation[0]} \\cdot (\\text{kernel_size[0]} - 1) - 1}{stride[0]} + 1 $$ $$ W_{out} = \\frac{W_{in} + 2 \\cdot \\text{padding[1]} - \\text{dilation[1]} \\cdot (\\text{kernel_size[1]} - 1) - 1}{stride[1]} + 1 $$ Demo: # With square kernels and equal stride m = nn.Conv2d(16, 33, 3, stride=2) # non-square kernels and unequal stride and with padding m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2)) # output.shape: 20 x 33 x 28 x 100 # non-square kernels and unequal stride and with padding and dilation m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1)) # output.shape: 20 x 33 x 26 x 100 input = torch.randn(20, 16, 50, 100) output = m(input) # ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:2:2","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"3. nn.functional.interpolate() torch.nn.functional.interpolate(input, size=None, scale_factor=None, mode='nearest', align_corners=None, recompute_scale_factor=None, antialias=False) ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:2:3","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"4. nn.functional.ReLU() $$ \\text{ReLU} = (x)^+ = \\max {(0,x)}$$ torch.nn.ReLU(inplace=False) 作用: Sigmoid的导数只有在0附近的时候有比较好的激活性，在正负饱和区的梯度都接近于0，所以这会造成梯度弥散，而ReLU函数在大于0的部分梯度为常数，所以不会产生梯度弥散现象。 ReLU函数在负半区的导数为0 ，所以一旦神经元激活值进入负半区，那么梯度就会为0，而正值不变，这种操作被成为单侧抑制。（也就是说：在输入是负值的情况下，它会输出0，那么神经元就不会被激活。这意味着同一时间只有部分神经元会被激活，从而使得网络很稀疏，进而对计算来说是非常有效率的。）正因为有了这单侧抑制，才使得神经网络中的神经元也具有了稀疏激活性。尤其体现在深度神经网络模型(如CNN)中，当模型增加N层之后，理论上ReLU神经元的激活率将降低2的N次方倍。 relu函数的导数计算更快，程序实现就是一个if-else语句，而sigmoid函数要进行浮点四则运算。 Shape: Input: $(∗)$, where $*$ means any number of dimensions. Output: $(∗)$, same shape as the input. Demo: m = nn.ReLU() input = torch.randn(2) output = m(input) # An implementation of CReLU - https://arxiv.org/abs/1603.05201 m = nn.ReLU() input = torch.randn(2).unsqueeze(0) output = torch.cat((m(input),m(-input))) ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:2:4","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"5. nn.MaxPool2d() torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False) Shape: Input: $(N, C, H_{in}, W_{in})$ or $(C, H_{in}, W_{in})$ Output: $(N, C, H_{out}, W_{out})$ or $(C, H_{out}, W_{out})$ where, $$ H_{out} = \\frac{H_{in} + 2 * \\text{padding}[0] - \\text{dilation}[0] * (\\text{kernel_size}[0]-1) - 1}{\\text{stride}[0]} + 1$$ $$ W_{out} = \\frac{W_{in} + 2 * \\text{padding}[1] - \\text{dilation}[1] * (\\text{kernel_size}[1]-1) - 1}{\\text{stride}[1]} + 1$$ demo: # pool of square window of size=3, stride=2 m = nn.MaxPool2d(3, stride=2) # pool of non-square window m = nn.MaxPool2d((3, 2), stride=(2, 1)) input = torch.randn(20, 16, 50, 32) output = m(input) # 20 16 24 31 ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:2:5","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"6. nn.AvgPool2d() torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True, divisor_override=None) Shape: Input: $(N, C, H_{in}, W_{in})$ or $(C, H_{in}, W_{in})$ Output: $(N, C, H_{out}, W_{out})$ or $(C, H_{out}, W_{out})$ where, $$ H_{out} = \\frac{H_{in} + 2 * \\text{padding}[0] - (\\text{kernel_size}[0])}{\\text{stride}[0]} + 1$$ $$ W_{out} = \\frac{W_{in} + 2 * \\text{padding}[1] - (\\text{kernel_size}[1])}{\\text{stride}[1]} + 1$$ demo: # pool of square window of size=3, stride=2 m = nn.AvgPool2d(3, stride=2) # pool of non-square window m = nn.AvgPool2d((3, 2), stride=(2, 1)) input = torch.randn(20, 16, 50, 32) output = m(input) # 20 16, 24 31 ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:2:6","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["PyTorch"],"content":"torch.cuda ref link: https://zhuanlan.zhihu.com/p/76908135 torch.cuda.current_device(): 返回当前选择的设备的索引 torch.cuda.current_stream(): 返回参数设备的当前的Stream torch.cuda.default_stream(): 返回当前参数设备的Stream CLASS torch.cuda.device: 可以改变选择的设备的上下文管理器 Parameters：device (torch.device or int) – device index to select. It’s a no-op if this argument is a negative integer or None. torch.cuda.device_count(): 返回可使用GPU的数量 CLASS torch.cuda.device_of(obj) Context-manager 将参数对象的设备改成当前的设备。你可以使用张量或者存储作为参数。如果传入的对象没有分配在GPU上，这个操作是无效的。 torch.cuda.empty_cache() 释放caching allocator当前持有的所有未占用的cached memory，使其可以用在其他GPU应用且可以在 nvidia-smi可视化。 注意：empty_cache() 并不会增加PyTorch可以使用的GPU显存的大小。 查看 Memory management 来获取更多的GPU显存管理的信息。 torch.cuda.get_device_capability(device=None) Gets the cuda capability of a device. Parameters：device (torch.device or int, optional) – device for which to return the device capability. This function is a no-op if this argument is a negative integer. It uses the current device, given bycurrent_device(), if device is None (default). Returns：the major and minor cuda capability of the device Return type ： tuple(int, int) torch.cuda.get_device_name(device=None) torch.cuda.init() 初始化PyTorch的CUDA状态。如果你通过C API与PyTorch进行交互，你可能需要显式调用这个方法。只有CUDA的初始化完成，CUDA的功能才会绑定到Python。用户一般不应该需要这个，因为所有PyTorch的CUDA方法都会自动在需要的时候初始化CUDA。如果CUDA的状态已经初始化了，将不起任何作用。 [torch.cuda.is_available()] torch.cuda.max_memory_allocated(device=None) Returns the maximum GPU memory occupied by tensors in bytes for a given device. torch.cuda.max_memory_cached(device=None) torch.cuda.memory_allocated(device=None) Parameters：device (torch.device or int, optional) – selected device. Returns statistic for the current device, given by current_device(), if device is None (default). torch.cuda.memory_cached(devide=None) [``] ","date":"2023-07-15","objectID":"/posts/pytorchnotes/:3:0","tags":["draft"],"title":"PyTorch Notes","uri":"/posts/pytorchnotes/"},{"categories":["ML"],"content":"ref: [1] https://www.cnblogs.com/rushup0930/p/13359513.html [2] https://blog.csdn.net/u013250861/article/details/123029585#t12 [3] https://blog.csdn.net/wf592523813/article/details/95202448 [4] https://zhuanlan.zhihu.com/p/69101372 classification 分类 主要涉及的知识点： 混淆矩阵、Precision(精准率)、Recall(召回率)、Accuracy(准确率)、F1-score （包括二分类和多分类问题） ROC、AUC 最常见的指标Accuracy到底有哪些不足？ 解: Accuracy是分类问题中最常用的指标，它计算了分类正确的预测数与总预测数的比值。但是，对于不平衡数据集而言，Accuracy并不是一个好指标。 假设我们有100张图片，其中91张图片是「狗」，5张是「猫」，4张是「猪」，我们希望训练一个三分类器，能正确识别图片里动物的类别。其中，狗这个类别就是大多数类 (majority class)。当大多数类中样本（狗）的数量远超过其他类别（猫、猪）时，如果采用Accuracy来评估分类器的好坏，那么即便模型性能很差 (如无论输入什么图片，都预测为「狗」)，也可以得到较高的Accuracy Score (如91%)。此时，虽然Accuracy Score很高，但是意义不大。当数据异常不平衡时，Accuracy评估方法的缺陷尤为显著。 ","date":"2023-07-15","objectID":"/posts/metrics/:0:0","tags":["draft"],"title":"Classification and Regression Metrics","uri":"/posts/metrics/"},{"categories":["ML"],"content":"二分类模型的常见指标 在二分类问题中，假设该样本一共有两种类别：Positive和Negative。当分类器预测结束，我们可以绘制出混淆矩阵（confusion matrix）。其中分类结果分为如下几种： True Positive (TP): 把正样本成功预测为正。 True Negative (TN)：把负样本成功预测为负。 False Positive (FP)：把负样本错误地预测为正。 False Negative (FN)：把正样本错误的预测为负。 一个小技巧， 第一个字母表示划分正确与否， T 表示判定正确（判定正确）， F表示判定错误(False)； 第二个字母表示分类器判定结果， P表示判定为正例， N表示判定为负例。 在二分类模型中，Accuracy，Precision，Recall和F1 score的定义如下： $$\\text{Accuracy} = \\frac{TP + TN}{TP + TN + FP + FN}$$ Accuracy 能够清晰的判断我们模型的表现，但有一个严重的缺陷： 在正负样本不均衡的情况下，占比大的类别往往会成为影响 Accuracy 的最主要因素，此时的 Accuracy 并不能很好的反映模型的整体情况。 $$\\text{Precision} = \\frac{TP}{TP + FP}$$ Precision着重评估在预测为Positive的所有数据中，真实Positve的数据到底占多少？ 精确率高，意味着分类器要尽量在 “更有把握” 的情况下才将样本预测为正样本， 这意味着精确率能够很好的体现模型对于负样本的区分能力，精确率越高，则模型对负样本区分能力越强。 $$\\text{Recall} = \\frac{TP}{TP + FN}$$ Recall着重评估：在所有的Positive数据中，到底有多少数据被成功预测为Positive 召回率高，意味着分类器尽可能将有可能为正样本的样本预测为正样本，这意味着召回率能够很好的体现模型对于正样本的区分能力，召回率越高，则模型对正样本的区分能力越强。 举例: 一个医院新开发了一套癌症AI诊断系统，想评估其性能好坏。我们把病人得了癌症定义为Positive，没得癌症定义为Negative。那么， 到底该用什么指标进行评估呢？ 如用Precision对系统进行评估，那么其回答的问题就是： 在诊断为癌症的一堆人中，到底有多少人真得了癌症？ 如用Recall对系统进行评估，那么其回答的问题就是： 在一堆得了癌症的病人中，到底有多少人能被成功检测出癌症？ 如用Accuracy对系统进行评估，那么其回答的问题就是： 在一堆癌症病人和正常人中，有多少人被系统给出了正确诊断结果（患癌或没患癌）？ 那啥时候应该更注重Recall而不是Precision呢？ 当False Negative (FN)的成本代价很高 (后果很严重)，希望尽量避免产生FN时，应该着重考虑提高Recall指标。 那啥时候应该更注重Precision而不是Recall呢？ 当False Positive (FP)的成本代价很高 (后果很严重)时，即期望尽量避免产生FP时，应该着重考虑提高Precision指标。 $$\\text{F1-score} = \\frac{2 \\times Precision \\times Recall}{Precision + Recall}$$ 而F1-score是Precision和Recall两者的综合。 举个更有意思的例子（我拍脑袋想出来的，绝对原创哈），假设检察机关想将罪犯捉拿归案，需要对所有人群进行分析，以判断某人犯了罪（Positive），还是没犯罪（Negative）。显然，检察机关希望不漏掉一个罪人（提高recall），也不错怪一个好人（提高precision），所以就需要同时权衡recall和precision两个指标。 尤其在上个世纪，中国司法体制会更偏向Recall，即「天网恢恢，疏而不漏，任何罪犯都插翅难飞」。而西方司法系统会更偏向Precision，即「绝不冤枉一个好人，但是难免有罪犯成为漏网之鱼，逍遥法外」。到底是哪种更好呢？显然，极端并不可取。Precision和Recall都应该越高越好，也就是F1应该越高越好。 如何通俗的解释召回率与精确率？ 例：公园里有50只皮卡丘和10只臭臭泥。有正常审美的人都会想要用精灵球把尽可能多的皮卡丘抓回来，同时尽可能少地抓住臭臭泥。 最终我们的精灵球成功抓回来了45只皮卡丘和10只臭臭泥。 我们就可以说50只皮卡丘中有45只被召唤 (call) 回来 (re) 了，所以 recall = 45 / 50。 但同时，这台机器还误把5只臭臭泥识别为皮卡丘，在它抓回来的所有55只神奇宝贝中，精灵球对皮卡丘判断的精准性 (precision) = 45 / 55。 在上面的例子中，精灵球=预测模型，皮卡丘=正样本，臭臭泥=负样本。 总结这两个概念的用处：描述模型对正样本的预测性能 1、recall描述模型“把正样本叫 (call) 回来(re)”的能力。 2、precision描述模型“叫回来的正样本”有多少是精确的。 ","date":"2023-07-15","objectID":"/posts/metrics/:1:0","tags":["draft"],"title":"Classification and Regression Metrics","uri":"/posts/metrics/"},{"categories":["ML"],"content":"AOC / AUC 混淆矩阵中有着Positive、Negative、True、False的概念，其意义如下： 称预测类别为1的为Positive（阳性），预测类别为0的为Negative（阴性）。 预测正确的为True（真），预测错误的为False（伪）。 对上述概念进行组合，就产生了如下的混淆矩阵: 然后，由此引出True Positive Rate（真阳率）、False Positive（伪阳率）两个概念： $$TP Rate = \\frac{TP}{TP + FN}$$ $$FP Rate = \\frac{FP}{FP + TN}$$ 仔细看这两个公式，发现其实TPRate就是TP除以TP所在的列，FPRate就是FP除以FP所在的列，二者意义如下： TPRate的意义是所有真实类别为1的样本中，预测类别为1的比例。 FPRate的意义是所有真实类别为0的样本中，预测类别为1的比例。 如果上述概念都弄懂了，那么ROC曲线和AUC就so easy了： 按照定义，AUC即ROC曲线下的面积，而ROC曲线的横轴是FPRate，纵轴是TPRate，当二者相等时，即y=x，如下图: 表示的意义是：对于不论真实类别是1还是0的样本，分类器预测为1的概率是相等的。 换句话说，分类器对于正例和负例毫无区分能力，和抛硬币没什么区别，一个抛硬币的分类器是我们能想象的最差的情况，因此一般来说我们认为AUC的最小值为0.5（当然也存在预测相反这种极端的情况，AUC小于0.5，这种情况相当于分类器总是把对的说成错的，错的认为是对的，那么只要把预测类别取反，便得到了一个AUC大于0.5的分类器）。 而我们希望分类器达到的效果是：对于真实类别为1的样本，分类器预测为1的概率（即TPRate），要大于真实类别为0而预测类别为1的概率（即FPRate），即y＞x，因此大部分的ROC曲线长成下面这个样子： 说了这么多还是不够直观，不妨举个简单的例子。 首先对于硬分类器（例如SVM，NB），预测类别为离散标签，对于8个样本的预测情况如下： 得到混淆矩阵如下： 进而算得TPRate=3/4，FPRate=2/4，得到ROC曲线： 最终得到AUC为0.625。 对于LR等预测类别为概率的分类器，依然用上述例子，假设预测结果如下： 这时，需要设置阈值来得到混淆矩阵，不同的阈值会影响得到的TPRate，FPRate，如果阈值取0.5，小于0.5的为0，否则为1，那么我们就得到了与之前一样的混淆矩阵。其他的阈值就不再啰嗦了。依次使用所有预测值作为阈值，得到一系列TPRate，FPRate，描点，求面积，即可得到AUC。 最后说说AUC的优势，AUC的计算方法同时考虑了分类器对于正例和负例的分类能力，在样本不平衡的情况下，依然能够对分类器作出合理的评价。 例如在反欺诈场景，设欺诈类样本为正例，正例占比很少（假设0.1%），如果使用准确率评估，把所有的样本预测为负例，便可以获得99.9%的准确率。 但是如果使用AUC，把所有样本预测为负例，TPRate和FPRate同时为0（没有Positive），与(0,0) (1,1)连接，得出AUC仅为0.5，成功规避了样本不均匀带来的问题。 ","date":"2023-07-15","objectID":"/posts/metrics/:2:0","tags":["draft"],"title":"Classification and Regression Metrics","uri":"/posts/metrics/"},{"categories":["ML"],"content":"多分类模型的常见指标详细解析 在多分类（大于两个类）问题中，假设我们要开发一个动物识别系统，来区分输入图片是猫，狗还是猪。给定分类器一堆动物图片，产生了如下结果混淆矩阵。 在混淆矩阵中，正确的分类样本（Actual label = Predicted label）分布在左上到右下的对角线上。其中，Accuracy的定义为分类正确（对角线上）的样本数与总样本数的比值。Accuracy度量的是全局样本预测情况。而对于Precision和Recall而言，每个类都需要单独计算其Precision和Recall。 classify_multiclass_prediction 比如，对类别「猪」而言，其Precision和Recall分别为: $$\\text{Precision} = \\frac{TP}{TP + FP} = \\frac{20}{20 + 50} = \\frac{2}{7}$$ $$\\text{Recall} = \\frac{TP}{TP + FN} = \\frac{20}{10} = \\frac{2}{3}$$ 也就是: $$P_{cat} = \\frac{8}{15}, P_{dog} = \\frac{17}{23}, P_{pig} = \\frac{2}{7}, (P代表Precision) $$ $$R_{cat} = \\frac{4}{7}, R_{dog} = \\frac{17}{32}, R_{pig} = \\frac{2}{3}, (R代表Recall) $$ 如果想评估该识别系统的总体功能，必须考虑猫、狗、猪三个类别的综合预测性能。那么，到底要怎么综合这三个类别的Precision呢？是简单加起来做平均吗？通常来说， 我们有如下几种解决方案（也可参考scikit-learn官网）： 1. Macro-average方法 该方法最简单，直接将不同类别的评估指标（Precision/ Recall/ F1-score）加起来求平均，给所有类别相同的权重。该方法能够平等看待每个类别，但是它的值会受稀有类别影响。 $$\\text{Macro-Precision} = \\frac{P_{cat} + P_{dog} + P_{pig}}{3} = 0.5194$$ $$\\text{Macro-Recall} = \\frac{R_{cat} + R_{dog} + R_{pig}}{3} = 0.5898$$ 2. Weighted-average方法 该方法给不同类别不同权重（权重根据该类别的真实分布比例确定），每个类别乘权重后再进行相加。该方法考虑了类别不平衡情况，它的值更容易受到常见类（majority class）的影响。 $$W_{cat} : W_{dog} : W_{pig} = N_{cat} : N_{dog} : N_{pig} = \\frac{7}{26} : \\frac{16}{26} : \\frac{3}{26} (W代表权重，N代表样本在该类别下的真实数目)$$ $$\\text{Weighted-Precision} = P_{cat} \\times W_{cat} + P_{dog} \\times W_{dog} + P_{pig} \\times W_{pig} = 0.6314$$ $$\\text{Weighted-Recall} = {R_{cat} \\times W_{cat} + R_{dog} \\times W_{dog} + R_{pig} \\times W_{pig}}= 0.5577$$ 3. Micro-average方法 该方法把每个类别的TP, FP, FN先相加之后，在根据二分类的公式进行计算。 $$\\text{Micro-Precision} = \\frac{TP_{cat} + TP_{dog} + TP_{pig}}{TP_{cat} + TP_{dog} + TP_{pig} + FP_{cat} + FP_{dog} + FP_{pig}} = 0.5577$$ $$\\text{Micro-Recall} = \\frac{TP_{cat} + TP_{dog} + TP_{pig}}{TP_{cat} + TP_{dog} + TP_{pig} + FN_{cat} + FN_{dog} + FN_{pig}} = 0.5577$$ 其中，特别有意思的是，Micro-precision 和 Micro-recall竟然始终相同！这是为啥呢？ 这是因为在某一类中的False Positive样本，一定是其他某类别的False Negative样本。听起来有点抽象？举个例子，比如说系统错把「狗」预测成「猫」，那么对于狗而言，其错误类型就是False Negative，对于猫而言，其错误类型就是False Positive。于此同时，Micro-precision和Micro-recall的数值都等于Accuracy，因为它们计算了对角线样本数和总样本数的比值，总结就是 $$\\text{Micro-Precision} = \\text{Micro-Recall} = \\text{Micro-F1 score} = \\text{Accuracy}$$ demo示例: import numpy as np import seaborn as sns from sklearn.metrics import confusion_matrix import pandas as pd import matplotlib.pyplot as plt from sklearn.metrics import accuracy_score, average_precision_score,precision_score,f1_score,recall_score # create confusion matrix y_true = np.array([-1]*70 + [0]*160 + [1]*30) y_pred = np.array([-1]*40 + [0]*20 + [1]*20 + [-1]*30 + [0]*80 + [1]*30 + [-1]*5 + [0]*15 + [1]*20) cm = confusion_matrix(y_true, y_pred) conf_matrix = pd.DataFrame(cm, index=['Cat','Dog','Pig'], columns=['Cat','Dog','Pig']) # plot size setting fig, ax = plt.subplots(figsize = (4.5,3.5)) sns.heatmap(conf_matrix, annot=True, annot_kws={\"size\": 19}, cmap=\"Blues\") plt.ylabel('True label', fontsize=18) plt.xlabel('Predicted label', fontsize=18) plt.xticks(fontsize=18) plt.yticks(fontsize=18) plt.savefig('confusion.pdf', bbox_inches='tight') plt.show() print('------Weighted------') print('Weighted precision', precision_score(y_true, y_pred, average='weighted')) print('Weighted recall', recall_score(y_true, y_pred, average='weighted')) print('Weighted f1-score', f1_score(y_true, y_pred, average='weighted')) print('------Macro------') print('Macro precision', precision_score(y_true, y_pred, average='macro')) print('Macro recall', recall_score(y_true, y_pred, average='macro')) print('Macro f1-score', f1_score(y_true, y_pred, average='macro')) print('------Micro------') print('Micro precision', precision_score(y_true, y_pred, average='micro')) print('Micro recall', recall_score(y_true, y_pred, average='micro')) print('Micro f1-score', f1_score(y_true, y_pred, average='micro')) Regression 回归 回归算法的评价指标就是MSE，RMSE，MAE、R-Squared。 MSE和MAE适用于误差相对明显的时候，大的误差也有比较高的权重，RMSE则是针对误差不是很明显的时候；MAE是一个线性的指标，所有个体差异在平均值上均等加权，所以它更加凸显出异常值，相比MSE； RMSLE: 主要针对数据集中有一个特别大的异常值，这种情况下，data会被s","date":"2023-07-15","objectID":"/posts/metrics/:3:0","tags":["draft"],"title":"Classification and Regression Metrics","uri":"/posts/metrics/"},{"categories":["ML"],"content":"用pickle保存和加载模型 保存模型 import pickle from sklearn.svm import SVC model_dir = './model.pkl' model = SVC() with open(model_dir, 'wb') as f: pickle.dump(model, f) f.close() # 注意:保存完模型之后要关闭文件 加载模型 import pickle model_dir = './model.pkl' with open(model_dir, 'rb') as f: model = pickel.load(f) print(mode.predict(x)) ","date":"2023-07-15","objectID":"/posts/notes_1/:1:0","tags":["draft"],"title":"Maching Learning Notes 1","uri":"/posts/notes_1/"},{"categories":["ML"],"content":"逻辑回归 Logistic Regression LR Implementation code snippets from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score import numpy as np import matplotlib.pyplot as plt import pickle from tqdm import tqdm data_path = './data/merged_data/data.npy' data = np.load(data_path, allow_pickle=True) model_l1_path='./model/logistic_reg_l1.pickle' model_l2_path='./model/logictic_reg_l2.pickle' X = data[:,0:35] y = data[:, -1] X_train, x_test, Y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1) # lr_l1 = LogisticRegression(penalty=\"l1\", C=0.5, solver='sag', multi_class=\"auto\") # lr_l2 = LogisticRegression(penalty=\"l2\", C=0.5, solver='sag', multi_class=\"auto\") # # train model # lr_l1.fit(X_train, Y_train) # lr_l2.fit(X_train, Y_train) # model performence on train set l1_train_predict = [] l2_train_predict = [] # model performence on test set l1_test_predict = [] l2_test_predict = [] for c in tqdm(np.linspace(0.01, 2, 50)): # lr_l1 = LogisticRegression(penalty=\"l1\", C=c, solver='liblinear', max_iter=1000) # lr_l2 = LogisticRegression(penalty='l2', C=c, solver='liblinear', max_iter=1000) lr_l1 = LogisticRegression(penalty=\"l1\", C=c, solver='liblinear', max_iter=1000, multi_class='auto') lr_l2 = LogisticRegression(penalty='l2', C=c, solver='liblinear', max_iter=1000, multi_class='auto') # 训练模型，记录L1正则化模型在训练集测试集上的表现 lr_l1.fit(X_train, Y_train) l1_train_predict.append(accuracy_score(lr_l1.predict(X_train), Y_train)) l1_test_predict.append(accuracy_score(lr_l1.predict(x_test), y_test)) # 记录L2正则化模型的表现 lr_l2.fit(X_train, Y_train) l2_train_predict.append(accuracy_score(lr_l2.predict(X_train), Y_train)) l2_test_predict.append(accuracy_score(lr_l2.predict(x_test), y_test)) if c == 2: pred_y_test = lr_l2.predict(x_test) mask = abs(pred_y_test-y_test) \u003c 5 neg_test = pred_y_test[mask] res = (len(neg_test)/len(pred_y_test)) print(res) with open(model_l1_path, 'wb') as f1: pickle.dump(lr_l1, f1) with open(model_l2_path, 'wb') as f2: pickle.dump(lr_l2, f2) data = [l1_train_predict, l2_train_predict, l1_test_predict, l2_test_predict] label = ['l1_train', 'l2_train', 'l1_test', \"l2_test\"] color = ['red', 'green', 'orange', 'blue'] plt.figure(figsize=(12, 6)) for i in range(4) : plt.plot(np.linspace(0.01, 2, 50), data[i], label=label[i], color=color[i]) plt.legend(loc=\"best\") plt.show() ","date":"2023-07-15","objectID":"/posts/notes_1/:2:0","tags":["draft"],"title":"Maching Learning Notes 1","uri":"/posts/notes_1/"},{"categories":["ML"],"content":"支持向量机 Support Vector Machine Using GridSearch to find the best parameters [code snippets] import numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import Perceptron, LogisticRegression from sklearn.svm import SVC from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn import datasets from sklearn import metrics import pickle merged_data_dir = '../data/merged_data/merged_data.npy' model_dir='./svm.pkl' data = np.load(merged_data_dir, allow_pickle=True) #labeling for ele in data: if ele[-1] \u003c 20: ele[-1] = 0 elif ele[-1] \u003e=20 and ele[-1] \u003c 40: ele[-1] = 1 else: ele[-1] = 2 X = data[:,0:34] y = data[:,-1] print(y) # Create training and test split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1, stratify=y) # feature scaling # sc = StandardScaler() # sc.fit(X_train) # X_train_std = sc.transform(X_train) # X_test_std = sc.transform(X_test) ################################## # # Instantiate the Support Vector Classifier (SVC) # svc = SVC(C=10, random_state=1, kernel='rbf', gamma=0.3) # # Fit the model # svc.fit(X_train, y_train) # # Make the predictions # y_predict = svc.predict(X_test) # # Measure the performance # print(\"Accuracy score %.3f\" %metrics.accuracy_score(y_test, y_predict)) ############################################# def svm_cross_validation(train_x, train_y): from sklearn.model_selection import GridSearchCV from sklearn.svm import SVC model = SVC(kernel='rbf', probability=True) param_grid = {'C': [1e-3, 1e-2, 1e-1, 1, 10, 100, 1000], 'gamma': [0.001, 0.0001]} grid_search = GridSearchCV(model, param_grid, n_jobs = 8, verbose=1, scoring='accuracy') grid_search.fit(train_x, train_y) best_parameters = grid_search.best_estimator_.get_params() for para, val in list(best_parameters.items()): print(para, val) model = SVC(kernel='rbf', C=best_parameters['C'], gamma=best_parameters['gamma'], probability=True) model.fit(train_x, train_y) return model svm_model = svm_cross_validation(X_train, y_train) with open(model_dir, 'wb') as f1: pickle.dump(svm_model, f1) f1.close() print(svm_model.score(X_test, y_test)) y_predict = svm_model.predict(X_test) print(y_predict) ","date":"2023-07-15","objectID":"/posts/notes_1/:3:0","tags":["draft"],"title":"Maching Learning Notes 1","uri":"/posts/notes_1/"},{"categories":["Memo"],"content":"docker 入门教程 Ref Link: [1] https://ruanyifeng.com/blog/2018/02/docker-tutorial.html [2] https://cloud.tencent.com/developer/article/1885678 [3] 「Docker」 - 保存镜像 [4] 如何制作Docker镜像(image)? ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:0","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"一、Docker 是什么？ \u0026\u0026 Docker 的用途 Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:1","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"二、docker 安装 参考连接:ubuntu下docker的安装 安装完成后，运行下面的命令，验证是否安装成功。 docker version # or docker info Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组。 # 创建docker用户组 sudo groupadd docker # 应用用户加入docker用户组 sudo usermod -aG docker $USER # 重启docker服务 sudo systemctl restart docker su root su ${USER} Docker是服务器–客户端(server–client)架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动: # service 命令的用法 sudo service docker start # systemctl 命令的用法 sudo systemctl start docker ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:2","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"三、image 文件 Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 # 列出本机的所有 image 文件。 $ docker image ls # 删除 image 文件 $ docker image rm [imageName] image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。 为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。 ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:3","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"四、实例：hello world 首先，运行下面的命令，将 image 文件从仓库抓取到本地。 docker image pull library/hello-world 上面代码中，docker image pull是抓取 image 文件的命令。library/hello-world是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，hello-world是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。 docker image pull hello-world 抓取成功以后，就可以在本机看到这个 image 文件了。 docker image ls 运行image: docker container run hello-world docker container run命令会从 image 文件，生成一个正在运行的容器实例。 注意，docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的docker image pull命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。 $ docker container run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. ... ... 输出这段提示以后，hello world就会停止运行，容器自动终止。 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。 $ docker container run -it ubuntu bash 对于那些不会自动终止的容器，必须使用docker container kill命令手动终止。 $ docker container kill [containID] ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:4","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"五、容器文件 image文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。 上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的docker container kill命令。 终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm命令删除。 $ docker container rm [containerID] 运行上面的命令之后，再使用docker container ls --all命令，就会发现被删除的容器文件已经消失了。 ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:5","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"六、 Dockerfile 文件 学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 下面通过一个实例，演示如何编写 Dockerfile 文件。 ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:6","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"七、实例: 下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 作为准备工作，请先下载源码[]。 $ git clone https://github.com/ruanyf/koa-demos.git $ cd koa-demos 7.1 编写 Dockerfile 文件 首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。 .git node_modules npm-debug.log 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 上面代码一共五行，含义如下。 FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。 WORKDIR /app：指定接下来的工作路径为/app。 RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。 EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 7.2 创建image文件 有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。 $ docker image build -t koa-demo . # 或者 $ docker image build -t koa-demo:0.0.1 . 上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件koa-demo了。 docker image ls 7.3 生成容器 docker container run命令会从 image 文件生成容器。 $ docker container run -p 8000:3000 -it koa-demo /bin/bash # 或者 $ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash 上面命令的各个参数含义如下： p参数：容器的 3000 端口映射到本机的 8000 端口。 it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。 root@66d80f4aaf1e:/app# 这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。 root@66d80f4aaf1e:/app# node demos/01.js 这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示\"Not Found\"，这是因为这个 demo 没有写路由。 这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。 现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用docker container kill终止容器运行。 # 在本机的另一个终端窗口，查出容器的 ID $ docker container ls # 停止指定的容器运行 $ docker container kill [containerID] 容器停止运行之后，并不会消失，用下面的命令删除容器文件。 # 查出容器的 ID $ docker container ls --all # 删除指定的容器文件 $ docker container rm [containerID] 也可以使用docker container run命令的–rm参数，在容器终止运行后自动删除容器文件。 $ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash 7.4 CMD命令 上一节的例子里面，容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 CMD node demos/01.js 上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。 你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。 注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。 $ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 7.5 发布 image 文件 容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。 $ docker login 接着，为本地的 image 标注用户名和版本。 $ docker image tag [imageName] [username]/[repository]:[tag] # 实例 $ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。 $ docker image build -t [username]/[repository]:[tag] . 最后，发布 image 文件。 $ docker image push [username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:7","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"八、其他有用的命令 (1) docker container start 前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。 $ docker container start [containerID] (2) docker container stop 前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。 docker container stop [containerID] 这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 (3) docker container logs docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。 docker container logs [containerID] (4) docker container exec docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。 $ docker container exec -it [containerID] /bin/bash (5) docker container cp 和 docker cp docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。 docker container cp [containID]:[/path/to/file] . docker cp命令用于从将宿主机内的文件拷贝文件到container中: docker cp [OPTIONS] [src path] [container id]:[dest path] 非常感谢你一直读到了这里，这个系列还有下一篇，介绍如何使用 Docker 搭建真正的网站，欢迎继续阅读。 (6) docker commit docker commit命令用于保存container的修改。 docker commit -m \"commit message\" [containr ID] [new REPOSITORY:TAG] (7) docker save and docker load docker save 和 docker load 将image文件保存为压缩文件或者加载本地的压缩文件为image。 docker save -o [outputname path] [REPOSITORY:TAG] docker load -i [outputname.tar] ","date":"2023-07-15","objectID":"/posts/dockerintroduction/:1:8","tags":["docker"],"title":"Docker安装及学习","uri":"/posts/dockerintroduction/"},{"categories":["Memo"],"content":"一、 apt-get source update apt-get source change the /etc/apt/sources.list file to aliyun source add sudo user in rootlink adduser [name] apt-get install sudo 赋予用户sudo权限: sudo usermod -a -G adm username sudo usermod -a -G sudo username su [name] 在文件/etc/sudoers 中更改用户的sudo权限: # sudoers file. # # This file MUST be edited with the 'vi sudo' command as root. # # See the sudoers man page for the details on how to write a sudoers file. # # Host alias specification # User alias specification # Cmnd alias specification # Defaults specification # User privilege specification root ALL=(ALL) ALL [username] ALL=(ALL) ALL # Uncomment to allow people in group wheel to run all commands # %wheel ALL=(ALL) ALL # Same thing without a password # %wheel ALL=(ALL) NOPASSWD: ALL # Samples # %users ALL=/sbin/mount /cdrom,/sbin/umount /cdrom # %users localhost=/sbin/shutdown -h now ","date":"2023-07-15","objectID":"/posts/softwareinstallation/:1:0","tags":["draft"],"title":"程序安装教程","uri":"/posts/softwareinstallation/"},{"categories":["Memo"],"content":"二、 Anaconda or Miniconda Installation download anaconda or miniconda from tsinghua source website download command: wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh run the command to install: bash Miniconda3-latest-linux-x86_64.sh change the conda channels to tsinghua source nano ~/.condarc paste the following channels into your ~/.condarc file:ref link conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ #Conda Forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ #msys2（可略） conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ #bioconda（可略） conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ #menpo（可略） conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ #pytorch conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ # for legacy win-64（可略） conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/ conda config --set show_channel_urls yes ","date":"2023-07-15","objectID":"/posts/softwareinstallation/:2:0","tags":["draft"],"title":"程序安装教程","uri":"/posts/softwareinstallation/"},{"categories":["Memo"],"content":"三、 Cmake Installation Ref Link Download cmake source file: wget https://cmake.org/files/v3.20/cmake-3.20.0-linux-x86_64.tar.gz extract the file and move the file to /opt/cmake-3.20.0 tar zxvf cmake-3.20.0-linux-x86_64.tar.gz mv cmake-3.20.0-linux-x86_64 /opt/cmake-3.20.0 link the cmake as system cmake ln -sf /opt/cmake-3.20.0/bin/* /usr/bin/ check if successfully installed cmake --version ","date":"2023-07-15","objectID":"/posts/softwareinstallation/:3:0","tags":["draft"],"title":"程序安装教程","uri":"/posts/softwareinstallation/"},{"categories":["Memo"],"content":"四、 openmpi installation (Ref Link) Install openmpi with command line: sudo apt-get install openmpi-bin openmpi-doc libopenmpi-dev 在conda下安装openmapi: conda install openmpi ","date":"2023-07-15","objectID":"/posts/softwareinstallation/:4:0","tags":["draft"],"title":"程序安装教程","uri":"/posts/softwareinstallation/"},{"categories":["Memo"],"content":"五、 Anaconda下安装jupyter notebook 1、 安装jupyter notebook conda intall jupyter notebook 2、 安装nbextensions pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user 3、 安装nbextensions_configurator pip install jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user 4、 在codemirror.css文件中更改字体 ","date":"2023-07-15","objectID":"/posts/softwareinstallation/:5:0","tags":["draft"],"title":"程序安装教程","uri":"/posts/softwareinstallation/"},{"categories":["Transformer"],"content":"reference: [1]. The Transformer Family [2]. Attention [3]. 细节考究 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:0:0","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"Transformer Family ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:1:0","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"Notations Symbol Meaning $d$ The model size / hidden state dimension / positional encoding size. $h$ The number of heads in multi-head attention layer. $L$ The segment length of input sequence. $X \\in \\mathbb R ^ {L \\times d}$ The input sequence where each element has been mapped into an embedding vector of shape , same as the model size. $W^k \\in \\mathbb R ^ {d \\times d^k}$ The key weight matrix. $W^q \\in \\mathbb R ^ {d \\times d^k}$ The query weight matrix. $W^v \\in \\mathbb R ^ {d \\times d^k}$ The value weight matrix.Often we have $d_k = d_v = d$. $W^K_i, W^q_i \\in \\mathbb R ^ {d \\times d^k / h}; W^v_i \\in \\mathbb R^{d x d_v / h}$ The weight matrices per head. $W^o \\in \\mathbb d_v \\times d$ The output weight matrix. $Q = XW^q \\in \\mathbb R^{L \\times d_q}$ The query embedding inputs. $K = XW^k \\in \\mathbb R^{L \\times d_k}$ The key embedding inputs. $V = XW^v \\in \\mathbb R^{L \\times d_v}$ The value embedding inputs. $S_i$ A collection of key positions for the -th query to attend to. $A \\in \\mathbb R ^ {L \\times L}$ The self-attention matrix between a input sequence of lenght $L$ and itself. $A = softmax (Q K^T/\\sqrt{(d_k)} )$ $a_ij \\ in A $ The scalar attention score between query $q_i$ and key $k_j$. $P \\in \\mathbb R ^ {L \\times d}$ position encoding matrix, where the $i-th$ row is the positional encoding for input $x_i$. ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:1:1","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"Attention and Self-Attention Attention is a mechanism in the neural network that a model can learn to make predictions by selectively attending to a given set of data. The amount of attention is quantified by learned weights and thus the output is usually formed as a weighted average. Self-attention is a type of attention mechanism where the model makes prediction for one part of a data sample using other parts of the observation about the same sample. Conceptually, it feels quite similar to non-local means. Also note that self-attention is permutation-invariant; in other words, it is an operation on sets. There are various forms of attention / self-attention, Transformer (Vaswani et al., 2017) relies on the scaled dot-product attention: given a query matrix $Q$, a key matrix $K$ and a value matrix $V$, the output is a weighted sum of the value vectors, where the weight assigned to each value slot is determined by the dot-product of the query with the corresponding key: $$\\text{Attention}(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V$$ And for a query and a key vector $q_i, k_j \\in \\mathbb R ^ d$ (row vectors in query and key matrices), we have a scalar score: $$a_{ij} = softmax(\\frac{q_i k_j^T}{\\sqrt{d_k}}) = \\frac{\\exp(q_i k_j^T)}{\\sqrt{d_k}\\sum_{r \\in S_i}(q_i k_j^T)}$$ where $S_i$ is a collection of key positions for the $i$-th query to attend to. See my old post for other types of attention if interested. ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:1:2","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"Multi-Head Self-Attention The multi-head self-attention module is a key component in Transformer. Rather than only computing the attention once, the multi-head mechanism splits the inputs into smaller chunks and then computes the scaled dot-product attention over each subspace in parallel. The independent attention outputs are simply concatenated and linearly transformed into expected dimensions. $$\\text{MulitHeadAttention}(X_q, X_k, X_v) = [\\text{head}_1,;…; \\text{head}_h] W^o, where \\text{head}_i = \\text{Attention}(X_qW_i^q, X_kW_i^k, X_vW_i^v)$$ where $[.;.]$ is a concatenation operation. $W_i^q, W_i^k \\in \\mathbb R^{d \\times d_{k} / h}$, $W_i^v \\in \\mathbb R^{d \\times d_{v} / h}$ are weight matrices to map input embeddings of size $L \\times d$ into query, key and value matrices. And $W^o \\in \\mathbb R ^ {d_v \\times d}$ is the output linear transformation. All the weights should be learned during training. ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:1:3","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"Transformer The Transformer (which will be referred to as “vanilla Transformer” to distinguish it from other enhanced versions; Vaswani, et al., 2017) model has an encoder-decoder architecture, as commonly used in many NMT models. Later decoder-only Transformer was shown to achieve great performance in language modeling tasks, like in GPT and BERT. Encoder-Decoder Architecture The encoder generates an attention-based representation with capability to locate a specific piece of information from a large context. It consists of a stack of 6 identity modules, each containing two submodules, a multi-head self-attention layer and a point-wise fully connected feed-forward network. By point-wise, it means that it applies the same linear transformation (with same weights) to each element in the sequence. This can also be viewed as a convolutional layer with filter size 1. Each submodule has a residual connection and layer normalization. All the submodules output data of the same dimension $d$. The function of Transformer decoder is to retrieve information from the encoded representation. The architecture is quite similar to the encoder, except that the decoder contains two multi-head attention submodules instead of one in each identical repeating module. The first multi-head attention submodule is masked to prevent positions from attending to the future. Positional Encoding Because self-attention operation is permutation invariant, it is important to use proper positional encoding to provide order information to the model. The positional encoding $P \\in \\mathbb R ^ {L \\times d}$ has the same dimension as the input embedding, so it can be added on the input directly. The vanilla Transformer considered two types of encodings: (1). Sinusoidal positional encoding is defined as follows, given the token $i = 1, …, L$ position and the dimension $\\delta = 1, …, d$: $$ \\text{PE}(i, \\delta) = \\left{ \\begin{aligned} \\sin\\big(\\frac{i}{10000^{2\\delta’/d}}\\big) , if \\delta\u0026=2\\delta’\\ \\cos\\big(\\frac{i}{10000^{2\\delta’/d}}\\big) , if \\delta\u0026=2\\delta’+1 \\ \\end{aligned} \\right.$$ In this way each dimension of the positional encoding corresponds to a sinusoid of different wavelengths in different dimensions, from $2\\pi$ to 10000 * $2\\pi$. (2). Learned positional encoding, as its name suggested, assigns each element with a learned column vector which encodes its absolute position (Gehring, et al. 2017). ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:1:4","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"视觉Transformer入门 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:2:0","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"0 摘要 transformer结构是google在17年的Attention Is All You Need论文中提出，在NLP的多个任务上取得了非常好的效果，可以说目前NLP发展都离不开transformer。最大特点是抛弃了传统的CNN和RNN，整个网络结构完全是由Attention机制组成。由于其出色性能以及对下游任务的友好性或者说下游任务仅仅微调即可得到不错效果，在计算机视觉领域不断有人尝试将transformer引入，近期也出现了一些效果不错的尝试，典型的如目标检测领域的detr和可变形detr，分类领域的vision transformer等等。本文从transformer结构出发，结合视觉中的transformer成果(具体是vision transformer和detr)进行分析，希望能够帮助cv领域想了解transformer的初学者快速入门。由于本人接触transformer时间也不长，也算初学者，故如果有描述或者理解错误的地方欢迎指正。 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:2:1","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"1 transformer介绍 一般讲解transformer都会以机器翻译任务为例子讲解，机器翻译任务是指将一种语言转换得到另一种语言，例如英语翻译为中文任务。从最上层来看，如下所示： 1.1 早期seq2seq 机器翻译是一个历史悠久的问题，本质可以理解为序列转序列问题，也就是我们常说的seq2seq结构，也可以称为encoder-decoder结构，如下所示： encoder和decoder在早期一般是RNN模块(因为其可以==捕获时序信息==)，后来引入了LSTM或者GRU模块，不管内部组件是啥，其核心思想都是通过Encoder编码成一个表示向量，即上下文编码向量，然后交给Decoder来进行解码，翻译成目标语言。一个采用典型RNN进行编码翻译的可视化图如下： 可以看出，其解码过程是顺序进行，每次仅解码出一个单词。对于CV领域初学者来说，RNN模块构建的seq2seq算法，理解到这个程度就可以了，不需要深入探讨如何进行训练。但是上述结构其实有缺陷，具体来说是：(缺陷) 不论输入和输出的语句长度是什么，中间的上下文向量长度都是固定的，一旦长度过长，仅仅靠一个固定长度的上下文向量明显不合理 仅仅利用上下文向量解码，会有信息瓶颈，长度过长时候信息可能会丢失 通俗理解是编码器与解码器的连接点仅仅是编码单元输出的隐含向量，其包含的信息有限，对于一些复杂任务可能信息不够，如要翻译的句子较长时，一个上下文向量可能存不下那么多信息，就会造成翻译精度的下降。 1.2 基于attention的seq2seq 基于上述缺陷进而提出带有注意力机制Attention的seq2seq，同样可以应用于RNN、LSTM或者GRU模块中。注意力机制Attention对人类来说非常好理解，假设给定一张图片，我们会自动聚焦到一些关键信息位置，而不需要逐行扫描全图。此处的attention也是同一个意思，其本质是对输入的自适应加权，结合cv领域的senet中的se模块就能够理解了。 se模块最终是学习出一个$1 \\times 1 \\times c$的向量，然后逐通道乘以原始输入，从而对特征图的每个通道进行加权即通道注意力，对attention进行抽象，不管啥领域其机制都可以归纳为下图： 将Query(通常是向量)和4个Key(和Q长度相同的向量)分别计算相似性，然后经过softmax得到q和4个key相似性的概率权重分布，然后对应权重乘以Value(和Q长度相同的向量)，最后相加即可得到包含注意力的attention值输出，理解上应该不难。举个简单例子说明： 假设世界上所有小吃都可以被标签化，例如微辣、特辣、变态辣、微甜、有嚼劲….，总共有1000个标签，现在我想要吃的小吃是[微辣、微甜、有嚼劲]，这三个单词就是我的Query 来到东门老街一共100家小吃店，每个店铺卖的东西不一样，但是肯定可以被标签化，例如第一家小吃被标签化后是[微辣、微咸],第二家小吃被标签化后是[特辣、微臭、特咸]，第三家小吃被标签化后是[特辣、微甜、特咸、有嚼劲]，其余店铺都可以被标签化，每个店铺的标签就是Keys,但是每家店铺由于卖的东西不一样，单品种类也不一样，所以被标签化后每一家的标签List不一样长 Values就是每家店铺对应的单品，例如第一家小吃的Values是[烤羊肉串、炒花生] 将Query和所有的Keys进行一一比对，相当于计算相似性，此时就可以知道我想买的小吃和每一家店铺的匹配情况，最后有了匹配列表，就可以去店铺里面买东西了(Values和相似性加权求和)。最终的情况可能是，我在第一家店铺买了烤羊肉串，然后在第10家店铺买了个玉米，最后在第15家店铺买了个烤面筋 以上就是完整的注意力机制，采用我心中的标准Query去和被标签化的所有店铺Keys一一比对，此时就可以得到我的Query在每个店铺中的匹配情况，最终去不同店铺买不同东西的过程就是权重和Values加权求和过程。简要代码如下： # 假设q是(1,N,512),N就是最大标签化后的list长度，k是(1,M,512),M可以等于N，也可以不相等 # (1,N,512) x (1,512,M)--\u003e(1,N,M) attn = torch.matmul(q, k.transpose(2, 3)) # query compare with keys # softmax转化为概率，输出(1,N,M)，表示q中每个n和每个m的相关性 attn=F.softmax(attn, dim=-1) # (1,N,M) x (1,M,512)--\u003e(1,N,512)，V和k的shape相同 output = torch.matmul(attn, v) 带有attention的RNN模块组成的ser2seq,解码时候可视化如下： 在没有attention时候，不同解码阶段都仅仅利用了同一个编码层的最后一个隐含输出，加入attention后可以通过在每个解码时间步输入的都是不同的上下文向量，以上图为例，解码阶段会将第一个开启解码标志(也就是Q)与编码器的每一个时间步的隐含状态(一系列Key和Value)进行点乘计算相似性得到每一时间步的相似性分数，然后通过softmax转化为概率分布，然后将概率分布和对应位置向量进行加权求和得到新的上下文向量，最后输入解码器中进行解码输出，其详细解码可视化如下： 通过上述简单的attention引入，可以将机器翻译性能大幅提升，引入attention有以下几个好处： 注意力显著提高了机器翻译性能 注意力允许解码器以不同程度的权重利用到编码器的所有信息，可以绕过瓶颈 通过检查注意力分布，可以看到解码器在关注什么，可解释性强 1.3 基于transformer的seq2seq 基于attention的seq2seq的结构虽然说解决了很多问题，但是其依然存在不足： 不管是采用RNN、LSTM还是GRU都不利于并行训练和推理，因为相关算法只能从左向右依次计算或者从右向左依次计算 长依赖信息丢失问题，顺序计算过程中信息会丢失，虽然LSTM号称有缓解，但是无法彻底解决 最大问题应该是无法并行训练，不利于大规模快速训练和部署，也不利于整个算法领域发展，故在Attention Is All You Need论文中抛弃了传统的CNN和RNN，将attention机制发挥到底，整个网络结构完全是由Attention机制组成，这是一个比较大的进步. google所提基于transformer的seq2seq整体结构如下所示： 其包括6个结构完全相同的编码器，和6个结构完全相同的解码器，其中每个编码器和解码器设计思想完全相同，只不过由于任务不同而有些许区别，整体详细结构如下所示： 第一眼看有点复杂，其中N=6，由于基于transformer的翻译任务已经转化为分类任务(目标翻译句子有多长，那么就有多少个分类样本)，故在解码器最后会引入fc+softmax层进行概率输出，训练也比较简单，直接采用ce loss即可，对于采用大量数据训练好的预训练模型，下游任务仅仅需要训练fc层即可。上述结构看起来有点复杂，一个稍微抽象点的图示如下： 看起来比基于RNN或者其余结构构建的seq2seq简单很多。下面结合代码和原理进行深入分析。 1.4 transformer深入分析 前面写了一大堆，没有理解没有关系，对于cv初学者来说其实只需要理解QKV的含义和注意力机制的三个计算步骤: Q和所有K计算相似性； 对相似性采用softmax转化为概率分布； 将概率分布和V进行一一对应相乘，最后相加得到新的和Q一样长的向量输出即可. 重点是下面要讲的transformer结构。 下面按照 编码器输入数据处理-\u003e编码器运行-\u003e解码器输入数据处理-\u003e解码器运行-\u003e分类head 的实际运行流程进行讲解。 1.4.1 编码器输入数据处理 (1). 源单词嵌入 以上面翻译任务为例，原始待翻译输入是三个单词: 输入是三个单词，为了能够将文本内容输入到网络中肯定需要进行向量化(不然单词如何计算？)，具体是采用nlp领域的embedding算法进行词嵌入，也就是常说的Word2Vec。对于cv来说知道是干嘛的就行，不必了解细节。假设每个单词都可以嵌入成512个长度的向量，故此时输入即为3x512，注意Word2Vec操作只会输入到第一个编码器中，后面的编码器接受的输入是前一个编码器输出。 为了便于组成batch(不同训练句子单词个数肯定不一样)进行训练，可以简单统计所有训练句子的单词个数，取最大即可，假设统计后发现待翻译句子最长是10个单词，那么编码器输入是10x512，额外填充的512维向量可以采用固定的标志编码得到. (2) 位置编码 positional encoding 采用经过单词嵌入后的向量输入到编码器中还不够，因为transformer内部没有类似RNN的循环结构，没有捕捉顺序序列的能力，或者说无论句子结构怎么打乱，transformer都会得到类似的结果。为了解决这个问题，在编码词向量时会额外引入了位置编码position encoding向量表示两个单词i和j之间的距离，简单来说就是在词向量中加入了单词的位置信息。 加入位置信息的方式非常多，最简单的可以是直接将绝对坐标0,1,2编码成512个长度向量即可。作者实际上提出了两种方式： 网络自动学习 自己定义规则 提前假设单词嵌入并且组成batch后，shape为(b,N,512)，N是序列最大长度，512是每个单词的嵌入向量长度,b是batch (a) 网络自动学习 self.pos_embedding = nn.P","date":"2023-07-15","objectID":"/posts/transformerintroduction/:2:2","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"2 视觉领域的transformer 在理解了标准的transformer后，再来看视觉领域transformer就会非常简单，因为在cv领域应用transformer时候大家都有一个共识：尽量不改动transformer结构，这样才能和NLP领域发展对齐，所以大家理解cv里面的transformer操作是非常简单的。 2.1 分类vision transformer 论文题目：An Image is Worth 16x16 Words:Transformers for Image Recognition at Scale 论文地址：https://arxiv.org/abs/2010.11929 github: https://github.com/lucidrains/vit-pytorch 其做法超级简单，只含有编码器模块： 本文出发点是彻底抛弃CNN，以前的cv领域虽然引入transformer，但是或多或少都用到了cnn或者rnn，本文就比较纯粹了，整个算法几句话就说清楚了，下面直接分析。 2.1.1 图片分块和降维 因为transformer的输入需要序列，所以最简单做法就是把图片切分为patch，然后拉成序列即可。假设输入图片大小是256x256，打算分成64个patch，每个patch是32x32像素 x = rearrange(img, 'b c (h p1) (w p2) -\u003e b (h w) (p1 p2 c)', p1=p, p2=p) 这个写法是采用了爱因斯坦表达式，具体是采用了einops库实现，内部集成了各种算子，rearrange就是其中一个，非常高效。不懂这种语法的请自行百度。p就是patch大小，假设输入是b,3,256,256，则rearrange操作是先变成(b,3,8x32,8x32)，最后变成(b,8x8,32x32x3)即(b,64,3072)，将每张图片切分成64个小块，每个小块长度是32x32x3=3072，也就是说输入长度为64的图像序列，每个元素采用3072长度进行编码。 考虑到3072有点大，故作者先进行降维： # 将3072变成dim，假设是1024 self.patch_to_embedding = nn.Linear(patch_dim, dim) x = self.patch_to_embedding(x) 仔细看论文上图，可以发现假设切成9个块，但是最终到transfomer输入是10个向量，额外追加了一个0和_。为啥要追加？原因是**我们现在没有解码器了，而是编码后直接就进行分类预测，那么该解码器就要负责一点点解码器功能，那就是：需要一个类似开启解码标志，非常类似于标准transformer解码器中输入的目标嵌入向量右移一位操作。**试下如果没有额外输入，9个块输入9个编码向量输出，那么对于分类任务而言，我应该取哪个输出向量进行后续分类呢？选择任何一个都说不通，所以作者追加了一个可学习嵌入向量输入。那么额外的可学习嵌入向量为啥要设计为可学习，而不是类似nlp中采用固定的token代替？个人不负责任的猜测这应该就是图片领域和nlp领域的差别，nlp里面每个词其实都有具体含义，是离散的，但是图像领域没有这种真正意义上的离散token，有的只是一堆连续特征或者图像像素，如果不设置为可学习，那还真不知道应该设置为啥内容比较合适，全0和全1也说不通。自此现在就是变成10个向量输出，输出也是10个编码向量，然后取第0个编码输出进行分类预测即可。从这个角度看可以认为编码器多了一点点解码器功能。具体做法超级简单，0就是位置编码向量，_是可学习的patch嵌入向量。 # dim=1024 self.cls_token = nn.Parameter(torch.randn(1, 1, dim)) # 变成(b,64,1024) cls_tokens = repeat(self.cls_token, '() n d -\u003e b n d', b=b) # 额外追加token，变成b,65,1024 x = torch.cat((cls_tokens, x), dim=1) 2.1.2 位置编码 位置编码也是必不可少的，长度应该是1024，这里做的比较简单，没有采用sincos编码，而是直接设置为可学习，效果差不多 # num_patches=64，dim=1024,+1是因为多了一个cls开启解码标志 self.pos_embedding = nn.Parameter(torch.randn(1, num_patches + 1, dim)) 对训练好的pos_embedding进行可视化，如下所示： 相邻位置有相近的位置编码向量，整体呈现2d空间位置排布一样。 将patch嵌入向量和位置编码向量相加即可作为编码器输入 x += self.pos_embedding[:, :(n + 1)] x = self.dropout(x) 2.1.3 编码器前向过程 作者采用的是没有任何改动的transformer，故没有啥说的。 self.transformer = Transformer(dim, depth, heads, mlp_dim, dropout) 2.1.4 分类head 在编码器后接fc分类器head即可 self.mlp_head = nn.Sequential( nn.LayerNorm(dim), nn.Linear(dim, mlp_dim), nn.GELU(), nn.Dropout(dropout), nn.Linear(mlp_dim, num_classes) ) # 65个输出里面只需要第0个输出进行后续分类即可 self.mlp_head(x[:, 0]) 到目前为止就全部写完了，是不是非常简单，外层整体流程为： class ViT(nn.Module): def __init__(self, *, image_size, patch_size, num_classes, dim, depth, heads, mlp_dim, channels=3, dropout=0.,emb_dropout=0.): super().__init__() # image_size输入图片大小 256 # patch_size 每个patch的大小 32 num_patches = (image_size // patch_size) ** 2 # 一共有多少个patch 8x8=64 patch_dim = channels * patch_size ** 2 # 3x32x32=3072 self.patch_size = patch_size # 32 # 1,64+1,1024,+1是因为token，可学习变量，不是固定编码 self.pos_embedding = nn.Parameter(torch.randn(1, num_patches + 1, dim)) # 图片维度太大了，需要先降维 self.patch_to_embedding = nn.Linear(patch_dim, dim) # 分类输出位置标志，否则分类输出不知道应该取哪个位置 self.cls_token = nn.Parameter(torch.randn(1, 1, dim)) self.dropout = nn.Dropout(emb_dropout) # 编码器 self.transformer = Transformer(dim, depth, heads, mlp_dim, dropout) # 输出头 self.mlp_head = nn.Sequential( nn.LayerNorm(dim), nn.Linear(dim, mlp_dim), nn.GELU(), nn.Dropout(dropout), nn.Linear(mlp_dim, num_classes) ) def forward(self, img, mask=None): p = self.patch_size # 先把图片变成64个patch,输出shape=b,64,3072 x = rearrange(img, 'b c (h p1) (w p2) -\u003e b (h w) (p1 p2 c)', p1=p, p2=p) # 输出 b,64,1024 x = self.patch_to_embedding(x) b, n, _ = x.shape # 输出 b,1,1024 cls_tokens = repeat(self.cls_token, '() n d -\u003e b n d', b=b) # 额外追加token，变成b,65,1024 x = torch.cat((cls_tokens, x), dim=1) # 加上位置编码1,64+1,1024 x += self.pos_embedding[:, :(n + 1)] x = self.dropout(x) x = self.transformer(x, mask) # 分类head,只需要x[0]即可 # x = self.to_cls_token(x[:, 0]) x = x[:, 0] return self.mlp_head(x) 2.1.5 实验分析 作者得出的结论是：cv领域应用transformer需要大量数据进行预训练，在同等数据量的情况下性能不如cnn。一旦数据量上来了，对应的训练时间也会加长很多，那么就可以轻松超越cnn。 同时应用t","date":"2023-07-15","objectID":"/posts/transformerintroduction/:2:3","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"3 总结 本文从transformer发展历程入手，并且深入介绍了transformer思想和实现细节；最后结合计算机视觉领域的几篇有典型代表文章进行深入分析，希望能够给cv领域想快速理解transformer的初学者一点点帮助。 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:2:4","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"4 参考资料 [1] http://jalammar.github.io/illustrated-transformer/ [2] https://zhuanlan.zhihu.com/p/54356280 [3] https://zhuanlan.zhihu.com/p/44731789 [4] https://looperxx.github.io/CS224n-2019-08-Machine%20Translation,%20Sequence-to-sequence%20and%20Attention/ [5] https://github.com/lucidrains/vit-pytorch [6] https://github.com/jadore801120/ attention-is-all-you-need-pytorch [7] https://github.com/facebookresearch/detr ref: [1]. https://mp.weixin.qq.com/s/Tb0Zh5n_3dEYwInU6sJUhA ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:2:5","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"基于Transformer的多模态轨迹预测 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:3:0","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"0 引言 轨迹预测是自动驾驶领域关注的热点。对周围车辆轨迹的精确预测可以辅助自动驾驶车辆做出合理的决策规划，进而实现车辆在异构高动态复杂多变环境中安全驾驶。在车辆交互场景中，由于驾驶员意图与环境的不确定性，车辆轨迹将呈现多模态属性，即在相同历史轨迹条件下，车辆的未来轨迹具有多种可能性。对车辆的多模态轨迹预测并保证预测的准确性与多样性是当前自动驾驶领域研究的重点与难点。 近年来，Transformer在多模态预测领域取得突破性进展，其特有的完全基于注意力机制模块能够充分挖掘高动态场景下车辆之间的交互关系并有效建模轨迹的多模态分布。在近年来的一些研究中，基于Transformer的多模态轨迹预测显示出比CNN，RNN等多模态预测模型更优的准确性与多样性。本文以基于Transformer的多模态车辆轨迹预测为主线，回顾近年来代表性的基于Transformer的多模态轨迹预测的算法，最后对基于Transformer的多模态轨迹预测做出总结与展望。 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:3:1","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"1 Transformer框架 2017年，Waswani等人提出Transformer[1]，这是一种完全基于注意力机制的模型。注意力机制是一种捕捉向量之间相关性的方法，既可以考虑全局又可以聚焦重点，其在捕获车辆之间交互信息有非常好的性能。 基于注意力机制的Transformer比经典的深度学习模型CNN[12]和RNN[2]具备如下优势。注意力机制可以解决基于CNN方法中可解释性差以及无法建模智能体间交互关系的问题。注意力机制可以解决基于RNN[2]方法中长距离依赖问题，可以有更好的记忆力，可以获取更长距离的信息。相较于基于 RNN的方法在第t时间步的隐藏状态Ht需要前一个时间步t-1的隐藏状态输出后才能处理，难以并行，Transformer模型可以实现并行计算, Transformer可以同时提取上下文信息，并且在信息传递过程中规避梯度爆炸或梯度遗忘问题。 Transformer框架主要包含编码器、解码器、注意力机制三个重要部分，以下具体介绍。 1.1 编码器-解码器 编码器用于将历史轨迹和环境信息嵌入到上下文信息中并输入到Transformer中，其输入为车道信息，历史轨迹，车辆交互信息等，输出为具有这些信息的特征。编码器由N=6个独立层组成，每层有两个子层，分别是多头注意力和全连接前馈网络，子层通过残差结构连接后进行归一化输出，每层维度d_model=512确保输入输出维度不变。 解码器用于生成预测轨迹，其输入为编码器的输出，输出为预测轨迹。解码器由N=6个独立层组成，每层有三个子层，除了多头注意力和全连接前馈网络，还插入第三个子层，掩码多头注意力(Masked Multi-head attention)，用于对编码器堆栈的输出执行多头注意，掩码用于未来时刻进行掩码处理，确保当前位置的预测不会依赖于未来位置。 1.2 注意力机制 注意力机制用于建模车辆间交互关系。注意力机制将查询向量Q和一组键值对向量K-V映射到输出，输出值的加权和，权重则是通过Q和K相似度计算。Transformer框架主要由缩放点积注意力机制和多头注意力机制组成，缩放点积注意力机制中输入由向量query(dk)，key(dk)以及value(dv)组成，如图2，QK向量通过点积处理计算相似度，通过比例因子$\\sqrt{d_k}$(用来求dk的平方根)处理避免QK内积方差太大导致难以学习的情况，应用softmax函数获取权重来获得value的权重。掩码(Mask)处理避免解码器在训练是获取未来的信息影响预测。 $$Attention(Q, K, V) = softmax(\\frac{QK^{T}}{\\sqrt{d_k}}) V$$ 多头注意机制通过将Q,K,V分别线性投影到缩放点积注意机制中，投影h次后做h次注意力函数运算，通过并行计算，生成dv维输出value，将每一个输出值链接后再做一次投影得到最终value。通过多头注意机制，Transformer模型可以联合注意来自不同位置的不同子空间信息。 1.3 小结 在这一节中主要介绍了Transformer框架中三个主要部分，编码器，解码器，注意力机制的输入输出及其在轨迹预测中的用途。下一节中将对基于Transformer的多模态轨迹方法介绍。 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:3:2","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"2 基于Transformer的多模态轨迹预测方法 上一部分介绍了Transformer中编码器解码器结构，缩放点积注意机制，多头注意机制。这一部分中，将介绍近年来基于Transformer框架的可随场景变化的自适应调整的多模态方法。多模态轨迹预测旨在为处于异构复杂高动态环境中的目标车辆生成多条可能的且具有安全性的轨迹，由于不确定性的存在，目标车辆即使在相同场景下也有可能表现不同，因此这也是多模态轨迹预测面临的挑战。实现多模态预测的另一个挑战在于如何用有限的训练样本覆盖给定场景中所有可能的结果。多智能体轨迹预测需要在两个关键维度建模：(1)时间维度：将历史信息对智能体未来状态的影响建模 (2)社会维度：对每个智能体之间的交互关系建模。在时间维度层面，现有基于经典深度学习的模型CNN，RNN无法建模长时间序列，会导致时间信息丢失问题，基于Transformer可以通过将位置编码通过时间编码的形式保存长历史轨迹的信息。在社会维度层面，Transformer模型可以通过注意力机制建模人-车，车-车，车-环境之间的交互关系，可以通过分配权重的方式选择影响力最大的交互，以此为基础，Transformer可扩展到多智能体交互环境中。 现有基于概率的方法[3]和基于建议的启发式[4]的方法虽然可以通过添加规则的方式输出概率分布或通过添加具有强约束的锚点实现多模态轨迹预测，但是基于概率的方法过度依赖于先验分布和损失函数，容易出现优化不稳定或模式崩溃现象，基于建议的启发式方法过度依赖于锚点质量，不能保证生成多模态情况。基于Transformer的方法可以避免在设计先验分布和损失函数过程中大量的人工工作，同时可以更好的捕捉到轨迹预测的多模态性质，实现多模态轨迹预测。 Liu[5]等针对如何实现多模态轨迹预测，提出mmTransformer框架，该方法在Argoverse基准排行榜排名第一名，框架由三个独立的堆叠式的Transformer模型组成，分别聚合历史轨迹，道路信息以及交互信息。如图2所示，mmTransformer整体框架可由两部分组成，第一部分仅由运动提取器和地图聚合器分别对车辆的信息及环境信息进行编码，不考虑交互信息，第二部分通过社会构造函数对临近信息进行聚合，并对车辆之间的依赖关系进行建模，整个过程是依照逻辑顺序，即社会关系是基于每个车辆特征构建的。该方法还提出基于区域的训练策略(RTS)，在初始化建议后，将建议路径分为空间群组，通过路径分配计算路径回归损失和分类损失，以确保生成预测轨迹的多样性。 Yuan等针对时间和社会维度上独立特征编码信息丢失问题，提出AgentFormer[6]允许一个智能体在某个时间的状态直接影响另一个智能体未来的状态，而不是通过在一个维度上编码的中间特征，AgentFormer(图3)可以同时学习时序信息和交互关系，智能体当前时刻的关系可以通过不同时刻关系体现，解决了传统Transformer注意力中各个输入元素权重平等造成的时间和智能体信息损失，该模型采用时间编码减少时间信息损失，通过独特的Agent-aware注意力机制编码智能体和时间的关系，采用CVAE形式，以概率形式描述，确保了生成轨迹的多模态性。 Huang[10]等针对如何编码多智能体交互问题，使用TF编码器(图4)建模智能体与周围车辆的交互关系，多头注意机制可以帮助提取智能体交互的不同信息。通过矢量地图表示和基于地车道集的地图结构提取地图和目标智能体之间的关系。 Zhao等针对传统注意力机制无法捕获多智能体之间交互的问题，提出Spatial-Channel Transformer[9]在基于Transformer框架的基础上，插入了一个通道注意力(Channel-wise attention)模块(图5)，即挤压激励网络（SE）[8]，并将SE网络用于轨迹前途，以捕获相邻通道之间的相互作用。Zhang等针对多智能体轨迹预测问题，提出的Gatformer[11]相较于GNN，采用灵活的图结构，相比基于图神经网络的方法，降低了全连通图造成的计算复杂性。基于稀疏图，Gatformer可以预测多智能体未来的轨迹，同时考虑智能体之间相互作用。目前基于GAN和CVAE方法导致模型存在可解释性差的问题，Gatformer注意机制通过对交互权重分配可以提高性能并提高模型的可解释性，该模型对模型在多环境下验证了模型的鲁棒性。 复杂的驾驶环境通常是静态动态混合形式作为输入信息，针对如何表示融合有关道路几何形状，车道连通性，时变交通信号灯状态，其他交通参与者状态以及交互的历史信息，并将其编码，现有方法为了对多样特征建模而设计的具有不同特定模块集的复杂TF模型，由于注意对输入序列长度是二次方，且位置前馈网络是昂贵的自网络因此导致TF难以规模化，质量和效率无法同时保证。针对此问题，Waymo提出WayFormer7 在Transformer框架的基础上，研究了三种输入模式：前融合，后融合和分层融合的利弊，对于每种融合类型，探索通过分解注意或潜在query注意来权衡效率和质量的策略。后融合中每种特征都有与之相对应的编码器，前融合不是将注意编码器专用于每个模态，而是减少特定模态的参数到投影层，分层融合是前融合，后融合折中的模型，将场景信息分别通过注意编码器编码后聚合，将聚合特征输入到最终的注意机制交叉模型中，有效的将场景编码器的深度在模态特定编码器和跨模态编码器之间平均。本文还对如何将Transformer扩展到大型多维序列中提供了解决方案，减少了每个块的注意分量和位置前馈网络的计算成本。 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:3:3","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"3 总结与展望 综上所述，现阶段在多模态轨迹预测领域的整体框架已经成型，都是由编码器+交互+解码器组成，针对多模态轨迹预测目前具有的挑战性问题，基于Transformer轨迹预测在Argoverse数据集的平均位移误差(ADE)和最终位移误差(FDE)性能指标上取得了最优水平。Transformer框架在交互部分，特别是对障碍物周围信息交互效果相比CNN与RNN方法有明显的提升，Transformer可以解决长历史轨迹信息丢失问题，同时依靠注意力机制捕获车辆之间交互信息。 然而Transformer模型虽然在自然语言处理及视觉领域均取得了非常显著的成果，但是在自动驾驶轨迹预测方向的研究还是较少。目前还无法确Transformer算法可以应用到更为复杂多变的环境中，因为在现实环境中，由于传感器限制，如果有其他交通参与者遮挡，或者出现缺失/过时/不准确的道路基础设施信息，以及感知范围有限，无法获得实验阶段的理想数据，会导致预测轨迹出现偏差。同时可解释性低也是基于Transformer模型面临的主要问题之一，现有方法中对于预测轨迹的置信度难以解释，因此导致模型解释性低。这些问题也将是未来使用Transformer做多模态轨迹预测的可继续深入的方向。其次现有方法对于多模态的研究还不充分，相信在未来的发展中，基于Transformer的多模态轨迹预测方法会更加完善，轨迹预测技术走进现实生活一定可以实现。 参考文献： [1]A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I. Polosukhin, “Attention is all you need,” CoRR, vol. abs/1706.03762, 2017.arXiv: 1706.03762. [Online]. Available: http://arxiv.org/abs/1706.03762. [2]A. Graves, “Generating sequences with recurrent neural networks,” CoRR, vol. abs/1308.0850, 2013. arXiv: 1308 . 0850. [Online]. Available: http : / /arxiv.org/abs/1308.0850. [3]N. Lee, W. Choi, P. Vernaza, C. B. Choy, P. H. S. Torr, and M. K. Chandraker, “DESIRE: distant future prediction in dynamic scenes with interacting agents,” CoRR, vol. abs/1704.04394, 2017. arXiv: 1704 . 04394. [Online]. Available: http://arxiv.org/abs/1704.04394. [4]H. Zhao, J. Gao, T. Lan, C. Sun, B. Sapp, B. Varadarajan, Y. Shen, Y. Shen, Y. Chai, C. Schmid, C. Li, and D. Anguelov, “TNT: target-driven trajectory prediction,”CoRR, vol. abs/2008.08294, 2020. arXiv: 2008 . 08294. [Online]. Available:https://arxiv.org/abs/2008.08294. [5]Y. Liu, J. Zhang, L. Fang, Q. Jiang, and B. Zhou, “Multimodal motion prediction with stacked transformers,” in 2021 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2021, pp. 7573–7582. DOI: 10.1109/CVPR46437.2021.00749. [6]Y. Yuan, X. Weng, Y. Ou, and K. Kitani, “Agentformer: Agent-aware transformers for socio-temporal multi-agent forecasting,” in 2021 IEEE/CVF International Conference on Computer Vision (ICCV), 2021, pp. 9793–9803. DOI: 10.1109/ICCV48922.2021.00967. [7]Nayakanti, N., Al-Rfou, R., Zhou, A., Goel, K., Refaat, K. S., and Sapp, B., “Wayformer: Motion Forecasting via Simple \u0026 Efficient Attention Networks”, arXiv e-prints, 2022. [8]J. Hu, L. Shen, S. Albanie, G. Sun, and E. Wu, “Squeeze-and-excitation networks,” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 42,no. 8, pp. 2011–2023, 2020. DOI: 10.1109/TPAMI.2019.2913372. [9]J. Zhao, X. Li, Q. Xue, and W. Zhang, “Spatial-channel transformer network for trajectory prediction on the traffic scenes,” CoRR, vol. abs/2101.11472,2021. arXiv: 2101.11472. [Online]. Available: https://arxiv.org/abs/2101.11472. [10]Z. Huang, X. Mo and C. Lv, “Multi-modal Motion Prediction with Transformer-based Neural Network for Autonomous Driving,” 2022 International Conference on Robotics and Automation (ICRA), 2022, pp. 2605-2611, doi: 10.1109/ICRA46639.2022.9812060. [11]K. Zhang, X. Feng, L. Wu, and Z. He, “Trajectory prediction for autonomous driving using spatial-temporal graph attention transformer,” IEEE Transac tions on Intelligent Transportation Systems, pp. 1–11, 2022. DOI: 10.1109/TITS.2022.3164450. [12]G. Xie, A. Shangguan, F. Rong, W. Ji, M. Weigang, and X. Hei, “Motion trajectory prediction based on a cnn-lstm sequential model,” Science China Information Sciences, 2020. ref: [1]. https://mp.weixin.qq.com/s/yCcsHNXeIBdCVuUwpUVy3w ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:3:4","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"Transformer 详解 B站讲解视频 参考连接: https://wmathor.com/index.php/archives/1438/ Transformer 是谷歌大脑在 2017 年底发表的论文 attention is all you need 中所提出的 seq2seq 模型。现在已经取得了大范围的应用和扩展，而 BERT 就是从 Transformer 中衍生出来的预训练语言模型 这篇文章分为以下几个部分 - Transformer 直观认识 - Positional Encoding - Self Attention Mechanism - 残差连接和 Layer Normalization - Transformer Encoder 整体结构 - Transformer Decoder 整体结构 - 总结 - 参考文章 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:0","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"0. Transformer 直观认识 Transformer 和 LSTM 的最大区别，就是 LSTM 的训练是迭代的、串行的，必须要等当前字处理完，才可以处理下一个字。而 Transformer 的训练时并行的，即所有字是同时训练的，这样就大大增加了计算效率。Transformer 使用了位置嵌入 (Positional Encoding) 来理解语言的顺序，使用自注意力机制（Self Attention Mechanism）和全连接层进行计算，这些后面会讲到 Transformer 模型主要分为两大部分，分别是 Encoder 和 Decoder。Encoder 负责把输入（语言序列）隐射成隐藏层（下图中第 2 步用九宫格代表的部分），然后解码器再把隐藏层映射为自然语言序列。例如下图机器翻译的例子（Decoder 输出的时候，是通过 N 层 Decoder Layer 才输出一个 token，并不是通过一层 Decoder Layer 就输出一个 token） 本篇文章大部分内容在于解释 Encoder 部分，即把自然语言序列映射为隐藏层的数学表达的过程。理解了 Encoder 的结构，再理解 Decoder 就很简单了 上图为 Transformer Encoder Block 结构图，注意：下面的内容标题编号分别对应着图中 1,2,3,4 个方框的序号 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:1","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"1. Positional Encoding 由于 Transformer 模型没有循环神经网络的迭代操作，所以我们必须提供每个字的位置信息给 Transformer，这样它才能识别出语言中的顺序关系 现在定义一个位置嵌入的概念，也就是 Positional Encoding，位置嵌入的维度为 [max_sequence_length, embedding_dimension], 位置嵌入的维度与词向量的维度是相同的，都是 embedding_dimension。max_sequence_length 属于超参数，指的是限定每个句子最长由多少个词构成 注意，我们一般以字为单位训练 Transformer 模型。首先初始化字编码的大小为 [vocab_size, embedding_dimension]，vocab_size 为字库中所有字的数量，embedding_dimension 为字向量的维度，对应到 PyTorch 中，其实就是 nn.Embedding(vocab_size, embedding_dimension) 论文中使用了 sin 和 cos 函数的线性变换来提供给模型位置信息: $$\\left{\\begin{aligned} PE(pos, 2i) = \\sin (pos/10000^{2i/d_{model}}) \\ PE(pos, 2i + 1) = \\cos (pos/10000^{2i/d_{model}}) \\ \\end{aligned}\\right.$$ 上式中 $pos$ 指的是一句话中某个字的位置，取值范围是 $[0, \\text{max_sequence_length}]$ ， $i$ 指的是字向量的维度序号，取值范围是 $[0, \\text{embedding_dimension} / 2]$ ， $d_{model}$ 指的是 embedding_dimension​的值 上面有 sin 和 cos 一组公式，也就是对应着 embedding_dimension 维度的一组奇数和偶数的序号的维度，例如 0,1 一组，2,3 一组，分别用上面的 sin 和 cos 函数做处理，从而产生不同的周期性变化，而位置嵌入在 embedding_dimension​维度上随着维度序号增大，周期变化会越来越慢，最终产生一种包含位置信息的纹理，就像论文原文中第六页讲的，位置嵌入函数的周期从 $ 2\\pi $ 到 $10000 * 2 \\pi$ 变化，而每一个位置在 embedding_dimension ​维度上都会得到不同周期的 $ \\sin $ 和 $ \\cos $ 函数的取值组合，从而产生独一的纹理位置信息，最终使得模型学到位置之间的依赖关系和自然语言的时序特性。 如果不理解这里为何这么设计，可以看这篇文章 Transformer 中的 Positional Encoding 下面画一下位置嵌入，纵向观察，可见随着 embedding_dimension​序号增大，位置嵌入函数的周期变化越来越平缓 import numpy as np import matplotlib.pyplot as plt import seaborn as sns import math def get_positional_encoding(max_seq_len, embed_dim): # 初始化一个positional encoding # embed_dim: 字嵌入的维度 # max_seq_len: 最大的序列长度 positional_encoding = np.array([ [pos / np.power(10000, 2 * i / embed_dim) for i in range(embed_dim)] if pos != 0 else np.zeros(embed_dim) for pos in range(max_seq_len)]) positional_encoding[1:, 0::2] = np.sin(positional_encoding[1:, 0::2]) # dim 2i 偶数 positional_encoding[1:, 1::2] = np.cos(positional_encoding[1:, 1::2]) # dim 2i+1 奇数 return positional_encoding positional_encoding = get_positional_encoding(max_seq_len=100, embed_dim=16) plt.figure(figsize=(10,10)) sns.heatmap(positional_encoding) plt.title(\"Sinusoidal Function\") plt.xlabel(\"hidden dimension\") plt.ylabel(\"sequence length\") plt.figure(figsize=(8, 5)) plt.plot(positional_encoding[1:, 1], label=\"dimension 1\") plt.plot(positional_encoding[1:, 2], label=\"dimension 2\") plt.plot(positional_encoding[1:, 3], label=\"dimension 3\") plt.legend() plt.xlabel(\"Sequence length\") plt.ylabel(\"Period of Positional Encoding\") ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:2","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"2. Self Attention Mechanism 对于输入的句子 $ X $，通过 WordEmbedding 得到该句子中每个字的字向量，同时通过 Positional Encoding 得到所有字的位置向量，将其相加（维度相同，可以直接相加），得到该字真正的向量表示。第 $ t $ 个字的向量记作 $ x_t $。 接着我们定义三个矩阵 $ W_Q $, $ W_K $, $ W_V $，使用这三个矩阵分别对所有的字向量进行三次线性变换，于是所有的字向量又衍生出三个新的向量 $ q_t $, $ k_t $, $ v_t $。我们将所有的 $ q_t $ 向量拼成一个大矩阵，记作查询矩阵 $ Q $ ，将所有的 $ k_t $ 向量拼成一个大矩阵，记作键矩阵 $ K $ ，将所有的 $ v_t $ 向量拼成一个大矩阵，记作值矩阵 $ V $ （见下图） 为了获得第一个字的注意力权重，我们需要用第一个字的查询向量 $ q_1 $ 乘以键矩阵 $ K $（见下图） [0, 4, 2] [1, 0, 2] x [1, 4, 3] = [2, 4, 4] [1, 0, 1] 之后还需要将得到的值经过 softmax，使得它们的和为 1（见下图） softmax([2, 4, 4]) = [0.0, 0.5, 0.5] 有了权重之后，将权重其分别乘以对应字的值向量 $ v_t $（见下图） 0.0 * [1, 2, 3] = [0.0, 0.0, 0.0] 0.5 * [2, 8, 0] = [1.0, 4.0, 0.0] 0.5 * [2, 6, 3] = [1.0, 3.0, 1.5] 最后将这些权重化后的值向量求和，得到第一个字的输出（见下图） [0.0, 0.0, 0.0] + [1.0, 4.0, 0.0] + [1.0, 3.0, 1.5] ----------------- = [2.0, 7.0, 1.5] 对其它的输入向量也执行相同的操作，即可得到通过 self-attention 后的所有输出 矩阵计算 上面介绍的方法需要一个循环遍历所有的字$ x_t $，我们可以把上面的向量计算变成矩阵的形式，从而一次计算出所有时刻的输出 第一步就不是计算某个时刻的$ q_t $, $ k_t $, $ v_t $了，而是一次计算所有时刻的 $ Q $, $ K $, $ V $。计算过程如下图所示，这里的输入是一个矩阵 $ X $，矩阵第 $ t $ 行为第 $ t $ 个词的向量表示 $x_t$ 接下来将 $ Q $ 和 $K_T$ 相乘，然后除以 $ \\sqrt{d_k} $（这是论文中提到的一个 trick），经过 softmax 以后再乘以 $ V $ 得到输出 Multi-Head Attention 这篇论文还提出了 Multi-Head Attention 的概念。其实很简单，前面定义的一组 $Q $, $ K $, $ V $, 可以让一个词 attend to 相关的词，我们可以定义多组 $Q $, $ K $, $ V $，让它们分别关注不同的上下文。计算 $Q $, $ K $, $ V $ 的过程还是一样，只不过线性变换的矩阵从一组 $ W^Q $, $ W^K $, $ W^V $ 变成了多组$ W^Q_0 $, $ W^K_0 $, $ W^V_0 $ ，$ W^Q_1 $, $ W^K_1 $, $ W^V_1 $ ，… 如下图所示: 对于输入矩阵 $ X $ ，每一组 $ Q $ 、$ K $ 和 $ V $ 都可以得到一个输出矩阵 $ Z $ 。如下图所示 Padding Mask 上面 Self Attention 的计算过程中，我们通常使用 mini-batch 来计算，也就是一次计算多句话，即 $ X $ 的维度是 [batch_size, sequence_length]，sequence_length​是句长，而一个 mini-batch 是由多个不等长的句子组成的，我们需要按照这个 mini-batch 中最大的句长对剩余的句子进行补齐，一般用 0 进行填充，这个过程叫做 padding 但这时在进行 softmax 就会产生问题。回顾 softmax 函数 $\\sigma(z_i) = \\frac{e^{z_i}}{\\sum_K^{j=i} e^{z_j}}$，$e^0$ 是 1，是有值的，这样的话 softmax 中被 padding 的部分就参与了运算，相当于让无效的部分参与了运算，这可能会产生很大的隐患。因此需要做一个 mask 操作，让这些无效的区域不参与运算，一般是给无效区域加一个很大的负数偏置，即 $$\\left{\\begin{aligned} Z_{illegal} = Z_{illegal} + bias_{illegal} \\ bias_{illegal}-\u003e -\\infin \\ \\end{aligned}\\right.$$ ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:3","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"3. 残差连接和 Layer Normalization 残差连接 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:4","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"4. Transformer Encoder 整体结构 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:5","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"5. Transformer Decoder 整体结构 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:6","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"6. 总结 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:7","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Transformer"],"content":"7. 参考文章 ","date":"2023-07-15","objectID":"/posts/transformerintroduction/:4:8","tags":["draft"],"title":"Transformer Introduction","uri":"/posts/transformerintroduction/"},{"categories":["Planning"],"content":"[new ref 1] (https://zhuanlan.zhihu.com/p/619039492) [old ref 1] (https://zhuanlan.zhihu.com/p/399545248) ","date":"2023-07-15","objectID":"/posts/latticeplanner/:0:0","tags":["draft"],"title":"Lattice Planner","uri":"/posts/latticeplanner/"},{"categories":["Planning"],"content":"一、Lattice Planner简介 LatticePlanner算法属于一种局部轨迹规划器，输出轨迹将直接输入到控制器，由控制器完成对局部轨迹的跟踪控制。因此，Lattice Planner输出的轨迹是一条光滑无碰撞满足车辆运动学约束和速度约束的平稳安全的局部轨迹。Lattice Planner的输入端主要由三部分组成，感知及障碍物信息、参考线信息及定位信息。 [pic] 局部规划模块的输出是带有速度信息的一系列轨迹点组成的轨迹，其保证了车辆控制器在车辆跟踪控制过程中的平稳性和安全性。 ","date":"2023-07-15","objectID":"/posts/latticeplanner/:1:0","tags":["draft"],"title":"Lattice Planner","uri":"/posts/latticeplanner/"},{"categories":["Planning"],"content":"二、Lattice规划算法实现过程 Lattice规划算法是一种基于采样的运动规划算法，通过将车辆坐标系转换到参考线坐标系，也就是frenet坐标系下，然后在frenet坐标系下分别对frenet的d轴和s轴进行规划，形成frenet坐标系下的规划轨迹，然后将frenet坐标系下的轨迹合成到世界坐标系下还原为世界坐标系下的轨迹。算法实现过程大概可以分为以下几步： 将车辆当前位姿信息转换到frenet坐标系下，获得车辆在frenet坐标系的初始状态；根据当前速度计算前瞻距离，获得前瞻点，获得车辆在前瞻点位置frenet坐标系下的目标状态。 对轨迹状态进行采样，分别是轨迹运行时间t，目标速度v，及到参考线的横向位移d，通过这三个规划参数可以获得采样状态。 构建横向位移和纵向位移的多项式规划函数s(t)，d(s)，获得横向位移和纵向位移的规划函数后，进行时间插值就可以获得参考线frenet坐标系下的轨迹点，最后将轨迹点从frenet坐标系转换到cartesian坐标系，就可以获得物理世界采样轨迹，由于横向和纵向都是通过高次多项式插值获得，以此cartesian坐标系下的轨迹也是光滑的。 采样轨迹的碰撞检测、曲率约束及最优轨迹打分。采样轨迹是一系列满足速度约束的光滑轨迹，但其还需要满足无碰撞和车辆运动学曲率约束的强制约束，及远离障碍物和靠近参考线等组成的代价约束。采样轨迹的打分就是为了获得一条最优的满足约束条件的无碰撞光滑轨迹。该轨迹也是lattice输出到controller用于车辆跟随的轨迹。 Frenet坐标系和Cartesian坐标系的相互转换 Frenet坐标系是参考线上的坐标系，是一个动坐标系。Frenet坐标系的建立，以车辆位置到参考线的最近点R作为frenet坐标系的原点，以参考线切线方向作为T轴，垂直于T轴向外为N轴。如下图所示，是frenet坐标系和cartesian坐标系的相互转换关系，黑色虚线是车辆当前运行的轨迹方向，黑色实线是车辆运行的参考线。 [pic] 如上图所示，参考线（Reference line）是一条光滑的车道线，按上图所示将汽车的坐标点P（图中红色点）投影到参考线上，得到一个参考线上的投影点R（图中绿色点）。从参考线起点到投影点的路径长度就是汽车在Frenet坐标系下的纵向偏移量，用s表示。而投影点到汽车位置的距离 $l(s)$ 则是汽车在Frenet坐标系下的横向偏移量。因为参考线是足够光滑的，我们也可通过汽车的朝向、速度、加速度来计算出Frenet坐标系下，横向和纵向偏移量的一阶导和二阶导。这里将横向偏移量 $l(s)$ 设计成纵向偏移量s的函数。这是因为对于carlike模型的汽车而言，横向运动是由纵向运动诱发的。而\u003c/font color=red\u003e将坐标点转换到frenet坐标系的目的则是为了方便规划曲线的生成和车道线横向和纵向方向上的轨迹采样，从而获得覆盖整个车道的光滑采样轨迹。 frenet坐标系和cartesian坐标系的转换关系可以可以参考如下论文[https://link.zhihu.com/?target=https%3A//www.researchgate.net/profile/Moritz-Werling/publication/224156269_Optimal_Trajectory_Generation_for_Dynamic_Street_Scenarios_in_a_Frenet_Frame/links/54f749df0cf210398e9277af/Optimal-Trajectory-Generation-for-Dynamic-Street-Scenarios-in-a-Frenet-Frame.pdf] 如下所示是两个坐标系之间的变换公式。 ref:https://blog.csdn.net/u013468614/article/details/108748016 cartesian坐标系到frenet坐标系的变换公式： frenet坐标系到cartesian坐标系的变换公式： 上式中，各变量的含义如下： 如下图所示绿色线代表了参考线reference_line，红色和蓝色线代表经过横向偏移位移均匀变化之后形成的路线。 ","date":"2023-07-15","objectID":"/posts/latticeplanner/:2:0","tags":["draft"],"title":"Lattice Planner","uri":"/posts/latticeplanner/"},{"categories":["Planning"],"content":"三、Lattice Planner轨迹采样 Lattice规划器的轨迹采样，主要分为横向采样、纵向采样以及轨迹时间周期采样。 横向轨迹的采样需要涵盖多种横向运动状态，需要根据车道宽度设置横向采样的采样区间，通过横向采样间隔，形成不同的横向采样偏移量。 纵向采样的采样区间可以通过前瞻点的位移长度s，作为基准采样长度，然后通过对轨迹速度ds进行采样。 时间周期采样，就是对轨迹的运行周期时间进行采样。而百度Apollo的轨迹采样，只对横向位移和纵向位移进行了采样，并设计了采样状态横向偏移量，-0.5，0.0和0.5，以及四个到达这些横向偏移量的纵向位移，分别为10，20，40，80来得到采样状态。所以Lattice规划器的轨迹采样主要是对轨迹横纵向状态进行采样，但采样方式可以根据环境情况进行调整。 ","date":"2023-07-15","objectID":"/posts/latticeplanner/:3:0","tags":["draft"],"title":"Lattice Planner","uri":"/posts/latticeplanner/"},{"categories":["Planning"],"content":"四、Lattice Planner速度规划 有了前面的采样状态，现在需要做的是根据采样状态生成横向 $l(s)$ 和纵向 $s(t)$ 和规划函数，两种规划函数都是通过多项式进行拟合求解生成。主要使用了4次和5次多項式拟合，从而满足了车辆运行过程中的一阶导，二阶导连续，也就是速度和加速度连续，保证了轨迹的平滑性要求。 对于纵向轨迹 $s(t)$ ，在停车和跟车状态，都是五次多项式，但对于巡航状态，由于我们不需要确定状态的S值，所以只有五个变量，因此用四次多项式就可以了。对于横向轨迹$l(s)$也使用了五次多项式拟合。 这里规划器的采样方式没有使用Apollo中Lattice的横纵向采样方式，而是采用了上文中提到的采样方式，因此约束变量有： 巡航模式下的纵向拟合函数的求解 ","date":"2023-07-15","objectID":"/posts/latticeplanner/:4:0","tags":["draft"],"title":"Lattice Planner","uri":"/posts/latticeplanner/"},{"categories":["Planning"],"content":"五、轨迹生成及轨迹评价函数 轨迹的生成成就是将frenet坐标系下的轨迹转换到cartesian坐标系中，前面我们知道了位姿点在frenet坐标系和cartesian坐标系的相互转换关系，因此现在我们需要做的就是对横纵向轨迹函数 $s(t)$ 和 $l(s(t))$ 进行轨迹的时间细分形成规划函数的横纵向轨迹规划点 $s(t_i)$ 和 $l(s(t_i))$，该规划点是在frenet坐标系中，因此需要进行frenet坐标系到cartesian坐标系的坐标转换，从而形成控制器可用的采样轨迹。 获得采用轨迹之后，接着需要进行目标轨迹的曲率检查和碰撞检测，目的是为了使目标采样轨迹满足车辆的运动学控制要求和无碰撞要求，这样就形成了安全可靠的轨迹簇。这些轨迹簇都可以满足车辆的控制要求，但并不是最优的，因此需要从轨迹簇中选出一组最优的运行轨迹。这时就需要引入轨迹评价函数，用来对候选轨迹进行打分。 轨迹评价函数主要为了使得目标轨迹尽量靠近静态参考线轨迹运行，同时，速度尽量不发生大突变，满足舒适性要求，且尽量远离障碍物。因此最后轨迹评价函数可以通过如下伪代码描述： $$traj_{cost} = k_{lat} * cost_{lat} + k_{lon} * cost_{lon} + k_{obs} * obs_{cost};$$ 上式中， - k_lat : 表示纵向误差代价权重 - cost_lat： 表示纵向误差，综合考虑纵向速度误差，时间误差及加加速度的影响。 - k_lon : 表示横向误差代价权重 - cost_lon： 表示横向向误差，综合考虑了横向加速度误差及横向偏移误差的影响。 - k_obs : 表示障碍物代价权重 - obs_cost： 表示障碍物距离损失。 最后选择出代价值最好的一条轨迹输入到控制器，用于控制器的跟踪控制。 ","date":"2023-07-15","objectID":"/posts/latticeplanner/:5:0","tags":["draft"],"title":"Lattice Planner","uri":"/posts/latticeplanner/"},{"categories":["Planning"],"content":"ref: [1]. https://blog.csdn.net/qq_41667348/category_11789612.html [2]. https://zhuanlan.zhihu.com/p/492988036 [3]. https://www.zhihu.com/column/c_1020971709242818560 [4]. https://blog.csdn.net/qq_35503971/article/details/106337900 简介 EM Planner是Apollo面向L4的实时运动规划算法，该算法首先通过顶层多车道策略，选择出一条参考路径，再根据这条参考线，在Frenet坐标系下，进行车道级的路径和速度规划，规划主要通过Dynamic Programming和基于样条的Quadratic Programming实现。EM Planner充分考虑了无人车安全性、舒适性、可扩展性的需求，通过考虑交通规则、障碍物决策、轨迹光滑性等要求，可适应高速公路、低速城区场景的规划需求。通过Apollo仿真和在环测试，EM Planner算法体现了高度的可靠性，和低耗时性。 ","date":"2023-07-15","objectID":"/posts/emplanner/:0:0","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"多车道EM Planner框架 ","date":"2023-07-15","objectID":"/posts/emplanner/:1:0","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"整体框架 所有规划需要的信息在EM Planner的顶层汇集，然后参考线生成器会生成一些基于障碍物和交通规则的候选车道级参考线，这个过程主要是依赖于高精度地图和Routing模块给出的全局规划结果。以下是车道级的规划过程： 首先会基于给定参考线生成Frenet坐标系，通过给定参考线将所有的自车信息和环境信息转换到参考线下的Frenet坐标系。 接下来所有的车道级信息将会传递给车道级最优求解器，该求解器会求解最优路径和最优速度。在求解最优路径时，周围环境信息将会被投影到Frenet坐标系（E-step），然后基于投影的信息生成一条光滑路径（M-step）。 同样的，在求解最优速度时，一旦生成了一条最优路径，障碍物就会被投影到ST图中（E-step），然后最优速度求解器会生成一条光滑的速度规划（M-step）。结合路径和速度规划结果，就生成了一条给定车道的光滑轨迹。 最后一步会将所有的车道级轨迹传递给参考线轨迹决策器，基于当前车辆状态、相关约束和每条轨迹的代价，轨迹决策器会决定一条最优的轨迹。 ","date":"2023-07-15","objectID":"/posts/emplanner/:1:1","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"多车道策略 利用搜索算法【2】【3】结合代价估算形成变道策略是一种比较常见的处理变道问题的方法，但是这种方法存在计算量大、难以适用交规以及前后决策可能缺少连贯性等特点。Apollo的解决办法是将多车道策略划分为两种类型：无法通行的被动变道，和能够通行的主动变道。 被动变道一般由道路阻挡造成的，通过全局规划模块重新生成全局路径解决； 主动变道是考虑动态障碍物而做出的决策。Apollo通过同步生成多条候选车道的方法解决主动变道问题，在Frenet坐标系下，投影障碍物、考虑交规后生成多条车道级的候选路径，最后传递到变道决策器中选择出一条最优的车道决策。 ","date":"2023-07-15","objectID":"/posts/emplanner/:1:2","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"路径-速度迭代算法 在Frenet坐标下的轨迹规划实际上是带约束的3D最优求解问题。该问题一般有两种求解方法：直接3D最优化求解和路径-速度解耦求解。 直接方法【4】【5】试图在SLT坐标系下使用轨迹采样或Lattice搜索,这些方法都受到搜索复杂度的限制，因此搜索结果是次优的。 而路径-速度解耦规划会分别求解路径和速度的最优解。速度的生成将会在生产的路径上进行【6】。虽然结果可能也不是最优的，但会在速度和路径分别求解时更加灵活。 EM Planner迭代地进行路径和速度最优求解，通过估计和来向、低速障碍物的交互，上一帧的速度规划将有助于下一帧的路径规划。然后将路径规划结果再交给速度最优求解器来推算出一个最优的速度结果。 ","date":"2023-07-15","objectID":"/posts/emplanner/:1:3","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"决策和交通规则约束 交通规则是硬约束，而与障碍物的交互是软约束。一些决策方法直接考虑的是数值上的最优解【7】，也有像【5】一样同时进行规划和决策。而Apollo EM Planner的决策是优先于规划的，决策模块将会为规划带来更明确的意图，减少最优求解的搜索空间。决策部分的第一步是将车辆的运动意图用一根粗略、灵活的轨迹来描述。这条轨迹也可以用来估计与障碍物之间的交互，并且当情景更加复杂时，这种基于轨迹的决策方法也是灵活的。第二步是基于决策生成的轨迹来构造一个凸空间，用来做基于样条光滑的轨迹生成，主要是通过二次规划来达到迭代生产路径、速度解的目的。 ","date":"2023-07-15","objectID":"/posts/emplanner/:1:4","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"车道级EM PLanner框架 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:0","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"整体框架 框架包括了一帧规划中的两个E-step和两个M-step，轨迹信息将会在前后两帧中传递，以下是整个车道级规划的流程： 在第一个E-step中，障碍物会被投影到车道Frenet坐标系，障碍物包括了静态障碍物和动态障碍物。静态障碍物会直接从笛卡尔坐标系转换到Frenet坐标系，而动态的信息则以其运动轨迹来描述。通过上一帧的预测信息，和自车的运动信息，可以估算自车和动态障碍物在每个时间点的交互情况，轨迹重叠的部分会被映射到Frenet坐标系中。初次之外，在最优路径求解过程中，动态障碍物的出现会最终导致自车做出避让的决策。因此，出于安全的考虑，SL投影只考虑低速和来向障碍物，而对于高速的动态障碍物，EM Planner的平行变道策略会考虑这种情景。 在第二个E-step，所有的障碍物都会在ST中与生成的速度信息进行估计，如果对应的ST中重叠部分，那么对应区域将会在ST中进行重新生成。 在两次M-step过程中，通过Dynamic Programming和Quadratic Programming生成路径和速度规划。然而在进行投影的SL和ST坐标内求解时非凸的，因此，为了解决这个问题，首先使用Dynamic Programming获得一个粗略的解，同时这个解也能够提供诸如避让、减速、超车的决策。通过这个粗略的解，可以构建一个凸的通道，然后使用基于Quadratic Programming的样条最优求解。 接下来的部分将会详细介绍框架中的步骤。 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:1","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"SL和ST投影（E-step） SL投影 SL投影是基于类似于【3】中的G2光滑参考线（曲率导数连续）。给定一个时刻，如果自车与预测的障碍物轨迹有重叠区域，那么这个重叠区域将会在SL坐标系被标注为与动态障碍物的估计交互区域。这个区域可以理解为自车和动态障碍物的包围盒的重叠区域。图4展示了这一种案例，红色代表动态障碍物的预测轨迹，用离散点来表示；蓝色表示自车的状态。 ST投影 ST投影用于帮助我们估计自车的速度规划。当生成了一条光滑的路径以后，与自车有交互的动态障碍物和静态障碍物都会被投影到路径上，同理，这种交互也定义为包围盒的重叠。如图5，这是一个ST图投影案例。 红色区域表示在2s处距离自车40m远切入规划路径的动态障碍物ST信息，绿色表示在自车后的动态障碍物ST信息，M-step将会在剩下的区域找到可行光滑最优解。 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:2","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"DP路径（M-step） M-step求解Frenet坐标系下的最优路径规划，实际上在一个非凸的区间（从左和从右避让是两个局部最优情景）就是找到一个最优的 $l=f(s)$ 方程。主要包括两步：基于Dynamic Programming的路径决策和基于样条的路径规划。 基于Dynamic Programming的路径步骤提供一条粗略的路径信息，其可以带来可行通道和绕障决策，如图6所示，这一步包括Lattice采样、代价函数、Dynamic Programming搜索。 Lattice采样基于Frenet坐标系，多行的点在撒在自车前。如图7所示，行与行之间的点使用五次方多项式连接，而行与行之间的间隔取决于自车速度、道路结构、是否换道等等。出于安全考虑，路径总长可以达到200m或者覆盖8s的行驶长度。 每段Lattice路径的代价通过光滑程度、障碍物避让、车道代价来评价： 而光滑程度又通过以下方程来衡量，一阶导表示朝向偏差，二阶导表示曲率，三阶导表示曲率导数： 障碍物的代价由以下方程给出，方程中的d由自车bounding box到障碍物bounding box的距离表示。迹规划 车道代价由以下方程给出，主要是考虑在道路上与否以及与参考线之间的差异，一般是与车道中心线的差异： ","date":"2023-07-15","objectID":"/posts/emplanner/:2:3","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"样条QP路径（M-step） 基于样条的路径可以理解为是Dynamic Programming更精细的版本。通过DP采样出的路径生成一条可通行通道，然后在通道中利用基于Quadratic Programming的样条曲线生产光滑路径。具体实例如图8所示，步骤流程可由图9所示： QP的目标函数为： 其中 $ g(s) $ 为DP规划的路径，$ f(s) $ 的一阶导表示朝向、二阶导表示曲率、三阶导表示曲率的导数。该函数描述了避让障碍物和曲线光滑性之间的权衡。 QP的约束包括边界约束和动力学可行性。这些约束都会施加在每个s处，通过限制l来将车辆限制在车道内。由于EM Planner使用的是自行车模型，因此这样对l的限制也是不够的。如图10所示，为了使得边界约束变凸并且线性，在自车的前后两端各增加了一个半圆。前轮到后轮中心的距离用 l_f ​表示，车宽用w表示，因此车的左前角的横向位置可以用以下方程给出： 通过线性化可以变为： 同理，其余三个角的位置都可以被线性化，显然因为 $ \\theta $ 足够小，小于 $ pi/12 $，因此可以这样线性化。 $ f(s) $ 的二阶导和三阶导与动力学可行性相关，除了边界条件以外，生成的路径还应该和自车的初始条件相匹配。因为所有的约束都是线性的，所以使用Quadratic Programming求解非常迅速。 具体的光滑样条曲线和QP问题可以在附录中查阅。 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:4","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"DP速度求解（M-step） M-step的速度规划是在ST图中求解最优速度规划，即求解出最优函数 S(t)。与求解最优路径相似，在ST图中求解最优速度规划也是非凸的最优化问题。同样也采用Dynamic Programming配合样条曲线Quadratic Programming来找到光滑速度规划。图12是速度求解的pipeline： DP速度求解包括代价函数、ST栅格图以及Dynamic Programming搜索。生成的结果包括分段线性的速度规划、可通行通道以及障碍物速度决策。如图11所示，该结果在QP中用来作为参考速度规划，通过该参考速度生成凸的区域。 在栅格图中，使用有限差分法来估计速度、加速度和jerk： 从DP生成的速度中选择出最优的一条的方法是最小化以下的代价函数： 第一项是速度误差，g用来惩罚与 $ V_ref $ 的不同的误差。第二项、第三项用来描述曲线的光滑程度。最后一项用来描述障碍物代价，以到障碍物的距离来衡量。 DP搜索空间也收到车辆动力学约束，并且也有单调性约束，因为不希望车辆倒退。一些对于动力学约束的必要简化也用来加速算法。 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:5","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"QP速度求解（M-step） 因为分段线性的速度规划不能满足动力学的要求，所以需要使用Quadratic Programming来填补动力学空缺。图13是样条曲线QP速度求解的pipeline： QP速度求解包括三部分：代价函数、线性约束以及样条曲线QP求解器。 除了初始条件约束以外，主要有以下的边界约束： 第一个约束是单调性约束；第二、第三、第四约束主要是交通规则和车辆动力学约束。通过约束、cost函数计算以后，spline QP speed会生成一条如图14中的光滑可行的速度规划。 结合路径规划，EM Planner最终会生成一条光滑轨迹。 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:6","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"解QP问题的说明 为了安全考虑，路径和速度大概在100个不同的位置或时间点，那么约束就有超过600个。对于速度、路径求解，分段五次多项式已经足够，因此样条曲线大概有3-5个多项式，大概就有30个参数。因此Quadratic Programming就变成了相对小的目标函数，和相对大的约束。QP能比较好的解决这个问题，并且使用了上一帧的解作为热启动，加速求解过程。实践中，QP问题解的平均时间3ms。 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:7","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"DP和QP非凸问题的说明 在非凸问题上，DP和QP都有他们单独的限制。DP和QP的组合，能够很好吸收两者优点，并求得一个理性解。 DP:DP的优劣受到撒点分辨率和时间分辨率的影响，通常在运行时间限制的情况下，一般只会得出一个粗糙解而非最优解，比如会从障碍物左侧绕开，但并不是按照最完美的路径绕开。 QP:QP需要在凸空间求解，因此必须借助DP的解来形成凸空间。随机的或者基于规则的决策，通常会给QP带来非凸的空间，因此解QP问题会失败或者陷入局部最优。 DP+QP:（1）通过DP寻求粗糙解；（2）DP解能够生成凸空间；（3）QP在DP解形成的凸空间内，很大可能能够获得全局最优解。 ","date":"2023-07-15","objectID":"/posts/emplanner/:2:8","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"案例分析 图15展示了EM Planner在规划周期内，帧与帧之间完成最优轨迹规划的过程。 假设自车以10m/s的速度行进，一动态障碍物沿着相反方向朝着我们以同样10m/s的速度驶来，EM Planner按以下步骤迭代生成速度和路径规划： 历史规划（图15-a）：在动态障碍物出现之前，自车以恒定速度10m/s向前行驶。 路径规划迭代1（图15-b）：基于当前车速和动态障碍物的车速，两者将会在S=40m处相遇，因此，最好的方法是在S=40m处绕开障碍物。 速度规划迭代1（图15-c）：基于路径规划结果，即从右侧避开障碍物，自车将调整其速度规划，在避开障碍物之前减速到5m/s。 路径规划迭代2（图15-d）：由于产生了新的速度规划，自车将不再会与动态障碍物在S=40m处避开，而会在一个新的位置S=30m处避开障碍物。因此，路径规划结果也将会随速度规划改变而重新更新。 速度规划迭代2（图15-e）：由于路径规划已经更新，新的绕障位置在S=30m处，因此在S=40处减速也就没有必要了，新的速度规划使得自车可以在S=40m处加速而在S=30m处形成一个光滑的绕障。 经过迭代之后，最终车辆将在S=30m处减速绕障，并且绕障结束之后会加速，这样一个过程和人类驾驶员的表现很相似。 但值得注意的是，并不是每次规划都必须采取如上四步骤，根据场景不同可能会产生更多或更少的步骤。一般而言，场景越复杂，所需要的步骤就越多。 ","date":"2023-07-15","objectID":"/posts/emplanner/:3:0","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"总结 EM Planner是一种基于弱决策的算法，相比于强决策算法，EM Planner在复杂场景、多障碍物情况下表现更好。强决策依赖于提前制定出的决策行为，并且有难以理解和预测与障碍物交互的缺陷、难以满足大量障碍物阻挡生成基于规则的最佳轨迹的缺陷。 EM Planner通过将三维规划问题转化为两个二维规划问题，显著地降低了运算复杂度，因此会带来运行时间的压缩和整个系统的可交互性。 ","date":"2023-07-15","objectID":"/posts/emplanner/:4:0","tags":["draft"],"title":"EM Planner","uri":"/posts/emplanner/"},{"categories":["Planning"],"content":"决策规划（一）自动驾驶安全、舒适、高效的“守护神” ","date":"2023-07-15","objectID":"/posts/decisionandplanning_1/:1:0","tags":["draft"],"title":"Decision and Planning [1]","uri":"/posts/decisionandplanning_1/"},{"categories":["Planning"],"content":"决策规划分层架构 决策规划的任务，就是在对感知到的周边物体的预测轨迹的基础上，结合自动驾驶车辆的和当前位置，对车辆做出最合理的决策和控制。 正如人的大脑又分为左脑和右脑、并负责不同的任务一样，模块化自动驾驶系统中决策规划层也可以继续细分为执行不同任务的子层。而这一分层设计最早其实是源自2007年举办的DAPRA城市挑战赛，比赛中多数参赛队伍都将自动驾驶系统的决策规划方式包括三层：全局路径规划层（Route Planning）、行为决策层（Behavioral Layer）和运动规划层（Motion Planning），如图5所示。 全局路径规划层聚焦在相对顶层的路径规划，聚焦在分钟到小时级别的规划。该层在接收到输入的目的地信息后，基于存储的地图信息搜素出一条自起始点至目标点的一条可通过的路径。如图6所示，在蓝色起点和黄色终点之间，黑色就是搜索出来的一条可通行的路径，当然路径不止一条，如何搜索出最优是下文将要介绍的内容。 行为决策层在收到全局路径后，结合感知环境信息、交通规则信息、车辆状态信息、驾驶场景信息等，推导判断下一分钟或下一秒时刻的情况，作出车道保持、车辆跟随、车道变换和制动避撞等的适合当前交通环境的驾驶行为。如图8所示，自车在检测到前方存在低速行驶车辆，且右侧车道满足变道条件后，作出向右变道的驾驶行为决策。 运动规划层也被成为局部路径规划层，与全局路径规划聚焦在分钟到小时级别的规划不同，运动规划聚焦在毫秒级到秒级的规划。规划的时候，根据输入的行为决策信息、结合车辆实时位姿信息、局部环境信息、全局路径参考信息等，在“安全、舒适、效率”的精神引领下，规划生成一条满足特定约束条件的平滑轨迹轨迹（包括行驶轨迹、速度、方向等），并输入给控制执行层。 ","date":"2023-07-15","objectID":"/posts/decisionandplanning_1/:1:1","tags":["draft"],"title":"Decision and Planning [1]","uri":"/posts/decisionandplanning_1/"},{"categories":["planning"],"content":"ref: [1]. https://mp.weixin.qq.com/s?__biz=MzI2NDY3OTExNw==\u0026mid=2247487486\u0026idx=1\u0026sn=830e7989f285214903c377b35e4b26d1\u0026chksm=eaa9b45cddde3d4a800aaf20fe318f491db75dda42e195cf14bf40084764c29464e7ccb4aad7\u0026mpshare=1\u0026scene=24\u0026srcid=0304BpDN7zLg79RhCijHZ2vJ\u0026sharer_sharetime=1677894823237\u0026sharer_shareid=56cef55fe29db276ae71bc9f586487a1\u0026key=2feb26e6a61e3d07649dfd6a51be6bb25154bc6376a7efb1822eb9800c6762bdec0839b31eac2d53e7f3a38b41696a04763e2640b202142a465d103b5d979e98f8f58c6e6605e2a76edf1c546c4d4d5f42dfe55935123958e7d001d2f802261f3473e6a62ac38fbb731fa7b486d65f38fe75c7121cb46fbab1e7b14f414379f9\u0026ascene=14\u0026uin=MjUyNzM0ODk1\u0026devicetype=Windows+10+x64\u0026version=6309001c\u0026lang=zh_CN\u0026countrycode=DE\u0026exportkey=n_ChQIAhIQpLbne6sMPw4l4V2IEPhLPxLZAQIE97dBBAEAAAAAAD%2FvOcyN4xcAAAAOpnltbLcz9gKNyK89dVj0cCpL6X4%2F9D%2BOuEd517ZezCwL3LfXM5G32y6FBL094wgcVWCTvgW%2Bz4fcrxht5Et9%2FUDDn2cw7Ay9T9fyCNiz21sZHDrEOhZlmmdWpjj2WKQ1flB1hocdJwzrYu0PN7DoVSQ4LEsw3yErLBUhYBSwGAArxC5y%2FzMbMZ8hFAQhKnpd9GPPRQCQmIeWvMl2Zb6nmhgch5icU5Ro%2F%2BmZx%2BV7tbmT0VIVBN7amHSXzs8eAiXSq0I%3D\u0026acctmode=0\u0026pass_ticket=xjMi8aZX3Oq63c%2B7lWkTHtjTObwzDeknqt%2FUl2bVeVY8VC%2F1bfFzwKgz6ydTfuv150JdS2QIagqoczC%2FeNOvBg%3D%3D\u0026wx_header=1\u0026fontgear=2 ","date":"2023-07-15","objectID":"/posts/decisionandplanning_4/:0:0","tags":["draft"],"title":"Decision and Planning [4]","uri":"/posts/decisionandplanning_4/"},{"categories":["planning"],"content":"决策规划（四）行为决策常用算法 满足两个要求: 安全性和舒适性 运动规划生成的轨迹是一种由二维空间和一维时间组成的三维空间中的曲线，是一种偏实时的路径规划。 ","date":"2023-07-15","objectID":"/posts/decisionandplanning_4/:1:0","tags":["draft"],"title":"Decision and Planning [4]","uri":"/posts/decisionandplanning_4/"},{"categories":["planning"],"content":"PRM 概率路标法 (Probabilistic Road Maps, PRM），是一种经典的采样方法，由Lydia E.等人在1996年提出。PRM主要包含三个阶段，一是采样阶段，二是碰撞检测阶段，三是搜索阶段。 采样阶段: 在采样阶段中，PRM首先在地图空间进行均匀的随机采样，也就是对地图进行稀疏采样，目的是将大地图简化为较少的采样点。 碰撞检测阶段: 剔除落在障碍物上的采样点，并将剩下的点与其一定距离范围内的点相连，同时删除穿越障碍物的连线，从而构成一张无向图。 搜索阶段: 利用全局路径规划算法章节介绍的搜索算法（Dijkstra、A*等）在无向图中进行搜索，从而找出一条起点A到终点B之间的可行路径。 算法步骤可以总结为： （1）构造无向图G =（V，E），其中V代表随机采样的点集，E代表两采样点之间所有可能的无碰撞路径，G初始状态为空。 （2）随机撒点，并选取一个无碰撞的点c(i)加入到V中。 （3）定义距离r，如果c(i)与V中某些点的距离小于r，则将V中这些点定义为c(i)的邻域点。 （4）将c(i)与其邻域点相连，生成连线t，并检测连线t是否与障碍物发生碰撞，如果无碰撞，则将t加入E中。 （5）重复步骤2-4，直到所有采样点（满足采样数量要求）均已完成上述步骤。 （5）采用图搜索算法对无向图G进行搜索，如果能找到起始点A到终点B的路线，说明存在可行的行驶轨迹。 PRM算法相比基于搜索的算法，简化了环境、提高了效率。但是在有狭窄通道场景中，很难采样出可行路径，效率会大幅降低。 ","date":"2023-07-15","objectID":"/posts/decisionandplanning_4/:1:1","tags":["draft"],"title":"Decision and Planning [4]","uri":"/posts/decisionandplanning_4/"},{"categories":["planning"],"content":"RRT 快速探索随机树（Rapidly Exploring Random Trees，RRT），是Steven M. LaValle和James J. Kuffner Jr.在1998年提出的一种基于随机生长树思想实现对非凸高维空间快速搜索的算法。 与PRM相同的是两者都是基于随机采样的算法，不同的是PRM最终生成的是一个无向图，而RRT生成的是一个随机树。RRT的最显著特征就是具备空间探索的能力，即从一点向外探索拓展的特征。 RRT分单树和双树两种类型，单树RRT将起点作为随机树的根节点，通过随机采样、碰撞检测的方式为随机树增加叶子节点，最终生成一颗随机树。而双树RRT则拥有两颗随机树，分别以起点和终点为根节点，以同样的方式进行向外的探索，直到两颗随机树相遇，从而达到提高规划效率的目的。 对于单树RRT算法，我们将起点A设置为随机树的根，并生成一个随机采样点，如图27所示，随机采样点有下面这几种情况。 （1）随机采样点1落在自由区域中，但是根节点A和随机采样点1之间的连线存在障碍物，无法通过碰撞检测，采样点1会被舍弃，重新再生成随机采样点。 （2）随机采样点2落在障碍物的位置，采样点2也会被舍弃，重新再生成随机采样点。 （3）随机采样点3落在自由区域，且与根节点A之间的连线不存在障碍物，但是超过根节点的步长限制。但此时这个节点不会被简单的舍弃掉，而是会沿着根节点和随机采样点3的连线，找出符合步长限制的中间点，将这个中间点作为新的采样点，也就是图29中的4。 接着我们继续生成新的随机采样点，如果新的随机采样点位于自由区域，那么我们就可以遍历随机树中已有的全部节点，找出距离新的随机采样点最近的节点，同时求出两者之间的距离，如果满足步长限制的话，我们将接着对这两个节点进行碰撞检测，如果不满足步长限制的话，我们需要沿着新的随机采样点和最近的节点的连线方向，找出一个符合步长限制的中间点，用来替代新的随机采样点。最后如果新的随机采样点和最近的节点通过了碰撞检测，就意味着二者之间存在边，我们便可以将新的随机采样点添加进随机树中，并将最近的点设置为新的随机采样点的父节点。 重复上述过程，直到新的随机采样点在终点的步长限制范围内，且满足碰撞检测。则将新的随机采样点设为终点B的父节点，并将终点加入随机树，从而完成迭代，生成如图30所示的完整随机树。 相比PRM，RRT无需搜索步骤、效率更高。通过增量式扩展的方式，找到路径后就立即结束，搜索终点的目的性更强。但是RRT作为一种纯粹的随机搜索算法，对环境类型不敏感，当地图空间中存在狭窄通道时，因被采样的概率低，导致算法的收敛速度慢，效率会大幅下降，有时候甚至难以在有狭窄通道的环境找到路径。 图31展示了 RRT应对存在狭窄通道地图空间时的两种表现，一种是RRT很快就找到了出路，一种是一直被困在障碍物里面。 围绕如何更好的“进行随机采样”、“定义最近的点”以及“进行树的扩展”等方面，诞生了多种改进型的算法，包括双树RRT-Connect（双树）、lazy-RRT, RRT-Extend等。 PRM和RRT都是一个概率完备但非最优的路径规划算法，也就是只要起点和终点之间存在有效的路径，那么只要规划的时间足够长，采样点足够多，必然可以找到有效的路径。但是这个解无法保证是最优的。 采用PRM和RRT等随机采样算法生成的行驶轨迹，大多是一条条线段，线段之间的曲率也不不连续，这样的行驶轨迹是不能保证舒适性的，所以还需要进一步进行曲线平滑、角度平滑处理。代表算法是基于曲线插值的方法：RS曲线、Dubins曲线、多项式曲线、贝塞尔曲线和样条曲线等。 所有基于曲线插值方法要解决的问题就是：在图32上的若干点中，求出一条光滑曲线尽可能逼近所有点。下文以多项式曲线和贝塞尔曲线为例，介绍曲线插值算法的示例。 ","date":"2023-07-15","objectID":"/posts/decisionandplanning_4/:1:2","tags":["draft"],"title":"Decision and Planning [4]","uri":"/posts/decisionandplanning_4/"},{"categories":["planning"],"content":"多项式曲线 ","date":"2023-07-15","objectID":"/posts/decisionandplanning_4/:1:3","tags":["draft"],"title":"Decision and Planning [4]","uri":"/posts/decisionandplanning_4/"},{"categories":["Planning"],"content":"ref: [1] https://mp.weixin.qq.com/s/hgT-a3Ug9578k1DmioRgUg [2] http://www.gamedev.net/reference/articles/article2003.asp ","date":"2023-07-15","objectID":"/posts/a_star/:0:0","tags":["Planning"],"title":"A star (A*) 算法","uri":"/posts/a_star/"},{"categories":["Planning"],"content":"A*算法详解 ","date":"2023-07-15","objectID":"/posts/a_star/:1:0","tags":["Planning"],"title":"A star (A*) 算法","uri":"/posts/a_star/"},{"categories":["Planning"],"content":"概述 虽然掌握了 A* 算法的人认为它容易，但是对于初学者来说， A* 算法还是很复杂的。 ","date":"2023-07-15","objectID":"/posts/a_star/:1:1","tags":["Planning"],"title":"A star (A*) 算法","uri":"/posts/a_star/"},{"categories":["Planning"],"content":"搜索区域(The Search Area) ","date":"2023-07-15","objectID":"/posts/a_star/:1:2","tags":["Planning"],"title":"A star (A*) 算法","uri":"/posts/a_star/"},{"categories":["Planning"],"content":"开始搜索(Starting the Search) 一旦我们把搜寻区域简化为一组可以量化的节点后，就像上面做的一样，我们下一步要做的便是查找最短路径。在 A* 中，我们从起点开始，检查其相邻的方格，然后向四周扩展，直至找到目标。 我们这样开始我们的寻路旅途： 1.从起点 A 开始，并把它就加入到一个由方格组成的 open list( 开放列表 ) 中。这个 open list 有点像是一个购物单。当然现在 open list 里只有一项，它就是起点 A ，后面会慢慢加入更多的项。 Open list 里的格子是路径可能会是沿途经过的，也有可能不经过。基本上 open list 是一个待检查的方格列表。 2.查看与起点 A 相邻的方格 ( 忽略其中墙壁所占领的方格，河流所占领的方格及其他非法地形占领的方格 ) ，把其中可走的 (walkable) 或可到达的 (reachable) 方格也加入到 open list 中。把起点 A 设置为这些方格的父亲 (parent node 或 parent square) 。当我们在追踪路径时，这些父节点的内容是很重要的。稍后解释。 3.把 A 从 open list 中移除，加入到 close list( 封闭列表 ) 中， close list 中的每个方格都是现在不需要再关注的。 如下图所示，深绿色的方格为起点，它的外框是亮蓝色，表示该方格被加入到了 close list 。与它相邻的黑色方格是需要被检查的，他们的外框是亮绿色。每个黑方格都有一个灰色的指针指向他们的父节点，这里是起点 A 。 ","date":"2023-07-15","objectID":"/posts/a_star/:1:3","tags":["Planning"],"title":"A star (A*) 算法","uri":"/posts/a_star/"},{"categories":["Distributed Computing"],"content":"TensorRT 介绍 TensorRT是一个高性能的深度学习推理（Inference）优化器，可以为深度学习应用提供低延迟、高吞吐率的部署推理。TensorRT可用于对超大规模数据中心、嵌入式平台或自动驾驶平台进行推理加速。TensorRT现已能支持TensorFlow、Caffe、Mxnet、Pytorch等几乎所有的深度学习框架，将TensorRT和NVIDIA的GPU结合起来，能在几乎所有的框架中进行快速和高效的部署推理。 TensorRT 是一个C++库，从 TensorRT 3 开始提供C++ API和Python API，主要用来针对 NVIDIA GPU进行 高性能推理（Inference）加速。 由以上图可以很清楚的看出，训练(training)和 推理(inference)的区别： **训练(training)**包含了前向传播和后向传播两个阶段，针对的是训练集。训练时通过误差反向传播来不断修改网络权值(weights)。 **推理(inference)**只包含前向传播一个阶段，针对的是除了训练集之外的新数据。可以是测试集，但不完全是，更多的是整个数据集之外的数据。其实就是针对新数据进行预测，预测时，速度是一个很重要的因素。 一般的深度学习项目，训练时为了加快速度，会使用多GPU分布式训练。但在部署推理时，为了降低成本，往往使用单个GPU机器甚至嵌入式平台（比如 NVIDIA Jetson）进行部署，部署端也要有与训练时相同的深度学习环境，如caffe，TensorFlow等。 由于训练的网络模型可能会很大（比如，inception，resnet等），参数很多，而且部署端的机器性能存在差异，就会导致推理速度慢，延迟高。这对于那些高实时性的应用场合是致命的，比如自动驾驶要求实时目标检测，目标追踪等。所以为了提高部署推理的速度，出现了很多轻量级神经网络，比如squeezenet，mobilenet，shufflenet等。基本做法都是基于现有的经典模型提出一种新的模型结构，然后用这些改造过的模型重新训练，再重新部署。 而tensorRT 则是对训练好的模型进行优化。 tensorRT就只是 推理优化器。当你的网络训练完之后，可以将训练模型文件直接丢进tensorRT中，而不再需要依赖深度学习框架（Caffe，TensorFlow等），如下: 可以认为tensorRT是一个只有前向传播的深度学习框架，这个框架可以将 Caffe，TensorFlow的网络模型解析，然后与tensorRT中对应的层进行一一映射，把其他框架的模型统一全部 转换到tensorRT中，然后在tensorRT中可以针对NVIDIA自家GPU实施优化策略，并进行部署加速。 目前TensorRT8.0 几乎可以支持所有常用的深度学习框架，对于caffe和TensorFlow来说，tensorRT可以直接解析他们的网络模型；对于caffe2，pytorch，mxnet，chainer，CNTK等框架则是首先要将模型转为 ONNX 的通用深度学习模型，然后对ONNX模型做解析。而tensorflow和MATLAB已经将TensorRT集成到框架中去了。 **ONNX(Open Neural Network Exchange)**是微软和Facebook携手开发的开放式神经网络交换工具，也就是说不管用什么框架训练，只要转换为ONNX模型，就可以放在其他框架上面去inference。这是一种统一的神经网络模型定义和保存方式，上面提到的除了tensorflow之外的其他框架官方应该都对onnx做了支持，而ONNX自己开发了对tensorflow的支持。从深度学习框架方面来说，这是各大厂商对抗谷歌tensorflow垄断地位的一种有效方式；从研究人员和开发者方面来说，这可以使开发者轻易地在不同机器学习工具之间进行转换，并为项目选择最好的组合方式，加快从研究到生产的速度。 ONNX / TensorFlow / Custom deep-learning frame模型的工作方式： tensorRT中有一个 Plugin 层，这个层提供了 API 可以由用户自己定义tensorRT不支持的层。 TensorRT-plugin 目前TensorRT支持的层有:https://github.com/onnx/onnx-tensorrt/blob/main/docs/operators.md 目前ONNX支持的算子:https://github.com/onnx/onnx/blob/main/docs/Operators.md ","date":"2023-07-14","objectID":"/posts/tensorrt_introduction/:0:1","tags":["TensorRT"],"title":"TensorRT Introduction","uri":"/posts/tensorrt_introduction/"},{"categories":["Distributed Computing"],"content":"TensorRT 优化方式 TensorRT优化方法主要有以下几种方式，最主要的是前面两种。 层间融合或张量融合(Layer \u0026 Tensor Fusion) 如下图左侧是GoogLeNetInception模块的计算图。这个结构中有很多层，在部署模型推理时，这每一层的运算操作都是由GPU完成的，但实际上是GPU通过启动不同的CUDA（Compute unified device architecture）核心来完成计算的，CUDA核心计算张量的速度是很快的，但是往往大量的时间是浪费在CUDA核心的启动和对每一层输入/输出张量的读写操作上面，这造成了内存带宽的瓶颈和GPU资源的浪费。TensorRT通过对层间的横向或纵向合并（合并后的结构称为CBR，意指 convolution, bias, and ReLU layers are fused to form a single layer），使得层的数量大大减少。横向合并可以把卷积、偏置和激活层合并成一个CBR结构，只占用一个CUDA核心。纵向合并可以把结构相同，但是权值不同的层合并成一个更宽的层，也只占用一个CUDA核心。合并之后的计算图（图4右侧）的层次更少了，占用的CUDA核心数也少了，因此整个模型结构会更小，更快，更高效。 数据精度校准(Weight \u0026Activation Precision Calibration) 大部分深度学习框架在训练神经网络时网络中的张量（Tensor）都是32位浮点数的精度（Full 32-bit precision，FP32），一旦网络训练完成，在部署推理的过程中由于不需要反向传播，完全可以适当降低数据精度，比如降为FP16或INT8的精度。更低的数据精度将会使得内存占用和延迟更低，模型体积更小。 Precision Dynamic Range FP32 −3.4×1038 +3.4×1038 FP16 −65504 +65504 INT8 −128 +127 INT8只有256个不同的数值，使用INT8来表示 FP32精度的数值，肯定会丢失信息，造成性能下降。不过TensorRT会提供完全自动化的校准（Calibration ）过程，会以最好的匹配性能将FP32精度的数据降低为INT8精度，最小化性能损失。 Kernel Auto-Tuning 网络模型在推理计算时，是调用GPU的CUDA核进行计算的。TensorRT可以针对不同的算法，不同的网络模型，不同的GPU平台，进行 CUDA核的调整（怎么调整的还不清楚），以保证当前模型在特定平台上以最优性能计算。 TensorRT will pick the implementation from a library of kernels that delivers the best performance for the target GPU, input data size, filter size, tensor layout, batch size and other parameters. Dynamic Tensor Memory 在每个tensor的使用期间，TensorRT会为其指定显存，避免显存重复申请，减少内存占用和提高重复使用效率。 Multi-Stream Execution Scalable design to process multiple input streams in parallel，这个应该就是GPU底层的优化了。 ","date":"2023-07-14","objectID":"/posts/tensorrt_introduction/:0:2","tags":["TensorRT"],"title":"TensorRT Introduction","uri":"/posts/tensorrt_introduction/"},{"categories":["Distributed Computing"],"content":"TensorRT 安装 CUDA的安装 安装显卡驱动 安装cuda 2.1 进入nvidia开发者网站的CUDA下载页面选择runfile格式的文件下载。 2.2 下载完成后，解压，并运行上图中的命令，会有条款，接受即可，注意安装CUDA的时候不要安装驱动 2.3 路径设置 $ export PATH=/usr/local/cuda-10.2/bin:/usr/local/cuda-10.2/nsight-compute-2019.5.0${PATH:+:${PATH}} $ export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64/${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 并使设置生效: source ~/.bashrc 2.4 验证安装是否成功 进入/usr/local/cuda-10.1/samples/1_Utilities/目录， cd deviceQuery sudo make ./deviceQuery 出现如下输出，则CUDA安装成功。 安装cuDNN 3.1进入cudnn下载页面，下载版本合适的版 3.2 解压，并进入到相应目录，运行以下命令： sudo cp cuda/include/cudnn*.h /usr/local/cuda-10.2/include sudo cp cuda/lib64/libcudnn* /usr/local/cuda-10.2/lib64 sudo chmod a+r /usr/local/cuda-10.2/include/cudnn*.h sudo chmod a+r /usr/local/cuda-10.2/lib64/libcudnn* 3.3 查看cudnn版本 cat /usr/local/cuda-10.2/include/cudnn.h | grep CUDNN_MAJOR -A 2 新版本: cat /usr/local/cuda-10.2/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 ref: https://blog.csdn.net/weixin_43592742/article/details/115689886?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0\u0026spm=1001.2101.3001.4242 TensorRT的安装 英伟达提供的安装指导 tensorRT 要匹配cuda和cudnn版本。在安装之前请匹配。 OSS 和 GA 两个版本: TensorRT OSS: git clone -b master https://github.com/nvidia/TensorRT TensorRT cd TensorRT git submodule update --init --recursive GA 版本(下载地址) 对GA版本和OSS版本在~/.bashrc文件中声明路径: (GA: General Availability Stable Version) (OSS: OPEN SOURCE) [oss版本路径]export TRT_SOURCE=/home/yejian/TensorRT/TensorRT_7.2.1 [GA Release 版本路径]export TRT_RELEASE=/home/yejian/TensorRT/TensorRT_7.2.1/TensorRT-7.2.1.6/TensorRT-7.2.1.6 Build TensorRT RSS (这一步需要在编写自定义算子的时候编译通过，参能调用自定义算子) cd $TRT_OSSPATH mkdir -p build \u0026\u0026 cd build cmake .. -DTRT_LIB_DIR=$TRT_LIBPATH -DTRT_OUT_DIR=`pwd`/out make -j$(nproc) ","date":"2023-07-14","objectID":"/posts/tensorrt_introduction/:0:3","tags":["TensorRT"],"title":"TensorRT Introduction","uri":"/posts/tensorrt_introduction/"},{"categories":["Distributed Computing"],"content":"自定义算子开发 – ScatterElements 在自定义算子开发过程中，需要撰写一下4个文件，并且把文件放在scatterElementsPlugin文件夹中: CmakeLists.txt scatterElements.cu scatterElementsPlugin.cpp scatterElementsPlugin.h 如图所示: 自定义算子的生成与注册 将以上四个文件报括文件夹复制到TensorRT(OOS)下的plugin文件夹下; 然后修改注册信息文件:(这些文件也在plugin文件夹下) ${TRT_SOURCE}/plugin: CMakeLists.txt ${TRT_SOURCE}/InferPlugin.cpp ${TRT_SOURCE}/common/kernels/kernel.h ${TRT_SOURCE}/parsers/onnx/builtin_op_importers.cpp 执行完以上步骤以后，重新编译OOS版本，然后就可以调用自定义算子: cd $TRT_OSSPATH mkdir -p build \u0026\u0026 cd build cmake .. -DTRT_LIB_DIR=$TRT_LIBPATH -DTRT_OUT_DIR=`pwd`/out make -j$(nproc) ","date":"2023-07-14","objectID":"/posts/tensorrt_introduction/:1:0","tags":["TensorRT"],"title":"TensorRT Introduction","uri":"/posts/tensorrt_introduction/"},{"categories":["RL"],"content":" quote note abstract info tip success question warning failure danger bug example quote https://zhuanlan.zhihu.com/p/337976595 DRL:DQN, PG, AC, DDPG, SAC概述 ","date":"2023-07-14","objectID":"/posts/dpg/:0:0","tags":["draft"],"title":"DPG","uri":"/posts/dpg/"},{"categories":["RL"],"content":"[DQN]paper link: https://arxiv.org/pdf/1312.5602v1.pdf ","date":"2023-07-14","objectID":"/posts/dqn/:0:0","tags":null,"title":"DQN","uri":"/posts/dqn/"},{"categories":["RL"],"content":"DQN: Playing Atari with Deep Reinforcement Learning ","date":"2023-07-14","objectID":"/posts/dqn/:1:0","tags":null,"title":"DQN","uri":"/posts/dqn/"},{"categories":["RL"],"content":"General Architecture Here is Network listed: play Atari games using RL and perform better than human CNN + Q Learning: CNN for frame-skiped images features extraction; and Q Learning for policy generation Network Channel Kernel Size Stride Activation Output Size Input NA NA NA NA $84\\times84\\times4$ First Conv 16 8x8 4 Relu $20 \\times 20 \\times 6$ Second Conv 32 4x4 2 Relu $9 \\times 9 \\times 32$ Hidden NA NA NA Relu 256 Output NA NA NA None 4 to 18 在当时，普遍的做法是为每一个action学习一个函数，而不是一个网络结构直接输出所有q的value. ","date":"2023-07-14","objectID":"/posts/dqn/:1:1","tags":null,"title":"DQN","uri":"/posts/dqn/"},{"categories":["RL"],"content":"Key 1: Input Info Process 图像处理部分 Grayscale, Downsampling and Cropping RGB channels to gray scale channel (将RGB取均值为灰度图): 216 x 163 x 3 =\u003e(grayscale) 216 x 163 x 1 =\u003e(downsampling) 110 x 84 x 1 =\u003e(cropping) 84 x 84 x 1 游戏部分 Key Frame and Action Repeat select skipped frames (每个4帧选取关键帧)，假设智能体看不见中间过程; 而且agent在每k帧选择一个action，可以加速训练 作用: 加速游戏进行: 计算Q-Value是最耗时的步骤; 减少噪声: 过分紧密的frame重复信息过多，之前的action容易被否决; 缩短reward signal到具体aciton之间的时间间隔。 History as Input continuous history key frames as input (连续四个关键帧作为输入) 作用: 可以帮助智能体获得更多有效信息进行训练 Reward Clipping 将多有的reward简化为+1, -1和0 缺点: 有可能对训练效果有影响 作用: 损失了部分信息，但是可以保证不同游戏的reward scale相同，可以用相同的参数进行训练(因为在论文中，作者在多个游戏上对DQN进行了验证)。 ","date":"2023-07-14","objectID":"/posts/dqn/:1:2","tags":null,"title":"DQN","uri":"/posts/dqn/"},{"categories":["RL"],"content":"Key 2: Replay Buffer 原理: DQN中对神经网络的训练本质依然是SGD，SGD要求多次利用样本，并且样本独立，但相邻的transition都是高度相关的，所以要记住过去的transition一起抽样; Replay Buffer通过记忆一段时间内的trainsition，可以让训练数据分布更平稳; Replay Buffer通过忘记很久之前的trainsition，可以保证记住的分布大致模拟当前policy的分布，从而进行policy update; 可以多次重复采样，提升data efficiency. Replay Buffer生效的一个重要条件: 存储transition数量合适 太多: 可能使reward signal太过稀疏，影响训练 太少: 可能会导致训练数据的分布迅速变化 ","date":"2023-07-14","objectID":"/posts/dqn/:1:3","tags":null,"title":"DQN","uri":"/posts/dqn/"},{"categories":["RL"],"content":"Key 3: Semi-Gradient Method 在Eauation3中， $$y_i = r + \\gamma \\max_{a’}Q(s’, a’; \\theta_{t-1})$$ 不和之后的Q函数共享参数; 但是在实际的训练过程中，采用 $$ y_i = r + \\gamma \\max_{a’}Q(s’, a’; \\theta_{t})$$ 和之后的Q函数共享参数，但是实际上不参与导数计算，这种方法称为Semi-Gradient Method。 作用: 使训练更新更稳定。 ","date":"2023-07-14","objectID":"/posts/dqn/:1:4","tags":null,"title":"DQN","uri":"/posts/dqn/"},{"categories":["Distributed Computing"],"content":"1. 概述 分布式训练服务框架与集合通信库的组合构成了分布式训练的整体服务软件栈，在第3篇、第4篇文章里已经剖析完集合通信的相关内容，而本文会以Horovod为例介绍数据并行下分布式训练服务框架的基本原理以及进行架构解析。当前，在分布式训练里分布式训练服务框架需要解决以下几个核心问题 ： 计算与通信同步耦合问题：如果反向传播一产生一份梯度，就马上对其调用全局AllReduce，计算与通信同步耦合，容易造成死锁同时性能也会很不如意； 计算时间与通信时间串行问题：神经网络是分层的，梯度计算的过程是数据加载，然后前向传播算出损失值，再反向传播算出梯度，而反向计算时梯度是从输出层往输入层方向一层一层产生的，在有些模型里，如果需要等所有的梯度都计算完毕才能触发全局AllReduce，那么对性能的影响也会很大； 梯度生成的落后者问题：集群内每个计算节点的同一份梯度的产生不一定都是同一时刻的，如果梯度没有全部生成就发起对这个梯度的全局规约，否则容易造成训练出来的模型精度不达标或者不收敛的问题； 梯度融合问题：如果每一份梯度都触发一次全局AllReduce，在梯度Tensor较多的神经网络训练里，整体的训练系统性能会变得极低； 易用性问题：从TensorFlow，PyTorch迁移过来需要改的代码需要极少，从单卡训练迁移到多卡训练需要改动的代码也需要极少； 可移植问题：支持多种多样的深度学习训练框架，比如 TensorFlow、PyTorch、MxNet等，也能支持多种多样的通信库，比如openMPI、NCCL、Gloo、CCL、RCCL等； 可靠性问题：在集群训练的过程中网络时不可靠的、计算卡是会出故障的、服务器是会出故障的、系统软件也是会出Bug的，这些因素造成了分布式训练过程中还存在可靠性问题，如何解决这个问题也是一个难题。 软件是由人实现的，解析一个软件系统最难的地方在于从庞杂的代码里倒推出背后实现它的人的设计意图，为了更好的理解Horovod，本文会基于以上这几个分布式训练的核心问题，以Horovod为例介绍分布式训练服务框架的基本原理以及进行架构解析。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:1:0","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"2. 基础知识 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:2:0","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"2.1 单卡训练 神经网络的训练，本质上就是Y=F(x)的迭代，通过反复输入X、输出Y，使得神经网络的参数变化与输入输出间的复杂关系拟合。在神经网络训练的过程中，通过输入数据利用梯度下降的方法进行迭代从而优化神经网络参数，并最终输出神经网络模型。而神经网络可以看作一种运算模型，其由大量的神经元（节点）相互联接构成，其由输入层、隐藏层以及输出层组合而成（如下图左侧所示）。神经元(neuron)是神经网络的基本计算单元，也被称作节点(node)，它可以接受来自其他神经元或外部数据的输入，然后计算出一个输出（如下图右上角所示）。 如上图右下角所示，在单卡训练迭代中，基于并行梯度下降法，会有以下操作： 第一步，读取部分数据，并且将数据加载进训练卡的存储空间； 第二步，对模型进行前向传播计算，从输入层往输出层一层一层的进行计算，得到损失差LOSS； 第三步，对模型进行反向传播计算，从输出层往输入层一层一层的进行计算，得到梯度值，注意这一步会把每一层都计算出一个梯度张量（Gradient Tensor）出来； 第四步，将新的到的梯度与部分数据 作为新的输入，重新开始以上步骤的迭代。 在这一步里有一个很重要的与性能优化相关的信息是反向传播是每一层输出一个梯度张量，以及反向传播是从输出层往输入层一层一层的进行计算的，这一点信息可以用通信隐藏性能优化与梯度融合优化。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:2:1","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"2.2 多卡训练 以数据并行随机梯度下降法( SGD )为例，多卡神经网络的训练过程如下图，与单卡训练相比，多卡训练多了梯度全局规约的过程： 第一步，通过Broadcast操作将第一个节点参数同步到集群内的所有的训练卡上，保证每个计算节点的初始参数是一致的，同时训练脚本在多个计算节点上运行，每个计算节点包含了整体的模型参数； 第二步，将数据样本切片分发到整个集群内的个计算节点（训练卡）上并且通过数据流水技术将数据样本加载进训练卡的高速内存空间内，作为输入X; 第三步，每个训练卡在其数据样本上运行前向传播，计算出损失差LOSSi； 第四步，对计算出的LOSSi进行反向传播，得到梯度GRADi，这一步也需要注意得是每一层都会计算出一个梯度，同时梯度是以输出的Tensor来表示的； 第五步，所有的训练卡计算出来的部分梯度，在主机内及主机之间通过集合通信进行全局归约(AllReduce)得到全局梯度； 第六步，最后再将这个全局梯度作为参数进行更新，再进行以上2-5步骤的迭代从而获得新的梯度。 以上2-6步骤就是多卡并行梯度下降的基本思想，即多个计算节点通过分片的数据样本进行梯度计算，得到分区梯度后，再通过全局梯度规约以及将这个聚合好的梯度作为新的参数进行更新，从而实现并行梯度下降。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:2:2","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3. 几个核心问题 在本章节里会解读本文概述里提到的分布式服务框架需要解决的几个与性能、易用性等相关的几个核心问题，并且以Horovod为例讲述Horovod是如何解决这个几个难题的。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:0","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3.1 计算与通信解耦 在神经网络的训练过程中，每一神经网络层都会计算出一个梯度，同时梯度是以输出Tensor来表示的，如果反向传播一计算出一个梯度就马上调用通信去做梯度规约，将计算与通信同步耦合，那么整体的性能的表现就会很差。比如一个ResNet-50 v3的梯度张量个数是153个，如果一计算出一个梯度就马上进行通信，假设计算梯度花了1ms，通信这个梯度花了 500ms，那么这个过程就是 501ms，总体上就需要501x153 = 76653ms，即近76.6s才能完成一次梯度迭代。而将计算与通信解耦，计算的归计算，通信的归通信，通过性能优化策略减少通信的次数，既能提升整体训练性能也能避免某些死锁问题，比如计算梯度grad i的时候花了很长时间，而通信线程一直在等待这个梯度，表现出来就是死锁现象。 Horovod采用计算与通信分离的设计思想，解耦了计算过程与通信过程，从而提升了整体训练的性能与可靠性。如下图的Horovod逻辑架构图所示，从图中可以看出Horovod解耦了计算与通信，其将框架层计算出来的梯度request信息push 到一个消息队列message_queue里，同时将梯度信息push到一个Tensor_table里，再通过控制层在后台起一个loop线程，周期性的从消息队列里读取梯度消息，在控制层集群的节点之间协商达成一致后，再进行消息分发触发训练行为。 如上图可看出，Horovod从下到上分为7层：物理层、链路层、数据传输层、控制层、消息层、框架层以及用户层。框架层，控制层以及数据传输层体现了Horovod的核心设计理念，即：框架层，用户可以自定义Op，以插件的形式hack进框架；在控制层，worker节点与master节点之间协商达成触发训练行为的约定；在数据传输层，服务器内以及服务器之间采用集合通信库传输数据。 本质上Horovod的整体设计理念之一遵循的是生产者消费者模式，如下图所示： 在Horovod里每个计算节点都会有有两个核心线程：Execution thread 和 Background thread ： 生产者Execution Thread 是用来做梯度计算的，在TensorFlow、PyTorch之类的之类的训练框架计算出梯度Tensor后，将Tensor 信息push进tenor_table队列，同时将Tensor的request信息push进message_queue队列; 消费者Background thread 是做集合通讯以及全局Allreduce的，后台线程会每隔一段时间轮询消息队列，拿到一批Tensor信息之后，会进行相应的操作。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:1","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3.2 通信隐藏 神经网络是分层的，在训练的过程中，先是数据加载，然后前向传播算出LOSS，再反向传播算出梯度，而反向计算时梯度是从输出层往输入层方向一层一层产生的，如果需要等所有的梯度都计算完毕才能触发全局AllReduce，对性能不是很友好。如下图所示，计算时间与通信时间是串行的，如果能将全局梯度规约的通信时间与计算时间想办法并行起来，将通信时间隐藏在计算时间之内，那么就能节约梯度的训练时间从而提升分布式训练系统整体的训练性能。 如下图所示，将计算出来的梯度进行分桶触发异步Allreduce，一边反向传播计算梯度，一边做部分梯度的全局规约通信，从而达到将通信时间隐藏在计算时间内的效果。而Horovod为达成这一效果，Background thread 会每隔一段时间轮询梯度消息队列里的梯度信息，获取了可以过全局规约的梯度后，就进行全局规约操作，而这个时间其他的梯度还在计算过程中，通过调整轮询的时间间隔从而达到调整梯度分桶的效果。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:2","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3.3 梯度协商 神经网络的每一层对应一个梯度Tensor，在分布式训练集群里每张训练卡对同一份梯度计算产生的时间是有差异的，当集群内每个计算节点的同一神经网络层的同一梯度都产生时，才能发起对这个梯度的全局AllReduce规约，否则容易造成丢梯度，训练出来模型精度不达标或者模型不收敛。比如在一个128卡的训练集群里，同一份梯度是对应同一个神经网络模型里的同一层神经网络的，只有每张训练卡上都计算出了同一层神经网络的梯度 才能对这一层神经网络的梯度进行全局规约，如下图所示： Horovod设计了一种梯度状态协商机制，它将 计算节点Rank0 作为coordinator（master），其余的rank1-N节点进程为worker，由coordinator来协商确定同一份梯度是否在每个计算节点上都已经计算出来，只有在每个计算节点上都计算出来的同一梯度才可以进行全局规约操作。在Horovod里每个计算节点上都有一个message_queue以及tensor_table，而在coordinator节点上除此之外，还有一个message_table用于保存可以进行全局Allreduce的梯度请求次数信息。Horovod 控制面的ComputeResponseList 函数里实现了这一梯度的协商过程，在从message_queue获取了本节点生成的梯度信息后，coordinator会与其他节点协商这个梯度是否都计算出来，这一过程是阻塞进行的，这个协商过程如下图： 一个梯度是否能满足全局规约AllReduce的协商过程如下： 首先，集群内的每个计算节点进程都会往coordinator Rank0发送一个 tensor的请求request，表示说本节点这一层神经网络的梯度已经生成，比如tensor1，每个rank都会往rank0 发送一个本梯度tensor1已经计算出来的请求信息； 第二步，coordinator接收到节点的梯度协商请求后（包括本节点），会把收到的tensor请求次数进行累加，并将这个信息记录在message_table里，当这个梯度的请求信息达到集群内节点的个数时，比如在N个节点的集群，一个神经网络层的梯度tensor的通信请求出现了N次，那就表示在本集群里所有的计算节点都已经发出了对该梯度tensor的通信request，这就表明这个梯度tensor是符合全局规约要求的，就能进行集合通信全局规约，不符合要求的梯度tensor将继续留在message_table中，直到条件符合为止； 第三步，再接着coordinator会将满足全局allreduce规约条件的梯度Tensor通过response返回给其他节点，告诉其他节点这个梯度可以启动全局规约AllReduce。 经过这几步的协商达成梯度全局状态一致的目的，从而避免梯度丢失造成的模型精度不达标、不收敛或者进程死锁问题。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:3","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3.4 梯度融合 神经网络的每一层都能对应一个梯度，假设每生成一个梯度就进行一次全局规约时，100个梯度就需要进行100次全局通信100次全局规约，而通信对训练的性能有巨大的影响，这种情况表现出来的效果就是分布式训练集群的整体性能极差。通过梯度融合计算将多个梯度合成一个，从而减少全局规约的次数能大幅提高分布式训练的训练性能，如下图所示，将N个小梯度Tensor合成两个，能将全局通信的次数减少到2次，从而大幅提升训练性能，在Horovod里这个功能对TensorFusion特性。但这个特性也会与3.2通信隐藏特性相冲突，需要根据具体情况进行合理的调试优化。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:4","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3.5 易用性 从TensorFlow，PyTorch等框架迁移到Horovod需要改的的代码极少，horovod接入方式比较简单，与原生训练框架对比，主要的区别在于： 1，初始化 Horovod，包括机器资源的分配： horovod.init() 2，向每个进程分配XPU资源， 典型的设置是 1 个 XPU 一个进程，即设置 local rank： config.gpu_options.visible_device_list = str(hvd.local_rank()) 3，对原优化器进行包装，分布式优化器将梯度计算委托给原始优化器，使用allreduce或allgather对梯度求平均，然后应用这些平均梯度： opt=hvd.DistributedOptimizer(opt) 4， 将初始化参数从rank 0广播给其他进程(rank表示进程序号)，实现参数的初始化，确保所有节点的初始化参数保持一致： hvd.BroadcastGlobalVariablesHook(0)： ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:5","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3.6 可移植 可移植问题，Horovod通过 OP和OpKernels的插件化机制支持多种多样的深度学习训练框架，比如 TensorFlow、PyTorch、MxNet等。基于的opKernels的可定制化机制，Horovod自定义了Op然后hack了数据链路层的通信协议，从而达到在多个深度学习框架之间可移植。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:6","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"3.7 可靠性问题 在集群训练的过程中网络时不可靠的、计算卡是会出故障的、服务器是会出故障的的，这些因素造成了分布式训练过程中需要考虑训练集群的可靠性，Horovod结合集合通信库Gloo对外提供了弹性训练的特性，但可靠性不只是弹性训练就能完全解决的，它还有更多的系统级的问题需要解决，因此可靠性问题留着一个后续研究问题，不在本文阐述。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:3:7","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"4. 优点缺点、改进点 简单易用、可移植，并且支持弹性训练提升了可靠性； 不依赖于某个框架，其通过MPI机制独立建立了一套分布式训练服务系统； 将计算与通信分离，完成了allreduce、allgather等集合通信工作，实现了规模可扩展； 巧妙的通过间隔轮询的机制支持通信时间隐藏，并且完成了梯度协商从而保证训练出来的模型是可收敛、精度达标的； 支持梯度融合，支持将小的tensor合并成一个大的tensor再进行通信传递，从而减小通信操作的额外开销； 自带压缩算法，可以减少集合通信的数据量； ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:4:0","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"5. 思考题 问题1，将通信时间隐藏在计算时间内能有助于提升训练系统的整体性能，但这一特性是针对SIMT芯片的架构的进行性能优化的，如果DSA芯片不能支持这一特性，那应该如何优化Horovod从而大幅提升整体的训练性能？（可以确定这一定是能做到的） 问题2，梯度协商的过程中，每个梯度都需要协商一次，在梯度较多，网络规模较大的集群里，这一特性也会影响性能，如何进行优化才能有效提升Horovod性能？\\ 问题3，不同的模型对梯度融合有不同的要求，那么梯度融合需要融合到什么程度才能有效提升性能？ 可以说明的是，这三个问题解决后还能继续提升Horovod在DSA架构芯片上的整体的分布式训练系统级性能。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:5:0","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"6. 小结 本文介绍了分布式训练的基础知识以及剖析了分布式训练服务框架所面临的几个核心问题，以Horovod为例从计算与通信解耦、通信隐藏、梯度协商、梯度融合、易用性以及可移植这几个角度倒推了分布式训练服务框架背后的设计意图，从而帮助大家能更好的理解分布式训练服务框架。 ref: [1] https://www.changping.me [2] https://horovod.ai [3] https://www.cnblogs.com/rossiXYZ/p/14910959.html [4] https://zhuanlan.zhihu.com/p/374575049 ","date":"2023-07-13","objectID":"/posts/distributedtraining_5/:6:0","tags":["Distributed Training"],"title":"分布式训练 - 第5篇 - 分布式训练服务框架基本原理与架构解析","uri":"/posts/distributedtraining_5/"},{"categories":["Distributed Computing"],"content":"ref: [1]. https://www.changping.me/2022/04/10/ai-distributed-training-coll-topo/ ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:0:0","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"1. 概述 在深度学习的分布式训练里，Ring AllReduce拓扑算法奠定了数据并行训练的集合通信基础，但集合通信拓扑不只是仅有Ring Allreduce，经典的集合通信拓扑算法还有2D-Ring/Hierarchical Ring AllReduce，halving and doubling AllReduce，Butterfly AllReduce，2D-Torus AllReduce，2D-Mesh AllReduce，double binary tree等。拓扑算法很多，但也不是所有的拓扑算法都能满足实际的生产需求的，这需要具体问题具体分析、具体场景具体设计。 集合通信的难点在于需要在固定的网络互联结构的约束下进行高效的通信，集合通信拓扑算法与物理网络互联结构强相关，为了发挥网络通信的效率，也不是说就能随意发挥通信拓扑算法，更多的是在效率与成本、带宽与时延、客户要求与质量、创新与产品化等之间进行合理取舍。 充分发挥训练加速卡与网络的效率是通信拓扑算法的初衷，但除了设计高效的集合通信拓扑算法外，分布式训练中需要解决的通信难题还有：网络是异构的，网络带宽是有限的，主机内PCIE SWITCH是有亲和性的，网络是会出故障的，节点是有落后者效应的，设备成本是需要考虑的，数据中心是有部署约束的，用户是有多租户要求的等，这些属于产品化的范畴不在本文阐述。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:1:0","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"2. 网络互联结构 分布式训练的集合通信拓扑算法与物理的网络互联结构强相关，而网络互联结构又多种多样，因此，本文需要先对网络互联结构进行约束，依据生产中常用的、既定的互联结构设计集合通信算法，网络互联结构描述如下： ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:2:0","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"2.1 服务内网络互联结构 以一台集成了8张训练加速卡的服务器为例，如下图: 这台服务器内的网络互联情况如下： 1）在这台服务器内，8张训练加速卡通过私有协议连接组成多个主机内的物理ring环，且可双工； 2）服务期内网络带宽 NVLINK\u003ePCIE switch \u003e QPI； 3）加速卡1、2、3、4之间两两全互联，加速卡5,、6、7、8之间两两全互联，2、5、3、8之间非全互联； 4）加速卡1、4与网卡NIC1 挂在同一个PCIE Switch上，具有亲和性，加速卡2、3与网卡NIC2挂在同一个PCIE Switch上，具有亲和性，而PCIE Switch之间也互联，因此 加速卡 1、2、3、4 与网卡NIC 1、NIC2具备亲和性，它们无需通过CPU的QPI线进行通信； 5）加速卡5、8与网卡NIC3 挂在同一个PCIE Switch上，具有亲和性，加速卡6、7与网卡NIC4挂在同一个PCIE Switch上，具有亲和性，而PCIE Switch之间也互联的，因此 加速卡 5、6、7、8 与网卡NIC 3、NIC4具备亲和性，它们也无需通过CPU的QPI线进行通信； 6）网卡可根据需要 选择 1张、2张、4张或8张，最多可以采用8张RDMA物理网卡； ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:2:1","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"2.2 服务器间网络互联结构 以一个训练加速卡集群为例，如下图是一个常用的CLOS互联架构方案: 在这个集群内，其网络互联情况如下： 1）集群内每台服务器自带高速RDMA网卡，通过RDMA 交换机在主机间两两全互联； 2）交换机组成CLOS架构，分为Spine与Leaf交换机，当然也可以是更为高端的Spine、Leaf合一的高端交换机； 3）RDMA网卡与Leaf交换机互联，每台服务器的RDMA网卡数量根据成本与性能考虑，可以是1张、2张+每卡虚拟化4卡、4张+每卡虚拟化2卡或8张； ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:2:2","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"2.3 高速网卡及其虚拟化使用 RDMA网卡是双工的且可虚拟化，在这里每台服务器可根据成本、性能的考虑选用1张、2张、4张或8张，且在服务器内左右对称，如下图： 从成本与效率的角度考虑，每台服务器内的网卡可以是以下配置： 1张物理RDMA网卡，不进行虚拟化，直接用双工通道，适合选用2D/Hierarchical Ring拓扑算法； 2张物理RDMA网卡，可以每张虚拟化出4个虚拟网卡，2X4共8卡，适合选用2D-MESH、2D-Torus拓扑算法； 4张物理RDMA网卡，可每张虚拟化出2个虚拟网卡，4X2共8卡，适合选用2D-MESH、2D-Torus拓扑算法； 8张物理RDMA网卡，不需要虚拟化，直接采用双工通道，适合选用2D-MESH、2D-Torus拓扑算法； 在实际的分布式训练生产集群中，集合通信算法也可以结合RDMA网卡端口（包括虚拟化的）的具体个数进行设计，而拓扑算法的选择也是需要根据成本与效率的进行合理取舍的。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:2:3","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"2.4 网络结构抽象 网络根据连接情况可分为ring结构、mesh结构、 torus 结构以及tree结构，基于以上的服务器内网络互联结构、服务器间网络互联结构以及网卡的具体情况，可以抽象出一个网络结构，即二维环面网络：Torus 网络，而Torus网络横向与纵向都可以看成ring结构，因此相应的拓扑算法基本上就是Ring-Based 集合通信拓扑算法。如下图： TORUS网络是常见的大规模并行计算机的互连网络，在上图这个Torus网络里： 1）横向：主机内8卡通过私有连接协议，比如CXL/CCIX/NVLINK等组成一个或多个ring，如上图的黄色连接线，横向8卡组成二维Torus的横向维度； 2）纵向：主机间通过RDMA（RoCE/IB）网卡、交换机互联组成1到8个ring，如上图的红色连接线，纵向采用RDMA网卡组成二维Torus的纵向维度； 3）根据物理网卡数量、网卡虚拟化以及PCIe Switch亲和性的实际情况： 每台服务器1张网卡可组成主机间一个ring，网卡与XPU0 挂载同一个PCIE switch上，依据最佳实践原则（比如性能、成本、客户要求等），适合选用2D/Hierarchical Ring拓扑算法； 两张网卡可组成主机间两个ring或者经过虚拟化组成8个ring，根据PCIE SWITCH亲和性原则，一张网卡与XPU0挂在同一个pcie switch，另一张网卡与XPU4挂在同一个pcie switch，依据最佳实践原则（比如性能、成本、客户要求等），适合选用2D-MESH、2D-Torus拓扑算法； 4张网卡、8张网卡以此类推，也是根据PCIE SWITCH亲和性原则进行连接，主机间RDMA物理网卡不够就虚拟化网口来凑，并且要服务器内的RDMA出口端口数左右平衡，依据最佳实践原则（比如性能、成本、客户要求等），也是适合选用2D-MESH、2D-Torus拓扑算法，这样才能发挥多张网卡以及XPU的算力优势。 4）更复杂的Torus网络组合关系还可以如下图，从横向只有 主机内的8卡纵向只有主机间的RDMA互联，扩展到 横向与纵向 主机内互联与主机间互联混合，但本文仅限于在横向8卡的二维Torus网络下进行拓扑算法选择与设计，因此不展开讲述。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:2:4","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"3. 常用的通信拓扑算法 Torus 网络结构可以解读本文中的物理网络互联结构的一切，而Torus网络的横向与纵向都可以看成ring结构，因此，相应的集合通信拓扑算法都可以看成是Ring-Based 集合通信拓扑算法。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:3:0","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"3.1 Ring AllReduce 在分布式训练中，Ring 是最基础的互联结构，在本文中Ring AllReduce的应用场景是在服务器内将8张加速卡组环通信进行分布式训练。每个XPU都是这个主机内互联环上的一个计算节点，每个节点都有一个前向和一个后向，它只会向它的前向接收数据，并向它的右向发送数据，如下图所示，8张XPU 通过主机内的私有互联网络组成一个环，当然因为这些通信网络是双工的，这8张XPU训练加速卡也可以看成是通过多个逻辑环互联起来的，同时缺点是，如果这个ring太大，Ring Allreduce的效率也会变得很低。 Ring Allreduce 有两种组合实现策略： 1）先Reduce后broadcast； 2）先ScatterReduce后AllGather，这两个策略执行后都会让每个XPU节点得到一样的平均梯度，如下图所示： 3.1.1 Reduce +broadcast 在Reduce + broadcast里，reduce先将8张卡的梯度reduce sum到master节点 XPU0 上，再通过broadcast将这个总的平均梯度复制给其他XPU，如下图： Reduce + broadcast这种策略有几个比较大的缺点： 1）8张卡的数据都reduce sum到一张卡，假设每张卡的梯度是100MB，8张卡就是800MB，这可能存在XPU 0计算很久，而其他7张卡空闲的情况存在，整体效率不高； 2）XPU0 的网络带宽可能会成为瓶颈，8张卡的数据都只能通过XPU0的互联网络进行reduce和broadcast，在数据量比较大的场景 XPU0的带宽成为瓶颈； 3）8张XPU不都是两两全互联的，因此，要把8张卡的数据一次Reduce或broadcast，这一点受限于网络互联条件做不到，那么就需要采用 ring或tree的策略进行reduce或broadcast，这样效率也不高。 3.1.2 ScatterReduce + AllGather Ring AllReduce 的Ring ScatterReduce + Ring AllGather策略组合里，每个 XPU只会从前向接受数据，并发送数据给后向，其算法主要分为： ScatterReduce：这一步会先scatter拆分数据块再进行reduce，并且在执行完毕后，每张XPU都会包括一个完整的经过融合的同维梯度； AllGather：这一步会进行全局Gather同步，最后所有 XPU都会得到完整的大的整个梯度； Ring ScatterReduce + Ring AllGather是效率比较高的 Ring AllReduce 组合策略，这个策略考虑到了XPU上的梯度可能很大的情况，比如一个梯度有400MB，在scatterreduce阶段就会先被拆分成 ring上XPU个数份，比如主机内XPU个数等于8，那么 这400MB 就会被 拆分成8份，每份50MB，从而减少了加速卡的计算量以及节约带宽。此外，scatterReduce通过将数据拆分成小块，同时并发进行scatterReduce，从而将通信时间隐藏在计算时间内进而提高Ring AllReduce的效率。 3.1.2.1 ScatterReduce 首先， ScatterReduce先将梯度拆分为N个更小的块，N等于ring里XPU个数，8张卡就拆分成8份，然后进行N-1次scatterreduce迭代。在第一轮迭代中XPU 0上的A0传递给XPU1上A1并相加，XPU1上的B1传递给XPU2上的B2并相加，XPU 2上的C2传递给XPU3上C3并相加，XPU3上的D3传递给XPU4上的D4并相加，以此类推，过程如下图左侧： 接下来，XPU还会进行N-2次 ScatterReduce 迭代，在每次迭代过程中，XPU都会从前向接收一个小梯度块并累加到自己的梯度块中，并且也会向其后向发送一个小梯度块，每个XPU接收和发送的小梯度块在每次迭代中都是不同的，这样经过迭代，到最后，每个XPU将有一个完整的同维梯度，该块梯度中包含所有XPU中该块对应的所有梯度的总和，如上图右侧的累加和部分。 3.1.2.2 Allgather 在scatterReduce迭代完成之后，每个XPU都会得到一个同维度的完整的梯度累加值，将这些完整的累加值复制到其他的加速卡后，才算完成allReduce。Allgather的迭代次数与scatterReduce是相同的，也都需要进行N-1次（N是ring上的XPU卡数）迭代，但是不同于ScatterReduce的是allGather没有reduce的过程，只有数值的复制。这样迭代到最后，每个XPU都得到大的拆分前的梯度的完整累加值，如下图演示了这一过程，从第一次迭代开始，到最后AllGather拿到整体的结果。这里头的具体过程就不在这里描述了，可以查相关资料。 Ring AllReduce 实现简单，在ring较少时，效率也较高，但是在ring比较大时需要的网络节点跳数变得比较大，通信时延增加，因此效率也会降低。比如，一个1000张XPU的 ring，这里头网络的跳数 是N-1= 1000-1 =999， 同时传输的过程中，传输效率还受效率最低、带宽最低的XPU的限制，这时网络上的时延会变得巨高，这个时候ring allreduce拓扑算法就变得不大适用这个场景，同时如果在异构网络里涉及网络的不同连接方式，Ring AllReduce也不大适合使用，因此就需要采用另外的更适合网络结构的更高效的集合通信拓扑算法来进行优化。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:3:1","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"3.2 2D-Ring AllReduce 如果一台2.1里的服务器只配置了一张RDMA网卡，每台服务器通过RDMA交换机互联，这个集群的网络是异构的（如下图），那么Ring AllReduce拓扑算法就不适用了，这个时候，对于这个网络拓扑结构比较适合的是2D-Ring AllReduce也叫Hierarchical Ring AllReduce。 经过抽象，可以将这个网络结构表达成如下的Torus结构： 横向：每台服务器8个XPU节点，每个XPU节点通过私有协议网络互联； 纵向：每台服务器通过一张RDMA网卡NIC 0 通过交换机互联，这个网卡NIC0 与XPU0 挂在同一个PCIE switch上，满足具备亲和性条件，XPU0上的梯度可以通过NIC 0 与其他服务器上的XPU进行全局规约。 2D-Ring AllReduce的过程如下图所示： 第1步，先进行主机内Ring AllReduce，也可以是 Ring Reduce或者根据主机内的互联情况选用的分层reduce方式，将8张卡上的梯度累加到Master节点 XPU0 上； 第2步，进行主机间XPU 0的 Ring AllReduce，将每台服务器的XPU0上的数据进行全局规约； 第3步，进行主机内Broadcast，将XPU0上的梯度复制到服务器内的其他XPU上 2D-Ring AllReduce能充分发挥异构网络的优势，将主机内、主机间的网络带宽充分利用起来。但是XPU的利用率也不是很高，比如在做主机间的Ring AllReduce，每台服务器内的其他7张XPU是处于空闲状态的。 再假设，如果每台服务器配置了 2张/4张/8张RDMA网卡，这个时候 2D-RING AllReduce又难以将网络的优势发挥出来，那么就需要选用 2D-Torus/2D-Mesh AllReduce拓扑算法。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:3:2","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"3.3 2D-Torus AllReduce 考虑到服务器内PCIE SWITCH 的亲和性问题，2D-Torus至少需要配备2张 左右对称的RDMA网卡才能发挥这个拓扑算法的优势。在这个集群里主机内每张卡都通过私有的通信协议组成Ring，而主机间，可以通过RDMA网卡（包括虚拟化出来的）与RDMA交换机将XPU两两互联，这个网络也是异构的，如下图所示： 经过抽象，可以将这个网络结构表达成如下的Torus结构： 横向：每台服务器8个XPU节点，每个XPU节点通过私有协议网络互联； 纵向：每台服务器通过至少2张RDMA网卡NIC 0 /NIC 1通过交换机互联，这个网卡NIC0 与XPU0、1、2、3 挂在同一个PCIE switch上，具备亲和性条件，XPU0、1、2、3上的梯度数据可以通过NIC 0 与其他服务器上的XPU进行交换。网卡NIC1 与XPU4、5、6、7 挂在同一个PCIE switch上，具备亲和性条件，XPU4、5、6、7上的梯度数据可以通过NIC 1 与其他服务器上的XPU进行交换； 当然如果网卡是4个或者8个，也可以根据PCIE SWITCH的亲和性情况合理安排XPU与NIC的对应关系。 2D-Torus AllReduce的过程如下图所示： 第1步，横向，先进行主机内Ring ScatterReduce，将主机内8张卡上的梯度进行拆分与规约，这样经过迭代，到最后每个XPU将有一个完整的同维梯度，该块梯度包含所有XPU中该块所对应的所有梯度的总和（参考3.1.2.1 scatterReduce) 第2步，纵向，进行主机间N个（N等于服务器内XPU个数，这里是8个）纵向的 Ring AllReduce，将每台服务器的XPU0-XPU7上的数据进行集群内纵向全局规约； 第3步，横向，进行主机内AllGather，将XPUi(i=0-7)上的梯度复制到服务器内的其他XPU上； 2D-Torus AllReduce能充分挖掘XPU的效率以及发挥异构网络里多网卡的优势，将XPU以及主机内、主机间的网络带宽优势充分利用起来。此外，除了 2D-Torus AllReduce外，2D-Mesh AllReduce也能发挥类似效率。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:3:3","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"3.4 2D-Mesh AllReduce 2D-Mesh AllReduce的主要思想也是分层，与2D-Torus AllReduce类似，都是水平和垂直两个方向，但是有点差异，如下图所示： 不同于2D-Torus AllReduce的拓扑算法，2D-Mesh AllReduce 过程是： 第1步，横向，先进行主机内Ring AllReduce 将主机内的8张XPU的梯度都进行规约； 第2步，纵向，进行主机间N个（N等于主机内XPU个数，这里是8个）纵向的 Ring AllReduce； 经过这两步，完成了整体的梯度累加，2D-Mesh AllReduce 也能充分发挥XPU与多网卡异构网络的优势，将XPU与主机内、主机间的网络带宽优势充分利用起来。这里的2D-Mesh与Google论文上的有点差异，主要是吸取了其分层的思想而不是复制其一样的设计。理论上2D-Mesh AllReduce对比 2D-Torus AllReduce，主机间AllReduce用的是 主机内8卡的全局梯度，数据量会比ScatterReduce部分来的大点，因此效率也会相应降低一点。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:3:4","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"4. 问题探讨 如下图所示，基于Torus网络的结构，组合Ring AllReduce，2D-Ring AllReduce, 2D-Mesh AllReduce，2D-Torus AllReduce还能构建 3D-Ring/Mesh/Torus AllReduce拓扑算法，但是这些拓扑算法的效率需要进行实践才能证实，也许在规模较大的集群里才能发挥出3D 拓扑算法的优势。 关于 3D-Ring/Mesh/Torus AllReduce的拓扑算法，这里就不在阐述，可作为研究使用。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:4:0","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"5. 小结 本文讲述了分布式训练里最常用的几个网络结构以及通信拓扑算法： Ring AllReduce 的最佳组合是 ScatterReduce + AllGather； 2D-Ring AllReduce = 主机内 ringAllReduce/Ring Reduce +主机间 RingAllReduce + 主机内Broadcast； 2D-Torus AllReduce = 主机内 Ring ReduceScatter + 主机间N个Ring AllReduce + 主机内Ring AllGather； 2D-Mesh AllReduce = 主机内Ring AllReduce + 主机间N个Ring AllReduce; Ring AllReduce适合主机内互联Ring的情况使用，2D-Ring AllReduce适合一台服务器配置了一张网卡的异构网络场景，2D-Torus AllReduce与2D-Mesh AllReduce适合一台服务器配置了2/4/8张网卡的异构网络场景。 集合通信拓扑算法多种多样，但基于成本以及效率的取舍考虑，可生产适用的其实也不多，除了理论上的理解之外更重要的是自己编写代码去实践落地。除此之外，还需要解决网络带宽有限、网络容易出故障、落后者效应、部署约束、多租户等产品化的质量要求。 REF: [1] https://www.changping.me [2] 《volta-architecture-whitepaper》 [3] 2D-HRA: Two-Dimensional Hierarchical Ring-based All-reduce Algorithm in Large-Scale Distributed Machine Learning [4] Massively Distributed SGD: ImageNet/ResNet-50 Training in a Flash [5] https://zhuanlan.zhihu.com/p/79030485 , 腾讯机智团队分享–AllReduce算法的前世今生 [6] https://zhuanlan.zhihu.com/p/370548366, ring allreduce和tree allreduce的具体区别是什么？ [7] https://zhuanlan.zhihu.com/p/184942777 , 分布式深度学习初探 [8] https://arxiv.org/abs/1811.06992 ， Image Classification at Supercomputer Scale ","date":"2023-07-13","objectID":"/posts/distributedtraining_4/:5:0","tags":["Distributed Training"],"title":"分布式训练 – 第4篇 - 分布式训练常用的网络结构及集合通信拓扑算法","uri":"/posts/distributedtraining_4/"},{"categories":["Distributed Computing"],"content":"ref: [1]. https://zhuanlan.zhihu.com/p/493092647 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:0:0","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"概述 集合通信（Collective Communications）是一个进程组的所有进程都参与的全局通信操作，其最为基础的操作有 发送send、接收receive、复制copy、组内进程栅障同步Barrier以及节点间进程同步(signal+wait)，这几个最基本的操作经过组合构成了一组通信模板也叫通信原语，比如：1对多的广播broadcast、多对1的收集gather、多对多的收集all-gather、1对多的发散scatter、多对1的规约reduce、多对多的规约all-reduce、组合的规约与发散reduce-scatter、多对多的all-to-all等，集合通信的难点在于通信效率以及网络硬件连接拓扑结构的最佳适用。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:1:0","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"通信原语 以一台集成了4张训练加速卡的服务器为例，如下图，服务器内四张训练加速卡是全连接的，物理连接方式可以是私有物理互联协议，比如CXL、NVLINK，也可以是PCIe、InfiniBand、Ethernet等，本文将以此物理拓扑结构描述集合通信中常用的几组通信原语。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:0","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"Broadcast Broadcast属于1对多的通信原语，一个数据发送者，多个数据接收者，可以在集群内把一个节点自身的数据广播到其他节点上。如下图所示，圈圈表示集群中的训练加速卡节点，相同的颜色的小方块则代表相同的数据。当主节点 0 执行Broadcast时，数据即从主节点0被广播至其他节点。 Broadcast是数据的1对多的同步，它将一张XPU卡上的数据同步到其他所有的XPU卡上，其应用场景有： 1）数据并行的参数初始化，确保每张卡上的初始参数是一致的； 2）allReduce里的 broadcast + reduce组合里的broadcast操作； 3）分布式训练parameter server 参数服务器结构里的 master节点 broadcast 数据到worker节点，再从worker节点reduce数据回master节点里的broadcast操作； ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:1","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"Scatter 同Broadcast一样，Scatter也是一个1对多的通信原语，也是一个数据发送者，多个数据接收者，可以在集群内把一个节点自身的数据发散到其他节点上。与Broadcast不同的是Broadcast把主节点0的数据发送给所有节点，而Scatter则是将数据的进行切片再分发给集群内所有的节点，如下图所示，不相同的颜色的小方块代表不相同的数据，主节点 0 将数据分为四份分发到了节点0-3。 Scatter是数据的1对多的分发，它将一张XPU卡上的数据进行分片再分发到其他所有的XPU卡上，他的反向操作对应Gather，其应用场景有: 1）ReduceScatter组合里的 Scatter操作； 2）模型并行里初始化时将模型scatter到不同的XPU上； ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:2","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"Gather Gather操作属于多对1的通信原语，具有多个数据发送者，一个数据接收者，可以在集群内把多个节点的数据收集到一个节点上，如下图所示，不相同的颜色的小方块代表不相同的数据。 Gather是数据的多对1的收集，它将多张XPU卡上的数据收集到1张XPU卡上，他的反向操作对应Scatter，其应用场景有： 1）ReduceScatter组合里的 Scatter操作； ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:3","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"AllGather AllGather属于多对多的通信原语，具有多个数据发送者，多个数据接收者，可以在集群内把多个节点的数据收集到一个主节点上（Gather），再把这个收集到的数据分发到其他节点上（broadcast），即收集集群内所有的数据到所有的节点上。 AllGather是数据的多对多的同步全收集，它将多张XPU卡上的数据收集到多张XPU卡上，可以看做Gather + Broadcast的操作组合，它的反向操作对应ReduceScatter，其最应用场景有： 1） AllGather可应用于模型并行； 2）模型并行里前向计算里的参数全同步，需要用allgather把模型并行里将切分到不同的XPU上的参数全同步到一张XPU上才能进行前向计算。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:4","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"Reduce Reduce属于多对1的通信原语，具有多个数据发送者，一个数据接收者，可以在集群内把多个节点的数据规约运算到一个主节点上，常用的规约操作符有：求累加和SUM、求累乘积PROD、求最大值MAX、求最小值MIN、逻辑与 LAND、按位与BAND、逻辑或LOR、按位或BOR、逻辑异或LXOR、按位异或BOXR、求最大值和最小大的位置MAXLOC、求最小值和最小值的位置MINLOC等，这些规约运算也需要加速卡支持对应的算子才能生效。 Reuduce操作从集群内每个节点上获取一个输入数据，通过规约运算操作后，得到精简数据，如下图的SUM求累加和：节点0数值 5、节点1数值6、节点2数值7、节点3数值8，经过SUM运算后 累积和为 26，即得到更为精简的数值，在reduce原语里回会去调用 reduce SUM算子来完成这个求和累加。 Reduce是数据的多对1的规约运算，它将所有张XPU卡上的数据规约（比如SUM求和）到1张XPU卡上，其应用场景有： 1）AllReduce里的 broadcast + reduce组合里的reduce操作； 2）ReduceScatter组合里的 reduce操作； 3）分布式训练parameter server 参数服务器结构里的 master节点 broadcast 数据到worker节点，再从worker节点reduce数据回master节点里的reduce操作； ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:5","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"ReduceScatter ReduceScatter属于多对多的通信原语，具有多个数据发送者，多个数据接收者，其在集群内的所有节点上都按维度执行相同的Reduce规约运算，再将结果发散到集群内所有的节点上，Reduce-scatter等价于节点个数次的reduce规约运算操作，再后面执行节点个数的scatter次操作，其反向操作是AllGather。 如下图所示，先reduce操作 XPU 0-3的数据reduce为 A(A0+A1+A2+A3) + B(B0 + B1 +B2 + B3) + C(C0 + C1 + C2 + C3) + D(D0 + D1 + D2 + D3 ) 到一张XPU上，再进行分片scatter到集群内所有的XPU卡上。 ReduceScatter是数据的多对多的reduce + scatter运算，它将所有的XPU卡上的数据先规约（比如SUM求和）到1张XPU卡上，再进行scatter，其应用场景有： 1）ReduceScatter即可应用于数据并行也可应用于模型并行； 2）数据并行allReduce里的 ReduceScatter+ Allgather组合里的ReduceScatter操作； 3）模型并行里在前向allgather后的反向计算里的ReduceScatter； ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:6","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"AllReduce AllReduce属于多对多的通信原语，具有多个数据发送者，多个数据接收者，其在集群内的所有节点上都执行相同的Reduce操作，可以将集群内所有节点的数据规约运算得到的结果发送到所有的节点上。AllReduce操作可通过在主节点上执行Reduce + Broadcast或ReduceScatter + AllGather实现，如下图所示：先在主节点上执行reduce得到规约累加和26，再把这个累加和26 broadcast到其他的节点，这样整个集群内，每个节点的数值就都保持一致。 AllReduce是数据的多对多的规约运算，它将所有的XPU卡上的数据规约（比如SUM求和）到集群内每张XPU卡上，其应用场景有： 1） AllReduce应用于数据并行； 2）数据并行各种通信拓扑结构比如Ring allReduce、Tree allReduce里的 allReduce操作； ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:7","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"All-To-All All-To-All操作每一个节点的数据会scatter到集群内所有节点上，同时每一个节点也会Gather集群内所有节点的数据。ALLTOALL是对ALLGATHER的扩展，区别是ALLGATHER 操作中，不同节点向某一节点收集到的数据是相同的，而在ALLTOALL中，不同的节点向某一节点收集到的数据是不同的，如下图所示: AllToAll是数据的多对多的转置，它将所有张XPU卡上的数据转置到所有的XPU卡上，其主要应用场景有： 1） AllToAll应用于模型并行； 2）模型并行里的矩阵转置； 3）数据并行到模型并行的矩阵转置； ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:8","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"Send 与 Receive 数据或参数在不同XPU之间的发送与接收。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:9","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"Barrier BARRIER同步操作会阻塞所有的调用者直到所有的组内成员都调用了它， 用于一个集合通信子中所有进程的同步，调用函数时进程将处于等待状态，直到通信子中所有进程 都调用了该函数后才继续执行。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:10","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"Signal与Wait Signal与Wait属于记录型信号量机制： wait(s)，signal(s)可用于解决进程间的同步问题，在通信原语里从一个节点发送一个数据到另外一个节点时，会同时signal一个event值到对端，对端的wait操作接收到这个event时会返回一个确认给signal，这样保证在节点的进程间进行数据的同步操作。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:2:11","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"小结 在分布式训练过程中，深度学习训练框架不会去直接操作底层的通信网络，而是通过使用网络通信库来完成数据的集合通信，各家AI芯片加速卡厂家都会提供私有的网络通信库比如：xxx-AWARE OpenMPI或xCCL来完成这个底层通信硬件的屏蔽与抽象。在分布式训练集群里网络通信硬件连接样式多种多样，可以是Ethernet、InfiniBand 、RoCE v2/v1 等也可以是CXL、NVLINK等私有协议，这就要求在通信的后端层根据各个厂家的自己的SDK开发库接口，根据实际情况实现 各自的网络通信库，比如cuda-aware MPI、NCCL、NVSHMEM，以及根据实际的网络拓扑组合完成对应的最有效的网络拓扑算法。 本文讲述了分布式训练里的集合通信原语，这些原语是集合通信拓扑算法的基本组成单元，后续的文章里会讲述如何组合这些通信原语以完成合适的通信拓扑算法。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_3/:3:0","tags":["Distributed Training"],"title":"分布式训练 – 第3篇 - 集合通信及其通信原语","uri":"/posts/distributedtraining_3/"},{"categories":["Distributed Computing"],"content":"ref: [1]. https://zhuanlan.zhihu.com/p/492667659 ","date":"2023-07-13","objectID":"/posts/distributedtraining_2/:0:0","tags":["Distributed Training"],"title":"分布式训练 – 第2章 - 训练与系统评价指标","uri":"/posts/distributedtraining_2/"},{"categories":["Distributed Computing"],"content":"前言 不同于教科书里讲的深度学习的评价指标，这里主要讲述生产训练中常用的评价指标。通常在分布式训练中对训练的过程与结果会进行评价，比如选择一个评价指标：准确率，即表明模型求解给定问题的准确度。而本文提到的评价指标主要分为两大类，即训练结果评价与训练系统评价。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_2/:1:0","tags":["Distributed Training"],"title":"分布式训练 – 第2章 - 训练与系统评价指标","uri":"/posts/distributedtraining_2/"},{"categories":["Distributed Computing"],"content":"训练指标 教科书里经常提到的深度学习的评价指标有准确率、精确率、召回率、F1值等，如下： 准确率（Accuracy），所有的预测正确（正类负类）的占总的比重； 精确率（Precision），查准率，即正确预测为正的占全部预测为正的比例； 召回率（Recall），查全率，即正确预测为正的占全部实际为正的比例； F1值（H-mean值），F1值为算数平均数除以几何平均数，且越大越好； 实际上这些指标在真正的生产过程中用的不多，在实际的分布式训练过程中，比较关心的训练评价指标有： 加速比（speedup），即多卡训练下的单卡吞吐量平均指标除以单卡训练下的吞吐量平均指标，比如，大规模训练下的 ResNet-50 v1.5的单卡FPS指标是600，而单卡训练的FPS指标是800，那么加速比即 600/800 = 0.75，加速比体现的是训练集群的效率与可扩展性，越高的加速比表明训练集群的资源利用率越高，但是越高的加速比要求对训练集群的技术要求也越高。比如 一个 1000张卡的训练集群，要求 加速比 0.9以上，那么对于主机间的网络、主机内的网络、全栈软件、训练卡内部的硬件架构、集合通信拓扑算法、训练算法的优化等的要求都极高，这就涉及到整个分布式训练系统的问题，而不是单个点能彻底解决的； 吞吐量，sequence/sec 或 FPS, 即每秒能处理的图片数或数据量； 收敛时间（Time）与训练次数（epoch），生产过程中对训练所有的时间是有要求的，假设给定一个模型的训练次数(epoch)为100，如果要把这个100次都训练完需要 好几天，甚至好几个星期，那么可以认为生产不适用，基本上可以定义 训练一个模型到收敛需要 24小时以上，都可以看做是生产不适用，需要扩大训练集群的规模，使之训练时间控制在24小时之内； 平均准确率(eval Accuracy)，平均准确率是训练是否收敛的重要评判标准之一，比如定义一个 Resnet50 v1.5 的训练模型的准确率为 76%，如果训练结束的平均准确率能达到这个值就认为训练是收敛的； 可收敛，训练的最终结果可以达到 平均准确率的要求，即认为可收敛，否者即任务训练失败； 学习率(Learning rate)与损失率(Loss)，学习率大模型训练学习速度快，但是易导致损失率爆炸, 学习率小模型训练学习速度慢，而且容易过拟合，收敛速度慢； 曲线拟合(Curve Fitting)，这是一个非常重要的评价手段，在XPU训练的场景下，通常先用一个已有的之前训练好模型为基础或先用GPU训练出一个基础模型，然后把XPU训练的结果指标跟GPU训练模型的指标进行比较，曲线拟合即认为XPU的训练结果达标，这也是调试XPU训练结果的一个重要手段。这里埋一个问题，按照曲线拟合的说法，假设有一个2000张XPU卡的集群，怎样评价这个集群训练的结果是正确的？以GPU训练的结果做比较，那么找一个这么大规模的GPU集群进行训练然后得到想要的模型做基础匹配也是不大现实的，那么需要采用什么技术方案才能解决这个问题？ 以TensorBoard为例，说明模型的评价指标，在下面的命令行列输入一个baseline:/log_path_2： tensorboard --logdir=training_model:/log_path_1, baseline:/log_path_2 这个baseline 的模型已经确定是精度达标，生产可用的。然后 XPU训练的模型的 training_model:/log_path_1 与这个GPU训练处的baseline进行比，在tensorboard里可以表现如下图： 在上图里，新的模型的eval_accuracy值与baseline的值最终是一样的，这说明训练结果是收敛且精度达标，eval_accuracy中间的线有点差异是由于按不同的训练次数进行tensorboard指标保存所造成。新模型的Loss线与Learning_rate 线也与基础线吻合，这说明XPU训练的模型质量可生产适用。eval_accuracy、Loss、Learning_rate是三个最重要的度量指标，只要这样三个指标达标，那么大概率即可判断这个在XPU下新训练的模型具备生产可用能力。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_2/:2:0","tags":["Distributed Training"],"title":"分布式训练 – 第2章 - 训练与系统评价指标","uri":"/posts/distributedtraining_2/"},{"categories":["Distributed Computing"],"content":"系统指标 分布式训练系统其本身也是一个分布式系统，因此除了训练领域相关的度量指标，也有与分布式系统质量有关的一套度量指标，其中比较重要的几项内容如下： 可用性(Availability)，可用性指的是分布式训练系统长时间可对外提供服务的能力，通常采用小数点后的9的个数作为度量指标，按照这种约定“五个九”等于0.99999（或99.999％）的可用性，默认企业级达标的可用性为6个9。但是当前从时间维度来度量可用性已经没有太大的意义，因为设计得好的系统可以在系统出现故障得情况下也能保证对外提供得服务不中断，因此，当前更合适得可用性度量指标 是请求失败率; 可靠性(Reliability)，可靠性一般指系统在一定时间内、在一定条件下可以无故障地执行指定功能的能力或可能性， 也是采用小数点后的9的个数作为度量指标，通常5个9的可靠性就可以满足企业级达标； 可伸缩性(Scalability)，是指通过向系统添加资源来处理越来越多的工作并且维持高质量服务的能力，其受可用性以及可靠性的制约，集群规模越大出故障的概率越高从而降低可用性、可靠性，为了保证可用性以及可靠性达标，需要适配合理的可伸缩性指标； 韧性(resilience)，通常也叫容错性（fault-tolerant），也就是健壮和强壮的意思，指的是系统的对故障与异常的处理能力，比如在软件故障、硬件故障、认为故障这样的场景下，系统还能保持正常工作的能力，分布式训练系统的容错能力是一个非常重要的指标。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_2/:3:0","tags":["Distributed Training"],"title":"分布式训练 – 第2章 - 训练与系统评价指标","uri":"/posts/distributedtraining_2/"},{"categories":["Distributed Computing"],"content":"小结 本文从实践的角度讲述了分布式训练的训练结果评价指标与系统评价指标，这些指标是度量一个分布式训练系统与训练的模型是否生产可用的重要参考。日拱一卒，功不唐捐，分享是最好的学习，与其跟随不如创新，希望这个知识点对大家有用。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_2/:4:0","tags":["Distributed Training"],"title":"分布式训练 – 第2章 - 训练与系统评价指标","uri":"/posts/distributedtraining_2/"},{"categories":["Distributed Computing"],"content":"ref: [1]. https://zhuanlan.zhihu.com/p/487945343 ","date":"2023-07-13","objectID":"/posts/distributedtraining_1/:0:0","tags":["Distributed Training"],"title":"分布式训练 – 第1章 - 什么是分布式训练","uri":"/posts/distributedtraining_1/"},{"categories":["Distributed Computing"],"content":"前言 深度学习软件工程具有一体两面性：单卡的功能完备性、质量、用户体验以及多卡大规模。多卡大规模的出现是为了解决这样一个主要矛盾，即：“日益增长的数据、模型训练的需求与当前单卡计算能力无法满足这个需求之间的矛盾”，而分布式训练可以通过扩展卡子的规模解决这个矛盾，因此，这就是分布式训练的价值。 然而，正如懂得很多道理，仍旧过不好这一生一样，懂得很多分布式训练的理论与知识，也不一定就能做好一个分布式训练系统。把这么多机器连接跑起来、跟跑好也是两回事，分布式训练是一门实践的软件工程，只有你PK过设计方案，调试过一个个Bug，手把手的敲过一行行的代码，为了性能指标能达标无所不用其极的去验证各种性能优化方案，才能知道细节在哪里，难点在哪里，痛点、挑战点在哪里。因此，宏观处着眼，微观处着手，才能完全理解分布式训练的道理。 一个知识领域里的 “道 法 术 器” 这四个境界需要从 微观、中观以及宏观 三个角度来把握，微观是实践，中观讲方法论，宏观靠领悟。本系列文章我把它命名为《分布式训练》，从工程实战的角度拆解分布式训练里最重要的套路，也是从“微观实践、中观方法论、宏观领悟”这三个维度系统性的探讨分布式训练技术，本文讲述第一篇，也是最难讲清楚的一篇（后续保持迭代更新），即本质的一问：“什么是分布式训练\"。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_1/:1:0","tags":["Distributed Training"],"title":"分布式训练 – 第1章 - 什么是分布式训练","uri":"/posts/distributedtraining_1/"},{"categories":["Distributed Computing"],"content":"什么是分布式训练 简单来说，分布式训练 = 分布式训练系统 = 分布式系统 + 训练系统，因此，要解答什么是分布式训练就需要解答什么是分布式系统以及什么是训练系统，而“系统 = 要素x连接 + 目的 + 边界”，因此进一步的就是需要分析分布式系统的要素、连接、目的与边界以及训练系统的要素、连接、目的与边界。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_1/:2:0","tags":["Distributed Training"],"title":"分布式训练 – 第1章 - 什么是分布式训练","uri":"/posts/distributedtraining_1/"},{"categories":["Distributed Computing"],"content":"分布式系统 在AI训练过程中采用单卡总会遇到一些问题，比如原始的数据样本太大无法加载进训练卡，或者模型太大无法训练，那么这就需要用到分布式技术把大量的数据分割成小块由多个训练卡分别进行计算，在更新运算结果后，再将结果统一合并得出最终的可用模型。百科上对分布式系统的定义有： A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another. The components interact with one another in order to achieve a common goal. 即： 分布式系统是指其组件位于不同的网络计算机上的系统，这些组件通过相互传递消息来进行通信和协调其动作，且彼此相互交互以完成一个共同的任务目标。 从这句话可以得出三个结论： 分布式系统的组件是位于不同的网络计算机上的； 分布式系统的组件通过传递消息进行通信与协调的； 分布式系统的组件是通过相互交互以完成一个共同的任务目标，同时是有边界的； 因此基于此定义，拆解分布式系统的概念，从中可以看到分布式系统里的要素即为组件，连接即网络，目的是共同的任务目标。其中的位于不同的网络计算机上的“组件”是分布式系统的要素，即各种计算单元，比如Ai训练加速卡，“网络”是分布式系统的连接，即神经网与数据网，“共同的任务目标”是分布式系统的目的，即训练，至此，再进一步抽象，可以推导出分布式系统的公理化定义，也是分布式系统的本质理论定义： 分布式系统 = 计算 x 网络 + 功能 + 边界 在这个公式里，计算即计算单元，是各种AI训练加速卡，比如GPU, TPU, DPU, DTU。网络即网络连接单元，在单个训练卡内为计算用的神经网，主机内的多个卡子之间是PCIE 以及PCIE Switch，以及各种高带宽通信网，比如GenZ,CXL,NVLINK,OpenCAPI,CCIX等，在主机之间是各种通信网络，比如RDMA网络、InfiniBand网络、普通的TCP网络以及对应的各种交换机，另外从磁盘 + 主机内存 + 训练卡的HBM这个IO路径我们认为属于IO网络，而这里的目的即训练，同时这个系统是有边界的，其专注于解决Ai训练过程中的难题，不是什么功能都能往里塞都能解决的。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_1/:2:1","tags":["Distributed Training"],"title":"分布式训练 – 第1章 - 什么是分布式训练","uri":"/posts/distributedtraining_1/"},{"categories":["Distributed Computing"],"content":"训练系统 以数据并行随机梯度下降( SGD )技术为例，神经网络训练的过程如下: 1，首先需要通过在第一个step进行Broadcast操作将参数同步到集群内的所有的训练卡上; 2，将数据样本切片分发到整个集群的每张训练卡上并且通过data Loader技术将数据样本加载进训练卡的高速内存空间内，作为输入X; 3，每个训练卡在其数据样本上运行前向传播，计算出误差LOSSi； 4，对计算出的LOSSi进行反向传播，得到梯度GRADi； 5，所有的训练卡在主机内及主机之间进行集合通信并进行梯度归约(AllReduce)； 6，最后再进行参数更新以获得新的梯度参数。 本质上分布式训练是数据加载、前向传播、反向传播、集合通信以及参数更新这5个步骤的逻辑组合，因此，基于以上步骤，这里可以推导出训练系统的公式定义如下： 训练系统 = 数据加载 + （前向传播 + 反向传播） + 集合通信 + 参数更新 从上面的步骤可知分布式训练是在固定的步骤迭代中进行的，并且需要系统内的所有的训练卡都完成它们的迭代步骤，才能进行最后的参数更新，这相当于在单个训练卡上执行梯度下降技术，但是通过在系统内所有的训练卡之间分发数据样本并同时执行计算来获得训练的加速。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_1/:2:2","tags":["Distributed Training"],"title":"分布式训练 – 第1章 - 什么是分布式训练","uri":"/posts/distributedtraining_1/"},{"categories":["Distributed Computing"],"content":"举例说明 以TensorFlow为例说明模型的训练过程，TensorFlow 是用数据流图做计算的，如下图所示: 图中显示了 TensorFlow 的训练过程，其包含输入（input）、塑形（reshape）、Relu 层（Relu layer）、Logit 层（Logit layer）、Softmax、交叉熵（cross entropy）、梯度（gradient）、SGD 训练（SGD Trainer）等部分。 它的训练过程是，首先从数据分片输入开始，经过Reshape数据清洗后，进行前向传播运算，通过Relu 层后得到LOSS值，然后进入 Logit 层，再进行反向传播并且用 Cross Entropy、softmax等 来计算梯度，接着进行梯度归约(Allreduce)，这一步在分布式场景就涉及集合通信的过程，最后进行参数更新SGD Trainer，如此迭代循环直到获得收敛指标达标的结果为止。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_1/:2:3","tags":["Distributed Training"],"title":"分布式训练 – 第1章 - 什么是分布式训练","uri":"/posts/distributedtraining_1/"},{"categories":["Distributed Computing"],"content":"小结 采用分布式训练的目的往往也是因为数据量或模型太大，一个加速卡的高速内存放不下，因此对数据或者模型进行切分，分发到多卡上进行计算与归约。本文很概况性的讲述了什么是分布式训练，简单来说分布式训练就是分布式计算的一种，通过对数据样本的计算，得出最后可用的模型再用于数据推理。本系列文章的后续内将展开讲述分布式训练的基础理论、训练过程、质量保证、集合通信、系统工程、产品化等，同样分布式训练系统除了解决训练所带来的各种故障也还需要解决分布式所带来的各种故障。 ","date":"2023-07-13","objectID":"/posts/distributedtraining_1/:3:0","tags":["Distributed Training"],"title":"分布式训练 – 第1章 - 什么是分布式训练","uri":"/posts/distributedtraining_1/"},{"categories":["Distributed Computing"],"content":"Horovod 介绍 Horovod 是 Uber 开源的深度学习工具，它的发展吸取了Facebook “Training ImageNet In 1 Hour” 与百度 “Ring Allreduce” 的优点，在保证分布式训练性能的同时，兼顾了前端的简洁和对不同深度学习框架的支持，使用起来对开发人员比较的友好，算是分布式训练方向的标杆项目了。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:1:0","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"集合通信库 集合通信库，这个词可能听起来会比较的陌生，不过如果我再提几个关键字，可能大家多少都会有所耳闻。资历比较老的是 MPI (Message Passing Interface 及其实现 OpenMPI 和 MPICH，年轻一点的会是 Nvidia 针对其显卡开源的 NCCL，或者是 facebook 开源的 gloo，或者是像华为针对其高性能硬件提供的HCCL，大体上都可以归入到集合通信库的类别。他们相同的地方是大体上会遵照 MPI 提供的接口规定，实现了包括点对点通信（SEND,RECV等），集合通信（ REDUCE，BROADCAST，ALLREDUCE等）等相关接口，然后根据自己硬件或者是系统的需要，在底层实现上进行了相应的改动，保证接口的稳定和性能。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:2:0","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"点对点通信: Point-to-Point Communication Send/Recv: ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:2:1","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"集合通信 Scatter/Gather reduce/allreduce boradcast/all-gather 这里在机器学习训练中使用比较多的是 all-reduce，场景类似在不同的 node 上跑不同 batch 的数据，然后更新梯度需要从各个汇总之后平均再回传到各自的 node 中。而这部分，有很多种实现的方式，比较直观和简单的是把所有的梯度都汇总到的某一个 node 上（如下图 node d 所示），然后再把汇总的信息重新分发到不同的 node 上 ，这样可以计算通信量，如下：对于 P 个节点，每个节点消息大小为 M，node d 节点的通信量为 2*(P-1)M，这里假设节点之间互联互通，带宽为B。 不过这种情况下，很容易导致 node d 会成为性能瓶颈，因为 node d 需要跟其他所有 node 通信所以它的通信量是其他节点的 P 倍。假设节点间的带宽还是一样，node d 完成所有通信所需要的时间是 2(P-1)M/B*。所以现在很多的集合通信框架不会使用这种方式，更多的是通过树状或者是环状(ring) 去实现 all-reduce。 如果只是做成树状的可以做成如下图所示，虽然传递的步数增多了，不过消除了node d 的通信瓶颈，完成所有的通信的时间大概是 2log_2N(M/B)*，随着节点数目 P 的增加，树形结构的效果会越来越明显。 业界用得最多一种优化的方式是，每次只传一部分，这部分是百度提出的 ring-allreduce 的方案，具体的介绍可以参考这篇博客Bringing HPC Techniques to Deep Learning，这边就不赘述了。整体上就是每次不会像上面这样整份数据传递，而是一部分一部分传，优化后，所有节点需要传输的数据量的传输 2(N−1)M/N 比较平均，所需要的时间可以大概是 2(N−1)M/(NB)，horovod 也是基于这种 all-reduce 的形式实现的。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:2:2","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"实践: pytorch.distributed 尝试使用 pytorch 自带的分布式工具包 torch.distributed，进行一些概念性的尝试。 为了方便尝试，我这里提供了一个简单的 demo，大家如果安装了 gpu 版本的 pytorch \u003e= 1.3，应该都可以尝试下面的例子尝试使用多进程模拟分布式（单机上可以跑）。 import os import torch import torch.distributed as dist import time import argparse from torch.multiprocessing import Process parser = argparse.ArgumentParser(description='PyTorch MNIST Example') parser.add_argument('-m', '--mode', type=str, default='one_device', metavar='N', help='distribute mode, distributed/one_device') parser.add_argument('-f', '--function', type=str, default='p2p', metavar='N', help='function to run (p2p/all_reduce/gpu_all_reduce)') parser.add_argument('-b', '--backend', type=str, default=\"nccl\", metavar='N', help='distribute backend (gloo/nccl)') def init_process(rank, size, fn, backend='nccl'): \"\"\" Initialize the distributed environment. \"\"\" os.environ['MASTER_ADDR'] = '127.0.0.1' os.environ['MASTER_PORT'] = '29500' dist.init_process_group(backend, rank=rank, world_size=size) fn(rank, size) def run(rank, size): tensor = torch.zeros(1) print('Rank ', rank, ' has data before send/recv', tensor) if rank == 0: tensor += 1 # Send the tensor to process 1 dist.send(tensor=tensor, dst=1) else: # Receive tensor from process 0 dist.recv(tensor=tensor, src=0) print('Rank ', rank, ' has data after send/recv', tensor) def run_allreduce(rank, size): \"\"\" Simple reduce communication. \"\"\" group = dist.new_group([0, 1]) device = torch.device('cuda:%d' % rank) tensor = torch.ones(1).to(device) dist.all_reduce(tensor, op=dist.ReduceOp.SUM, group=group) print('Rank ', rank, ' has data ', tensor[0]) def run_multigpu_allreduce(rank, size): group = dist.new_group([0, 1]) tensor_list = [] for dev_idx in range(2): device = torch.device('cuda:%d' % (2 * rank + dev_idx)) tensor = torch.ones(1).to(device) tensor_list.append(tensor) dist.all_reduce_multigpu(tensor_list) print('all_reduce_multigpu', tensor_list) dist.all_reduce(tensor_list[0], op=dist.ReduceOp.SUM, group=group) print('Rank ', rank, ' has data tensor[0]:', tensor_list[0], \", tensor[1]:\", tensor_list[1]) if __name__ == \"__main__\": args = parser.parse_args() backend = args.backend if args.mode == \"distributed\" or os.environ.get('RANK',None): print(\"in distribute mode\") if args.function == \"all_reduce\": function, size = run_allreduce, 2 elif args.function == \"gpu_all_reduce\": function, size = run_multigpu_allreduce, 2 else: function, size, backend = run, 2, \"gloo\" rank = int(os.environ['RANK']) p = Process(target=init_process, args=(rank, size, function, backend)) p.start() p.join() else: print(\"in one device mode\") if args.function == \"all_reduce\": function, size = run_allreduce, 2 elif args.function == \"gpu_all_reduce\": function, size = run_multigpu_allreduce, 2 else: function, size, backend = run, 2, \"gloo\" processes = [] for rank in range(size): p = Process(target=init_process, args=(rank, size, function, backend)) p.start() processes.append(p) for p in processes: p.join() 可以简单地运行上面的例子： send/recv: $ python3 distribute_test.py # 输出如下： in one device mode Rank 0 has data before send/recv tensor([0.]) Rank 1 has data before send/recv tensor([0.]) Rank 0 has data after send/recv tensor([1.]) Rank 1 has data after send/recv tensor([1.]) 上面是演示的是通过 pytorch 的 multiprocessing 包，模拟一次分布式的 send/recv 过程，这里是 rank0 的进程往 rank1 的进程发送一个 tensor，可以看到 rank 1 tensor 初始化为 0，是接收到 rank 0 的tensor 后变为 1 的。（注意：这里特别设置了 backend 为 gloo 是因为 nccl 不支持 point2point 的传输，具体不同 backend 支持什么形式的原语，参考文档backend部分 ） all_reduce $ python3 distribute_test.py -f all_reduce # 输出如下： in one device mode Rank 0 has data tensor(2., device='cuda:0') Rank 1 has data tensor(2., device='cuda:1') # 对应函数 def run_allreduce(rank, size): \"\"\" Simple reduce communication. \"\"\" group = dist.new_group([0, 1]) # use rank 0 and rank 1 device = torch.device('cuda:%d' % rank) tensor = torch.ones(1).to(device) dist.all_reduce(tensor, op=dist.ReduceOp.SUM, group=group) print('Rank ', rank, ' has data ', tensor[0]) 这里也很浅白，主要就是对两个进程上的 tensor 进行一次 allreduce，可以看到两个 rank 上的结果都为 2了。 g","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:2:3","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"MPI 更深入的尝试，可以尝试了解一下 mpi 的知识，这个mpi教程 算是写得比较系统的，大家可以参考一下来练习，特别是对底层不是很了解的同学，可以多看看 Running an MPI cluster within a LAN 的部分，实操一下通过 ssh 跑起一个分布式的 demo。集合通信库的基础大概先到这里，如果要深入的可以再去看看 openMPI，和 nccl 的实现。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:2:4","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"Horovod流程分析 下面我会以一个简单的 pytorch horovod 的 demo 尝试去理解一下 horovod 的工作机理，demo 如下（省略了一些不关键的代码段）。为了准确起见，我们是根据 horovod v0.20.3 的版本进行阅读的，如果是其他版本，可能会跟这里的内容有一些出入。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:3:0","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"pytorch demo 一般的 horovod 训练程序都会包含以下几个关键步骤： 1. hvd.init: 对 horovod 2. 初始化。初始化模型，数据集，优化器，初始化不同 node 的模型权重。 3. 使用 hvd.DistributedOptimizer 包装优化器。 4. 进入训练流程，进行优化迭代。 我们会着重介绍第 1 和 4 步，因为主要也是1，4步会跟 c++ 后端进行信息交换。 import torch.backends.cudnn as cudnn import torch.nn.functional as F import torch.optim as optim import torch.utils.data.distributed from torchvision import models import horovod.torch as hvd import timeit import numpy as np ... # some argparse hvd.init() # Set up standard model. model = getattr(models, args.model)() optimizer = optim.SGD(model.parameters(), lr=0.01 * lr_scaler) # Horovod: (optional) compression algorithm. compression = hvd.Compression.fp16 if args.fp16_allreduce else hvd.Compression.none # Horovod: wrap optimizer with DistributedOptimizer. optimizer = hvd.DistributedOptimizer(optimizer, named_parameters=model.named_parameters(), compression=compression, op=hvd.Adasum if args.use_adasum else hvd.Average) # Horovod: broadcast parameters \u0026 optimizer state. hvd.broadcast_parameters(model.state_dict(), root_rank=0) hvd.broadcast_optimizer_state(optimizer, root_rank=0) # Set up fixed fake data data = torch.randn(args.batch_size, 3, 224, 224) target = torch.LongTensor(args.batch_size).random_() % 1000 if args.cuda: data, target = data.cuda(), target.cuda() def benchmark_step(): optimizer.zero_grad() output = model(data) loss = F.cross_entropy(output, target) loss.backward() optimizer.step() #... some log configuration img_secs = [] for x in range(args.num_iters): time = timeit.timeit(benchmark_step, number=args.num_batches_per_iter) img_sec = args.batch_size * args.num_batches_per_iter / time img_secs.append(img_sec) # Results ... 然后下图是我对 horovod 整体流程的梳理，把一些不是很关键的部分隐藏了，可能有一些细节的地方和实现有出入，不过我待会会有详细的说明。这里先解释一下，下面几个大的部分: main.py： 表示训练脚本，一般是 使用 horovod 提供的函数跟特定的训练框架相互合作完成分布式训练（下文称前端） C++ interface：是指 horovod python 函数调用 C++ 的接口 GlobalState：在 horovod 中是一个全局变量，其中的元素可以供不同的线程访问，在加载 C++ 的代码时候就已经创建了，同时创建的还有各种 context（mpi_context, nccl_context, gpu_context）后面会提到，主要会在下图 backgroundThreadLoop 中完成 globalstate 不同元素初始化，比较重要的有 controller 管理总体通信控制流，tensor_queue 会处理从前端过来的通信需求（allreduce，broadcast 等）。 BackgroundThreadLoop：是训练过程中的后台线程，主要负责跟其他节点的通信，和处理前端过来的通信需求（request），会轮询调用 RunLoopOnce，不断查看 tensor_queue 中有没有需要通信的tensor，如果有跟其他节点同步更新，然后执行通信操作。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:3:1","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"流程分析 下面使用 mpi_controller 进行 allreduce 操作进行分析。 1.hvd.init()-\u003eInitializeHorovodOnce 首先，hvd.init() 会通过一系列的调用和配置最终调用 horovod/common/http://operations.cc 下的 InitializeHorovodOnce 函数，这个函数会根据加载的集合通讯库（mpi 或者 gloo）为 globalstate 创建对应的 controller，然后使用 BackgroundThreadLoop 启动一个后台线程。 horovod/common/http://operations.cc #628 void InitializeHorovodOnce(const int* ranks, int nranks) { // ... some envParse #if HAVE_MPI // Enable mpi is it's used either i[n cpu data transfer or controller if (horovod_global.cpu_operation == LibType::MPI || horovod_global.control_operation == LibType::MPI) { mpi_context.Enable(); } // 创建一个 MPIController 对象 if (horovod_global.control_operation == LibType::MPI){ horovod_global.controller.reset(new MPIController( horovod_global.response_cache, horovod_global.tensor_queue, horovod_global.timeline, horovod_global.parameter_manager, mpi_context)); horovod_global.controller-\u003eSetRanks(ranks, nranks); } #endif #if HAVE_GLOO //... #endif // Reset initialization flag horovod_global.initialization_done = false; // 启动后台线程 horovod_global.background_thread = std::thread( BackgroundThreadLoop, std::ref(horovod_global)); } while (!horovod_global.initialization_done) { std::this_thread::sleep_for(std::chrono::milliseconds(1)); } } 2.BackgroundThreadLoop BackgroundThreadLoop 会为 GlobalState 初始化一系列包括初始化 mpi_context， controller的元素，然后轮询调用 RunLoopOnce，还有一些对 RunLoopOnce 结束后的后处理。 void BackgroundThreadLoop(HorovodGlobalState\u0026 state) { #if HAVE_MPI // Initialize mpi context auto mpi_ctx_manager = MPIContextManager(); #endif // mpi_context 会根据前端和环境变量传过来的信息，创建 mpi 线程，和一些 mpiOps mpi_context.Initialize(state.controller-\u003eGetRanks(), mpi_ctx_manager); #endif // Initialize controller // 会同步不同 node 的 global_size, local_size, rank, is_coordinator 等信息 state.controller-\u003eInitialize(); // Set background thread affinity parse_and_set_affinity(std::getenv(HOROVOD_THREAD_AFFINITY), local_size, local_rank); #if HAVE_GPU ... // 设置 gpu_context 的 stream 数目等初始化动作 #endif // 下面是设置 parameter_manager 这里为了节省篇幅直接给出，设置的语句， // 原来这里会读取对应的环境变量的，去设置 parameter_manager。 // 后面也会有篇幅介绍 parameter_manager，这里先不展开。 state.parameter_manager.SetTensorFusionThresholdBytes(64 * 1024 * 1024); state.parameter_manager.SetCycleTimeMs(5); state.parameter_manager.SetCacheEnabled(true); state.response_cache.set_capacity( (int)state.parameter_manager.CacheEnabled() * state.cache_capacity); state.parameter_manager.SetHierarchicalAllgather(value, true); state.parameter_manager.SetAutoTuning(true); ... // 其他一些初始化设置 // 设置op_manager，这里主要是注册不同的集合通信库的 ops //（ 如：NCCLAllreduce, MPI_GPUAllgather 等） op_manager.reset(CreateOperationManager(state)); // 初始化完成 state.initialization_done = true; // Iterate until shutdown. try { while (RunLoopOnce(state)); } catch (const std::exception\u0026 ex) { LOG(ERROR) \u003c\u003c \"Horovod background loop uncaught exception: \" \u003c\u003c ex.what(); } ... // 其他一些后处理函数 } 3.Optimizer.step()-\u003eDoAllReduce 这里我们先不急着看 RunLoopOnce 函数，先回到 InitializeHorovodOnce ，因为上面的 initialization_done = True，所以 InitializeHorovodOnce 可以退出了，就是前端的 hvd.init() 可以进行下一步了。这里 main.py 走完前向 loss = model(data,target)，后向逻辑 loss.backward()，调用 optimizer.step() 进行梯度同步。optimizer.step() 会通过一系列的调用和处理（如：compression 等操作）最终会调用 C++ interface 的 DoAllReduce 函数。 DoAllReduce 函数会调用 EnqueueTensorAllreduce 函数会把需要 reduce 的 tensor 组装成一个Request 往 GlobalState 的 tensor_queue 里面塞。这里注意每个 tensor 会创建对应 TensorTableEntry，用于保存tensor 的权重，message 主要是一些 元信息 metadata。然后就等后台线程去读取这些allreduce 的请求了。 Status EnqueueTensorAllreduce(std::shared_ptr\u003cOpContext\u003e context, std::shared_ptr\u003cTensor\u003e tensor, std::shared_ptr\u003cTensor\u003e output, std::shared_ptr\u003cReadyEvent\u003e ready_event, const std::string name, const int device, StatusCallback callback, ReduceOp reduce_op, double prescale_factor, double postscale_factor) { Status status; ... // some config Request message; message.set_request_rank(horovod_global.controller-\u003eGetRank()); message.set_tensor_name(name); message.set_tensor_type(tensor-\u003edtype()); message.set_device(device); message.set_prescale_factor(prescale_factor); messag","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:3:2","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"其他关键模块 上面只是介绍了 horovod 主流程工作原理，不过 horovod 还有其他一些模块协同主流程工作的，下面会对其中的一些我认为可以值得一说的模块说一下。 Parameter_manager: Parameter_manager 主要是 GlobalState 的一个用于管理一些调节 horovod 性能的参数的管理器，在 BackgroundThreadLoop 中跟其他的 GlobalState 的元素一同初始化，然后会读取下面这些对应的环境变量，然后进行设置。 HOROVOD_FUSION_THRESHOLD：指传输数据切片的大小，默认是64M，如果切片太大，传输的时候就不能很好地 pipeline 传输，如果太小，一个 tensor 需要传输多次，增加 IO 的 overhead。 HOROVOD_CYCLE_TIME：指 RunLoopOnce 的睡眠时长，默认是 5ms，我自己的猜测（还没进行验证）比较理想的睡眠时间应该是 RunLoopOnce 其余逻辑处理的时间 + HOROVOD_CYCLE_TIME 刚好等于一次前向传播和后向传播所用的时间，因为睡太久前端会在等 RunLoopOnce 睡醒；如果睡太短，不断地跑一次 RunLoopOnce，tensor_queue 也不会有新的元素，只是白跑。 HOROVOD_CACHE_CAPACITY：指 cache 的大小，这个可能跟 model 层数参数量相关了。 HOROVOD_HIERARCHICAL_ALLGATHER：是否使用分层的allgather的方式等 Parameter_manager也提供了对这些参数自动调节的功能。通过Parameter_manager.SetAutoTuning进行设置，设置后会在初始的几个batch尝试不同的参数组合进行通信，后面会收敛到一组最优的参数值。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:3:3","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"MPIContext mpi_context 是在加载 C++ 的代码时候就已经创建了，同时创建的还有其他 context（ nccl_context, gpu_context），主要是维护一些节点上 mpi 通信的必要环境信息和设置，如： 3 个 MPI communicator，mpi_comm，local_comm，cross_comm 分别负责 horovod mpi 传输，节点内传输，和节点间分层传输（主要用于 hierarchical allreduce）。 mpi_float16_t: horovod 主要以 float16 传输。 mpi_float16_sum: float16 对应的sum 操作。 在 horovod 使用 mpi 的时候，都会使用上面的 communicator 进行数据传输。 ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:3:4","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"Tensorflow2 TensorFlow2 前端对 horovod 的调用跟 pytorch 类似，只是因为 tensorflow 2 是通过 tape 等级制记录梯度的, 所以会有一些不同。 hvd.init() # Set up standard model. model = getattr(applications, args.model)(weights=None) opt = tf.optimizers.SGD(0.01) data = tf.random.uniform([args.batch_size, 224, 224, 3]) target = tf.random.uniform([args.batch_size, 1], minval=0, maxval=999, dtype=tf.int64) @tf.function def benchmark_step(first_batch): # Horovod: (optional) compression algorithm. compression = hvd.Compression.fp16 if args.fp16_allreduce else hvd.Compression.none # Horovod: use DistributedGradientTape with tf.GradientTape() as tape: probs = model(data, training=True) loss = tf.losses.sparse_categorical_crossentropy(target, probs) # Horovod: add Horovod Distributed GradientTape. tape = hvd.DistributedGradientTape(tape, compression=compression) gradients = tape.gradient(loss, model.trainable_variables) opt.apply_gradients(zip(gradients, model.trainable_variables)) if first_batch: hvd.broadcast_variables(model.variables, root_rank=0) hvd.broadcast_variables(opt.variables(), root_rank=0) for x in range(args.num_iters): benchmark_step(first_batch=False) with tf.GradientTape() as tape这一句会调用 horovod/tensorflow/__init__.py 中_DistributedGradientTape 下 init 函数注册 allreduce 的句柄（handle） 然后调用 gradients = tape.gradient(loss, model.trainable_variables) 会调用一系列的跳转最后会调用 tensorflow/mpi_ops.py 下的 _allreduce ，进而调用 `MPI_LIB.horovod_allreduce MPI_LIB.horovod_allreduce 在 horovod/tensorflow/http://mpi_ops.cc 中被 HorovodAllreduceOp 所注册，根据 TensorFlow 的 ops流程，会调用 ops.ComputeAsync，到这里会跟 pytorch 类似会调用 EnqueueTensorAllreduce 把对应的 tensor 和 ops 送到 GlobalState 的 tensor_queue 中。 class HorovodAllreduceOp : public AsyncOpKernel { public: explicit HorovodAllreduceOp(OpKernelConstruction* context) : AsyncOpKernel(context) { OP_REQUIRES_OK(context, context-\u003eGetAttr(\"reduce_op\", \u0026reduce_op_)); OP_REQUIRES_OK(context, context-\u003eGetAttr(\"prescale_factor\", \u0026prescale_factor_)); OP_REQUIRES_OK(context, context-\u003eGetAttr(\"postscale_factor\", \u0026postscale_factor_)); OP_REQUIRES_OK(context, context-\u003eGetAttr(\"ignore_name_scope\", \u0026ignore_name_scope_)); } void ComputeAsync(OpKernelContext* context, DoneCallback done) override { OP_REQUIRES_OK_ASYNC(context, ConvertStatus(common::CheckInitialized()), done); ... // 一些变量验证，初始化 auto enqueue_result = EnqueueTensorAllreduce( hvd_context, hvd_tensor, hvd_output, ready_event, node_name, device, [context, done](const common::Status\u0026 status) { context-\u003eSetStatus(ConvertStatus(status)); done(); }, reduce_op, (double) prescale_factor_, (double) postscale_factor_); OP_REQUIRES_OK_ASYNC(context, ConvertStatus(enqueue_result), done); } private: int reduce_op_; // Using float since TF does not support double OP attributes float prescale_factor_; float postscale_factor_; bool ignore_name_scope_; }; ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:3:5","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["Distributed Computing"],"content":"总结 horovod 的流程分析大概就是这样，没有特别复杂，代码的阅读体验也是比较好的，在主流程的关键函数都有比较清晰的注释。对于第三方开发者来说，horovod 本身已经用了很多提高性能的 tricks，可以 custom 优化的地方不多，一些可以动的参数，也已经提供了autotuning，直接使用就可以得到很好的性能。如果尝试优化，可能要从传输上着手，如 BytePS 会尝试使用不同的网络拓扑引入一些 PS 节点提高带宽等，如果有时间我也会聊一下这个。另外上面的分析也有很多是我自己阅读代码时候的一些思考可能不一定准确，如果有不准确或者模糊的地方，也希望大家可以多多斧正。 References: [1]. https://zhuanlan.zhihu.com/p/332825987 [2]. https://zhuanlan.zhihu.com/p/158584571 [3]. https://zhuanlan.zhihu.com/p/79030485 [4]. https://github.com/zjykzj/pytorch-distributed [5]. MPI教程 https://blog.csdn.net/qq_47058489/article/details/125980505 https://blog.csdn.net/weixin_45385568/article/details/121208161?spm=1001.2101.3001.6650.1\u0026utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-121208161-blog-87971642.pc_relevant_multi_platform_featuressortv2removedup\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-121208161-blog-87971642.pc_relevant_multi_platform_featuressortv2removedup\u0026utm_relevant_index=1 [5.] ubuntu20.04 + docker + horovod Horovod and Distributed Training ","date":"2023-07-13","objectID":"/posts/horovod_and_openmpi/:4:0","tags":["Horovod"],"title":"Horovod and Openmpi","uri":"/posts/horovod_and_openmpi/"},{"categories":["OS"],"content":"进程和线程的区别 ","date":"2023-07-13","objectID":"/posts/os_2/:1:0","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"进程、线程、协程的概念 进程： 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程： 是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 协程： 是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。 ","date":"2023-07-13","objectID":"/posts/os_2/:1:1","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"进程和线程的区别 地址空间： 线程共享本进程的地址空间，而进程之间是独立的地址空间。 资源： 线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。 健壮性： 多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。 执行过程： 每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。 但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。 可并发性： 两者均可并发执行。 切换时： 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。 其他： 线程是处理器调度的基本单位，但是进程不是。 ","date":"2023-07-13","objectID":"/posts/os_2/:1:2","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"协程和线程的区别 协程避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任。同时，协程也失去了标准线程使用多CPU的能力。 线程（thread） 相对独立 有自己的上下文 切换受系统控制； 协程（coroutine） 相对独立 有自己的上下文 切换由自己控制，由当前协程切换到其他协程由当前协程来控制。 ","date":"2023-07-13","objectID":"/posts/os_2/:1:3","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"何时使用多进程，何时使用多线程？ 对资源的管理和保护要求高，不限制开销和效率时，使用多进程。 要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。 ","date":"2023-07-13","objectID":"/posts/os_2/:1:4","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"为什么会有线程？ 每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。 ","date":"2023-07-13","objectID":"/posts/os_2/:1:5","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"*python多线程存在的问题 存在问题： python由于历史遗留的问题，严格说多个线程并不会同时执行（没法有效利用多核处理器，python的并发只是在交替执行不同的代码）。 多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。所以python的多线程并发并不能充分利用多核，并发没有java的并发严格。 原因： 原因就在于GIL ，在Cpython 解释器（Python语言的主流解释器）中，有一把全局解释锁（GIL, Global Interpreter Lock），在解释器解释执行Python 代码时，任何Python线程执行前，都先要得到这把GIL锁。 这个GIL全局锁实际上把所有线程的执行代码都给上了锁。 这意味着，python在任何时候，只可能有一个线程在执行代码。 其它线程要想获得CPU执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。 多个线程一起执行反而更加慢的原因： 同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上线文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。 什么时候GIL被释放？ 当一个线程遇到I/O 任务时，将释放GIL。 计算密集型（CPU-bound）线程执行100次解释器的计步（ticks）时（计步可粗略看作Python 虚拟机的指令），也会释放GIL。 即，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。 Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。 参考博客 ","date":"2023-07-13","objectID":"/posts/os_2/:1:6","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"*进程的几种通信方式 管道： 速度慢，容量有限，只有父子进程能通讯 FIFO： 任何进程间都能通讯，但速度慢 消息队列： 容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量： 不能传递复杂消息，只能用来同步 共享内存区： 能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 ","date":"2023-07-13","objectID":"/posts/os_2/:1:7","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"*举例说明进程、线程、协程 程序： 例如main.py这是程序，是一个静态的程序。 python进程： 一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。 multiprocessing.Process实现多进程 进程池： 如果要启动大量的子进程，可以用进程池的方式批量创建子进程。 multiprocessing.Pool 进程间通信： 各自在独立的地址空间，并不能直接进行全局的数据共享，在创建子进程的时候会将父进程的数据复制到子进程中一份。 进程间通信 Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。 python线程： thread是比较低级,底层的模块，threading是高级模块，对thread进行了封装,可以更加方便的被使用。 python协程： 线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员,当程序中存在大量不需要CPU的操作时（例如 I/O），适用于协程。 例如yield 其中 yield 是python当中的语法。 当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。 但是，yield让协程暂停，和线程的阻塞是有本质区别的。 \u003c/font color=red\u003e协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。 因此，协程的开销远远小于线程的开销。 最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。 这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 python可以通过 yield/send 的方式实现协程。在python 3.5以后，async/await 成为了更好的替代方案。 ","date":"2023-07-13","objectID":"/posts/os_2/:1:8","tags":["OS"],"title":"Process and Coroutine","uri":"/posts/os_2/"},{"categories":["OS"],"content":"操作系统(一) ","date":"2023-07-13","objectID":"/posts/os_1/:1:0","tags":["OS"],"title":"计算机操作系统","uri":"/posts/os_1/"},{"categories":["OS"],"content":"1.1 进程和线程的区别？ 进程和线程都是操作系统中进行任务调度的基本单位，二者之间的主要区别如下： 资源占用：进程是操作系统资源分配的基本单位，一个进程可以拥有多个线程，而线程是进程中的执行单元，是CPU调度的基本单位。每个线程共享所属进程的资源，如代码段、数据段、打开的文件等。而进程之间互相独立，互不干扰，每个进程有自己独立的资源空间，不同进程之间需要通过IPC（进程间通信）来进行通信和数据共享。 调度和切换：操作系统在调度和分配CPU时，将进程作为基本的调度和分配单位，即进程拥有自己的调度队列。而线程是依附于进程而存在的，一个进程中的多个线程共享进程的时间片和资源，因此在调度和切换时，线程切换比进程切换更快，也更加轻量级。 创建和销毁：进程的创建和销毁比线程更加复杂，创建一个进程需要为其分配资源、建立PCB（进程控制块）、建立内核对象等，而销毁进程需要回收资源、关闭打开的文件等。而线程的创建和销毁相对简单，只需要为其分配线程栈、建立TCB（线程控制块）等即可。 通信和同步：进程之间通过IPC（管道、套接字、消息队列等）进行通信和数据共享，而线程之间可以直接访问同一进程的共享数据区，也可以通过锁机制实现同步。 综上所述，进程和线程在资源占用、调度和切换、创建和销毁、通信和同步等方面有着不同的特点，开发者在实际编程时需要根据具体的情况选择使用进程还是线程来完成任务。 ","date":"2023-07-13","objectID":"/posts/os_1/:1:1","tags":["OS"],"title":"计算机操作系统","uri":"/posts/os_1/"},{"categories":["OS"],"content":"1.2 协程与线程的区别？ 协程和线程都是用于实现多任务的技术，但是它们的实现方式有所不同，具体区别如下： 调度方式不同：线程由操作系统内核进行调度，而协程则是在用户空间中进行调度，不需要切换到内核态。 并发性不同：线程是操作系统调度的最小单位，多个线程可以并行执行；协程则是在单线程内部通过协作式调度实现并发。 内存使用不同：线程是由操作系统内核创建的，需要占用一定的系统资源，而协程则是由用户程序创建，不需要占用额外的系统资源。 上下文切换开销不同：线程在切换时需要保存和恢复所有的寄存器状态和内核堆栈，而协程只需要保存和恢复少量的寄存器状态，开销较小。 编程难度不同：线程的编程难度相对较大，因为多线程之间需要共享资源并进行同步，而协程则是在单线程内部调度，因此编程难度相对较小。 总之，线程是操作系统内核的调度对象，具有独立的系统资源，可以并行执行多个任务；而协程是用户程序的调度对象，不需要占用额外的系统资源，通过协作式调度实现任务之间的切换。 ","date":"2023-07-13","objectID":"/posts/os_1/:1:2","tags":["OS"],"title":"计算机操作系统","uri":"/posts/os_1/"},{"categories":["OS"],"content":"1.3、并发和并行的区别？ 并发和并行都是指同时处理多个任务的方式，但是它们有不同的含义。 并发是指一个处理器同时处理多个任务，这些任务通常是通过在不同的时间间隔内交替进行的，这样在同一时刻可以看到有多个任务在运行。这些任务可以是在同一个程序内的不同线程，也可以是在不同程序之间的交互，例如客户端与服务器之间的通信。 并行是指使用多个处理器同时处理多个任务，这些任务在同一时刻可以看到有多个任务在同时运行。与并发不同的是，并行需要多个处理器或多个计算核心，而并发则可以在单个处理器上执行多个任务。 简单来说，并发是在一个处理器上同时执行多个任务，而并行是在多个处理器或计算核心上同时执行多个任务。 ","date":"2023-07-13","objectID":"/posts/os_1/:1:3","tags":["OS"],"title":"计算机操作系统","uri":"/posts/os_1/"},{"categories":["OS"],"content":"1.4 进程与线程的切换流程？ 进程与线程的切换流程如下： 当前进程或线程执行到阻塞状态（如等待I/O完成）时，触发切换操作。 操作系统内核保存当前进程或线程的上下文（即当前的寄存器值和程序计数器等信息），并将处理器分配给另一个进程或线程。 内核从调度队列中选择另一个进程或线程，并恢复其保存的上下文信息。 处理器开始执行新的进程或线程，从之前保存的状态恢复执行。 在进程切换时，需要将整个进程的上下文信息保存下来，包括进程的虚拟内存、全局变量等，切换时还需要进行内存映射，开销比较大。 在线程切换时，只需要保存当前线程的上下文信息即可，线程共享进程的虚拟内存，切换时不需要进行内存映射，开销较小。 ","date":"2023-07-13","objectID":"/posts/os_1/:1:4","tags":["OS"],"title":"计算机操作系统","uri":"/posts/os_1/"},{"categories":["OS"],"content":"1.5 为什么虚拟地址空间切换比较耗时？ 虚拟地址空间切换的耗时是因为它涉及到了硬件和操作系统的复杂操作。当进程或线程切换时，需要保存当前的程序状态（寄存器值、堆栈指针等）和上下文信息（当前指令位置、程序计数器等）。然后，内核必须选择另一个进程或线程，并将它的状态和上下文信息装入内存，这样才能保证程序能够继续运行。这个过程涉及到多个操作系统的内核和硬件机制，例如上下文切换、内存管理和硬件中断等。 在这个过程中，为了切换到另一个进程或线程，需要保存和恢复大量的状态信息，包括内核上下文和硬件寄存器等。这些操作需要耗费大量的CPU时间和内存带宽，因此切换过程通常是相对比较耗时的。 ref: [1].https://zhuanlan.zhihu.com/p/616080301 ","date":"2023-07-13","objectID":"/posts/os_1/:1:5","tags":["OS"],"title":"计算机操作系统","uri":"/posts/os_1/"},{"categories":["GPU"],"content":"[1] https://blog.csdn.net/Augusdi/article/details/12187291 ","date":"2023-07-12","objectID":"/posts/cuda/:0:0","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"CUDA编程 ","date":"2023-07-12","objectID":"/posts/cuda/:1:0","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"1.什么是CUDA CUDA(Compute Unified Device Architecture)，统一计算架构，是NVidia推出的并行计算平台。NVidia官方对其的解释是：一个并行计算平台和简单（简洁）地使用图像处理单元（GPU）进行通用计算的编程模型。利用GPU的能力在计算性能上有惊人的提升。 简单地说CUDA是便于程序员利用NVidia GPU进行通用计算的开发环境及工具，目前支持C/C++语言，将来还会支持Fortran语言。 ","date":"2023-07-12","objectID":"/posts/cuda/:1:1","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"2.为什么要用到CUDA CPU主频要比GPU高2-3倍左右，但是通常情况下GPU核心的数量要比CPU多2-3个数量级以上。因此GPU的计算能力要远大于CPU，充分发挥GPU的计算能力，可以有成倍的性能提升。 早期利用GPU的计算能力是使用着色器和着色语言（GLSL等）。目前广泛使用的是CUDA和OpenCL。CUDA是针对NVidia GPU硬件设备设计的，而 OpenCL是针对跨平台设计的。因此CUDA可充分发挥NVidia GPU的计算性能。 CUDA可以直接使用C/C++语言来开发GPU程序，省去了程序员重新学一种新语言的麻烦。 ","date":"2023-07-12","objectID":"/posts/cuda/:1:2","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"3.CUDA环境搭建 CUDA环境主要分为四点：硬件（GPU设备）、操作系统、C/C++编译器和CUDA工具包。 硬件（GPU设备），必须是支持CUDA的GPU。可到NVidia官网查询支持CUDA的GPU设备，具体地址为：http://www.nvidia.com/object/cuda_home_new.html 。 操作系统，支持Microsoft Windows、Mac OS X和Linux。 C/C++编译器，对不同的操作系统有不同的要求。 CUDA工具包，NVidia提供了不同操作系统对应的CUDA Toolkit，可从https://developer.nvidia.com/cuda-downloads 下载对应的版本。 本文只以Microsoft Windows为例介绍如何搭建CUDA环境。 准备材料： ·一台装有支持CUDA GPU的电脑。 ·Microsoft Windows操作系统（Microsoft Windows XP,Vista,7,or 8 or Windows Server 2003 or 2008）。 ·CUDA工具包（相应操作系统）。下载地址：https://developer.nvidia.com/cuda-downloads ·C/C++编译器：Microsoft Visual Studio 2008 或 2010，或者对应版本的Microsoft Visual C++ Express产品。 安装步骤： ·在装有支持CUDA GPU的电脑上安装Microsoft Windows操作系统（一般情况下都已经完成这步骤）。 ·安装C/C++编译器，可只安装其中的C++编译器部分。 ·安装CUDA工具包。（CUDA工具包中有NVidia GPU的驱动程序，尚未安装的请选择安装。） 安装验证： Windows XP系统：进入 C:\\Documents and Settings\\All Users\\Application Data\\NVIDIA Corporation\\CUDA Samples\\v5.0\\bin\\win32\\Release 目录运行deviceQuery.exe文件。 Windows Vista, Windows 7, Windows 8, Windows Server 2003, and Windows Server 2008系统：进入 C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v5.0\\bin\\win32\\Release 目录运行deviceQuery.exe文件。 如果安装正确，执行deviceQuery.exe文件会得到GPU设备的相应信息。如果没有安装支持CUDA的GPU也会得出GPU的信息，其中CUDA Capability Major/Minor version number信息为9999.9999。 Microsoft Windows上更详细的安装信息请查看：http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-microsoft-windows/index.html 。 Mac OS X的安装：http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html 。 Linux的安装：http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-linux/index.html 。 ","date":"2023-07-12","objectID":"/posts/cuda/:1:3","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"4.第一个CUDA程序 在Microsoft Windows系统上，如果成功搭建了CUDA环境，则在Microsoft Visual Studio中已经集成了CUDA的开发组件。 以下以Windows 7 + Microsoft Visual Studio 2008为例，创建第一个CUDA程序。 打开Microsoft Visual Studio 2008，依次：File-\u003eNew-\u003eProject-\u003eNVIDIA-\u003eCUDA-\u003eCUDA 5.0 Runtime，输入相应的项目名称确定即可。 默认会生成一个kernel.cu文件，内容如下： #include \"cuda_runtime.h\" #include \"device_launch_parameters.h\" #include \u003cstdio.h\u003e void addWithCuda(int *c, const int *a, const int *b, size_t size); __global__ void addKernel(int *c, const int *a, const int *b) { int i = threadIdx.x; c[i] = a[i] + b[i]; } int main() { const int arraySize = 5; const int a[arraySize] = { 1, 2, 3, 4, 5 }; const int b[arraySize] = { 10, 20, 30, 40, 50 }; int c[arraySize] = { 0 }; // Add vectors in parallel. addWithCuda(c, a, b, arraySize); printf(\"{1,2,3,4,5} + {10,20,30,40,50} = {%d,%d,%d,%d,%d}\\n\", c[0], c[1], c[2], c[3], c[4]); // cudaThreadExit must be called before exiting in order for profiling and // tracing tools such as Nsight and Visual Profiler to show complete traces. cudaThreadExit(); return 0; } // Helper function for using CUDA to add vectors in parallel. void addWithCuda(int *c, const int *a, const int *b, size_t size) { int *dev_a = 0; int *dev_b = 0; int *dev_c = 0; // Choose which GPU to run on, change this on a multi-GPU system. cudaSetDevice(0); // Allocate GPU buffers for three vectors (two input, one output) . cudaMalloc((void**)\u0026dev_c, size * sizeof(int)); cudaMalloc((void**)\u0026dev_a, size * sizeof(int)); cudaMalloc((void**)\u0026dev_b, size * sizeof(int)); // Copy input vectors from host memory to GPU buffers. cudaMemcpy(dev_a, a, size * sizeof(int), cudaMemcpyHostToDevice); cudaMemcpy(dev_b, b, size * sizeof(int), cudaMemcpyHostToDevice); // Launch a kernel on the GPU with one thread for each element. addKernel\u003c\u003c\u003c1, size\u003e\u003e\u003e(dev_c, dev_a, dev_b); // cudaThreadSynchronize waits for the kernel to finish, and returns // any errors encountered during the launch. cudaThreadSynchronize(); // Copy output vector from GPU buffer to host memory. cudaMemcpy(c, dev_c, size * sizeof(int), cudaMemcpyDeviceToHost); cudaFree(dev_c); cudaFree(dev_a); cudaFree(dev_b); } 代码1 这是一个将两个一维数组相加的例子。 其中addKernel是内核函数，它的计算过程是在GPU上实现的，用函数类型限定符__global__限制，且函数类型为void型。 cuda_runtime.h头文件包括了运行时API和其参数的定义。（如果使用驱动API则使用cuda.h头文件）。 device_launch_parameters.h头文件包含了内核函数的5个变量threadIdx、blockDim、blockIdx、gridDim和wrapSize。 对其中CUDA运行时API函数的解释： cudaSetDevice()：选择设备（GPU）。（可以不使用，不使用的情况下，默认选择设备0） cudaMalloc()：动态分配显存。 cudaMemcpy()：设备与主机之内的数据拷贝。 cudaThreadSynchronize()：同步所有设备上的线程，等待所有线程结束。 cudaFree():释放由cudaMalloc分配的显存。 cudaThreadExit():结束CUDA上下文环境，释放其中的资源。 这些函数的具体介绍在 http://docs.nvidia.com/cuda/cuda-runtime-api/index.html 中。 ","date":"2023-07-12","objectID":"/posts/cuda/:1:4","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"5. CUDA编程 5.1. 基本概念 CUDA编程中需要注意一些基本概念，分别为：主机(host)、设备(device)、运行时API、驱动API、warp、bank、函数类型限定符、变量类型限定符、thread、block、grid、计算能力、SIMT、内置变量、纹理、CUDA数组等。 主机(host)：可理解为CPU与内存的组合。 设备(device)：可理解为GPU与显存的组合。 运行时API：是指CUDA运行时API是在驱动API的基础上封装而成的，简化了CUDA的开发。 驱动API：是指CUDA驱动API，相比运行时API更接近于设备，可灵活运用设备的特性开发CUDA，可实现运行时API无法实现的功能。 warp：多处理器激活、管理、调度和执行并行任务的单位。计算能力2.x的设备warp为32个线程。未来的设备可能不同，可以通过内置变量warpSize查询。 bank：为了获得较高的存储器带宽，共享存储器被划分为多个大小相等的存储器模块，称为存储体，这些存储体就叫bank，可同步访问。 函数类型限定符：是CUDA C中特有的，用来修饰是主机函数，设备调用的设备函数，还是主机调用的设备函数。有__device__、global、host。 变量类型限定符：是用来修饰设备变量的。有__device__、constant、shared。 thread：设备中的线程，与主机中的线程是同一个概念。 block：线程块，由一组线程组成。一个线程块中的所以线程会在同一个多处理器上执行，一个多处理器上可同时执行多个线程块。 grid：有所有线程块组成的网格。 计算能力：是NVidia GPU不同架构的计算能力。 SIMT：单指令多线程，与单指令多数据（SIMD）类似。一条指令多个线程一同执行，实现程序的并行化。 内置变量：有threadIdx、blockDim、blockIdx、gridDim、warpSize。其中threadIdx指此线程在线程块中的位置；blockDim指线程块维度；blockIdx指该线程块在网格中的位置；gridDim指线程块网格维度；warpSize指一个warp多少个线程。 纹理：本文主要涉及到的是纹理参考、纹理绑定、纹理获取。 CUDA数组：区别于线性存储器，对数据进行了对齐等的处理，包括一维、二维和三维。其中的数据为：一元、二元或四元组。 CUDA编程模型基础 在给出CUDA的编程实例之前，这里先对CUDA编程模型中的一些概念及基础知识做个简单介绍。CUDA编程模型是一个异构模型，需要CPU和GPU协同工作。在CUDA中，host和device是两个重要的概念，我们用host指代CPU及其内存，而用device指代GPU及其内存。CUDA程序中既包含host程序，又包含device程序，它们分别在CPU和GPU上运行。同时，host与device之间可以进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行流程如下： 分配host内存，并进行数据初始化；分配device内存，并从host将数据拷贝到device上；调用CUDA的核函数在device上完成指定的运算；将device上的运算结果拷贝到host上；释放device和host上分配的内存。 上面流程中最重要的一个过程是调用CUDA的核函数来执行并行计算，kernel是CUDA中一个重要的概念，kernel是在device上线程中并行执行的函数，核函数用__global__符号声明，在调用时需要用«\u003cgrid, block»\u003e来指定kernel要执行的线程数量，在CUDA中，每一个线程都要执行核函数，并且每个线程会分配一个唯一的线程号thread ID，这个ID值可以通过核函数的内置变量threadIdx来获得。 由于GPU实际上是异构模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词开区别host和device上的函数，主要的三个函数类型限定词如下： __global__：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是void，不支持可变参数参数，不能成为类成员函数。注意用__global__定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。__device__：在device上执行，单仅可以从device中调用，不可以和__global__同时用。__host__：在host上执行，仅可以从host上调用，一般省略不写，不可以和__global__同时用，但可和__device__，此时函数会在device和host都编译。 要深刻理解kernel，必须要对kernel的线程层次结构有一个清晰的认识。首先GPU上很多并行化的轻量级线程。kernel在device上执行时实际上是启动很多线程，一个kernel所启动的所有线程称为一个网格（grid），同一个网格上的线程共享相同的全局内存空间，grid是线程结构的第一层次，而网格又可以分为很多线程块（block），一个线程块里面包含很多线程，这是第二个层次。线程两层组织结构如下图所示，这是一个gird和block均为2-dim的线程组织。grid和block都是定义为dim3类型的变量，dim3可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此grid和block可以灵活地定义为1-dim，2-dim以及3-dim结构，对于图中结构（主要水平方向为x轴），定义的grid和block如下所示，kernel在调用时也必须通过执行配置«\u003cgrid, block»\u003e来指定kernel所使用的线程数及结构。 所以，一个线程需要两个内置的坐标变量（blockIdx，threadIdx）来唯一标识，它们都是dim3类型变量，其中blockIdx指明线程所在grid中的位置，而threaIdx指明线程所在block中的位置，如图中的Thread (1,1)满足： threadIdx.x = 1 threadIdx.y = 1 blockIdx.x = 1 blockIdx.y = 1 一个线程块上的线程是放在同一个流式多处理器（SM)上的，但是单个SM的资源有限，这导致线程块中的线程数是有限制的，现代GPUs的线程块可支持的线程数可达1024个。有时候，我们要知道一个线程在blcok中的全局ID，此时就必须还要知道block的组织结构，这是通过线程的内置变量blockDim来获得。它获取线程块各个维度的大小。对于一个2-dim的block ，线程 的ID值为 ，如果是3-dim的block ，线程 的ID值为 。另外线程还有内置变量gridDim，用于获得网格块各个维度的大小。 kernel的这种线程组织结构天然适合vector,matrix等运算，如我们将利用上图2-dim结构实现两个矩阵的加法，每个线程负责处理每个位置的两个元素相加，代码如下所示。线程块大小为(16, 16)，然后将N*N大小的矩阵均分为不同的线程块来执行加法运算。 此外这里简单介绍一下CUDA的内存模型，如下图所示。可以看到，每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory）,可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）。内存结构涉及到程序优化，这里不深入探讨它们。 还有重要一点，你需要对GPU的硬件实现有一个基本的认识。上面说到了kernel的线程组织层次，那么一个kernel实际上会启动很多线程，这些线程是逻辑上并行的，但是在物理层却并不一定。这其实和CPU的多线程有类似之处，多线程如果没有多核支持，在物理层也是无法实现并行的。但是好在GPU存在很多CUDA核心，充分利用CUDA核心可以充分发挥GPU的并行计算能力。GPU硬件的一个核心组件是SM，前面已经说过，SM是英文名是 Streaming Multiprocessor，翻译过来就是流式多处理器。SM的核心组件包括CUDA核心，共享内存，寄存器等，SM可以并发地执行数百个线程，并发能力就取决于SM所拥有的资源数。当一个kernel被执行时，它的gird中的线程块被分配到SM上，一个线程块只能在一个SM上被调度。SM一般可以调度多个线程块，这要看SM本身的能力。那么有可能一个kernel的各个线程块被分配多个SM，所以grid只是逻辑层，而SM才是执行的物理层。SM采用的是SIMT (Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是线程束（warps)，线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。所以尽管线程束中的线程同时从同一程序地址执行，但是可能具有不同的行为，比如遇到了分支结构，一些线程可能进入这个分支，但是另外一些有可能不执行，它们只能死等，因为GPU规定线程束中所有线程在同一周期执行相同的指令，线程束分化会导致性能下降。当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。这是因为资源限制，SM要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。","date":"2023-07-12","objectID":"/posts/cuda/:1:5","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"5.3. 存储器层次结构 CUDA存储器有：寄存器(register)、共享存储器(shared memory)、常量存储器(constant memory)、本地存储器(local memory)、全局存储器(global memory)、纹理存储器等。其中寄存器和本地存储器是线程(thread)私有的，共享存储器是对线程块(block)中的所有线程可见，常量存储器、全局存储器和纹理存储器是对网格(grid)中所有线程可见。 下图解释了存储器的层次结构： 5.4. 运行时API 运用运行时API开发CUDA程序需要了解：初始化、设备管理、存储器管理、流管理、事件管理、纹理参考管理、OpenGL互操作和Direct3D互操作。 运行时API文档地址为：http://docs.nvidia.com/cuda/cuda-runtime-api/index.html 。 5.4.1. 初始化 运行时API不存在显示初始化函数，初始化会在首次调用运行时函数时完成。虽然不需要调用初始化函数进行初始化，但是退出时需要调用退出函数cudaThreadExit()释放资源。 5.4.2. 设备管理 有些电脑上可能有多块设备，因此对于不同的要求选择合适的设备。设备管理主要是获取设备信息和选择执行设备。 主要有三个函数： ·cudaGetDeviceCount()：得到电脑上设备的个数。 ·cudaGetDeviceProperties()：获得对应设备的信息。 ·cudaSetDevice()：设置CUDA上下文对应的设备。 运行__global__函数前需要提前选择设备，如果不调用cudaSetDevice()函数，则默认使用0号设备。 上面三个函数的具体用法请查看CUDA运行时API文档。 5.4.3. 存储器管理 共享存储器、常量存储器、线性存储器和CUDA数组的使用是存储器管理的主要部分。 5.4.3.1 共享存储器 共享存储器，使用__shared__变量限定符修饰，可静态或动态分配共享存储器。 代码一： 静态分配共享存储器，是在设备代码中直接分配共享存储器的大小，如下代码： #define SHARED_MEM 16 __global__ void kernel(…) { __shared__ int shared[SHARED_MEM]; } void main() { kernel\u003c\u003c\u003cnBlock, nThread\u003e\u003e\u003e(…); } 代码2 动态分配共享存储器，是在主机代码中使用内核函数的第三个特定参数传入分配共享存储器的大小，如下代码： #define SHARED_MEM 16 __global__ void kernel(…) { extern __shared__ int shared[]; } void main() { int nSharedMem = (int)SHARED_MEM; kernel\u003c\u003c\u003cnBlock, nThread, nSharedMem*sizeof(int)\u003e\u003e\u003e(…); } 5.4.3.2. 常量存储器 常量存储器，使用__constant__变量限定符修饰。使用常量存储器，是由于其在设备上有片上缓存，比全局存储器读取效率高很多。 使用常量存储器时会涉及的运行时API函数主要有： ·cudaMemcpyToSymbol() ·cudaMemcpyFromSymbol() ·cudaGetSymbolAddress() ·cudaGetSymbolSize() 主机代码中使用cudaGetSymbolAddress()获取__constant__或__device__定义的变量地址。设备代码中可通过提取__device__、__shared__或__constant__变量的指针获取变量地址。 5.4.3.3. 线性存储器 线性存储器是使用cudaMalloc()、cudaMallocPitch()或cudaMalloc3D()分配的，使用cudaFree()释放。二维的时候建议使用cudaMallocPitch()分配，cudaMallocPitch()函数对对齐进行了调整。这三个分配函数对应cudaMemset()、cudaMemset2D()、cudaMemset3D()三个memset函数和cudaMemcpy()、cudaMemcpy2D()、cudaMemcpy3D()三个memcpy函数。 5.4.3.4. CUDA数组 CUDA数组是使用cudaMallocArray()、cudaMalloc3DArray()分配的，使用cudaFreeArray()释放。 相关memcpy函数请查阅CUDA运行时API文档。 具体使用可查阅CUDA编程指南：http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html 。 5.4.4. 流管理 主机设备之间的内存拷贝与内核在设备上执行是异步的。在不使用流的情况下，是这样执行的：设备先从主机上拷贝内存，拷贝完成之后，再在设备上执行内核代码计算，最后当内核执行完毕，再把设备上的内存拷贝到主机上。当使用两个流的情况下，0号流执行内核代码的同时1号流拷贝主机内存到设备，1号流执行的同时0号流拷贝设备内存到主机（具体的实现并不一定如此，这里是为了说明流的作用简单做了假设）。两个流的情况下，部分内存拷贝和内置执行是同时进行的（异步的），比同步的内存拷贝和内核执行节省了时间。 与流有关的函数有： ·cudaStreamCreate()：流的创建； ·cudaStreamDestroy()：流的销毁； ·cudaStreamSynchronize()：流同步； ·*Async：与流相关的其他函数。 内核\u003c\u003c\u003c…\u003e\u003e\u003e的第四个参数为哪个流。 CUDA编程指南中有对流具体实现的讲解。 https://blog.csdn.net/a925907195/article/details/39500915 ","date":"2023-07-12","objectID":"/posts/cuda/:1:6","tags":["CUDA"],"title":"CUDA Introduction","uri":"/posts/cuda/"},{"categories":["GPU"],"content":"第5章 共享内存和常量内存 了解数据在共享内存中是如何被安排的 掌握从二维共享内存到线性全局内存的索引转换 解决不同访问模式中存储体中的冲突 在共享内存中缓存数据以减少对全局内存的访问 使用共享内存避免非合并全局内存的访问 理解常量缓存和只读缓存之间的差异 使用线程束洗牌指令编程 ","date":"2023-07-12","objectID":"/posts/cuda_05/:1:0","tags":["CUDA"],"title":"CUDA_C_NOTES [5]","uri":"/posts/cuda_05/"},{"categories":["GPU"],"content":"5.1 CUDA共享内存概述 GPU中有两种类型的内存: 板载内存: 全局内存是较大的板载内存，具有相对较高的延迟。 片上内存: 共享内存是较小的片上内存，具有相对较低的延迟，并且共享内存可以提供比全局内存高得多的带宽 共享内存通常的用途有: 块内线程通信的通道 用于全局内存数据的可编程管理的缓存 高速暂存存储器，用于转换数据以优化全局内存访问模式 5.1.1 共享内存 共享内存（shared memory，SMEM）是GPU的一个关键部件。物理上，每个SM都有一个小的低延迟内存池，这个内存池被当前正在该SM上执行的线程块中的所有线程所共享。(共享内存就是SM上的一块低延迟内存池) 共享内存使同一个线程块中的线程能够互相协作，便于重用片上数据，并可以大大降低核函数所需的全局内存带宽。由于共享内存中的内容是由应用程序显式管理的，所以它通常被描述为可编程管理的缓存。 当每个线程块开始执行时，会分配给它一定数量的共享内存。这个共享内存的地址空间被线程块中所有的线程共享。它的内容和创建时所在的线程块具有相同生命周期。每个线程束发出共享内存访问请求。在理想的情况下，每个被线程束共享内存访问的请求在一个事务中完成。最坏的情况下，每个共享内存的请求在32个不同的事务中顺序执行。如果多个线程访问共享内存中的同一个字，一个线程读取该字后，通过多播把它发送给其他线程。 共享内存被SM中的所有常驻线程块划分，因此，共享内存是限制设备并行性的关键资源。一个核函数使用的共享内存越多，处于并发活跃状态的线程块就越少。 可编程管理的缓存 共享内存是一个可编程管理的缓存。当数据移动到共享内存中以及数据被释放时,我们对它有充分的控制权。由于在CUDA中允许手动管理共享内存,所以通过在数据布局上提供更多的细粒度控制和改善片上数据的移动,使得对应用程序代码进行优化变得更简单了 5.1.2 共享内存分配 有多种方法可以用来分配或声明由应用程序请求所决定的共享内存变量。可以静态或动态地分配共享内存变量。在CUDA的源代码文件中,共享内存可以被声明为一个本地的CUDA核函数或是一个全局的CUDA核函数。CUDA支持一维、二维和三维共享内存数组的声明。 共享内存变量用下列修饰符进行声明: __shared__ 如果在核函数中进行声明,那么这个变量的作用域就局限在该内核中。如果在文件的任何核函数外进行声明,那么这个变量的作用域对所有核函数来说都是全局的。 ","date":"2023-07-12","objectID":"/posts/cuda_05/:1:1","tags":["CUDA"],"title":"CUDA_C_NOTES [5]","uri":"/posts/cuda_05/"},{"categories":["GPU"],"content":"CH04 全局内存 ","date":"2023-07-12","objectID":"/posts/cuda_04/:1:0","tags":["CUDA"],"title":"CUDA_C_NOTES [4]","uri":"/posts/cuda_04/"},{"categories":["GPU"],"content":"4.1 CUDA内存模型概述 在现有的硬件存储子系统下， 必须依靠内存模型获得最佳的延迟和带宽。 CUDA内存模结合了主机和设备的内存系统， 展现了完整的内存层次结构， 使你能显式地控制数据布以优化性能.s 4.1.1 内存层次结构的优点 两种不同类型的局部性: 时间局部性：时间局部性认为如果一个数据位置被引用， 那么该数据在较短的间周期内很可能会再次被引用， 随着时间流逝， 该数据被引用的可能性逐渐降低 空间局部性：空间局部性认为如果一个内存位置被引用， 则附近的位置也可能会被引用 现代计算机使用不断改进的低延迟低容量的内存层次结构来优化性能。 这种内存层次结构仅在支持局部性原则的情况下有效。 一个内存层次结构由具有不同延迟、 带宽容量的多级内存组成。 通常， 随着从处理器到内存延迟的增加， 内存的容量也在增加。 CPU和GPU的主存都采用的是DRAM（动态随机存取存储器），而低延迟内存（如CPU一级缓存）使用的则是SRAM（静态随机存取存储器）。内存层次结构中最大且最慢的级别通常使用磁盘或闪存驱动来实现。在这种内存层次结构中，当数据被处理器频繁使用时，该数据保存在低延迟、低容量的存储器中；而当该数据被存储起来以备后用时，数据就存储在高延迟、大容量的存储器中。这种内存层次结构符合大内存低延迟的设想。 GPU和CPU内存模型的主要区别是， CUDA编程模型能将内存层次结构更好地呈现给用户， 能让我们显式地控制它的行为. 4.1.2 CUDA内存模型 对于程序员来说， 一般有两种类型的存储器： 可编程的： 你需要显式地控制哪些数据存放在可编程内存中 不可编程的： 你不能决定数据的存放位置， 程序将自动生成存放位置以获得好的性能 在CPU内存层次结构中， 一级缓存和二级缓存都是不可编程的存储器。 CUDA内存模型提出了多种可编程内存的类型: 寄存器 (register) 共享内存 (shared memory) 本地内存 (local memory) 常量内存（constant memory） 纹理内存 () 全局内存(global memory) 一个核函数中的线程都有自己私有的本地内存。 一个线程块有自己的共享内存， 对同一线程块中所有线程都可见， 其内容持续线程块的整个生命周期。 所有线程都可以访问全局内存。 所有线程都能访问的只读内存空间有： 常量内存空间和纹理内存空间。 \u003e 全局内存、 常量内存和纹理内存空间有不同的用途。 纹理内存为各种数据布局提供了不同的寻址模式和滤波模式。 对于一个应用程序来说， 全局内存、 常量内存和纹理内存中的内容具有相同的生命周期. 4.1.2.1 寄存器 寄存器是GPU上运行速度最快的内存空间。 核函数中声明的一个没有其他修饰符的自变量， 通常存储在寄存器中。 在核函数声明的数组中， 如果用于引用该数组的索引是常量且能在编译时确定， 那么该数组也存储在寄存器中。 寄存器变量对于每个线程来说都是私有的， 一个核函数通常使用寄存器来保存需要频 繁访问的线程私有变量。 寄存器变量与核函数的生命周期相同。 一旦核函数执行完毕， 就不能对寄存器变量进行访问了。 寄存器是一个在SM中由活跃线程束划分出的较少资源: 在Fermi架构中，每个线程最多有63个寄存器； 在Kepler架构中，每个线程最多有255个寄存器； 在核函数中使用较少的寄存器将使在SM上有更多的常驻线程块。 每个SM上并发线程块越多，使用率和性能就越高 如果一个核函数使用了超过硬件限制数量的寄存器， 则会用本地内存替代多占用的寄 存器。 4.1.2.2 本地内存（local memory） 编译器可能存放到本地内存中的变量有： 在编译时使用未知索引引用的本地数组 可能会占用大量寄存器空间的较大本地结构体或数组 任何不满足核函数寄存器限定条件的变量 “本地内存”这一名词是有歧义的： 溢出到本地内存中的变量本质上与全局内存在同一 块存储区域， 因此本地内存访问的特点是高延迟和低带宽， 并且如在本章后面的4.3节中所描述的那样， 本地内存访问符合高效内存访问要求. 4.1.2.3 共享内存 在核函数中使用如下修饰符修饰的变量存放在共享内存中： __shared__ 因为共享内存是片上内存， 所以与本地内存或全局内存相比， 它具有更高的带宽和更 低的延迟。 它的使用类似于CPU一级缓存， 但它是可编程的。 每一个SM都有一定数量的由线程块分配的共享内存。 因此， 必须非常小心不要过度使用共享内存， 否则将在不经意间限制活跃线程束的数量。 共享内存在核函数的范围内声明， 其生命周期伴随着整个线程块。 当一个线程块执行结束后， 其分配的共享内存将被释放并重新分配给其他线程块。 共享内存是线程之间相互通信的基本方式。 一个块内的线程通过使用共享内存中的数 据可以相互合作。 访问共享内存必须同步使用如下调用， 该命令是在之前章节中介绍过的CUDA运行时调用： void __syncthreads(); 该函数设立了一个执行障碍点， 即同一个线程块中的所有线程必须在其他线程被允许 执行前达到该处。 为线程块里所有线程设立障碍点， 这样可以避免潜在的数据冲突。 SM中的一级缓存和共享内存都使用64KB的片上内存， 它通过静态划分， 但在运行时 可以通过如下指令进行动态配置： cudaError_t cudaFuncSetCacheConfig(const void* func, enum cadaFuncCache cacheConfig) 4.1.2.4 常量内存 常量内存驻留在设备内存中， 并在每个SM专用的常量缓存中缓存。 常量变量用如下 修饰符来修饰: __constant__ 常量变量必须在全局空间内和所有核函数之外进行声明。 对于所有计算能力的设备， 都只可以声明64KB的常量内存。 常量内存是静态声明的， 并对同一编译单元中的所有核函数可见。 核函数只能从常量内存中读取数据。（不能往常量内存中写数据） 因此， 常量内存必须在主机端使用下面的函数来 初始化： cudaError_t cudaMemoryToSymbol(const void* symbol, const void* src, size_t count) 这个函数将count个字节从src指向的内存复制到symbol指向的内存中， 这个变量存放在设备的全局内存或常量内存中。 线程束中的所有线程从相同的内存地址中读取数据时， 常量内存表现最好。 举个例子， 数学公式中的系数就是一个很好的使用常量内存的例子， 因为一个线程束中所有的线程使用相同的系数来对不同数据进行相同的计算。 如果线程束里每个线程都从不同的地址空间读取数据， 并且只读一次， 那么常量内存中就不是最佳选择， 因为每从一个常量内存中读取一次数据， 都会广播给线程束里的所有线程。 4.1.2.5 纹理内存 纹理内存是一种通过指定的只读缓存访问的全局内存。 只读缓存包括硬件滤波的支持， 它可以将浮点插入作为读过程的一部分来执行。 纹理内存是对二维空间局部性的优化， 所以线程束里使用纹理内存访问二维数据的线程可以达到最优性能。 4.1.2.6 全局内存 全局内存是GPU中最大、 延迟最高并且最常使用的内存。 global指的是其作用域和生命周期。 它的声明可以在任何SM设备上被访问到， 并且贯穿应用程序的整个生命周期。 一个全局内存变量可以被静态声明或动态声明。 你可以使用如下修饰符在设备代码中 静态地声明一个变量： __device__ 在第2章的2.1节中， 你已经学习了如何动态分配全局内存。 在主机端使用cuda-Malloc 函数分配全局内存， 使用cudaFree函数释放全局内存。 然后指向全局内存的指针就会作为 参数传递给核函数。 全局内存分配空间存在于应用程序的整个生命周期中， 并且可以访问 所有核函数中的所有线程。 从多个线程访问全局内存时必须注意。 因为线程的执行不能跨 线程块同步， 不同线程块内的多个线程并发地修改全局内存的同一位置可能会出现问题， 这将导致一个未定义的程序行为。 优化内存事务对于获得最优性能来说是至关重要的。 当一个线程束执行内存加载/ 存储时， 需要满足的传输数量通常取决于以下两个因素： 跨线程的内存地址分布 每个事务内存地址的对齐方式 对于一个给定的线程束内存请求， 事务数量和数据吞吐率是由设备的计算能力来确定 的。 对于计算能力为1.0和1.1的设备， 全局内存访问的要求是非常严格的。 对于计算能力高于1.1的设备， 由于内存事务被缓存， 所以要求较为宽松。 缓存的内存事务利用数据局部性来提高数据吞吐率。 4.1.2.7 GPU缓存 跟CPU缓存一样， GPU缓存是不可编程的内存。 在GPU上有4种缓存： 一级缓存 二级缓存 只读常量缓存 只读纹理缓存 每个SM都有一个一级缓存， 所有的SM共享一个二级缓存。 一级和二级缓存都被用来在存储本地内存和全局内存中的数据， 也包括寄存器溢出的部分。对Fermi GPU和Kepler K40或其后发布的GPU来说， CUDA允许我们配置读操作的数据是使用一级和二级缓存，还是只使用二级缓存。 在GPU上只有内存加载操作可以被缓存，内存存储操作不能被缓存。 每个SM也有一个只读常量缓存和只读纹理缓存， 它们用于在设备内存中提高来自于各自内存空间内的读取性能。 4.1.2.8 CUDA变量声明总结 4.1.2.9 静态全局内存 ","date":"2023-07-12","objectID":"/posts/cuda_04/:1:1","tags":["CUDA"],"title":"CUDA_C_NOTES [4]","uri":"/posts/cuda_04/"},{"categories":["GPU"],"content":"4.2 内存管理 CUDA编程的内存管理与C语言的类似， 需要程序员显式地管理主机和设备之间的数 据移动。 随着CUDA版本的升级， NVIDIA正系统地实现主机和设备内存空间的统一， 但对于大多数应用程序来说， 仍需要手动移动数据。 分配和释放设备内存 在主机和设备之间传输数据 4.2.1 内存分配和释放 CUDA编程模型假设了一个包含一个主机和一个设备的异构系统， 每一个异构系统都 有自己独立的内存空间。 核函数在设备内存空间中运行， CUDA运行时提供函数以分配和释放设备内存。 你可以在主机上使用下列函数分配全局内存： cudaError_t cudaMalloc(void **devPrt, size_t count); 这个函数在设备上分配了count字节的全局内存， 并用devptr指针返回该内存的地址。 你需要用从主机上传输的数据来填充所分配的全局内存， 或用下列函数将其初始 化: cudaError_t cudaMemset(void *devPtr, int value, size_t count); 这个函数用存储在变量value中的值来填充从设备内存地址devPtr处开始的count字节。 一旦一个应用程序不再使用已分配的全局内存， 那么可以以下代码释放该内存空间： cudaError_t cudaFree(void *devPtr); 这个函数释放了devPtr指向的全局内存， 该内存必须在此前使用了一个设备分配函数 （如cudaMalloc） 来进行分配。 否则， 它将返回一个错误cudaErrorInvalidDevicePointer。 如果地址空间已经被释放， 那么cudaFree也返回一个错误。 4.2.2 内存传输 一旦分配好了全局内存， 你就可以使用下列函数从主机向设备传输数据： cudaError_t cudaMemory(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind) 这个函数从内存位置src复制了count字节到内存位置dst。 变量kind指定了复制的方向， 可以有下列取值： cudaMemcpyHostToHost cudaMemcpyHostToDevice cudaMemcpyDeviceToHost cudaMemcpyDeviceToDevice CUDA编程的一个基本原则应是尽可能地减少主机与设备之间的传输. 4.2.3 固定内存 分配的主机内存默认是pageable（可分页） ， 它的意思也就是因页面错误导致的操 作， 该操作按照操作系统的要求将主机虚拟内存上的数据移动到不同的物理位置。 虚拟内存给人一种比实际可用内存大得多的假象， 就如同一级缓存好像比实际可用的片上内存大得多一样。 GPU不能在可分页主机内存上安全地访问数据， 因为当主机操作系统在物理位置上移 动该数据时， 它无法控制。 当从可分页主机内存传输数据到设备内存时， CUDA驱动程序首先分配临时页面锁定的或固定的主机内存， 将主机源数据复制到固定内存中， 然后从固定内存传输数据给设备内存， 如图4-4左边部分所示 CUDA运行时允许你使用如下指令直接分配固定主机内存： cudaError_t cudaMallocHost(void **devPtr, size_t count); 这个函数分配了count字节的主机内存， 这些内存是页面锁定的并且对设备来说是可 访问的。 由于固定内存能被设备直接访问， 所以它能用比可分页内存高得多的带宽进行读写。 然而， 分配过多的固定内存可能会降低主机系统的性能， 因为它减少了用于存储虚拟内存数据的可分页内存的数量， 其中分页内存对主机系统是可用的。 主机与设备间的内存传输 与可分页内存相比， 固定内存的分配和释放成本更高， 但是它为大规模数据传输提供 了更高的传输吞吐量 4.2.4 零拷贝内存 通常来说， 主机不能直接访问设备变量， 同时设备也不能直接访问主机变量。 但有一个例外： 零拷贝内存。 主机和设备都可以访问零拷贝内存。 GPU线程可以直接访问零拷贝内存。 在CUDA核函数中使用零拷贝内存有以下几个优 势。 当设备内存不足时可利用主机内存 避免主机和设备间的显式数据传输 提高PCIe传输率 当使用零拷贝内存来共享主机和设备间的数据时， 你必须同步主机和设备间的内存访 问， 同时更改主机和设备的零拷贝内存中的数据将导致不可预知的后果。 零拷贝内存是固定（不可分页） 内存， 该内存映射到设备地址空间中。 你可以通过下列函数创建一个到固定内存的映射： cudaError_t cudaHostAlloc(void **pHost, size_t count, unsigned int flags); 这个函数分配了count字节的主机内存， 该内存是页面锁定的且设备可访问的。 用这 个函数分配的内存必须用cudaFreeHost函数释放。 flags参数可以对已分配内存的特殊属性 进一步进行配置： - cudaHostAllocDefault - cudaHostAllocPortable - cudaHostAllocWriteCombined - cudaHostAllocMapped cudaHostAllocDefault函数使cudaHostAlloc函数的行为与cudaMallocHost函数一致。 设置cudaHostAllocPortable函数可以返回能被所有CUDA上下文使用的固定内存， 而不仅是执 行内存分配的那一个。 标志cudaHostAllocWriteCombined返回写结合内存， 该内存可以在某些系统配置上通过PCIe总线上更快地传输， 但是它在大多数主机上不能被有效地读取。因此， 写结合内存对缓冲区来说是一个很好的选择， 该内存通过设备使用映射的固定内存或主机到设备的传输。 零拷贝内存的最明显的标志是cudaHostAllocMapped， 该标志返回， 可以实现主机写入和设备读取被映射到设备地址空间中的主机内存。 你可以使用下列函数获取映射到固定内存的设备指针： cudaError_t cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags); 该函数返回了一个在pDevice中的设备指针， 该指针可以在设备上被引用以访问映射得到的固定主机内存。 如果设备不支持映射得到的固定内存， 该函数将失效。 flag将留作以后使用。 现在， 它必须被置为0。 在进行频繁的读写操作时， 使用零拷贝内存作为设备内存的补充将显著降低性能。 因为每一次映射到内存的传输必须经过PCIe总线。 与全局内存相比， 延迟也显著增加。 零拷贝内存 有两种常见的异构计算系统架构： 集成架构和离散架构。 在集成架构中， CPU和GPU集成在一个芯片上， 并且在物理地址上共享主存。 在这种架构中， 由于无须在PCIe总线上备份， 所以零拷贝内存在性能和可编程性方面可能更佳。 对于通过PCIe总线将设备连接到主机的离散系统而言， 零拷贝内存只在特殊情况下有优势。 因为映射的固定内存在主机和设备之间是共享的， 你必须同步内存访问来避免任何潜在的数据冲突， 这种数据冲突一般是由多线程异步访问相同的内存而引起的。 注意不要过度使用零拷贝内存。 由于其延迟较高， 从零拷贝内存中读取设备核函数可能很慢。 4.2.5 统一虚拟寻址 ","date":"2023-07-12","objectID":"/posts/cuda_04/:1:2","tags":["CUDA"],"title":"CUDA_C_NOTES [4]","uri":"/posts/cuda_04/"},{"categories":["GPU"],"content":"CH03 CUDA执行模型 ","date":"2023-07-12","objectID":"/posts/cuda_03/:1:0","tags":["CUDA"],"title":"CUDA_C_NOTES [3]","uri":"/posts/cuda_03/"},{"categories":["GPU"],"content":"3.1 CUDA执行模型概述 CUDA执行模型能够提供有助于在指令吞吐量和内存访问方面编写高效代码的见解 3.1.1 GPU架构概述 GPU架构是围绕一个流式多处理器（SM） (Stream Multiprocessor)的可扩展阵列搭建的,可以通过复制这种架构的构建块来实现GPU的硬件并行 Fermi SM的关键组件： CUDA核心 共享内存/一级缓存 寄存器文件 加载/存储单元 特殊功能单元 线程束调度器 GPU中的每一个SM都能支持数百个线程并发执行， 每个GPU通常有多个SM， 所以在一个GPU上并发执行数千个线程是有可能的。 当启动一个内核网格时， 它的线程块被分布在了可用的SM上来执行。 线程块一旦被调度到一个SM上， 其中的线程只会在那个指定的SM上并发执行。 多个线程块可能会被分配到同一个SM上， 而且是根据SM资源的可用性进行调度的。同一线程中的指令利用指令级并行性进行流水线化， 另外， 在CUDA中已经介绍了线程级并行。 CUDA采用单指令多线程（SIMT）（single instruciton multi thread） 架构来管理和执行线程， 每32个线程为一组， 被称为线程束（warp） 。 线程束中的所有线程同时执行相同的指令。 每个线程都有自己的指令地址计数器和寄存器状态， 利用自身的数据执行当前的指令。 每个SM都将分配给它的线程块划分到包含32个线程的线程束中， 然后在可用的硬件资源上调度执行。 SIMT架构与SIMD（单指令多数据） 架构相似。 两者都是将相同的指令广播给多个执行单元来实现并行。 一个关键的区别是SIMD要求同一个向量中的所有元素要在一个统一的同步组中一起执行， 而SIMT允许属于同一线程束的多个线程独立执行. SIMT确保可以编写独立的线程级并行代码、 标量线程以及用于协调线程的数据并行代码。 SIMT模型包含3个SIMD所不具备的关键特征。 每个线程都有自己的指令地址计数器 每个线程都有自己的寄存器状态 每个线程可以有一个独立的执行路径 一个神奇的数字： 32 从概念上讲， 它是SM用SIMD方式所同时处理的工作粒度。 优化工作负载以适应线程束（一组有32个线程） 的边界， 一般这样会更有效地利用GPU计算资源。 一个线程块只能在一个SM上被调度。 一旦线程块在一个SM上被调度， 就会保存在该SM上直到执行完成。 在同一时间， 一个SM可以容纳多个线程块. 在SM中， 共享内存和寄存器是非常重要的资源。 共享内存被分配在SM上的常驻线程块中， 寄存器在线程中被分配。 尽管线程块里的所有线程都可以逻辑地并行运行， 但是并不是所有线程都可以同时在物理层面执行。 因此， 线程块里的不同线程可能会以不同的速度前进。 在并行线程中共享数据可能会引起竞争： 多个线程使用未定义的顺序访问同一个数据， 从而导致不可预测的程序行为。 CUDA提供了一种用来同步线程块里的线程的方法，从而保证所有线程在进一步动作之前都达到执行过程中的一个特定点。 然而， 没有提供块间同步的原语。 当线程束由于任何理由闲置的时候（如等待从设备内存中读取数值） ， SM可以从同一SM上的常驻线程块中调度其他可用的线程束。 在并发的线程束间切换并没有开销， 因为硬件资源已经被分配到了SM上的所有线程和块中， 所以最新被调度的线程束的状态已经存储在SM上 SM： GPU架构的核心* SM是GPU架构的核心。 寄存器和共享内存是SM中的稀缺资源。 CUDA将这些资源分配到SM中的所有常驻线程里。 这些有限的资源限制了在SM上活跃的线程束数量，活跃的线程束数量对应于SM上的并行量。 了解一些SM硬件组成的基本知识， 有助于组织线程和配置内核执行以获得最佳的性能 3.1.2 Fermi架构 Fermi的特征是多达512个加速器核心， 这被称为CUDA核心。 每个CUDA核心都有一个全流水线的整数算术逻辑单元（ALU） 和一个浮点运算单元（FPU） ， 在这里每个时钟周期执行一个整数或是浮点数指令。 CUDA核心被组织到16个SM中， 每一个SM含有32个CUDA核心。 Fermi架构有6个384位的GDDR5 DRAM存储器接口， 支持多达6GB的全局机载内存， 这是许多应用程序关键的计算资源。 主机接口通过PCIe总线将GPU与CPU相连。 GigaThread引擎（图示左侧第三部分） 是一个全局调度器， 用来分配线程块到SM线程束调度器上。 一个SM(Stream Multiprocessor)包含以下内容： 执行单元（CUDA核心） 调度线程束的调度器和调度单元 共享内存、 寄存器文件和一级缓存 每一个多处理器有16个加载/存储单元（如图3-1所示） ， 允许每个时钟周期内有16个线程（线程束的一半） 计算源地址和目的地址。 特殊功能单元（SFU） 执行固有指令， 如正弦、 余弦、 平方根和插值。 每个SFU每个时钟周期内的每个线程上执行一个固有指令 每个SM有两个线程束调度器和两个指令调度单元。 当一个线程块被指定给一个SM时， 线程块中的所有线程被分成了线程束。 两个线程束调度器选择两个线程束， 再把一个 指令从线程束中发送到一个组上， 组里有16个CUDA核心、 16个加载/存储单元或4个特殊功能单元（如图3-4所示） 。 Fermi架构， 计算性能2.x， 可以在每个SM上同时处理48个线程束， 即可在一个SM上同时常驻1536个线程。 3.1.3 Kepler架构 发布于2012年秋季的Kepler GPU架构是一种快速、 高效、 高性能的计算架构。 Kepler 的特点使得混合计算更容易理解。 图3-6表示了Kepler K20X芯片框图， 它包含了15个SM 和6个64位的内存控制器。 以下是Kepler架构的3个重要的创新。 强化的SM 动态并行 Hyper-Q技术 Kepler K20X的关键部分是有一个新的SM单元， 其包括一些结构的创新， 以提高编程效率和功率效率。 每个Kepler SM单元包含192个单精度CUDA核心， 64个双精度单元， 32个特殊功能单元（SFU） 以及32个加载/存储单元（LD/ST） 3.1.4 配置文件驱动优化 配置文件驱动的发展对于CUDA编程尤为重要， 原因主要有以下几个方面。 一个单纯的内核应用一般不会产生最佳的性能。 性能分析工具能帮助你找到代码中影响性能的关键部分， 也就是性能瓶颈。 CUDA将SM中的计算资源当前SM中的多个常驻线程块之间进行分配。 这种分配形式导致一些资源成为了性能限制者。 性能分析工具能帮助我们理解计算资源是如何被利用的。 CUDA提供了一个硬件架构的抽象， 它能够让用户控制线程并发。 性能分析工具可以检测和优化， 并将优化可视化。 ","date":"2023-07-12","objectID":"/posts/cuda_03/:1:1","tags":["CUDA"],"title":"CUDA_C_NOTES [3]","uri":"/posts/cuda_03/"},{"categories":["GPU"],"content":"3.2 理解线程束执行的本质 本章已经提到了把32个线程划分到一个执行单元中的概念： 线程束（warp）。 现在从硬件的角度来介绍线程束执行， 并能够获得指导内核设计的方法。 3.2.1 线程束和线程块 线程束是SM中基本的执行单元。 当一个线程块的网格被启动后， 网格中的线程块分布在SM中。 一旦线程块被调度到一个SM上， 线程块中的线程会被进一步划分为线程束。 一个线程束由32个连续的线程组成， 在一个线程束中， 所有的线程按照单指令多线程（SIMT） 方式执行； 也就是说， 所有线程都执行相同的指令， 每个线程在私有数据上进 行操作。 一个给定的二维线程块， 在一个块中每个线程的独特标识符都可以用内置变量threadIdx和blockDim来计算： threadIdx.y * blockDim.x + threadIdx.x 对于一个三维线程块， 计算如下： threadIdx.x * blockDim.y * block.Dim.x + threadIdx.y * blockDim.x * threadIdx.x 一个线程块的线程束的数量可以根据下式确定： $$一个线程块中线程束的数量 = 向正无穷取整（\\frac{一个线程块中线程的数量}{线程束大小}）$$ 因此， 硬件总是给一个线程块分配一定数量的线程束。 线程束不会在不同的线程块之间分离。 如果线程块的大小不是线程束大小的偶数倍， 那么在最后的线程束里有些线程就不会活跃。 从逻辑角度来看， 线程块是线程的集合， 它们可以被组织为一维、 二维或三维布局。 从硬件角度来看， 线程块是一维线程束的集合。 在线程块中线程被组织成一维布局，每32个连续线程组成一个线程束。 3.2.2 线程束分化 GPU是相对简单的设备， 它没有复杂的分支预测机制。 一个线程束中的所有线程在同一周期中必须执行相同的指令， 如果一个线程执行一条指令， 那么线程束中的所有线程都必须执行该指令。 如果在同一线程束中的线程使用不同的路径通过同一个应用程序， 这可能会产生问题。 如果一个线程束中的线程产生分化， 线程束将连续执行每一个分支路径， 而禁用不执行这一路径的线程。 线程束分化会导致性能明显地下降。 重要提示: 当一个分化的线程采取不同的代码路径时， 会产生线程束分化 不同的if-then-else分支会连续执行 尝试调整分支粒度以适应线程束大小的倍数， 避免线程束分化 不同的分化可以执行不同的代码且无须以牺牲性能为代价 3.2.3 资源分配 线程束的本地执行上下文主要由以下资源组成： 程序计数器 寄存器 共享内存 由SM处理的每个线程束的执行上下文， 在整个线程束的生存期中是保存在芯片内的。 因此， 从一个执行上下文切换到另一个执行上下文没有损失。 每个SM都有32位的寄存器组， 它存储在寄存器文件中， 并且可以在线程中进行分配， 同时固定数量的共享内存用来在线程块中进行分配。 对于一个给定的内核， 同时存在于同一个SM中的线程块和线程束的数量取决于在SM中可用的且内核所需的寄存器和共享内存的数量。 若每个线程消耗的寄存器越多， 则可以放在一个SM中的线程束就越少。 如果可以减少内核消耗寄存器的数量， 那么就可以同时处理更多的线程束。 若一个线程块消耗的共享内存越多， 则在一个SM中可以被同时处理的线程块就会变少。 如果每个线程块使用的共享内存数量变少， 那么可以同时处理更多的线程块。 当计算资源（如寄存器和共享内存） 已分配给线程块时， 线程块被称为活跃的块。 它所包含的线程束被称为活跃的线程束。 活跃的线程束可以进一步被分为以下3种类型： 选定的线程束 阻塞的线程束 符合条件的线程束 一个SM上的线程束调度器在每个周期都选择活跃的线程束， 然后把它们调度到执行 单元。 活跃执行的线程束被称为选定的线程束。 如果一个活跃的线程束准备执行但尚未执 行， 它是一个符合条件的线程束。 如果一个线程束没有做好执行的准备， 它是一个阻塞的 线程束。 如果同时满足以下两个条件则线程束符合执行条件。 32个CUDA核心可用于执行 当前指令中所有的参数都已就绪 3.2.4 延迟隐藏 SM依赖线程级并行， 以最大化功能单元的利用率， 因此， 利用率与常驻线程束的数量直接相关。 在指令发出和完成之间的时钟周期被定义为指令延迟。 当每个时钟周期中所有的线程调度器都有一个符合条件的线程束时， 可以达到计算资源的完全利用。 这就可以保证， 通过在其他常驻线程束中发布其他指令， 可以隐藏每个指令的延迟。 考虑到指令延迟， 指令可以被分为两种基本类型： 算术指令: 一个算术操作从开始到它产生输出之间的时间； 内存指令: 指发送出的加载或存储操作和数据到达目的地之间的时间。 你可能想知道如何估算隐藏延迟所需要的活跃线程束的数量。 利特尔法则（Little’s Law） 可以提供一个合理的近似值。 它起源于队列理论中的一个定理， 它也可以应用于 GPU中： $$所需线程束数量 = 延迟 \\times 吞吐量$$ 吞吐量和带宽 吞吐量和带宽都是用来度量性能的速度指标。 带宽通常是指理论峰值， 而吞吐量是指已达到的值 带宽通常是用来描述单位时间内最大可能的数据传输量， 而吞吐量是用来描述单位时 间内任何形式的信息或操作的执行速度， 例如， 每个周期完成多少个指令。 吞吐量由SM中每个周期内的操作数量确定， 而执行一条指令的一个线程束对应32个 操作。 这个简单的单位转换表明， 有两种方法可以提高并行： 指令级并行（ILP） ： 一个线程中有很多独立的指令 线程级并行（TLP） ： 很多并发地符合条件的线程 延迟隐藏取决于每个SM中活跃线程束的数量， 这一数量由执行配置和资源约束隐式 决定（一个内核中寄存器和共享内存的使用情况） 。 选择一个最优执行配置的关键是在延 迟隐藏和资源利用之间找到一种平衡。 显示充足的并行 因为GPU在线程间分配计算资源并在并发线程束之间切换的消耗（在一个或两个周期 命令上） 很小， 所以所需的状态可以在芯片内获得。 如果有足够的并发活跃线程， 那么可 以让GPU在每个周期内的每一个流水线阶段中忙碌。 在这种情况下， 一个线程束的延迟可 以被其他线程束的执行隐藏。 因此， 向SM显示足够的并行对性能是有利的 3.2.5 占用率 在每个CUDA核心里指令是顺序执行的。 当一个线程束阻塞时， SM切换执行其他符 合条件的线程束。 理想情况下， 我们想要有足够的线程束占用设备的核心。 占用率是每个 SM中活跃的线程束占最大线程束数量的比值。 $$占用率 = \\frac{活跃线程束数量}{最大线程束数量}$$ 极端地操纵线程块会限制资源的利用： 小线程块： 每个块中线程太少， 会在所有资源被充分利用之前导致硬件达到每个SM的线程束数量的限制 大线程块： 每个块中有太多的线程， 会导致在每个SM中每个线程可用的硬件资源较少 网格和线程块大小的准则 使用这些准则可以使应用程序适用于当前和将来的设备： 保持每个块中线程数量是线程束大小（32） 的倍数 避免块太小： 每个块至少要有128或256个线程 根据内核资源的需求调整块大小 块的数量要远远多于SM的数量， 从而在设备中可以显示有足够的并行 通过实验得到最佳执行配置和资源使用情况 占用率唯一注重的是在每个SM中并发线程或线 程束的数量。 然而， 充分的占用率不是性能优化的唯一目标。 内核一旦达到一定级别的占 用率， 进一步增加占用率可能不会改进性能。 为了提高性能， 可以调整很多其他因素。 3.2.6 同步 在CUDA中， 同步可以在两个级别执行： 系统级： 等待主机和设备完成所有的工作 块级： 在设备执行过程中等待一个线程块中所有线程到达同一点 对于主机来说： cudaError_t cudaDeviceSynchronize(void):cudaDeviceSyn-chronize函数可以用来阻塞主机应用程序， 直到所有的CUDA操作（复制、核函数等） 完成; __device__ void __syncthreads(void);:CUDA提供了一个使用块局部栅栏来同步它们的执行的功能。 当__syncthreads被调用时， 在同一个线程块中每个线程都必须等待直至该线程块中所有其他线程都已经达到这个同步点。 线程块中的线程可以通过共享内存和寄存器来共享数据。 在不同的块之间没有线程同步。 块间同步， 唯一安全的方法是在每个内核执行结束端使用全局同步点； 也就是说， 在全局同步之后， 终止当前的核函数， 开始执行新的核函数。 不同块中的线程不允许相互同步， 因此GPU可以以任意顺序执行块。 这使得CUDA程序在大规模并行GPU上是可扩展的。 3.2.7 可扩展性 对于任何并行应用程序而言， 可扩展性是一个理想的特性。 可扩展性意味着为并行应用程序提供了额外的硬件资源， 相对于增加的资源， 并行应用程序会产生加速。 例如， 若一个CUDA程序在两个SM中是可扩展的， 则与在一个SM中运行相比， 在两个SM中运行会使运行时间减半。 一个可扩展的并行程序可以高效地使用所有的计算资源以提高性能。 可扩展性意味着增加的计算核心可以提高性能。 串行代码本身是不可扩展的， 因为在成千上万的内核上运行一个串行单线程应用程序， 对性能是没有影响的。 并行代码有可扩展的潜能， 但真正的可扩展性取决于算法设计和硬件特性。 ","date":"2023-07-12","objectID":"/posts/cuda_03/:1:2","tags":["CUDA"],"title":"CUDA_C_NOTES [3]","uri":"/posts/cuda_03/"},{"categories":["GPU"],"content":"3.3 并行性的表现 ","date":"2023-07-12","objectID":"/posts/cuda_03/:1:3","tags":["CUDA"],"title":"CUDA_C_NOTES [3]","uri":"/posts/cuda_03/"},{"categories":["GPU"],"content":"3.6 动态并行 在本书中， 到目前为止， 所有核函数都是从主机线程中被调用的。 GPU的工作负载完 全在CPU的控制下。 CUDA的动态并行允许在GPU端直接创建和同步新的GPU内核。 在一 个核函数中在任意点动态增加GPU应用程序的并行性， 是一个令人兴奋的新功能。 ","date":"2023-07-12","objectID":"/posts/cuda_03/:1:4","tags":["CUDA"],"title":"CUDA_C_NOTES [3]","uri":"/posts/cuda_03/"},{"categories":["GPU"],"content":"CH02 CUDA编程模型 ","date":"2023-07-12","objectID":"/posts/cuda_02/:1:0","tags":["CUDA"],"title":"CUDA_C_NOTES [2]","uri":"/posts/cuda_02/"},{"categories":["GPU"],"content":"2.1 CUDA编程模型概述 CUDA编程模型提供了一个计算机架构抽象作为应用程序和其可用硬件之间的桥梁。 CUDA编程模型还利用GPU架构的计算能力提供了以下几个特有功能: 一种通过层次结构在GPU中组织线程的方法(2.3) 一种通过层次结构在GPU中访问内存的方法(4.5) 程序员可以通过以下几个不同层面来看待并行计算: 领域层：如何解析数据和函数，以便在并行环境中正确高效的解决问题（在并行编程中高效的使用pthreads或者OpemMP技术显式地管理线程） 逻辑层：如何组织并发线程 硬件层：理解线程如何映射到核心以帮助提高其性能 ","date":"2023-07-12","objectID":"/posts/cuda_02/:1:1","tags":["CUDA"],"title":"CUDA_C_NOTES [2]","uri":"/posts/cuda_02/"},{"categories":["GPU"],"content":"2.1.1 CUDA编程 在一个异构环境中包含多个CPU和GPU， 每个GPU和CPU的内存都由一条PCI-Express总线分隔开。 主机： CPU及其内存（主机内存） 设备： GPU及其内存（设备内存） “统一寻址”（Unified Memory） 的编程模型的改进， 它连接了主机内存和设备内存空间， 可使用单个指针访问CPU和GPU内存， 无须彼此之间手动拷贝数据。 什么是“统一寻址”（Unified Memory)? CUDA 6.0提出了统一寻址， 使用一个指针来访问CPU和GPU的内存。(详见第4章) 内核（kernel） 是CUDA编程模型的一个重要组成部分， 其代码在GPU上运行。 CUDA编程模型主要是异步的， 因此在GPU上进行的运算可以与主机-设备通信重叠。 一个典型的CUDA程序包 括由并行代码互补的串行代码。 串行代码在cpu上执行，并行代码在GPU上执行。 一个典型的CUDA程序实现流程遵循以下模式： 把数据从CPU内存拷贝到GPU内存； 调用核函数对存储在GPU内存中的数据进行操作； 将数据从GPU内存传送回到CPU内存。 2.1.2 内存管理 CUDA运行时负责分配与释放设备内存， 并且在主机内存和设备内存之间传输数据。 表2-1 主机和设备内存函数 标准c函数 CUDA C函数 标准c函数 CUDA C函数 malloc cudaMalloc memset cudaMemset memcpy cudaMemcpy free cudaFree cudaMalloc函数负责在GPU的内存里分配内存； cudaMemcpy函数负责主机和设备之间的数据传输； cudaError_t cudaMemcpy(void* dst, const void* src, size_t count, cudaMemcpyKind kind) 从src指向的源存储区复制一定数量的字节到dst指向的目标存储区 kind有以下几种: cudaMemcpyHostToHost cudaMemcpyHostToDevice cudaMemcpyDeviceToHost cudaMemcpyDeviceToDevice CUDA编程模型从GPU架构中抽象出一个内存层次结构：全局内存和共享内存。 内存层次结构 全局内存 共享内存 为什么CPU和GPU是异步的？ 当数据被转移到GPU的全局内存后， 主机端调用核函数在GPU上进行数组求和。 一旦内核被调用， 控制权立刻被传回主机， 这样的话， 当核函数在GPU上运行时， 主机可以执行其他函数。 因此， 内核与主机是异步的。 不同的存储空间 2.1.3 线程管理 当核函数在主机端启动时， 它的执行会移动到设备上， 此时设备中会产生大量的线程并且每个线程都执行由核函数指定的语句。 由一个内核启动所产生的所有线程统称为一个网格。 同一网格中的所有线程共享相同的全局内存空间。 一个网格由多个线程块构成， 一个线程块包含一组线程， 同一线程块内的线程协作可以通过以下方式来实现： 同步 共享内存 不同线程块内的线程不能协作。 线程依靠以下两个坐标变量来区分彼此 blockIdx(线程块在线程格内的索引) threadIdx(块内的线程索引) 些变量是核函数中需要预初始化的内置变量。 当执行一个核函数时， CUDA运行时为每个线程分配坐标变量blockIdx和threadIdx。 基于这些坐标， 你可以将部分数据分配给不同的线程。 该坐标变量是基于uint3定义的CUDA内置的向量类型， 是一个包含3个无符号整数的结构， 可以通过x、 y、 z三个字段来指定： blockIdx.x blockIdx.y blockIdx.z threadIdx.x threadIdx.y threadIdx.z CUDA可以组织三维的网格和块. 网格和块的维度由下列两个内置变量指定: blockDim(线程块的维度， 用每个线程块中的线程数来表示) gridDim(线程格的维度， 用每个线程格中的线程数来表示) 它们是dim3类型的变量， 是基于uint3定义的整数型向量， 用来表示维度。 当定义一个dim3类型的变量时， 所有未指定的元素都被初始化为1。 dim3类型变量中的每个组件可以通过它的x、 y、 z字段获得。 如下所示: blockDim.x blockDim.y blockDim.z 网格和线程块的维度 一个线程格会被组织成线程块的二维数组形式， 一个线程块会被组织成线程的三维数组形式 在CUDA程序中有两组不同的网格和块变量： 手动定义的dim3数据类型和预定义的uint3数据类型。 手动定义的dim3类型的网格和块变量仅在主机端可见， 而unit3类型的内置预初始化的网格和块变量仅在设备端可见。 从主机端和设备端访问网格/块变量 区分主机端和设备端的网格和块变量的访问是很重要的。 例如， 声明一个主机端的块变量， 你按如下定义它的坐标并对其进行访问： block.x, block.y, block.z 在设备端， 你已经预定义了内置块变量的大小： blockDim.x, blockDim.y, and blockDim.z 在启动内核之前就定义了主机端的网格和块变量， 并从主机端通过由x、 y、 z三个字段决定的矢量结构来访问它们。 当内核启动时， 可以使用内核中预初始化的内置变量。 总之， 在启动内核之前就定义了主机端的网格和块变量， 并从主机端通过由x、 y、 z三个字段决定的矢量结构来访问它们。 当内核启动时， 可以使用内核中预初始化的内置变量. 对于一个给定的数据大小， 确定网格和块尺寸的一般步骤为： 确定块的大小 在已知数据大小和块大小的基础上计算网格维度 要确定块尺寸， 通常需要考虑： 内核的性能特性 GPU资源的限制 线程层次结构 CUDA的特点之一就是通过编程模型揭示了一个两层的线程层次结构（grid-\u003eblock-\u003ethread）。 由于一个内核 启动的网格和块的维数会影响性能， 这一结构为程序员优化程序提供了一个额外的途径。 2.1.4 启动一个CUDA核函数 CUDA内核调用是对C语言函数调用语句的延伸， «\u003c»\u003e运算符内是核函数的执行配置。 kernel_name \u003c\u003c\u003cgrid, block\u003e\u003e\u003e(argument list) 利用执行配置可以指定线程在GPU上调度运行的方式。 执行配置的第一个值是网格维度， 也就是启动块的数目。 第二个值是块维度， 也就是每个块中线程的数目。 通过指定网格和块的维度， 你可以进行以下 配置： 内核中线程的数目 内核中使用的线程布局 同一个块(block)中的线程之间可以相互协作， 不同块内的线程不能协作。 假设你有32个数据元素用于计算， 每8个元素一个块， 需要启动4个块： kernel_name\u003c\u003c\u003c4, 8\u003e\u003e\u003e(argument list) 由于数据在全局内存中是线性存储的， 因此可以用变量blockIdx.x和threadId.x来进行以下操作。 在网格中标识一个唯一的线程 建立线程和数据元素之间的映射关系 如果把所有32个元素放到一个块里， 那么只会得到一个块: kernel_name\u003c\u003c\u003c1, 32\u003e\u003e\u003e(argument list) 如果每个块只含有一个元素， 那么会有32个块： kernel_name\u003c\u003c\u003c32, 1\u003e\u003e\u003e(argument list) 核函数的调用与主机线程是异步的。 核函数调用结束后， 控制权立刻返回给主机端. 你可以调用以下函数来强制主机端程序等待所有的核函数执行结束： cudaError_t cudaDeivceSynchronize(void); 一些CUDA运行时API在主机和设备之间是隐式同步的。 当使用cudaMemcpy函数在主 机和设备之间拷贝数据时， 主机端隐式同步， 即主机端程序必须等待数据拷贝完成后才能 继续执行程序。 异步行为 不同于C语言的函数调用， 所有的CUDA核函数的启动都是异步的。 CUDA内核调用完成后， 控制权立刻返回给CPU。 2.1.5 编写核函数 核函数是在设备端执行的代码。 用__global__声明定义核函数: __global__ void kernel_name(argument list); 核函数必须有一个void返回类型。 表2-2总结了CUDA C程序中的函数类型限定符 限定符 执行 调用 备注 global device host CUDA核函数的限制 以下限制适用于所有核函数: 只能访问设备内存 必须具有void返回类型 不支持可变数量的参数 不支持静态变量 显示异步行为 ","date":"2023-07-12","objectID":"/posts/cuda_02/:1:2","tags":["CUDA"],"title":"CUDA_C_NOTES [2]","uri":"/posts/cuda_02/"},{"categories":["GPU"],"content":"2.3 组织并行线程 (以阅读为主) 从前面的例子可以看出， 如果使用了合适的网格和块大小来正确地组织线程， 那么可以对内核性能产生很大的影响。 2.3.1 使用块和线程建立矩阵索引 在一个矩阵加法核函数中，一个线程通常被分配一个数据元素来处理。首先要完成的任务是使用块和线程索引从全局内存中访问指定的数据。 ","date":"2023-07-12","objectID":"/posts/cuda_02/:1:3","tags":["CUDA"],"title":"CUDA_C_NOTES [2]","uri":"/posts/cuda_02/"},{"categories":["GPU"],"content":"Ch01 基于CUDA的异构并行计算 ","date":"2023-07-12","objectID":"/posts/cuda_01/:1:0","tags":["CUDA"],"title":"CUDA_C_NOTES [1]","uri":"/posts/cuda_01/"},{"categories":["GPU"],"content":"1.1 并行计算 并行计算通常设计两个不同的计算机领域 计算机架构(硬件)：在结构级别上支持并行性 并行程序设计(软件)：充分使用计算机架构的计算能力来并发地解决问题 1.1.1 串行编程和并行编程 1.1.2 并行性 并行性方式 任务并行： 当许多任务或函数可以独立地、大规模地并行执行时，这就是任务并行。任务并行的核心是在于利用多核系统对任务进行分配。 数据并行： 当可以处理许多数据的时候，就是数据并行。数据并行的重点是利用多核系统对数据进行分配。 CUDA编程非常适合解决数据并行问题。 数据划分方式： 块划分： 每个线程作用于一部分数据， 通常这些数据具有相同大小。 一组连续数据被分到一个块内，每个数据块以任意次序被安排给一个线程，线程通常在同一时间只处理一个数据块。 周期划分： 每个线程作用于数据的多部分。 在周期划分中，更少的数据被分到一个块内。相邻的线程处理相邻的数据块，每个线程可以处理多个数据块。为一个待处理的线程选择一个新的块，就意味着要跳过和现有线程一样多的数据块。 1.1.3 计算机架构 计算机机构分类(弗林分类(Flynn’s Taxonomy))：根据指令和数据进入CPU的方式进行分类 单指令单数据（SISD） 一种串行架构。 在这种计算机上只有一个核心。在任何时间点上只有一个指令流在处理一个数据流。 单指令多数据（SIMD） 一种并行架构类型。在这种计算机上有多个核心。 在任何时间点上所有的核心只有一个指令流处理不同的数据流，例如向量机。 优势: 在CPU上编写代码时， 程序员可以继续按串行逻辑思考但对并行数据操作实现并行加速，而其他细节则由编译器来负责。 多指令单数据（MISD） 比较少见, 每个核心通过使用多个指令流处理同一个数据流 多指令多数据（MIMD） 一种并行架构， 在这种架构中，多个核心使用多个指令流来异步处理多个数据流，从而实现空间上的并行性。 许多MIMD架构还包括SIMD执行的子组件。 计算机架构优劣的评价指标： 降低延迟 延迟是一个操作从开始到完成所需要的时间， 常用微秒来表示 提高带宽 带宽是单位时间内可处理的数据量， 通常表示为MB/s或GB/s。 提高吞吐量 吞吐量是单位时间内成功处理的运算数量， 通常表示为gflops（即每秒十亿次的浮点运算数量） ， 特别是在重点使用浮点计算的科学计算领域经常用到 延迟用来衡量完成一次操作的时间， 而吞吐量用来衡量在给定的单位时间内处理的操作量 根据内存组织方式进一步划分计算机架构: 分布式内存的多节点系统 大型计算引擎是由许多网络连接的处理器构成的。 每个处理器有自己的本地内存， 而且处理器之间可以通过网络进行通信(类似于多机多卡) 共享内存的多处理器系统 GPU代表了一种众核架构，几乎包括了前文描述的所有并行结构： 多线程、MIMD（多指令多数据）、 SIMD（单指令多数据）， 以及指令级并行。 NVIDIA公司称这 种架构为SIMT（单指令多线程）。 GPU核心和CPU核心 尽管可以使用多核和众核来区分CPU和GPU的架构， 但这两种核心是完全不同的。 CPU核心比较重， 用来处理非常复杂的控制逻辑， 以优化串行程序执行。 GPU核心较轻， 用于优化具有简单控制逻辑的数据并行任务， 注重并行程序的吞吐量。 ","date":"2023-07-12","objectID":"/posts/cuda_01/:1:1","tags":["CUDA"],"title":"CUDA_C_NOTES [1]","uri":"/posts/cuda_01/"},{"categories":["GPU"],"content":"1.2 异构计算 CPU和GPU是两个独立的处理器， 它们通过单个计算节点中的PCI-Express总线相连。 在这种典型的架构中， GPU指的是离散的设备，从同构系统到异构系统的转变是高性能计算 史上的一个里程碑。 同构计算使用的是同一架构下的一个或多个处理器来执行一个应用。 而异构计算则使用一个处理器架构来执行一个应用，为任务选择适合它的架构，使其最终 对性能有所改进. 1.2.1 异构架构 一个典型的异构计算节点包括两个多核CPU插槽和两个或更多个的众核GPU。 GPU不 是一个独立运行的平台而是CPU的协处理器。 因此， GPU必须通过PCIe总线与基于CPU的 主机相连来进行操作， 如图1-9所示。 这就是为什么CPU所在的位置被称作主机端(host)而GPU 所在的位置被称作设备端(device)。 一个异构应用包括两部分： 主机代码：在CPU上运行 设备代码：在GPU上运行. 描述GPU容量的两个重要特征 CUDA核心数量 内存大小 相应的， 有两种不同的指标来评估GPU的性能: 峰值计算性能：用来评估计算容量的一个指标， 通常定义为每秒能处理的单精度或双精度浮点运算的数量，通常用GFlops（每秒十亿次浮点运算） 或TFlops（每秒万 亿次浮点运算） 来表示 内存带宽：从内存中读取或写入数据的比率。 内存带宽通常用GB/s表示 计算能力 1.2.2 异构计算范例 GPU与CPU结合后， 能有效提高大规模计算问题的处理速度与性能。 CPU针对动态工作负载进行了优化， 这些动态工作负载是由短序列的计算操作和不可预测的控制流程标 记的； 而GPU在其他领域内的目的是： 处理由计算任务主导的且带有简单控制流的工作负载。 CPU线程与GPU线程 CPU上的线程通常是重量级的实体。 操作系统必须交替线程使用启用或关闭CPU执行通道以提供多线程处理功能。 上下文的切换缓慢且开销大。 GPU上的线程是高度轻量级的。 在一个典型的系统中会有成千上万的线程排队等待工作。 如果GPU必须等待一组线程执行结束， 那么它只要调用另一组线程执行其他任务即可 1.2.3 CUDA： 一种异构计算平台 CUDA是一种通用的并行计算平台和编程模型，它利用NVIDIA GPU中的并行计算引擎能更有效地解决复杂的计算问题。通过使用CUDA，你可以像在CPU上那样，通过GPU来进行计算。 CUDA提供了两层API来管理GPU设备和组织线程， 如图1-13所示。 CUDA驱动API：驱动API是一种低级API， 它相对来说较难编程， 但是它对于在GPU设备使用上提供了更多的控制。 CUDA运行时API：运行时API是一个高级API， 它在驱动API的上层实现。 每个运行时API函数都被分解为更多传给驱动API的基本运算。 一个CUDA程序包含了以下两个部分: 在CPU上运行的主机代码 在GPU上运行的设备代码 NVIDIA的CUDA nvcc编译器在编译过程中将设备代码从主机代码中分离出来. 主机代码是标准的C代码，使用C编译器进行编译。 设备代码，也就是核函数， 是用扩展的带有标记数据并行函数关键字的CUDA C语言编写的. 设备代码通过nvcc进行编译。 在链接阶段，在内核程序调用和显示GPU设备操作中添加CUDA运行时库。 ","date":"2023-07-12","objectID":"/posts/cuda_01/:1:2","tags":["CUDA"],"title":"CUDA_C_NOTES [1]","uri":"/posts/cuda_01/"},{"categories":["GPU"],"content":"1.3 用GPU输出Hello World 用专用扩展名.cu来创建一个源文件 使用CUDA nvcc编译器来编译程序 从命令行运行可执行文件， 这个文件有可在GPU上运行的内核代码。 首先， 我们编写一个C语言程序来输出“Hello World”， 如下所示 #include\u003cstdio.h\u003e int main(void) { printf(\"Hello World from CPU!\\n\")； } 把代码保存到hello.cu中， 然后使用nvcc编译器来编译。 CUDA nvcc编译器和gcc编译器及其他编译器有相似的语义 nvcc hello.cu -o hello 如果你运行可执行文件hello， 将会输出： Hello World from CPU! 接下来， 编写一个内核函数， 命名为helloFromGPU， 用它来输出字符串“Hello World from GPU！ ”。 __global__ void helloFromGPU(void) { printf(\"Hello World from GPU!\\n\"); } 修饰符__global__告诉编译器这个函数将会从CPU中调用， 然后在GPU上执行。用下面的代码启动内核函数. helloFromGPU \u003c\u003c\u003c1, 10\u003e\u003e\u003e() 三重尖括号意味着从主线程到设备端代码的调用。 一个内核函数通过一组线程来执行， 所有线程执行相同的代码。 三重尖括号里面的参数是执行配置， 用来说明使用多少线程来执行内核函数。 在这个例子中，有10个GPU线程被调用。 cudaDeviceReset()用来显式地释放和清空当前进程中与当前设备有关的所有资源。 一个典型的CUDA编程结构包括5个主要步骤: 1. 分配GPU内存 2. 从CPU内存中拷贝数据到GPU内存 3. 调用CUDA内核函数来完成程序指定的运算 4. 将数据从GPU拷回CPU内存 5. 释放GPU内存空间 ","date":"2023-07-12","objectID":"/posts/cuda_01/:1:3","tags":["CUDA"],"title":"CUDA_C_NOTES [1]","uri":"/posts/cuda_01/"},{"categories":["GPU"],"content":"1.4 使用CUDA C编程难吗 数据局部性: 指的是数据重用， 以降低内存访问的延迟 时间局部性：指在相对较短的时间段内数据或资源的重用 空间局部性：指在相对较接近的存储空间内数据元素的重用。 CUDA中有内存层次和线程层次的概念 内存层次结构 线程层次结构 CUDA核中有3个关键抽象 线程组的层次结构 内存的层次结构 障碍同步 ","date":"2023-07-12","objectID":"/posts/cuda_01/:1:4","tags":["CUDA"],"title":"CUDA_C_NOTES [1]","uri":"/posts/cuda_01/"},{"categories":["GPU"],"content":"1.5 总结 CPU + GPU的异构系统成为高性能计算的主流架构: 在GPU上执行数据并行工作， 在CPU上执行串行和任务并行的工作。 ","date":"2023-07-12","objectID":"/posts/cuda_01/:1:5","tags":["CUDA"],"title":"CUDA_C_NOTES [1]","uri":"/posts/cuda_01/"},{"categories":["C++"],"content":" quote c++ 八股文 第一部分 ","date":"2023-07-11","objectID":"/posts/basics_two/:0:0","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"6 基础知识(六) ","date":"2023-07-11","objectID":"/posts/basics_two/:1:0","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"6.1 构造函数为什么不能定义为虚函数？ ⽽析构函数⼀般写成虚函数的原因 ？ 构造函数不能声明为虚函数的原因是: 1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。 2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。 虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。（动态绑定是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本就不存在，它怎么动态绑定？） 编译器在调用基类的构造函数的时候并不知道你要构造的是一个基类的对象还是一个派生类的对象。 析构函数设为虚函数的作用: 解释：在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。（如果基类的析构函数不是虚函数，那么在delete 基类指针时，只调用基类的析构函数，不会调用派生类的析构函数，故派生类部分不会被析构。） ","date":"2023-07-11","objectID":"/posts/basics_two/:1:1","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"6.2 c/c++中register关键字（寄存器、缓存、内存） c/c++中register关键字（寄存器、缓存、内存） 一般情况下，变量的值是存储在内存中的，CPU 每次使用数据都要从内存中读取。如果有一些变量使用非常频繁，从内存中读取就会消耗很多时间，例如 for 循环中的增量控制。 为了解决这个问题，可以将使用频繁的变量放在CPU的通用寄存器中，这样使用该变量时就不必访问内存，直接从寄存器中读取，大大提高程序的运行效率。 寄存器、缓存、内存 为了加深对 register 变量的理解，这里有必要讲一下CPU寄存器。 按照与CPU的远近来分，离CPU最近的是寄存器，然后是缓存，最后是内存。 寄存器是最贴近CPU的，而且CPU只在寄存器中进行存取。寄存的意思是暂时存放数据，不用每次都从内存中读取，它是一个临时的存放数据的空间。 而寄存器的数据又来源于内存，于是 CPU \u003c– 寄存器 \u003c– 内存，这就是它们之间的信息交换。 那么为什么还需要缓存呢？因为如果频繁地操作内存中同一地址上的数据会影响速度，于是就在寄存器和内存之间设置一个缓存，把使用频繁的数据暂时保存到缓存，如果寄存器需要读取内存中同一地址上的数据，就不用大老远地再去访问内存，直接从缓存中读取即可。 缓存的速度远高于内存，价格也是如此。 注意：缓存的容量是有限的，寄存器只能从缓存中读取到部分数据，对于使用不是很频繁的数据，会绕过缓存，直接到内存中读取。所以不是每次都能从缓存中得到数据，这就是缓存的命中率，能够从缓存中读取就命中，否则就没命中。 关于缓存的命中率又是一门学问，哪些数据保留在缓存，哪些数据不保留，都有复杂的算法。 注意：上面所说的CPU是指CPU核心，从市场上购买的CPU已是封装好的套件，附带了寄存器和缓存，插到主板上就可以用。 从经济和速度的综合考虑，缓存又被分为一级缓存、二级缓存和三级缓存，它们的存取速度和价格依次降低，容量依次增加。购买到的CPU一般会标出三级缓存的容量。 register 变量 寄存器的数量是有限的，通常是把使用最频繁的变量定义为 register 的。 关于寄存器变量有以下事项需要注意： 为寄存器变量分配寄存器是动态完成的，因此，只有局部变量和形式参数才能定义为寄存器变量。 局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。 寄存器的长度一般和机器的字长一致，所以，只有较短的类型如int、char、short等才适合定义为寄存器变量，诸如double等较大的类型，不推荐将其定义为寄存器类型。 CPU的寄存器数目有限，因此，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的auto变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 register 关键字，也自动为其分配寄存器，无须由程序员来指定。 c++中register 在早期c语言编译器不会对代码进行优化，因此使用register关键字修饰变量是很好的补充，大大提高的速度。 register关键字请求让编译器将变量a直接放入寄存器里面，以提高读取速度，在C语言中register关键字修饰的变量不可以被取地址，但是c++中进行了优化。 c++中依然支持register关键字，但是c++编译器也有自己的优化方式，即某些变量不用register关键字进行修饰，编译器也会将多次连续使用的变量优化放入寄存器中，例如入for循环的循环变量i。 c++中也可以对register修饰的变量取地址，不过c++编译器发现程序中需要取register关键字修饰的变量的地址时，register关键字的声明将变得无效。 ","date":"2023-07-11","objectID":"/posts/basics_two/:1:2","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"6.3 c/c++中进程和线程的区别 c++多线程编程 – 进程与线程区别 c++面试-操作系统篇 面试必考 | 进程和线程的区别 何为进程(process)? 进程是一个应用程序被操作系统拉起来加载到内存之后从开始执行到执行结束的这样一个过程。简单来说，进程是程序（应用程序，可执行文件）的一次执行。进程通常由程序、数据和进程控制块（PCB）组成。比如双击打开一个桌面应用软件就是开启了一个进程。 传统的进程有两个基本属性：可拥有资源的独立单位；可独立调度和分配的基本单位。对于这句话我的理解是：进程可以获取操作系统分配的资源，如内存等；进程可以参与操作系统的调度，参与CPU的竞争，得到分配的时间片，获得处理机（CPU）运行。 进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，因此在系统中开启的进程数不宜过多。比如你同时打开十几个应用软件试试，电脑肯定会卡死的。于是紧接着就引入了线程的概念。 何为线程(thread)? 线程是进程中的一个实体，是被系统独立分配和调度的基本单位。也有说，线程是CPU可执行调度的最小单位。也就是说，进程本身并不能获取CPU时间，只有它的线程才可以。 引入线程之后，将传统进程的两个基本属性分开了，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。我对这句话的理解是：线程参与操作系统的调度，参与CPU的竞争，得到分配的时间片，获得处理机（CPU）运行。而进程负责获取操作系统分配的资源，如内存。 线程基本上不拥有资源，只拥有一点运行中必不可少的资源，它可与同属一个进程的其他线程共享进程所拥有的全部资源。 线程具有许多传统进程所具有的特性，故称为“轻量型进程”。同一个进程中的多个线程可以并发执行。 进程和线程的区别？ 线程分为用户级线程和内核支持线程两类，用户级线程不依赖于内核，该类线程的创建、撤销和切换都不利用系统调用来实现; 内核支持线程依赖于内核，即无论是在用户进程中的线程，还是在系统中的线程，它们的创建、撤销和切换都利用系统调用来实现。 但是，与线程不同的是，无论是系统进程还是用户进程，在进行切换时，都要依赖于内核中的进程(process)调度。因此，无论是什么进程都是与内核有关的，是在内核支持下进程切换的。尽管线程和进程表面上看起来相似，但是他们在本质上是不同的。 根据操作系统中的知识，进程至少必须有一个线程，通常将此线程称为主线程。 进程要独立地占用系统资源（如内存），而同一进程的线程之间是共享资源的。进程本身并不能获取CPU时间，只有它的线程才可以。 其他 进程在创建、撤销和切换过程中，系统的时空开销非常大。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。例如可以在一个进程中设置多个线程，当一个线程受阻时，第二个线程可以继续运行，当第二个线程受阻时，第三个线程可以继续运行……。这样，对于拥有资源的基本单位（进程），不用频繁的切换，进一步提高了系统中各种程序的并发程度。 ref: [1].https://blog.csdn.net/qq_41803340/category_10405604.html [待整理内容] ","date":"2023-07-11","objectID":"/posts/basics_two/:1:3","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"一.常考C++基础概念 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:0","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"1.C++三大特性（封装、继承、多态） 封装： 隐藏类的属性和实现细节，仅仅对外提供接口， 封装性实际上是由编译器去识别关键字public、private和protected来实现的， 体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。 私有成员是在封装体内被隐藏的部分，只有类体内声明的函数(类的成员函数)才可以访问私有成员， 而在类体外的函数是不能访问的，公有成员(public)是封装体与外界的一个接口， 类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。 优点：隔离变化；便于使用；提高重用性；提高安全性 缺点：如果封装太多，影响效率；使用者不能知道代码具体实现。 继承： 被继承的是父类（基类），继承出来的是子类（派生类），子类拥有父类的所有的特性。 继承方式有公有继承、私有继承，保护继承。默认是私有继承 *公有继承中父类的公有和保护成员在子类中不变，私有的在子类中不可访问。 *私有继承中父类的公有和保护成员在子类中变为私有，但私有的在子类中不可访问。 *保护继承中父类的公有和保护成员在子类中变为保护，但私有的在子类中不可访问。 c++语言允许单继承和多继承 优点：继承减少了重复的代码、继承是多态的前提、继承增加了类的耦合性； 缺点：继承在编译时刻就定义了，无法在运行时刻改变父类继承的实现； 父类通常至少定义了子类的部分行为，父类的改变都可能影响子类的行为； 如果继承下来的子类不适合解决新问题，父类必须重写或替换，那么这种依赖关系就限制了灵活性， 最终限制了复用性。 虚继承：为了解决多重继承中的二义性问题，它维护了一张虚基类表。 (菱形继承问题) 多态: ref: 多态的四种表现形式 运行时多态(虚函数) 编译时多态(模板) 重载 类型转换 运行时多态(Subtype Polymorphism/Runtime Polymorphism) 运行时多态就是派生类重写基类的虚函数，在调用函数里，参数为基类的指针或引用，会构成多态。我之前写过一篇多态的原理，就是在讲多态(运行时多态)在底层是怎么实现的 多态的底层实现 举个例子：比如买票这个行为，成人去买就是全价，学生买就是半价票。但是不管成人还是学生都是人这个体系。所以我们需要根据谁来买票才能决定价格，这个时候就需要多态。 #include \u003ciostream\u003e class ticket { public: virtual void price() = 0; }; class adult : public ticket { public: virtual void price() override { std::cout \u003c\u003c \"成人全价！\" \u003c\u003c std::endl; } }; class student : public ticket { public: virtual void price() override { std::cout \u003c\u003c \"学生半价！\" \u003c\u003c std::endl; } }; void BuyTicket(ticket\u0026 t) { t.price(); } int main(void) { adult a; student s; BuyTicket(a); BuyTicket(s); return 0; } 编译时多态(Parametric Polymorphism/Compile-Time Polymorphism) 编译时多态就是模板。在程序编译时，编译器根据参数的类型，就将生成某种类型的函数或类。我之前关于模板的(总结)[https://blog.csdn.net/weixin_42678507/article/details/88658291] 举个简单的例子：Add() 函数是一个非常简单的函数，但是如果你写一个整型的 Add 函数，那么我想加 double 型的呢？你再写一个 double 型的 Add 函数，那么我想加 char 型的呢？ 这个时候就用到了模板，我们先定义一个逻辑，具体类型等编译时再生成该类型的函数或类。 #include \u003ciostream\u003e template\u003cclass T\u003e T Add(T lhs, T rhs) { return lhs + rhs; } int main(void) { Add(1, 2); Add(2.0, 3.0); Add('a', 'b'); return 0; } 重载(Ad-hoc Polymorphism/Overloading) 函数名相同，参数不同就构成了重载。重载主要用于函数，当某个函数的功能无法处理某些参数的情况时，我们就可以重载一个函数来单独处理。 举个例子：比如说上面的 Add 函数，当前内置类型都可以处理，但是如果我传两个字符串怎么办？就不可以像刚才那么加了。得重载一个函数单独处理。 #include \u003ciostream\u003e #include \u003cstring\u003e int Add(int lhs, int rhs) { return lhs + rhs; } std::string Add(const std::string\u0026 lhs, const std::string\u0026 rhs) { std::string ans(lhs); ans += rhs; return ans; } int main(void) { Add(1, 2); Add(\"abc\", \"def\"); return 0; } 类型转换(Coercion Polymorphism/Casting) 类型转换主要分为四种： static_cast: 相当于隐式类型转换。 const_cast: 这个可以去除一个 const 变量的 const 性质，使可以改变它的值。 reinterpret_cast: 相当于强制类型转换。 dynamic_cast: 这个可以使子类指针或引用赋值给父类指针或引用。 类型转换很简单，这里就不多赘述了。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:1","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"2.数组和链表的区别 数组和链表是两种不同的数据存储方式 数组的定义 数组是一组具有相同数据类型的变量的集合，这些变量称之为集合的元素。 每个元素都有一个编号，称之为下标，可以通过下标来区别并访问数组元素，数组元素的个数叫做数据的长度。 链表的定义 链表是一种物理存储单元上非连续、非顺序的存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表的特性是在中间任意位置插入和删除元素都非常快，不需要移动其它元素。 对于单向链表而言，链表中的每一个元素都要保存一个指向下一个元素的指针。 对于双向链表而言，链表中的每个元素既要保存指向下一个元素的指针，又要保存指向上一个元素的指针。 对于双向循环链表而言，链表中的最后一个元素保存一个指向第一个元素的指针。 数组和链表的区别主要表现在以下几个方面 比较 数组 链表 逻辑结构 (1) 数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小； (3) 数组元素增加时，有可能会数组越界； (4) 数组元素减少时，会造成内存浪费； （5）数组增删时需要移动其它元素 (1) 链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素 (3) 需要时可以使用malloc或者new来申请内存，不用时使用free或者delete来释放内存 内存结构 数组从栈上分配内存，使用方便，但是自由度小 链表从堆上分配内存，自由度大，但是要注意内存泄漏 访问效率 数组在内存中顺序存储，可通过下标访问，访问效率高 链表访问效率低，如果想要访问某个元素，需要从头遍历 越界问题 数组的大小是固定的，所以存在访问越界的风险 越界的风险 只要可以申请得到链表空间，链表就无越界风险 数组和链表的使用场景 比较 数组使用场景 链表使用场景 空间 数组的存储空间是栈上分配的，存储密度大，当要求存储的大小变化不大时，且可以事先确定大小，宜采用数组存储数据 链表的存储空间是堆上动态申请的，当要求存储的长度变化较大时，且事先无法估量数据规模，宜采用链表存储 时间 数组访问效率高。当线性表的操作主要是进行查找，很少插入和删除时，宜采用数组结构 链表插入、删除效率高，当线性表要求频繁插入和删除时，宜采用链表结构 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:2","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"3. 智能指针 我们知道除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。 在C++中，动态内存的管理是用一对运算符完成的：new和delete，new:在动态内存中为对象分配一块空间并返回一个指向该对象的指针，delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。 动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。 为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。标准库提供的两种智能指针的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。 1 智能指针的作用 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源 2 智能指针的种类: shared_ptr、unique_ptr、weak_ptr、auto_ptr 四种指针详情 2.1 智能指针的实现原理 智能指针的实现原理就是在一个类的内部封装了类对象的指针，然后在析构函数里对我们的类对象指针进行释放，因为类的析构是在类对象生命期结束时自动调用的，这样我们就省去了手动释放内存的操作，避免忘记手动释放导致的内存泄漏。 2.2 C++11四种智能指针总结 2.2.1 auto_ptr： auto_ptr以前是用在C98中，C++11被抛弃，头文件一般用来作为独占指针 auto_ptr被赋值或者拷贝后，失去对原指针的管理 auto_ptr不能管理数组指针，因为auto_ptr的内部实现中，析构函数中删除对象使用delete而不是delete[]，释放内存的时候仅释放了数组的第一个元素的空间，会造成内存泄漏。 auto_ptr不能作为容器对象，因为STL容器中的元素经常要支持拷贝，赋值等操作。 2.2.2 unique_ptr: C++11中用来替代auto_ptr 拷贝构造和赋值运算符被禁用，不能进行拷贝构造和赋值运算 虽然禁用了拷贝构造和赋值运算符，但unique_ptr可以作为返回值，用于从某个函数中返回动态申请内存的所有权，本质上是移动拷贝，就是使用std:move()函数，将所有权转移。 2.2.3 share_ptr: 多个指针可以指向相同的对象，调用release()计数-1，计数0时资源释放 .use_count()查计数 .reset()放弃内部所有权 share_ptr多次引用同一数据会导致内存多次释放 循环引用会导致死锁， 引用计数不是原子操作。 shared_ptr 有两个数据成员，一个是指向 对象的指针 ptr，另一个是 ref_count 指针（包含vptr、use_count、weak_count、ptr等）； 在这里插入图片描述 shared_ptr\u003cFoo\u003e x(new Foo); shared_ptr\u003cFoo\u003e y = x; 步骤一： `y=x` 涉及两个成员的复制，这两步拷贝不会同时（原子）发生，中间步骤 1，复制 ptr 指针，中间步骤 2，复制 ref_count 指针，导致引用计数加 1 步骤二: 因为是两步，如果没有 mutex 保护，那么在多线程里就有数据竞争。 多线程读写同一个 shared_ptr 必须加锁。 2.2.4 weak_ptr: 1.解决两个share_ptr互相引用产生死锁，计数永远降不到0，没办法进行资源释放，造成内存泄漏的问题。 2.使用时配合share_ptr使用，把其中一个share_ptr更换为weak_ptr。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:3","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"4. 重载、重写、重定义 (1) 重载（overload）： 指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。 a 相同的范围（在同一个类中） b 函数名字相同、 参数不同 c virtual关键字可有可无 d 返回值可以不同； (2) 重写（覆盖override)是指派生类函数覆盖基类函数，特征是： a 不同的范围，分别位于基类和派生类中 b 函数的名字相同、 参数相同 c 基类函数必须有virtual关键字，不能有static d 返回值相同（或者协变），否则报错； e 重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public, protected也是可以的 (3) 重定义(隐藏redefine)是指派生类的函数屏蔽了与其同名的基类函数，特征是： a 不在同一个作用域（分别位于派生类与基类） b 函数名字相同 c 返回值可以不同 d 规则： 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏； 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。 ps: 多态性可以分为静态多态性（方法的重载，一个类）和动态多态性（方法的覆盖，有继承关系的类之间的行为）。进而多态性可以由重载和覆盖来实现。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:4","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"5.static与const区别和作用 static: 1.**static局部变量**将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完不会释放，而是继续保留在内存中； 2.**static全局变量**表示一个变量在当前文件的全局可以访问； 3.**static函数**表示一个函数只能在当前文件中被访问； 4.**static类成员变量**表示这个成员为全类所共有； 5.**static类成员函数**表示这个函数为全类所有，且只能访问成员变量。 6.全局变量在整个工程文件内有效；静态全局变量只在定义它的文件中有效； 7.静态局部变量只在定义它的函数内有效，且程序只分配一次内存，函数返回时不会释放，下次调用时不会重新赋值，还保留上次结果值；局部变量在函数返回时就释放掉； 8.全局变量和静态变量编译器会默认初始化为0；局部变量的默认值未知； 9.局部静态变量与全局变量共享全局数据，但是静态局部变量值在定义该变量的函数内部可见。 10.静态成员（静态成员函数）与非静态成员（成员函数）的区别在于有无this指针；静态成员是静态存储，必须进行初始化； 11.静态成员函数访问非静态成员报错: 静态成员在类加载时就已经分配内存，而此时非静态成员尚未分配内存，访问不存在的内存自然会报错； const 1.\u003cfont color=red\u003econst常量\u003c/font\u003e 定义时必须初始化，以后不能修改； 2.\u003cfont color=red\u003econst形参\u003c/font\u003e 该形参在函数里不能被修改； 3.\u003cfont color=red\u003econst修饰类成员函数\u003c/font\u003e 该函数对成员变量只能进行读操作； static关键字作用 1.函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此该值在下次调用时还维持上一次的值； 2.在模块内的static函数和变量可以被可以被模块内的函数访问，不能被模块外的函数访问； 3.在类内的static成员变量为整个类所有，类的所有对象只有一份拷贝； 4.在类内的static成员函数为整个类所有，这个函数不接收this指针，因此只能访问类的static成员变量； const关键字 1.阻止一个变量被改变； 2.声明常量指针和指针常量； 3.const修饰形参，表示为输入参数，在函数体内不能修改该参数的值； 4.const修饰成员函数，表明为一个常函数，不能修改成员变量的值； 5.类的成员函数，有时必须返回const类型的值，使得返回值不能为左值。 const修饰指针有三种情况 const修饰指针 — 常量指针 (const修饰的是指针,指针指向可以改,指针指向的值不可以更改) const int * p1 = \u0026a; p1 = \u0026b; //正确 //*p1 = 100; 报错 const修饰常量 — 指针常量 (const修饰的是常量,指针指向不可以改,指针指向的值可以更改) int * const p2 = \u0026a; //p2 = \u0026b; //错误 *p2 = 100; //正确 const即修饰指针,又修饰常量 (const既修饰指针又修饰常量，都不可以改) const int * const p3 = \u0026a; //p3 = \u0026b; //错误 //*p3 = 100; //错误 技巧:看const右侧紧跟着的是指针还是常量, 是指针就是常指针,是常量就是指针常量 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:5","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"6. const与宏定义（#define）区别和作用 const 定义的是变量不是常量，只是这个变量的值不允许改变，是常变量，带有类型。编译运行的时候起作用，存在类型检查。 define 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。 1、两者的区别 (1) 编译器处理方式不同 #define 宏是在预处理阶段展开。 const 常量是编译运行阶段使用。 (2) 类型和安全检查不同 #define 宏没有类型，不做任何类型检查，仅仅是展开。 const 常量有具体的类型，在编译阶段会执行类型检查。 (3) 存储方式不同 #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。） const常量会在内存中分配(可以是堆中也可以是栈中)。 (4) const 可以节省空间，避免不必要的内存分配。 例如： const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。 (5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 (6) 宏替换只作替换，不做计算，不做表达式求解;宏预编译时就替换了，程序运行时，并不分配内存。计算时注意边缘效应 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:6","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"7.虚函数和纯虚函数区别 1.虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。 2.虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。 3.虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。 4.虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。 5.虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。 6.虚函数充分体现了面向对象思想中的继承和多态性这两大特性，在C++语言里应用极广。比如在微软的MFC类库中，你会发现很多函数都有virtual关键字，也就是说，它们都是虚函数。难怪有人甚至称虚函数是C++语言的精髓。 7.定义纯虚函数就是为了让基类不可实例化，因为实例化这样的抽象数据结构本身并没有意义或者给出实现也没有意义。 纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现 虚函数: https://www.cnblogs.com/zkfopen/p/11061414.html ","date":"2023-07-11","objectID":"/posts/basics_two/:2:7","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"8. 指针和引用的区别 1.指针和引用的定义和性质区别： (1) 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如： int a=1;int *p=\u0026a; int a=1;int \u0026b=a; 上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。 而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。 (2)引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。 (3)可以有const指针，但是没有const引用； (4)指针可以有多级，但是引用只能是一级（int **p；合法 而 int \u0026\u0026a是不合法的） (5)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化； (6)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。 (7)“sizeof引用\"得到的是所指向的变量(对象)的大小，而\"sizeof指针\"得到的是指针本身的大小； (8)指针和引用的自增(++)运算意义不一样； (9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏； ","date":"2023-07-11","objectID":"/posts/basics_two/:2:8","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"9. 结构体赋值 (结构体赋值)[https://blog.csdn.net/datase/article/details/78988320] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:9","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"10. C和C++区别 (C和C++区别)[https://blog.csdn.net/czc1997/article/details/81254971] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:10","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"11. C和C++传参方式区别 C语言不支持引用传参，如果想要改变传入参数的值，只能用传入指针的方式。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:11","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"12. 深拷贝和浅拷贝区别 (深拷贝和浅拷贝区别)[https://blog.csdn.net/Situo/article/details/110225143] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:12","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"13. 避免头文件重复包含以及宏定义重定义 #ifndef LWIP_TCP_KEEPALIVE #define LWIP_TCP_KEEPALIVE #endif ","date":"2023-07-11","objectID":"/posts/basics_two/:2:13","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"14. 你怎么理解虚拟类？虚拟类可以实例化一个对象吗？为什么？它的作用和其他类的区别 答案：虚拟类可以派生对象，纯虚类不可以实例化对象。因为纯虚类存在未定义的函数，只是个概念，不可真实存在。虚拟类用做多态，纯虚类做接口。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:14","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"15. 内联函数怎么实现的，什么时期处理的，优缺点 答案：在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。 优点：不会产生函数调用的开销 缺点：增加目标程序的代码量，即增加空间开销 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:15","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"16 .位运算（按位与、按位或、异或） 按位与运算符（\u0026） 参加运算的两个数，按二进制位进行“与”运算。 运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算） 即 0 \u0026 0= 0 ，0 \u0026 1= 0，1 \u0026 0= 0， 1 \u0026 1= 1。 例：3 \u00265 即 00000011 \u0026 00000101 = 00000001 ，所以 3 \u0026 5的值为1。 按位或运算符（|） 参加运算的两个数，按二进制位进行“或”运算。 运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。 即 0 | 0= 0 , 1 | 0= 1 ， 0 | 1= 1 , 1 | 1= 1 。 例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。 异或运算符（^） 参加运算的两个数，按二进制位进行“异或”运算。 运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 即 0 ^ 0=0 ， 0 ^ 1= 1 ， 1 ^ 0= 1 ， 1 ^ 1= 0 。 例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:16","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"17. 原码、反码、补码 原码：是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。 反码：正数的反码还是等于原码 负数的反码就是他的原码除符号位外，按位取反。 补码：正数的补码等于他的原码 负数的补码等于反码+1。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:17","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"18 . 堆和栈 (堆和栈)[https://blog.csdn.net/qq_45856289/article/details/106473750] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:18","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"19. 类和对象 面向对象(Object Oriented,OO)。 起初，“面向对象”是指在程序设计中采用封装、继承、多态等设计方法。现在，面向对象的思想已经涉及到软件开发的各个方面。如，面向对象的分析（OOA，ObjectOriented Analysis），面向对象的设计（OOD，Object Oriented Design）、以及面向对象的编程实现（OOP，Object Oriented Programming）。 对象和类解释： 1）对象：对象是人们要进行研究的任何事物，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。对象具有状态，一个对象用数据值来描述它的状态。对象还有操作，用于改变对象的状态，对象及其操作就是对象的行为。对象实现了数据和操作的结合，使数据和操作封装于对象的统一体中。 2）类：具有相同特性（数据元素）和行为（功能）的对象的抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。类具有属性，它是对象的状态的抽象，用数据结构来描述类的属性。类具有操作，它是对象的行为的抽象，用操作名和实现该操作的方法来描述。 对象和类的关系： 类与对象的关系就如模具和铸件的关系，类的实力化的结果就是对象，而对对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为的对象。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:19","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"20 . new和malloc区别 0.属性 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。 1.参数 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 2.返回类型 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。 而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 3.分配失败 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 4.自定义类型 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 5.重载 C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。 6.内存区域 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:20","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"21. 内核链表与双向循环链表 (内核链表与双向循环链表)[https://blog.csdn.net/liebao_han/article/details/53956609] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:21","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"22. 结构体和类的区别 1.结构体是一种值类型，而类是引用类型。值类型用于存储数据的值，引用类型用于存储对实际数据的引用。 那么结构体就是当成值来使用的，类则通过引用来对实际数据操作。 结构体使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation) 栈的空间相对较小.但是存储在栈中的数据访问效率相对较高. 堆的空间相对较大.但是存储在堆中的数据的访问效率相对较低. 3.类是反映现实事物的一种抽象，而结构体的作用只是一种包含了具体不同类别数据的一种包装，结构体不具备类的继承多态特性 4.结构体赋值是 直接赋值的值. 而对象的指针 赋值的是对象的地址 5.Struct变量使用完之后就自动解除内存分配，Class实例有垃圾回收机制来保证内存的回收处理。 6.结构体的构造函数中，必须为结构体所有字段赋值，类的构造函数无此限制 首先,关于隐式构造函数.我们知道,在1个类中如果我们没有为类写任意的构造函数,那么C++编译器在编译的时候会自动的为这个类生成1个无参数的构造函数.我们将这个构造函数称之为隐式构造函数 但是一旦我们为这个类写了任意的1个构造函数的时候,这个隐式的构造函数就不会自动生成了.在结构体中,就不是这样了,在结构体中隐式的构造函数无论如何都存在。所以程序员不能手动的为结构添加1个无参数的构造函数。 7.结构体中声明的字段无法赋予初值，类可以: 如何选择结构体还是类 1． 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些 2． 结构表示如点、矩形和颜色这样的轻量对象，例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。 3． 在表现抽象和多级别的对象层次时，类是最好的选择 4． 大多数情况下该类型只是一些数据时，结构时最佳的选择 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:22","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"23. 结构体和联合体区别 两者最大的区别在于内存利用 一、结构体struct 各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。 二、联合体union 各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:23","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"24. 结构体和枚举 一、结构体 结构体:很像面向对象中的对象，但是结构体没有方法只有属性，一个结构体由不同类型的元素组成，而相较于数组来说，数组只能存储相同类型的元素。结构体占用的空间等于内部各元素占用空间的和，并且元素在内存中的地址（按照元素定义的顺序）是连续的。 注意：结构体不能像面向对象中那样递归调用，自己包含自己，但是可以包含其他类型的结构体。 二、枚举 枚举:和面向对象中一样，枚举都是用来定义一些固定取值的常量,但是C中的枚举中的值是整数，默认按照0递增,也可以在定义枚举的时候赋值，那么后面的元素的值就会以这个元素为第一个元素递增 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:24","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"25 . 数组和指针的区别与联系 (数组和指针的区别与联系)[https://blog.csdn.net/cherrydreamsover/article/details/81741459] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:25","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"26 . 函数指针\u0026指针函数 https://blog.csdn.net/baidu_37973494/article/details/83150266 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:26","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"27 . const放在函数前后的区别 1、int GetY() const; 2、const int * GetPosition(); 对于1 该函数为只读函数，不允许修改其中的数据成员的值。 对于2 修饰的是返回值，表示返回的是指针所指向值是常量 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:27","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"28 . goto语句 goto语句也称为无条件转移语句，其一般格式如下： goto 语句标号； 其中语句标号是按标识符规定书写的符号， 放在某一语句行的前面，标号后加冒号(：)。语句标号起标识语句的作用，与goto 语句配合使用。举个例子： goto label; cout \u003c\u003c \"This is the\" ","date":"2023-07-11","objectID":"/posts/basics_two/:2:28","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"29 . extern关键字 1、extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。也就是说，在一个文件中定义了变量和函数， 在其他文件中要使用它们， 可以有两种方式：使用头文件，然后声明它们，然后其他文件去包含头文件；在其他文件中直接extern。 2、extern C作用 链接指示符extern C 如果程序员希望调用其他程序设计语言尤其是C 写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写的，链接指示符有两种形式既可以是单一语句形式也可以是复合语句形式。 // 单一语句形式的链接指示符 extern “C” void exit(int); // 复合语句形式的链接指示符 extern “C” { int printf( const char* … ); int scanf( const char* … ); } // 复合语句形式的链接指示符 extern “C” { #include } 链接指示符的第一种形式由关键字extern 后跟一个字符串常量以及一个普通的函数，声明构成虽然函数是用另外一种语言编写的但调用它仍然需要类型检查例如编译器会检查传递给函数exit()的实参的类型是否是int 或者能够隐式地转换成int 型，多个函数声明可以用花括号包含在链接指示符复合语句中，这是链接指示符的第二种形式花扩号被用作分割符表示链接指示符应用在哪些声明上在其他意义上该花括号被忽略，所以在花括号中声明的函数名对外是可见的就好像函数是在复合语句外声明的一样，例如在前面的例子中复合语句extern “C\"表示函数printf()和scanf()是在C 语言中写的，函数因此这个声明的意义就如同printf()和scanf()是在extern “C\"复合语句外面声明的一样，当复合语句链接指示符的括号中含有#include 时，在头文件中的函数声明都被假定是用链接指示符的程序设计语言所写的，在前面的例子中在头文件中声明的函数都是C函数链接指示符不能出现在函数体中下列代码段将会导致编译错误。 int main() { // 错误: 链接指示符不能出现在函数内 extern \"C\" double sqrt( double ); 305 第七章函数 double getValue(); //ok double result = sqrt ( getValue() ); //... return 0; } 如果把链接指示符移到函数体外程序编译将无错误 extern \"C\" double sqrt( double ); int main() { double getValue(); //ok double result = sqrt ( getValue() ); //... return 0; } 但是把链接指示符放在头文件中更合适，在那里函数声明描述了函数的接口所属，如果我们希望C++函数能够为C 程序所用又该怎么办呢我们也可以使用extern \"C\"链接指示符来使C++函数为C 程序可用例如。 // 函数calc() 可以被C 程序调用 extern \"C\" double calc( double dparm ) { /* ... */ } 如果一个函数在同一文件中不只被声明一次则链接指示符可以出现在每个声明中它，也可以只出现在函数的第一次声明中，在这种情况下第二个及以后的声明都接受第一个声明中链接指示符指定的链接规则例如 // ---- myMath.h ---- extern \"C\" double calc( double ); // ---- myMath.C ---- // 在Math.h 中的calc() 的声明 #include \"myMath.h\" // 定义了extern \"C\" calc() 函数 // calc() 可以从C 程序中被调用 double calc( double dparm ) { // ... 在本节中我们只看到为C 语言提供的链接指示extern \"C\"，extern \"C\"是惟一被保证由所有C++实现都支持的，每个编译器实现都可以为其环境下常用的语言提供其他链接指示例如extern \"Ada\"可以用来声明是用Ada 语言写的函数，extern \"FORTRAN\"用来声明是用FORTRAN 语言写的函数，等等因为其他的链接指示随着具体实现的不同而不同所以建议读者查看编译器的用户指南以获得其他链接指示符的进一步信息。 总结 extern “C” extern “C” 不但具有传统的声明外部变量的功能，还具有告知C++链接器使用C函数规范来链接的功能。 还具有告知C++编译器使用C规范来命名的功能。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:29","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"30 . 动态内存管理 (动态内存管理)[https://blog.csdn.net/zgege/article/details/82054076] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:30","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"31 .数组、链表、哈希、队列、栈数据结构特点，各自优点和缺点 数组(Array)： 优点：查询快，通过索引直接查找；有序添加，添加速度快，允许重复； 缺点：在中间部位添加、删除比较复杂，大小固定，只能存储一种类型的数据； 如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。 链表(LinkedList)： 优点：有序添加、增删改速度快，对于链表数据结构，增加和删除只要修改元素中的指针就可以了； 缺点：查询慢，如果要访问链表中一个元素，就需要从第一个元素开始查找； 如果应用需要经常插入和删除元素，就应该用链表。 栈(Stack)： 优点：提供后进先出的存储方式，添加速度快，允许重复； 缺点：只能在一头操作数据，存取其他项很慢； 队列(Queue)： 优点：提供先进先出的存储方式，添加速度快，允许重复； 缺点：只能在一头添加，另一头获取，存取其他项很慢； 哈希(Hash)： 特点：散列表，不允许重复； 优点：如果关键字已知则存取速度极快； 缺点：如果不知道关键字则存取很慢，对存储空间使用不充分； ","date":"2023-07-11","objectID":"/posts/basics_two/:2:31","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"32. 友元函数 引入友元函数的原因 类具有封装、继承、多态、信息隐藏的特性，只有类的成员函数才可以访问类的私有成员，非成员函数只能访问类的公有成员。为了使类的非成员函数访问类的成员，唯一的做法就是将成员定义为public，但这样做会破坏信息隐藏的特性。基于以上原因，引入友元函数解决。 (友元函数)[https://blog.csdn.net/qq_26337701/article/details/53996104] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:32","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"33. 设计模式之单例模式、工厂模式、发布订阅模式以及观察者模式 (设计模式)[https://blog.csdn.net/m0_37322399/article/details/108515158] ","date":"2023-07-11","objectID":"/posts/basics_two/:2:33","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"34. 构造函数： 什么是构造函数？ 通俗的讲，在类中，函数名和类名相同的函数称为构造函数。它的作用是在建立一个对象时，做某些初始化的工作（例如对数据赋予初值）。C++允许同名函数，也就允许在一个类中有多个构造函数。如果一个都没有，编译器将为该类产生一个默认的构造函数。 构造函数上惟一的语法限制是它不能指定返回类型，甚至void 也不行。 不带参数的构造函数：一般形式为 类名 对象名(){函数体} 带参数的构造函数：不带参数的构造函数，只能以固定不变的值初始化对象。带参数构造函数的初始化要灵活的多，通过传递给构造函数的参数，可以赋予对象不同的初始值。一般形式为：构造函数名（形参表）； 创建对象使用时：类名 对象名（实参表）； 构造函数参数的初始值：构造函数的参数可以有缺省值。当定义对象时，如果不给出参数，就自动把相应的缺省参数值赋给对象。一般形式为： 构造函数名（参数=缺省值，参数=缺省值，……）; 析构函数： 当一个类的对象离开作用域时，析构函数将被调用(系统自动调用)。析构函数的名字和类名一样，不过要在前面加上 ~ 。对一个类来说，只能允许一个析构函数，析构函数不能有参数，并且也没有返回值。析构函数的作用是完成一个清理工作，如释放从堆中分配的内存。 一个类中可以有多个构造函数，但析构函数只能有一个。对象被析构的顺序，与其建立时的顺序相反，即后构造的对象先析构。 1、概念不同： 析构函数：对象所在的函数已调用完毕时，系统自动执行析构函数。 构造函数：是一种特殊的方法。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。 2、作用不同： 析构函数：析构函数被调用。 构造函数：为对象成员变量赋初始值 3、目的不同： 析构函数：”清理善后” 的工作 构造函数：主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:34","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"35. C++模板 https://blog.csdn.net/zhaizhaizhaiaaa/article/details/104091658 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:35","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"36. C++ STL https://www.cnblogs.com/shiyangxt/archive/2008/09/11/1289493.html ref: https://blog.csdn.net/qq_52621551/article/details/122960158 ","date":"2023-07-11","objectID":"/posts/basics_two/:2:36","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"c++ 八股文 ","date":"2023-07-11","objectID":"/posts/basics_two/:3:0","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":"关键字与运算符 1. 指针与引⽤ 指针：存放某个对象的地址，其本⾝就是变量（命了名的对象），本⾝就有地址，所以可以有指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变 (地址可变，地址存储的值也可变) 引⽤：就是变量的别名，从⼀⽽终，不可变，必须初始化， 不存在指向空值的引⽤，但是存在指向空值的指针 2. const 关键字 const的作⽤：被它修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。 顶层const: 表示指针本身是个常量 底层const: 表示指针所指的对象是一个常量 2.1 常量指针（底层const）（指针指的对象不可改变） 常量指针：是指定义了⼀个指针，这个指针指向⼀个只读的对象，不能通过常量指针来改变这个对象的值。常量指针强调的是指针对其所指对象的不可改变性。 特点：靠近变量名 形式: const 数据类型 *指针变量 = 变量名 数据类型 const *指针变量 = 变量名 举例: int temp = 10; const int* a = \u0026temp; int const *a = \u0026temp; 2.2 指针常量（顶层const）(指针不能改变) 指针常量：指针常量是指定义了⼀个指针，这个指针的值只能在定义时初始化，其他地⽅不能改变。指针常量强调的是指针的不可改变性。 特点: 靠近变量类型 形式: 数据类型 * const 指针变量=变量名 实例: int* const p = \u0026temp 3. define 和 typedef的区别 ref : https://blog.csdn.net/CSSDCC/article/details/122049204 ref : https://zhuanlan.zhihu.com/p/513450251 ","date":"2023-07-11","objectID":"/posts/basics_two/:3:1","tags":["basics"],"title":"C++ 基础知识[二]","uri":"/posts/basics_two/"},{"categories":["C++"],"content":" quote c++ 八股文 第一部分 ","date":"2023-07-11","objectID":"/posts/basics_one/:0:0","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1. 基础知识（一） ","date":"2023-07-11","objectID":"/posts/basics_one/:1:0","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.1 C++语言的特点 ①C++在C的基础上引入了面向对象机制，同时也兼容C语言； ②C++三大特性：封装、继承、多态； ③C++程序结构清晰、易于扩充、程序可读性好； ④C++代码质量高，运行效率高、仅比汇编语言慢10%~20%； ⑥C++可复用性高，C++引入了模板的概念，有专门的模板库(STL)； ⑦C++是不断发展的语言，C++11中新引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。 C++面向对象的三大特征 封装性： 将客观事物抽象成类，每个类对自身的数据和方法实行访问控制，包括（private，protected，public）。 继承性： 广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法，实现滞后到子类实现)。 多态性： 是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:1","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.2 C++和C语言的区别 ① C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等； ② C++是面对对象(object-oriented)的编程语言；C语言是面对过程(process-oriented)的编程语言； ③ C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等； ④ C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:2","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.3 C++中 struct 和 class 的区别 ① struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装； ② struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的； ③ 在继承关系中，struct 默认是公有继承，而 class 是私有继承； ④ class关键字可以用于定义模板参数，就像typename，而 struct 不能用于定义模板参数。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:3","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.4 include头文件的顺序以及双引号\"“和尖括号\u003c\u003e的区别 区别： ① 尖括号\u003c \u003e的头文件是系统文件，双引号\" \"的头文件是自定义文件； ② 编译器预处理阶段查找头文件的路径不一样； 查找路径： ① 使用尖括号\u003c \u003e(系统文件)的头文件的查找路径：编译器设置的头文件路径–\u003e系统变量; ② 使用双引号\" \"(自定义文件)的头文件的查找路径：当前头文件目录–\u003e编译器设置的头文件路径–\u003e系统变量。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:4","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.5 C++结构体和C结构体的区别 ①C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数； ②C的结构体对内部成员变量的访问权限只能是public，而C++允许public，protected，private三种； ③C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用； ④C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:5","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.6 导入C函数的关键字是什么，C++编译时和C有什么不同？ 关键字： 在C++中，导入C函数的关键字是extern，表达形式为extern \"C\"， extern \"C\" 的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \"C\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。 编译区别： 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 总结: 区别在于在编译过程中是否带上函数的参数类型，c++带，c不带。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:6","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.7 简述C++从代码到可执行二进制文件的过程 预编译、编译、汇编、链接 ①预编译：这个过程主要的处理操作如下： （1） 将所有的#define删除，并且展开所有的宏定义 （2） 处理所有的条件预编译指令，如#if、#ifdef （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。 （4） 过滤所有的注释 （5） 添加行号和文件名标识 ②编译：这个过程主要的处理操作如下： （1） 词法分析：将源代码的字符序列分割成一系列的记号。 （2） 语法分析：对记号进行语法分析，产生语法树。 （3） 语义分析：判断表达式是否有意义。 （4） 代码优化： （5） 目标代码生成：生成汇编代码。 （6） 目标代码优化 ③汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。 ④链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。 ​ 链接分为静态链接和动态链接。 ​ (1) 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你再去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。 ​ (2) 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:7","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.8 static关键字的作用 ①定义全局静态变量和局部静态变量：在变量前面加上static关键字。static的变量默认初始化为0。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量(在整个工程文件有效)和局部静态变量(在当前定义的文件内有效)的作用域不一样； ②定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；static int func() ③在变量类型前加上static关键字，变量即被定义为静态变量。静态变量只能在本源文件中使用； ④类内静态成员变量: 在c++中，static关键字可以用于定义类中的静态成员变量：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间，static修饰的变量要在类外初始化。 ⑤类内静态成员函数:在c++中，static关键字可以用于定义类中的静态成员函数：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间，只能访问类的static成员变量，static修饰的变量要在类外初始化。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:8","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.9 数组和指针的区别 概念： (1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址。 (2）指针：指针相当于一个变量，但是它和一般变量不一样，它存放的是其它变量在内存中的地址。指针名指向了内存的首地址。 区别： 赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝； 存储方式： 数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。 指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:9","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.10 什么是函数指针，如何定义函数指针，有什么使用场景 概念： 函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该函数入口地址就是函数指针所指向的地址。 定义形式： int func(int a); int (*f)(int a); f = \u0026func; 使用场景： 回调（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。 //以库函数qsort排序函数为例，它的原型如下： void qsort(void *base,//void*类型，代表原始数组 size_t nmemb, //第二个是size_t类型，代表数据数量 size_t size, //第三个是size_t类型，代表单个数据占用空间大小 int(*compar)(const void *,const void *)//第四个参数是函数指针 ); //第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。 //示例 int num[100]; int cmp_int(const void* _a , const void* _b){//参数格式固定 int* a = (int*)_a; //强制类型转换 int* b = (int*)_b; return *a - *b;　} qsort(num,100,sizeof(num[0]),cmp_int); //回调 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:10","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.11 静态变量什么时候初始化 对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。 而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:11","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.12 nullptr调用成员函数可以吗？为什么？ 可以。因为在编译时对象就绑定了函数地址，和指针空不空没关系。 //给出实例 class animal { public: void sleep() { cout \u003c\u003c \"animal sleep\" \u003c\u003c endl; } void breathe() { cout \u003c\u003c \"animal breathe haha\" \u003c\u003c endl; } }; class fish :public animal { public: void breathe(){ cout \u003c\u003c \"fish bubble\" \u003c\u003c endl; } }; int main() { animal *pAn=nullptr; //类指针 pAn-\u003ebreathe(); // 输出：animal breathe haha fish *pFish = nullptr; pFish-\u003ebreathe(); // 输出：fish bubble return 0; } // 原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。 // pAn-\u003ebreathe();编译的时候，函数的地址就和指针pAn绑定了； // 调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错， // 但是若用到this，因为this=nullptr，运行出错。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:12","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.13 什么是野指针，怎么产生的，如何避免？ 概念： 野指针就是指针指向的位置是不可知的(随机的、不正确的、没有明确限制的)； 产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。(内存泄露) 避免办法： （1）初始化置NULL （2）申请内存后判空 （3）指针释放后置NULL （4）使用智能指针 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:13","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.14 静态局部变量，全局变量，局部变量的特点，以及使用场景 ①首先从作用域考虑： C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。 局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。 ②从所在空间考虑：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。 ③生命周期： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。 ④使用场景：从它们各自特点就可以看出各自的应用场景，不再赘述。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:14","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.15 C++继承 ①公有继承public：基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。 ②私有继承private：私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。 ③保护继承protect：保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:15","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.16 常量指针和指针常量 常量指针: 内存里的值不变 指针常量: 指针指向的内存地址不变 1. const int a; //指的是a是一个常量，不允许修改。 2. const int *a; //a指针所指向的内存里的值不变，即（*a）不变 常量指针 3. int const *a; //同const int *a; 4. int *const a; //a指针所指向的内存地址不变，即a不变 指针常量 5. const int *const a; //都不变，即（*a）不变，a也不变 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:16","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.17 内联函数和函数的区别 ①内联函数比普通函数多了关键字inline； ②内联函数避免了函数调用的开销；普通函数有调用的开销； ③普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。 ④内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句(内联函数内不允许用循环语句和开关语句。普通函数没有这个要求。 ","date":"2023-07-11","objectID":"/posts/basics_one/:1:17","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.18 简述C++有几种传值方式，之间的区别是什么？ 值传递、引用传递、指针传递 ①值传递：形参即使在函数体内值发生变化，也不会影响实参的值； ②引用传递：形参在函数体内值发生变化，会影响实参的值； ③指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值； ","date":"2023-07-11","objectID":"/posts/basics_one/:1:18","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.19 内联函数和宏函数的区别 宏常量\u0026宏函数 定义: // a. 定义一个宏常量 #define MAX 1024 // 宏常量 MAX称为符号常量 // b. 定义一个宏函数 // 宏函数:宏函数就是使用宏定义定义出来的函数,并不是真正意义上的函数。 #define GETSUM(x, y) ((x) + (y)) // 宏函数 使用宏函数的注意事项: 要保证运算的完整性； 宏函数的使用场景:频繁调用和短小的函数,封装成宏函数； 使用宏函数的优点:以空间换时间； 宏定义和函数的区别: 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数； 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值； 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型； 宏定义不要在最后加分号； 宏定义和typedef的区别: 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名； 宏替换发生在预编译阶段，属于文本插入替换；typedef是编译的一部分； 宏不检查类型；typedef会检查数据类型； 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束； 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大； 宏函数和内联函数的区别: 1.在使用时，宏只做简单字符串替换（编译前或者预编译阶段）。而内联函数可以进行参数类型检查（编译时），且具有返回值； 2.内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载； 3.宏定义时要注意书写（参数要括起来）否则容易出现歧义(保证运算的完整性)，内联函数不会产生歧义； 4.内联函数有类型检测、语法判断等功能，而宏没有； define宏定义和const的区别: 处理阶段：define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用； 安全性： define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错； const常量有数据类型，编译器可以对其进行类型安全检查； 内存占用： define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表； 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间； ","date":"2023-07-11","objectID":"/posts/basics_one/:1:19","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"1.20 四种cast类型转换 作用：克服c语言中强制类型转化带来的风险，C++引入四种更加安全的强制类型转换运算符（明确转换的目的，便于程序的维护和分析） const_cast：去除const属性 // 1.去除const属性，将只读变为只读写 // 2.针对常量指针、常量引用和常量对象 const char *p; char *p1 = const_cast\u003cchar*\u003e(p); static_cast: 内置数据类型、基类-派生类之间的转换 内置数据类型之间的转换，int转double，char转int 基类指针与派生类之间的转换，只能转换有继承或派生关系的类。用于类层次结构之间基类和派生类指针和引用之间的转换，进行向上转型是安全的，但是进行向下转型是不安全的，但是是可以转换的; 向上转型(向基类转换 -\u003e 安全)：我们知道基类的引用和指针都可以指向派生类的对象，那么将派生类的指针或者引用强转为基类的指针或者引用，那么这就是向上转型，也就是向父类转; 向下转型(向派生类转换 -\u003e 不安全)：向下转型就和向上转型相反，它是将父类的指针或者引用，强制转换为子类的指针或者引用 把void类型指针转换为目标类型的指针 任何类型的表达式转化为void类型 // 整形转浮点型 int a = 10; double b = static_cast\u003cdouble\u003ea; //基类指针转派生类 class A{}; class B : public A{}; A *pA = new A; B *pB = static_cast\u003cB*\u003e(pA); reinterpret_cast: 可以将一个类型的指针转换为其它任意类型的指针，也可以用在指针和整形数据之间的转换。它是很危险的，如果我们没有使用它的充分理由，那么就不要使用它 为运算对象的位模式提供较低层次上的重新解释 用于底层的强制转换，依赖于机器，一般使用较少 dynamic_cast: 运行时处理；基类向派生类转换时比static_cast更安全 dynamic_cast是运行时处理的，运行时进行类型检查，其他三种是编译时处理的 不能用于内置数据类型之间的转换 dynamic_cast在进行上行转换时和static_cast效果是一样的，但是进行下行转换时会进行类型检查，比static_cast更加安全，下行转换是否成功取决于转换对象的实际类型与目标类型是否相同 要求基类必须具有虚函数，否则编译不通过 若转换成功，返回的是指向目标的指针或引用，不成功返回NULL ","date":"2023-07-11","objectID":"/posts/basics_one/:1:20","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2. 基础知识（二） ","date":"2023-07-11","objectID":"/posts/basics_one/:2:0","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.1 写出 int 、bool、 float 、指针变量与 “零值”比较的if 语句 //int与零值比较 if ( n == 0 ) if ( n != 0 ) //bool与零值比较 if (flag) // 表示flag为真 if (!flag) // 表示flag为假 //float与零值比较 const float EPSINON = 0.00001; if ((x \u003e= - EPSINON) \u0026\u0026 (x \u003c= EPSINON) //其中EPSINON是允许的误差（即精度）。 //指针变量与零值比较 if (p == nullptr) if (p != nullptr) ","date":"2023-07-11","objectID":"/posts/basics_one/:2:1","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.2 变量的声明和定义有什么区别 ① 变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。 ② 一个变量可以在多个地方声明， 但是只在一个地方定义。声明多次，定义一次。 ③ 加入extern 修饰的是变量的声明，说明此变量将在文件外部或在文件后面部分定义。 ④ 说明：很多时候一个变量，只是声明，不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。 int main() { extern int A; //这是个声明而不是定义，声明A是一个已经定义了的外部变量 //注意：声明外部变量时可以把变量类型去掉如：extern A; dosth(); //执行函数 } int A; //是定义，定义了A为整型的外部变量 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:2","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.3 简述 #ifdef、#else、#endif和#ifndef的作用 利用 #ifdef、#endif 将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。 #ifdef MATH #include “math.c” #endif //在子程序前加上标记，以便于追踪和调试。 #ifdef DEBUG printf (“Indebugging…!”); #endif 应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。 注意：虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长（因为在程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:3","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.4 结构体可以直接赋值吗? ①结构体声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。 ②注意：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:4","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.5 sizeof 和strlen 的区别 ①sizeof是一个操作符，strlen是库函数。 ②sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\\0’的字符串作参数。 ③编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。 ④数组做sizeof的参数不退化，传递给strlen就退化为指针了 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:5","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.6 sizeof求类型大小 ref: https://www.cnblogs.com/maji233/p/11439880.html ①类的大小为类的非静态成员数据的类型大小之和，也就是说静态成员数据不作考虑。 普通成员函数与sizeof无关。 ②虚函数由于要维护虚函数表，所以要占据一个指针大小，也就是4字节。 类的总大小也遵守类似class字节对齐的，调整规则。 ref: (32 位) 指针都是 4个字节 char 1个字节 short 两个字节 int 4个字节 long 4个字节 long int 4个字节 float 4个字节 double 8个字节 long double 8个字节 (64 字节) 指针都是一个字长, 8个字节 char 1个字节 short 2个字节 int 4个字节 long 8个字节 long int 8个字节 double 8个字节 long double 也可以变长了, 16个字节 例如有如下结构体： struct Stu //自定义的数据类型，允许用户存储不同的数据类型 { int id; char sex; float hight; }; 那么一个这样的结构体变量占多大内存呢？也就是 cout\u003c\u003csizeof(Stu)\u003c\u003cendl; 会输出什么？ 在了解字节对齐方式之前想当然的会以为：sizeof(Stu) = sizeof(int)+sizeof(char)+sizeof(float) = 9. 然而事实并非如此！ 字节对齐原则: 在系统默认的对齐方式下：每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，且最终占用字节数为成员类型中最大占用字节数的整数倍。 在这个例子中，id的偏移量为0（0=40），sex的偏移量为4（4=14），hight的偏移量为8（8=24），此时占用12字节，也同时满足12=34.所以sizeof(Stu)=12. 总结： ①最终大小一定是最大数据类型的整数倍； ②静态变量不占空间 ③每种类型的偏移量为自身的n倍； 详细请查阅：struct/class等内存字节对齐问题详解 ref: struct地址偏移量计算 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:6","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.7 C 语言的关键字 static 和 C++ 的关键字 static 有什么区别 ①在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。 ②注意：编程时 static 的记忆性和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:7","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.8 Ｃ 语言的 malloc 和 Ｃ＋＋ 中的 new 有什么区别 ①new 、delete 是操作符，可以重载，只能在C++ 中使用。 ②malloc、free 是函数，可以覆盖，C、C++ 中都可以使用。 ③new 可以调用对象的构造函数，对应的delete 调用相应的析构函数。 ④malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数。 ⑤new 、delete 返回的是某种数据类型指针，malloc、free 返回的是void 指针。 注意：malloc 申请的内存空间要用free 释放，而new 申请的内存空间要用delete 释放，不要混用。 2.11 new 和 malloc的区别 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:8","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.9 写一个 “标准” 宏MIN #define min(a,b) ((a)\u003c=(b)?(a):(b)) ","date":"2023-07-11","objectID":"/posts/basics_one/:2:9","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.10 ++i和i++的区别 ++i先自增1，再返回；i++先返回i,再自增1 前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:10","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.11 new和malloc的区别，各自底层实现原理 (delete 和 free类似) ①new是操作符，而malloc是函数。 ②new在调用的时候先分配内存，再调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。 ③malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。 ④new可以被重载；malloc不行 ⑤new分配内存更直接和安全。 ⑥new发生错误抛出异常，malloc返回null ","date":"2023-07-11","objectID":"/posts/basics_one/:2:11","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.12 const 和 define 的区别 区别 （1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。 （2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 （3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。 （4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。 const优点： （1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 （2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。 （3）const可节省空间，避免不必要的内存分配，提高效率 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:12","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.13 C++中函数指针和指针函数的区别 定义不同 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。 写法不同 指针函数：int *fun(int x, int y); 函数指针：int (*fun)(int x, int y); 用法不同 //指针函数示例 typedef struct _Data{ int a; int b; }Data; //指针函数 Data* f(int a,int b){ Data * data = new Data; //... return data; } int main(){ //调用指针函数 Data * myData = f(4,5); //Data * myData = static_cast\u003cData*\u003e(f(4,5)); //... } //函数指针示例 int add(int x,int y){ return x+y; } //函数指针 int (*fun)(int x,int y); //赋值 fun = add; //调用 cout \u003c\u003c \"(*fun)(1,2) = \" \u003c\u003c (*fun)(1,2) ; //输出结果 //(*fun)(1,2) = 3 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:13","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.14 使用指针需要注意什么？ ①定义指针时，先初始化为NULL。 ②用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。 ③不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 ④避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作。 ⑤动态内存的申请与释放必须配对，防止内存泄漏。 ⑥用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:14","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.15 volatile有什么作用 ①volatile为状态寄存器一类的并行设备硬件寄存器。 ②一个中断服务子程序会访问到的非自动变量。 ③多线程间被几个任务共享的变量。 注意：虽然volatile在嵌入式方面应用比较多，但是在PC软件的多线程中，volatile修饰的临界变量也是非常实用的。 C++中volatile的作用: 总结: 建议编译器不要对该变量进行优化 volatile是“易变/不稳定”的意思。volatile是C的一个较为少用的关键字，解决变量在“共享”环境下容易出现读取错误的问题。 定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确地处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。 在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。 而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。如下程序对这一现象进行了模拟。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:15","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.16 一个参数可以既是const又是volatile吗 可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。 注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:16","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.17 a 和\u0026a 有什么区别 \u003c1\u003e \u0026a：其含义就是“变量a的地址”。 \u003c2\u003e *a：用在不同的地方，含义也不一样。 ①在声明语句中，*a只说明a是一个指针变量，如int *a； ②在其他语句中，*a前面没有操作数且a是一个指针时，*a代表指针a指向的地址内存放的数据(解引用)，如b=*a； ③*a前面有操作数且a是一个普通变量时，a代表乘以a，如c=ba ","date":"2023-07-11","objectID":"/posts/basics_one/:2:17","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.18 用C 编写一个死循环程序 while(1) { } 注意：很多种途径都可实现同一种功能，但是不同的方法时间和空间占用度不同，特别是对于嵌入式软件，处理器速度比较慢，存储空间较小，所以时间和空间优势是选择各种方法的首要考虑条件。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:18","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.19 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？ ①全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）； ②而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。 ③操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:19","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"2.20 结构体内存对齐问题 请写出以下代码的输出结果： #include \u003cstdio.h\u003e using namespace std; /************************************************************** * 结构体内存对⻬问题 * 从偏移为0的位置开始存储； * 如果没有定义 #pragma pack(n) * sizeof 的最终结果必然是结构内部最⼤成员的整数倍，不够补⻬； * 结构内部各个成员的⾸地址必然是⾃身⼤⼩的整数倍； * ***************************************************************/ struct S1 { int i ; //起始偏移0，sizeof(i)=4; 地址0、1、2、3分配给成员i char j ; //起始偏移4，sizeof(j)=1; int a ; //sizeof(a)=4,内存对齐到8个字节，从偏移量为8处存放a; double b;//sizeof(b)=8,内存对齐到16个字节，再存放b,结构体总大小24; }; //结构体成员的首地址必须是自身大小的整数倍 struct S3 { char j;//起始偏移0，sizeof(j)=1; float i;//sizeof(i)=4，内存对齐到4，起始偏移量为4,再存放i double b;//当前地址为8，是b大小的整数倍，无需对齐，直接存放成员b 8个字节 int a;//sizeof(a)=4,内存对齐到20，再存放a,总大小24字节； }; int main() { printf(\"%d\\n\", sizeof(S1)); printf(\"%d\\n\", sizeof(S3)); return 0; } 输出: 24 24 说明： ①结构体作为一种复合数据类型，其构成元素既可以是基本数据类型的变量，也可以是一些复合型类型数据。对此，编译器会自动进行成员变量的对齐以提高运算效率。 ②默认情况下，按自然对齐条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同，向结构体成员中size最大的成员对齐。 ③许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，而这个k则被称为该数据类型的对齐模数。 ","date":"2023-07-11","objectID":"/posts/basics_one/:2:20","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3 基础知识（三） ","date":"2023-07-11","objectID":"/posts/basics_one/:3:0","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.1 简述C、C++程序编译的内存分配情况 ①从静态存储区域分配： 内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错， 因为有系统会善后。例如全局变量，static 变量，常量字符串等。 ②在栈上分配： 在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。大小为2M。 ③从堆上分配： 即动态内存分配。程序在运行的时候用 malloc 或new 申请任意大小的内存，程序员自己负责在何 时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生 堆内碎块。 一个C、C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:1","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.2 简述strcpy、sprintf 与memcpy 的区别 ①操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。 ②执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。 ③实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。 注意：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:2","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"请解析((void ()( ) )0)( )的含义 void (0)( ) ：是一个返回值为void，参数为空的函数指针0。 (void ()( ))0：把0转变成一个返回值为void，参数为空的函数指针。 ((void ()( ))0()：在上句的基础上加表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。 ((void (*)( ))0)( )：这就是上句的函数名所对应的函数的调用。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:3","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.4 typedef 和define 有什么区别 ①用法不同： typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。 ②执行时间不同： typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。 ③作用域不同： typedef 有作用域限定：define 不受作用域约束，只要在define 声明后的引用都是正确的。 ④对指针的操作不同： typedef 和define 定义的指针时有很大的区别。 注意：typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:4","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.5 指针常量与常量指针区别 指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。 常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。 指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。 注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:5","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.6 简述队列和栈的异同 队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是 “后进先出”。 注意：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS 回收。分配方式类似于链表。 它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:6","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.7 设置地址为0x67a9 的整型变量的值为0xaa66 int *ptr; ptr = (int *)0x67a9; *ptr = 0xaa66; 注意：这道题就是强制类型转换的典型例子，无论在什么平台，地址长度和整型数据的长度是一样的， 即一个整型数据可以强制转换成地址指针类型，只要有意义即可。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:7","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.8 编码实现字符串转化为数字 编码实现函数atoi()，设计一个程序，把一个字符串转化为一个整型数值。例如数字：“5486321 ”， 转化成字符：5486321。 int myAtoi(const char * str) { int num = 0; //保存转换后的数值 int isNegative = 0; //记录字符串中是否有负号 int n =0; char *p = str; if(p == NULL) //判断指针的合法性 { return -1; } while(*p++ != '\\0') //计算数字符串度 { n++; } p = str; if(p[0] == '-') //判断数组是否有负号 { isNegative = 1; } char temp = '0'; for(int i = 0 ; i \u003c n; i++) { char temp = *p++; if(temp \u003e '9' ||temp \u003c '0') //滤除非数字字符 { continue; } if(num !=0 || temp != '0') //滤除字符串开始的0 字符 { temp -= 0x30; //将数字字符转换为数值 num += temp *int( pow(10 , n - 1 -i) ); } } if(isNegative) //如果字符串中有负号，将数值取反 { return (0 - num); } else { return num; //返回转换后的数值 } } ","date":"2023-07-11","objectID":"/posts/basics_one/:3:8","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.9 C语言的结构体(struct)和C++的类(class)有什么区别 ①C语言的结构体是不能有成员函数的，而C++的类可以有。 ②C语言的结构体中数据成员是没有private、public和protected访问限定的。而C++的类的成员有这些访问权限限定。 ③C语言的结构体是没有继承关系的，而C++的类却有丰富的继承关系。 注意：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:9","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.10 简述指针常量与常量指针的区别 ①指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。指针常量的值只能在定义时初始化，常量指针指向一个只读的对象 ②指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。 注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:10","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.11 如何避免“野指针” ①指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。 ②指针p被free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。 ③指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:11","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.12 句柄和指针的区别和联系是什么？ 句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32bit的uint。指针则标记某个物理内存地址，两者是不同的概念。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:12","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.13 new/delete与malloc/free的区别是什么 new能自动计算需要分配的内存空间，而malloc需要手工计算字节数。 int *p = new int[2]; int *q = (int )malloc(2sizeof(int)); ①new与delete直接带具体类型的指针，malloc和free返回void类型的指针。 ②new类型是安全的，而malloc不是。例如int *p = new float[2];就会报错；而int p = malloc(2sizeof(int))编译时编译器就无法指出错误来。 ③new一般分为两步：new操作和构造。new操作对应与malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。 ④new调用构造函数，malloc不能；delete调用析构函数，而free不能。 ⑤malloc/free需要库文件stdlib.h的支持，new/delete则不需要！ 注意：delete和free被调用后，内存不会立即回收，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该讲该指针指向NULL。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:13","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.14 说一说extern“C” extern “C\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C\"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C\"就是其中的一个策略。 C++代码调用C语言代码在C++的头文件中使用在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:14","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.15 请你来说一下C++中struct和class的区别 在C++中，class和struct做类型定义是只有两点区别： ①默认继承权限不同，class继承默认是private继承，而struct默认是public继承 ②class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数 ③C++保留struct关键字，原因：保证与C语言的向下兼容性，C++必须提供一个struct ④C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制 ⑤对struct定义的扩展使C语言的代码能够更容易的被移植到C++中 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:15","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.16 C++类内可以定义引用数据成员吗？ 可以，必须通过成员函数初始化列表初始化。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:16","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.17 C++中类成员的访问权限 ①C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。 ②在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。 ③在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:17","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.18 什么是右值引用，跟左值又有什么区别？ 左值和右值的概念： ①左值： 能取地址，或者具名对象，表达式结束后依然存在的持久对象； 右值：不能取地址，匿名对象，表达式结束后就不再存在的临时对象； ②区别： 左值能寻址，右值不能； 左值能赋值，右值不能； 左值可变，右值不能（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）； ","date":"2023-07-11","objectID":"/posts/basics_one/:3:18","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.19 面向对象的三大特征 封装性：将客观事物抽象成类，每个类对自身的数据和方法实行 protection （private ， protected ， public ）。 继承性：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。 多态性：是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:19","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"3.20 C++的空类有哪些成员函数 C++空类成员函数： 缺省构造函数。 缺省拷贝构造函数。 缺省析构函数。 缺省赋值运算符。 缺省取址运算符。 缺省取址运算符 const 。 注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些空类成员函数的时候，编译器才会去定义它们。 ","date":"2023-07-11","objectID":"/posts/basics_one/:3:20","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4. 基础知识（四） ","date":"2023-07-11","objectID":"/posts/basics_one/:4:0","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.1 说一说c++中四种cast转换 C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast 1、const_cast 用于将const变量转为非const 2、static_cast 用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知； 3、dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。 向上转换：指的是子类向基类的转换 向下转换：指的是基类向子类的转换 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。 4、reinterpret_cast 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； 5、为什么不使用C的强制转换？ C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:1","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.2 对c++中的smart pointer四个智能指针的理解：shared_ptr,unique_ptr,weak_ptr,auto_ptr ①C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被C++11弃用。 ②智能指针的作用是管理一个指针，因为存在以下这种情况： 申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。 ③auto_ptr（c++98的方案，cpp11已经抛弃） 采用所有权模式。 unique_ptr p3 (new string (“auto”)); //#4 unique_ptr p4； //#5 p4 = p3;//此时会报错！！ 编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如： unique_ptr pu1(new string (“hello world”)); unique_ptr pu2; pu2 = pu1; // #1 not allowed unique_ptr pu3; pu3 = unique_ptr(new string (“You”)); // #2 allowed 其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。 注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如： unique_ptr ps1, ps2; ps1 = demo(“hello”); ps2 = move(ps1); ps1 = demo(“alexia”); cout \u003c\u003c *ps2 \u003c\u003c *ps1 \u003c\u003c endl; shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。 shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。 成员函数： use_count 返回引用计数的个数 unique 返回是否是独占所有权( use_count 为 1) swap 交换两个 shared_ptr 对象(即交换所拥有的对象) reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptrsp(new int(1)); sp 与 sp.get()是等价的 weak_ptr: weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。 weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。 weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。 class B; class A { public: shared_ptr\u003cB\u003e pb_; ~A(){ cout\u003c\u003c\"A delete\"; } }; class B { public: shared_ptr\u003cA\u003e pa_; ~B(){ cout\u003c\u003c\"B delete\"; } }; void fun() { shared_ptr\u003cB\u003e pb(new B()); shared_ptr\u003cA\u003e pa(new A()); pb-\u003epa_ = pa; pa-\u003epb_ = pb; cout \u003c\u003c pb.use_count() \u003c\u003c endl; cout \u003c\u003c pa.use_count() \u003c\u003c endl; } int main() { fun(); return 0; } 可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。 注意：不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-\u003epb_-\u003eprint(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-\u003epb_.lock(); p-\u003eprint(); ","date":"2023-07-11","objectID":"/posts/basics_one/:4:2","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.3 说说强制类型转换运算符 ①static_cast 用于非多态类型的转换 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -\u003e int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） ②dynamic_cast 用于多态类型的转换 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 ③const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） ④reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 ⑤bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用: try { Circle\u0026 ref_circle = dynamic_cast\u003cCircle\u0026\u003e(ref_shape); } catch (bad_cast b) { cout \u003c\u003c \"Caught: \" \u003c\u003c b.what(); } ","date":"2023-07-11","objectID":"/posts/basics_one/:4:3","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.4 谈谈你对拷贝构造函数和赋值运算符的认识 拷贝构造函数和赋值运算符重载有以下两个不同之处： ①拷贝构造函数生成新的类对象，而赋值运算符不能。 ②由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对之前不用检验原对象是否和新建对象相同，而赋值运算符则需要这个操作， ③另外，赋值运算中，如果原来的对象中有内存分配要先把内存释放掉。 注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:4","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.5 在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？ 不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。 ①malloc /free的操作对象都是必须明确大小的。而且不能用在动态类上。 ②new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。 当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:5","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.6 用C++设计一个不能被继承的类 ref: https://blog.csdn.net/wei_cheng18/article/details/81043858 template \u003ctypename T\u003e class A { friend T; private: A() {} ~A() {} }; class B : virtual public A\u003cB\u003e { public: B() {} ~B() {} }; class C : virtual public B { public: C() {} ~C() {} }; void main( void ) { B b; //C c; return; } 注意：构造函数是继承实现的关键，每次子类对象构造时，首先调用的是父类的构造函数，然后才 是自己的。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:6","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.8 访问基类的私有虚函数 写出以下程序的输出结果： #include \u003ciostream.h\u003e class A { virtual void g() { cout \u003c\u003c \"A::g\" \u003c\u003c endl; } private: virtual void f() { cout \u003c\u003c \"A::f\" \u003c\u003c endl; } }; class B : public A { void g() { cout \u003c\u003c \"B::g\" \u003c\u003c endl; } virtual void h() { cout \u003c\u003c \"B::h\" \u003c\u003c endl; } }; typedef void( *Fun )( void ); void main() { B b; Fun pFun; for(int i = 0 ; i \u003c 3; i++) { pFun = ( Fun )*( ( int* ) * ( int* )( \u0026b ) + i ); pFun(); } } 输出结果: B::g A::f B::h 注意：考察了面试者对虚函数的理解程度。一个对虚函数不了解的人很难正确的做出本题。 在学习面向对象的多态性时一定要深刻理解虚函数表的工作原理。 虚函数：通过基类访问派生类定义的函数，多态时使用，使用虚函数加上virtual关键字。 虚函数就是在基类定义一个未实现的函数名，为了提高程序的可读性 虚函数详解 C++虚函数详解_疯狂的麦克斯_max的博客-CSDN博客_c++虚函数 菱形继承1 菱形继承2 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:7","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.9 对虚函数和多态的理解 ①多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。 举个例子: 一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。 ②虚函数的实现: 在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:8","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.10 简述类成员函数的重写(overwrite)、重载(overload)和隐藏的区别 （1）重写和重载主要有以下几点不同。 ①范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。 ②参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。 ③virtual的区别：重写的基类中被重写的函数必须要有virtual修饰，而重载函数和被重载函数可以被virtual修饰，也可以没有。 （2）隐藏和重写、重载有以下几点不同。 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。 当参数不相同时，无论基类中的参数是否被virtual 修饰，基类的函数都是被隐藏，而不是被重写。 注意：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:9","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.11 链表和数组有什么区别 存储形式: 数组是一块连续的空间，声明时就要确定长度。 链表是一块可不连续的动态空间， 长度可变，每个结点要保存相邻结点指针。 数据查找: 数组的线性查找速度快，查找操作直接使用偏移地址。 链表需要按顺序检索结点， 效率低。 数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。 越界问题： 链表不存在越界问题，数组有越界问题。 注意： 在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:10","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.12 用两个栈实现一个队列的功能 typedef struct node { int data; node *next; }node,*LinkStack; //创建空栈： LinkStack CreateNULLStack( LinkStack \u0026S) { S = (LinkStack)malloc( sizeof( node ) ); // 申请新结点 if( NULL == S) { printf(\"Fail to malloc a new node.\\n\"); return NULL; } S-\u003edata = 0; //初始化新结点 S-\u003enext = NULL; return S; } //栈的插入函数： LinkStack Push( LinkStack \u0026S, int data) { if( NULL == S) //检验栈 { printf(\"There no node in stack!\"); return NULL; } LinkStack p = NULL; p = (LinkStack)malloc( sizeof( node ) ); // 申请新结点 if( NULL == p) { printf(\"Fail to malloc a new node.\\n\"); return S; } if( NULL == S-\u003enext) { p-\u003enext = NULL; } else { p-\u003enext = S-\u003enext; } p-\u003edata = data; //初始化新结点 S-\u003enext = p; //插入新结点 return S; } //出栈函数： node Pop( LinkStack \u0026S) { node temp; temp.data = 0; temp.next = NULL; if( NULL == S) //检验栈 { printf(\"There no node in stack!\"); return temp; } temp = *S; if( S-\u003enext == NULL ) { printf(\"The stack is NULL,can't pop!\\n\"); return temp; } LinkStack p = S -\u003enext; //节点出栈 S-\u003enext = S-\u003enext-\u003enext; temp = *p; free( p ); p = NULL; return temp; } //双栈实现队列的入队函数： LinkStack StackToQueuPush( LinkStack \u0026S, int data) { node n; LinkStack S1 = NULL; CreateNULLStack( S1 ); //创建空栈 while( NULL != S-\u003enext ) //S 出栈入S1 { n = Pop( S ); Push( S1, n.data ); } Push( S1, data ); //新结点入栈 while( NULL != S1-\u003enext ) //S1 出栈入S { n = Pop( S1 ); Push( S, n.data ); } return S; } 注意：用两个栈能够实现一个队列的功能，那用两个队列能否实现一个队列的功能呢？结果是否定的，因为栈是先进后出，将两个栈连在一起，就是先进先出。而队列是现先进先出，无论多少个连在一起都是先进先出，而无法实现先进后出。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:11","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.13 共享数据的保护 ①常引用：使所引用的形参不能被更新 void display(const double\u0026 a); ②常对象：在生存期内不能被更新，但必须被初始化 A const a(3,4); ③常成员函数： 不能修改对象中数据成员，也不能调用类中没有被const 修饰的成员函数（常对象唯一的对外接口）.如果声明了一个常对象，则该对象只能调用他的常函数！-\u003e可以用于对重载函数的区分; void print(); void print() const; ④extern int a:使其他文件也能访问该变量 声明一个函数或定义函数时，冠以static的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数(每一个cpp 文件就是一个编译单元)。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:12","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.14 程序内存分配方式以及它们的区别 内存分配大致上可以分成5块： 栈区（stack） 栈，就是那些由编译器在需要时分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理） 堆区（heap） 一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。注意，它与数据结构中的堆是两回事，分配方式类似于链表。 全局区（静态区）（static） 全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。 常量存储区 常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。 程序代码区 存放函数体的二进制代码。 C++程序在执行时，将内存大方向划分为4个区域: 程序运行前 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 程序运行后 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:13","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.15 explicit 函数声明时加上explicit可以阻止函数参数被隐式转换。 Class A { explicit A(int a); } Void main() { A a1=12; //不加explicit时会被隐式转换位 A a1=A(12);加了此时编译器会报错。 } 被声明为explicit的构造函数通常比non-explicit 函数更受欢迎。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:14","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.16 mutable关键字 mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。 被mutable修饰的变量(mutable只能用于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。 我们知道，假如类的成员函数不会改变对象的状态，那么这个成员函数一般会声明为const。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。（使用mutable修饰的数据成员可以被const成员函数修改）。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:15","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.17 用const修饰函数的返回值 如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。例如函数： const char * GetString(void); // 如下语句将出现编译错误： char*str = GetString(); // 正确的用法是 const char *str =GetString(); ","date":"2023-07-11","objectID":"/posts/basics_one/:4:16","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.18 宏、const和enum #define不被视为语言的一部分。对于单纯常量，最好用const对象或者enum替换#define。 对于类似函数的宏，尽量使用内联函数inline替换掉#define enum枚举类型是被当做 int 或者 unsigned int 类型来处理的。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:17","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.19 stack的生存期 ①C++中的static对象是指存储区不属于stack和heap、“寿命\"从被构造出来直至程序结束为止的对象。 ②这些对象包括全局对象，定义于namespace作用域的对象，在class、function以及file作用域中被声明为static的对象。 ③其中，函数内的static对象称为local static对象，而其它static对象称为non-local static对象。 这两者在何时被初始化(构造)这个问题上存在细微的差别： ①对于local static对象，在其所属的函数被调用之前，该对象并不存在，即只有在第一次调用对应函数时，local static对象才被构造出来。 ②而对于non-local static对象，在main()函数开始前就已经被构造出来，并在main()函数结束后被析构。 \u003c/font color=red\u003e建议： 1.对内置对象进行手工初始化，因为C++不保证初始化它们。 2.构造函数最好使用成员初值列，而不要在构造函数本体中使用赋值操作。初值列中列出的成员变量，其排序次序应该和它们在class中的声明次序相同(初始化顺序与声明变量顺序一致)。 3.为免除“跨编译单元的初始化次序问题”，尽量以local static对象替换non-local static对象。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:18","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"4.20 全局变量和static变量的区别 ①全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。 ②这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 ③而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。 ④由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。 ","date":"2023-07-11","objectID":"/posts/basics_one/:4:19","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5 基础知识（五） ","date":"2023-07-11","objectID":"/posts/basics_one/:5:0","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.1 为什么栈要比堆速度要快 ①首先, 栈是本着LIFO原则的存储机制, 对栈数据的定位相对比较快速, 而堆则是随机分配的空间, 处理的数据比较多, 无论如何, 至少要两次定位. ②其次, 栈是由CPU提供指令支持的, 在指令的处理速度上, 对栈数据进行处理的速度自然要优于由操作系统支持的堆数据. ③再者, 栈是在一级缓存中做缓存的, 而堆则是在二级缓存中, 两者在硬件性能上差异巨大. 最后, 各语言对栈的优化支持要优于对堆的支持, 比如swift语言中, 三个字及以内的struct结构, 可以在栈中内联, 从而达到更快的处理速度. ","date":"2023-07-11","objectID":"/posts/basics_one/:5:1","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.2 c++ 析构函数调用时间 对象生命周期结束，被销毁时 delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:2","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.3 静态绑定 动态绑定 （也叫动态连编，静态连编） 如果父类中存在有虚函数，那么编译器便会为之生成虚表（属于类）与虚指针（属于某个对象），在程序运行时，根据虚指针的指向，来决定调用哪个虚函数，这称之与动态绑定，与之相对的是静态绑定，静态绑定在编译期就决定了。 class和template都支持接口与多态； ①对classes而言，接口是显式的，以函数签名为中心。多态则是通过virtual函数(虚函数)发生于运行期； ②对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。 泛型 泛型是通过参数化类型来实现在同一份代码上操作多种数据类型。利用“参数化类型”将类型抽象化，从而实现灵活的复用。 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:3","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.4 C语言的指针和c++的引用有什么区别？ 指针有自己的一块空间，指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体。而引用只是一个别名； 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用； 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象； ","date":"2023-07-11","objectID":"/posts/basics_one/:5:4","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.5 请你说说C语言是怎么进行函数调用的 每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。（ESP（Extended Stack Pointer）为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针） C语言参数压栈顺序？：从右到左 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:5","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.6 C++中拷贝赋值函数的形参能否进行值传递？ 不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数(aa = ex.aa; //此处调用拷贝构造函数)。如此循环，无法完成拷贝，栈也会满。 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:6","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.7 include头文件的顺序以及双引号””和尖括号\u003c\u003e的区别 编译器预处理阶段查找头文件的路径不一样 使用双引号包含的头文件，查找头文件路径的顺序为： ①当前头文件目录 ②编译器设置的头文件路径（编译器可使用-I显式指定搜索路径） ③系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 对于使用尖括号包含的头文件，查找头文件的路径顺序为： ①编译器设置的头文件路径（编译器可使用-I显式指定搜索路径） ②系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:7","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.8 一个C++源文件从文本到可执行文件经历的过程 对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤： 预编译，预编译的时候做一些简单的文本替换，比如宏替换，而不进行语法的检查； 编译，在编译阶段，编译器将检查一些语法错误，但是，如果使用的函数事先没有定义这种情况，不再这一阶段检查，编译后，得到.s文件 汇编，将C/C++代码变为汇编代码，得到.o或者.obj文件 链接，将所用到的外部文件链接在一起，在这一阶段，就会检查使用的函数有没有定义 链接过后，形成可执行文件.exe 详细请参阅: 一个C++源文件从文本到可执行文件经历的过程 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:8","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.9 内存泄漏原因和判断方法 内存泄漏通常是因为调用了malloc/new等内存申请操作，但是缺少了对应的free/delete。 为了判断内存是否泄漏，我们一方面可以使用Linux环境下的内存泄漏检查工具Valgrind，另一方面我们写代码的时候，可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否有泄漏。 内存泄漏分类： 堆内存泄漏（heap leak）。堆内存值得是程序运行过程中根据需要分配通过malloc\\realloc\\new等从堆中分配的一块内存，再完成之后必须要通过调用对应的free或者delete删除。 如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap，handle，SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确的释放，从而造成内存泄漏。 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:9","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.10 段错误的产生原因 段错误是什么? 一句话来说，段错误是指访问的内存超出了系统给这个程序所设定的内存空间，例如访问了不存在的内存地址、访问了系统保护的内存地址、访问了只读的内存地址等等情况。这里贴一个对于“段错误”的准确定义。 段错误产生的原因 访问不存在的内存地址 访问系统保护的内存地址 访问只读的内存地址 栈溢出 详细请参阅：Linux环境下段错误的产生原因及调试方法小结 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:10","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.11 C++ 函数调用过程 总结起来整个过程就三步： 1）根据调用的函数名找到函数入口； 2）在栈中申请调用函数中的参数及函数体内定义的变量的内存空间 3）函数执行完后，释放函数在栈中的申请的参数和变量的空间，最后返回值（如果有的话） 详细请查阅：函数调用过程 / C/C++函数调用过程分析 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:11","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.12 如何调试c++多线程程序？ 打印日志，日志中加上线程ID；（简单粗暴） gdb有thread相关命令，如infothread（简写infoth）显示线程消息，bxxthreadyy可以 对某个thread设置断点，threadxx（简写成thrxx）切换到某个thread。再配合frame（简写f）相关的命令（比如up，down在不同frame间跳转），基本可以处理若干个不同的线程间的debug…… 详细请查阅：C++(vs)多线程调试 （转） ","date":"2023-07-11","objectID":"/posts/basics_one/:5:12","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.13 面向对象和面向过程的区别 ①面向对象方法中，把数据和数据操作放在一起，组成对象；对同类的对象抽象出其共性组成类；类通过简单的接口与外界发生联系，对象和对象之间通过消息进行通信。 ②面向对象的三大特性是\"封装、“多态”、“继承”，五大原则是\"单一职责原则”、“开放封闭原则”、“里氏替换原则”、“依赖倒置原则”、“接口分离原则”。 ③而面向过程方法是以过程为中心的开发方法，它自顶向下顺序进行， 程序结构按照功能划分成若干个基本模块，这些模块形成树状结构。 （过程）优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗源;比如嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。缺点：没有面向对象易维护、易复用、易扩展。 （对象）优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统。缺点：性能比面向过程低。 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:13","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.14 关于引用赋值的多态： Class B; Class D : public B; B\u0026 b; D\u0026 d; B\u0026 b1 = d ; //父类可以作为子类的引用，此时b1表现和指针形式一致（会调用B的非虚函数） D\u0026 d1 = b； //错误，不能将子类作为父类的引用 //父类可以作为子类的引用，此时b1表现和指针形式一致（会调用B的非虚函数） ","date":"2023-07-11","objectID":"/posts/basics_one/:5:14","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.15 模板的声明和实现不能分开的原因 链接的时候，需要实例化模板，这时候就需要找模板的具体实现了。假设在main函数中调用了一个模板函数，这时候就需要去实例化该类型的模板。注意main函数里面只包含了.h文件，也就是只有模板的声明，没有具体实现。就会报错。 而模板的实现.cpp里面，虽然有模板的具体实现，但是没有谁在该.cpp里面使用一个模板函数，就不会生成一个具体化的实例 详细请参阅：C++ 模板类的声明与实现分离问题 / ​​​​​​C++ 模板类的声明与实现分离问题（模板实例化）​​​​​​ ","date":"2023-07-11","objectID":"/posts/basics_one/:5:15","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.16 C++类中引用成员和常量成员的初始化（初始化列表） 如果一个类是这样定义的： Class A { public: A(int pram1, int pram2, int pram3); privite: int a; int \u0026b; const int c; } 假如在构造函数中对三个私有变量进行赋值则通常会这样写： A::A(int pram1, int pram2, int pram3) { a=pram1; b=pram2; c=pram3; } 但是，这样是编译不过的。因为常量和引用初始化必须赋值。所以上面的构造函数的写法只是简单的赋值，并不是初始化。 正确写法应该是： A::A(int pram1, int pram2, int pram3):b(pram2),c(pram3) { a=pram1; } 采用初始化列表实现了对常量和引用的初始化。采用括号赋值的方法，括号赋值只能用在变量的初始化而不能用在定义之后的赋值。 凡是有引用类型的成员变量或者常量类型的变量的类，不能有缺省构造函数。默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。并且必须使用初始化列表进行初始化const对象、引用对象。 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:16","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.17 memset为int型数组初始化问题： 头文件：#include \u003cstring.h\u003e memset() 函数用来将指定内存的前n个字节设置为特定的值，其原型为： void * memset( void * ptr, int value, size_t num ); 参数说明： ptr 为要操作的内存的指针。 value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。 num 为 ptr 的前 num 个字节，size_t 就是unsigned int。 【函数说明】memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后返回指向 ptr 的指针。 无法下面这样初始化，这样的结果是a被赋值成168430090，168430090….. int a[10]; memset(a, 1, sizeof(a)); 这是因为int由4个字节(说)表示，并且不能得到数组a中整数的期望值。 但我经常看到程序员使用memset将int数组元素设置为0或-1。其他值不行！ int a[10]; int b[10]; memset(a, 0, sizeof(a)); memset(b, -1, sizeof(b)); //假设a为int型数组： memset(a,0x7f,sizeof(a)); //a数组每个空间将被初始化为0x7f7f7f7f,原因是C函数传参过程中的指针降级，导致sizeof(a)，返回的是一个 something*指针类型大小的的字节数，如果是32位，就是4字节。所以memset按字节赋值。 memset(a,0xaf,sizeof(a)); //a数组每个空间将被初始化为0xafafafaf ","date":"2023-07-11","objectID":"/posts/basics_one/:5:17","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.18 编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO） 优点: 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点: 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 ","date":"2023-07-11","objectID":"/posts/basics_one/:5:18","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.19 虚函数（virtual）可以是内联函数（inline）吗？ 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类(如 Base::who())，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生; ","date":"2023-07-11","objectID":"/posts/basics_one/:5:19","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"5.20 静态库和动态库比较 静态库 (.a、.lib): 将静态库的内容添加到程序中，此时程序的空间，变成了源程序空间大小+静态库空间大小。 动态库（共享库）(.so、.dll): 常驻内存，当程序需要调用相关函数时，会从内存调用。 区别: 静态库：对空间要求较低，而时间要求较高的核心程序中。(.a、.lib) 动态库：对时间要求较低，对空间要求较高。(.so、.dll) hash ","date":"2023-07-11","objectID":"/posts/basics_one/:5:20","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"6 基础知识(六) ","date":"2023-07-11","objectID":"/posts/basics_one/:6:0","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["C++"],"content":"6.1 构造函数为什么不能定义为虚函数？ ⽽析构函数⼀般写成虚函数的原因 ？ 构造函数不能声明为虚函数的原因是: 1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。 2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。 虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。（动态绑定是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本就不存在，它怎么动态绑定？） 编译器在调用基类的构造函数的时候并不知道你要构造的是一个基类的对象还是一个派生类的对象。 析构函数设为虚函数的作用: 解释：在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。（如果基类的析构函数不是虚函数，那么在delete 基类指针时，只调用基类的析构函数，不会调用派生类的析构函数，故派生类部分不会被析构。） ref: [1]. https://blog.csdn.net/Yangy_Jiaojiao/article/details/127588598 [2]. https://blog.csdn.net/Yangy_Jiaojiao/article/details/128145609 参考（待补充）: [1]. https://zhuanlan.zhihu.com/p/401341063 [2]. https://zhuanlan.zhihu.com/p/602866792 ref: https://blog.csdn.net/m0_46245582/category_11569287.html ","date":"2023-07-11","objectID":"/posts/basics_one/:6:1","tags":["basics"],"title":"C++ 基础知识[一]","uri":"/posts/basics_one/"},{"categories":["Distributed Computing"],"content":"0 摘要 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，在业界得到了广泛应用。 本系列将通过源码分析来带领大家了解 Horovod。本文是系列第四篇，看看如何获取 host 之间的路由等网络信息。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:1:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"1 引子 在 horovod/runner/launch.py 文件中，_run_static 函数中使用 driver_service.get_common_interfaces 来获取路由信息等。 def _run_static(args): nics = driver_service.get_common_interfaces(settings, all_host_names, remote_host_names, fn_cache) 因为这部分比较复杂（ Driver 的概念很类似 Spark 之中 Driver 的概念），所以本文我们单独来分析。 本文的分析问题点是： 为什么要知道路由信息？ 当有多个host时候，horovod如何处理？ 如何找到路由信息？ 怎么互相交互？ （后文会详细分析）SparkDriverService，SparkTaskService，ElasticDriver, Worker 都有什么区别和联系？ 本文重点分析 HorovodRunDriverService 和 HorovodRunTaskService 相关。 先给出一个图例，大家可以有些概念。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:2:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"2 总体架构 从注释可知，get_common_interfaces 完成了获得路由信息（所有host之间的共有路由接口集合）的功能，主要是调用 _driver_fn 来完成相关工作。 def get_common_interfaces(settings, all_host_names, remote_host_names=None, fn_cache=None): ''' Find the set of common and routed interfaces on all the hosts. ''' # 得到远端host地址 if remote_host_names is None: remote_host_names = network.filter_local_addresses(all_host_names) if len(remote_host_names) \u003e 0: if settings.nics: # 如果参数有设定网络接口，就使用 # If args.nics is provided, we will use those interfaces. All the workers # must have at least one of those interfaces available. nics = settings.nics else: # Find the set of common, routed interfaces on all the hosts (remote # and local) and specify it in the args to be used by NCCL. It is # expected that the following function will find at least one interface # otherwise, it will raise an exception. local_host_names = set(all_host_names) - set(remote_host_names) # 获取其他host的网络接口 nics = _driver_fn(all_host_names, local_host_names, settings, fn_cache=fn_cache) else: nics = get_local_interfaces(settings) # 获取本地的网络接口 return nics ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:3:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"2.1 get_local_interfaces 此函数比较简单，目的是获取本地的网络接口。 def get_local_interfaces(settings): # If all the given hosts are local, find the interfaces with address # 127.0.0.1 nics = set() for iface, addrs in net_if_addrs().items(): if settings.nics and iface not in settings.nics: continue for addr in addrs: if addr.family == AF_INET and addr.address == '127.0.0.1': nics.add(iface) break return nics ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:3:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"2.2 _driver_fn 这是本文重点，获取其他host 的网络接口，_driver_fn 的作用是： 启动 service 服务； 使用 driver.addresses() 获取 Driver 服务的地址（使用self._addresses = self._get_local_addresses()完成）； 使用 _launch_task_servers（利用 Driver 服务的地址）在每个 worker 之中启动 task 服务，然后 task 服务会在 service 服务中注册； 因为是一个环形，每个 worker 会探测 worker index + 1 的所有网络接口； 最后 _run_probe 返回一个所有 workers 上的所有路由接口的交集； 代码如下： 这里需要注意的一点是：@cache.use_cache() 的使用：当第一次使用过之后，会把结果放入缓存。 @cache.use_cache() def _driver_fn(all_host_names, local_host_names, settings): \"\"\" launches the service service, launches the task service on each worker and have them register with the service service. Each worker probes all the interfaces of the worker index + 1 (in a ring manner) and only keeps the routed interfaces. Function returns the intersection of the set of all the routed interfaces on all the workers. :param all_host_names: list of addresses. for example, ['worker-0','worker-1'] ['10.11.11.11', '10.11.11.12'] :type all_host_names: list(string) :param local_host_names: host names that resolve into a local addresses. :type local_host_names: set :param settings: the object that contains the setting for running horovod :type settings: horovod.runner.common.util.settings.Settings :return: example: ['eth0', 'eth1'] :rtype: list[string] \"\"\" # Launch a TCP server called service service on the host running horovod # 启动 service 服务 num_hosts = len(all_host_names) driver = HorovodRunDriverService(num_hosts, settings.key, settings.nics) # Have all the workers register themselves with the service service. #（利用 Driver 服务的地址）在每个worker之中启动 task 服务，然后task服务会在 service 服务中注册 _launch_task_servers(all_host_names, local_host_names, driver.addresses(), settings) try: # 返回一个所有 workers 上的所有路由接口的交集 return _run_probe(driver, settings, num_hosts) finally: driver.shutdown() ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:3:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"2.3 获取路由接口 我们对 _run_probe 函数做进一步分析。 2.3.1 probe逻辑 _run_probe 函数就是当所有 task 都启动，注册，probe 环中下一个worker 邻居完成 之后，得到 接口集合。 利用 wait_for_initial_registration 等待所有 task 完成注册； 对于所有 task，完成 task.notify_initial_registration_complete 通知； 利用 driver.wait_for_task_to_task_address_updates 等待 每一个 worker probe 完成； 利用 nics.intersection_update 得到接口集合； def _run_probe(driver, settings, num_hosts): # wait for all the hosts to register with the service service. driver.wait_for_initial_registration(settings.start_timeout) tasks = [ task_service.HorovodRunTaskClient( index, driver.task_addresses_for_driver(index), settings.key, settings.verbose) for index in range( num_hosts)] # Notify all the drivers that the initial registration is complete. for task in tasks: task.notify_initial_registration_complete() # Each worker should probe the interfaces of the next worker in a ring # manner and filter only the routed ones -- it should filter out # interfaces that are not really connected to any external networks # such as lo0 with address 127.0.0.1. driver.wait_for_task_to_task_address_updates(settings.start_timeout) # Determine a set of common interfaces for task-to-task communication. nics = set(driver.task_addresses_for_tasks(0).keys()) for index in range(1, num_hosts): nics.intersection_update( driver.task_addresses_for_tasks(index).keys()) return nics 2.3.2 等待函数 probe 利用 wait_for_initial_registration 等待所有 task 完成注册，具体等待函数如下： def wait_for_initial_registration(self, timeout): self._wait_cond.acquire() try: while len(self._all_task_addresses) \u003c self._num_proc: self._wait_cond.wait(timeout.remaining()) timeout.check_time_out_for('tasks to start') finally: self._wait_cond.release() def wait_for_task_to_task_address_updates(self, timeout): self._wait_cond.acquire() try: while len(self._task_addresses_for_tasks) \u003c self._num_proc: self._wait_cond.wait(timeout.remaining()) timeout.check_time_out_for( 'tasks to update task-to-task addresses') finally: self._wait_cond.release() ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:3:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"3 基础网络服务 前面提到，Horovod Driver 的概念很类似 Spark 之中 Driver 的概念。Spark应用程序运行时主要分为 Driver 和 Executor，Driver负责总体调度及UI展示，Executor负责Task运行。用户的Spark应用程序运行在Driver上（某种程度上说，用户的程序就是Spark Driver程序），经过Spark调度封装成一个个Task，再将这些Task信息发给Executor执行，Task信息包括代码逻辑以及数据信息，Executor不直接运行用户的代码。 对于 Horovod 来说： HorovodRunDriverService 就是 Driver 的实现类。 HorovodRunTaskService 提供了 Task 部分服务功能，这些 task 需要注册到 HorovodRunDriverService 之中。 这套 driver \u0026 task 机制的底层由 “基础网络服务” 支撑。 所以我们就仔细分析下基础网络服务。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:4:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"3.1 继承关系 首先给出继承关系，我们下面讲解的 Driver 服务由 HorovodRunDriverService 提供，Task 服务由HorovodRunTaskService 提供。 这两个类最终都继承了 network.BasicService。 network.BasicService ^ ^ | | +-------------------+ +-------------+ | | + + driver_service.BasicDriverService task_service.BasicTaskService ^ ^ | | | | | | + + HorovodRunDriverService HorovodRunTaskService ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:4:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"3.2 network.BasicService BasicService 提供了一个网络服务器功能。即通过find_port函数构建了一个ThreadingTCPServer对外提供服务。 class BasicService(object): def __init__(self, service_name, key, nics): self._service_name = service_name self._wire = Wire(key) self._nics = nics self._server, _ = find_port( lambda addr: socketserver.ThreadingTCPServer( addr, self._make_handler())) self._server._block_on_close = True self._port = self._server.socket.getsockname()[1] self._addresses = self._get_local_addresses() self._thread = in_thread(target=self._server.serve_forever) 3.2.1 创建Server 创建服务器代码如下，这里是搜索一个随机端口，然后设置： def find_port(server_factory): min_port = 1024 max_port = 65536 num_ports = max_port - min_port start_port = random.randrange(0, num_ports) for port_offset in range(num_ports): try: port = min_port + (start_port + port_offset) % num_ports addr = ('', port) server = server_factory(addr) return server, port except Exception as e: pass raise Exception('Unable to find a port to bind to.') 3.2.2 Server功能 服务器就是基本的功能，比如获取本server地址，处理 ping，网络交互等。 def _make_handler(self): server = self class _Handler(socketserver.StreamRequestHandler): def handle(self): try: req = server._wire.read(self.rfile) resp = server._handle(req, self.client_address) # A tuple is the usual response object followed by a utf8 text stream if type(resp) == tuple: (resp, stream) = resp server._wire.write(resp, self.wfile) server._wire.stream(stream, self.wfile) else: server._wire.write(resp, self.wfile) except (EOFError, BrokenPipeError): # Happens when client is abruptly terminated, don't want to pollute the logs. pass return _Handler def _handle(self, req, client_address): if isinstance(req, PingRequest): return PingResponse(self._service_name, client_address[0]) raise NotImplementedError(req) def _get_local_addresses(self): result = {} for intf, intf_addresses in psutil.net_if_addrs().items(): if self._nics and intf not in self._nics: continue for addr in intf_addresses: if addr.family == socket.AF_INET: if intf not in result: result[intf] = [] result[intf].append((addr.address, self._port)) return result def addresses(self): return self._addresses.copy() def shutdown(self): self._server.shutdown() self._server.server_close() self._thread.join() def get_port(self): return self._port ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:4:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"3.3 network.BasicClient HorovodRunDriverClient 和 HorovodRunTaskClient 这两个类都继承了network.BasicClient。 network.BasicClient 的作用就是连接 network.BasicService，与其交互。即 network.BasicClient 是一个操作接口。 network.BasicClient ^ ^ | | +------------------+ +---------------+ | | + | + driver_service.BasicDriverClient task_service.BasicTaskClient ^ ^ | | | | + + HorovodRunDriverClient HorovodRunTaskClient 两个主要 API 如下： 3.3.1 _probe _probe 获取 server 的网络接口。 def _probe(self, addresses): result_queue = queue.Queue() threads = [] for intf, intf_addresses in addresses.items(): for addr in intf_addresses: thread = in_thread(target=self._probe_one, args=(intf, addr, result_queue)) threads.append(thread) for t in threads: t.join() result = {} while not result_queue.empty(): intf, addr = result_queue.get() if intf not in result: result[intf] = [] result[intf].append(addr) return result 3.3.2 发送消息 _send 的作用是给server发送消息。 def _send(self, req, stream=None): \"\"\" Sends the request and returns the response object. Streaming data response is transferred to the optional stream parameter. \"\"\" # Since all the addresses were vetted, use the first one. addr = list(self._addresses.values())[0][0] return self._send_one(addr, req, stream) ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:4:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"3.4 总结 我们可以看到，network.BasicService 会提供了一个server，这个 Service 都是通过 network.BasicClient 来访问。基于此，Horovod 的HorovodRunDriverService 和 HorovodRunTaskService 这两个类就可以互相交互，进行沟通。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:4:4","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"4 Driver 服务 Driver 服务由 HorovodRunDriverService 提供，其功能主要是维护维护各种 task 地址以及相应关系。具体各种 task 地址 就是 Task 服务 来注册的。 需要注意的是：HorovodRunDriverService 和 HorovodRunTaskService 都最终继承了 network.BasicService，他们之间可以是异地运行交互。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:5:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"4.1 HorovodRunDriverService HorovodRunDriverService 是对 BasicDriverService 的封装。 HorovodRunDriverClient 是 其 访问接口。 class HorovodRunDriverService(driver_service.BasicDriverService): NAME = 'horovod driver service' def __init__(self, num_hosts, key, nics): super(HorovodRunDriverService, self).__init__(num_hosts, HorovodRunDriverService.NAME, key, nics) class HorovodRunDriverClient(driver_service.BasicDriverClient): def __init__(self, driver_addresses, key, verbose, match_intf=False): super(HorovodRunDriverClient, self).__init__( HorovodRunDriverService.NAME, driver_addresses, key, verbose, match_intf=match_intf) ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:5:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"4.2 BasicDriverService BasicDriverService基类 主要就是 维护各种 task 地址以及相应关系。 class BasicDriverService(network.BasicService): def __init__(self, num_proc, name, key, nics): super(BasicDriverService, self).__init__(name, key, nics) self._num_proc = num_proc self._all_task_addresses = {} self._task_addresses_for_driver = {} self._task_addresses_for_tasks = {} self._task_index_host_hash = {} self._task_host_hash_indices = {} self._wait_cond = threading.Condition() 这里的各种 task 地址就是 Task 服务 注册到 Driver 的数值。 可以看到里面有各种关于地址的变量，为了让大家理解这些变量的作用，对于每一个变量我们举例如下（这里有些变量是专门为 spark 设计，都放到基类里面有点奇怪）： 4.2.1 _all_task_addresses 本变量是记录了所有 task 的地址，变量举例如下： self._all_task_addresses = { 1: { 'lo' : [('1.1.1.1', 12345)], 'eth0' : [('10.10.10.01', 12345)] }, 0: { 'lo' : [('2.2.2.2', 54321)], 'eth0' : [('10.10.10.02', 54321)] } } 本变量由 task 调用 RegisterTaskRequest 来注册。 if isinstance(req, RegisterTaskRequest): self._wait_cond.acquire() try: assert 0 \u003c= req.index \u003c self._num_proc self._all_task_addresses[req.index] = req.task_addresses 4.2.2 _task_addresses_for_driver 本变量是记录了所有 task 的地址，但是网卡接口有多种，这里选择与 本 driver 地址匹配的地址。 变量举例如下： self._task_addresses_for_driver = { 1: { 'eth0' : [('10.10.10.01', 12345)] }, 0: { 'eth0' : [('10.10.10.02', 54321)] } } 本变量由 task 调用 RegisterTaskRequest 来注册。 # Just use source address for service for fast probing. self._task_addresses_for_driver[req.index] = \\ self._filter_by_ip(req.task_addresses, client_address[0]) 具体使用举例如下： def task_addresses_for_driver(self, index): self._wait_cond.acquire() try: return self._task_addresses_for_driver[index].copy() finally: self._wait_cond.release() driver用这个地址来生成 其内部 task 变量。 tasks = [ task_service.HorovodRunTaskClient( index, driver.task_addresses_for_driver(index), settings.key, settings.verbose) for index in range( num_hosts)] 4.2.3 _task_addresses_for_tasks 该变量举例如下： self._task_addresses_for_tasks = { 1: { 'eth0' : [('10.10.10.01', 12345)] }, 0: { 'eth0' : [('10.10.10.02', 54321)] } } 本变量由RegisterTaskToTaskAddressesRequest注册。 if isinstance(req, RegisterTaskToTaskAddressesRequest): self.register_task_to_task_addresses(req.index, req.task_addresses) return network.AckResponse() def register_task_to_task_addresses(self, index, task_addresses): self._wait_cond.acquire() try: assert 0 \u003c= index \u003c self._num_proc self._task_addresses_for_tasks[index] = task_addresses # 这里赋值 finally: self._wait_cond.notify_all() self._wait_cond.release() 该变量被 task 用来获取 某个 task 的一套网络接口，比如： # Determine a set of common interfaces for task-to-task communication. nics = set(driver.task_addresses_for_tasks(0).keys()) 4.2.4 _task_index_host_hash 每一个 task 有一个对应的 host hash，该数值被 MPI 作为 host name 来操作。 self._task_index_host_hash = { 1: { 'ip-10-10-10-01-dfdsfdsfdsfdsf2' }, 0: { 'ip-10-10-10-02-treterwrtqwer' } } 具体使用如下。这个函数是 spark 相关会使用，具体是逐一通知 spark task 进入下一阶段。 def task_indices(self): self._wait_cond.acquire() try: return list(self._task_index_host_hash.keys()) finally: self._wait_cond.release() 或者使用如下，是为了获取某一个 host 对应的 host hash name。 def task_index_host_hash(self, index): self._wait_cond.acquire() try: assert 0 \u003c= index \u003c self._num_proc return self._task_index_host_hash[index] finally: self._wait_cond.release() 4.2.5 _task_host_hash_indices 该变量举例如下： self._task_host_hash_indices = { { 'ip-10-10-10-01-dfdsfdsfdsfdsf2' : [1] }, { 'ip-10-10-10-02-treterwrtqwer' : [0] } } 具体是在注册 RegisterTaskRequest 时候生成。 self._task_host_hash_indices[req.host_hash].append(req.index) 使用具体代码是： def task_host_hash_indices(self): self._wait_cond.acquire() try: return self._task_host_hash_indices.copy() finally: self._wait_cond.release() 具体是被 rsh 使用。rsh 就是在某一个 host 上，让某一个 horovod rank 启动。具体逻辑是： 获取某一个 host 上所有的 task indices ； 利用 task_host_hash_indices 取出本进程 local rank 对应的 task index； 取出在 driver 中 task index 对应保持的 task address； 最后依据这个 task addresses 生成一个 SparkTaskClient，进行后续操作。 driver_client = driver_service.SparkDriverClient(driver_addresses, key, verbose=verbose) task_indices = driver_client.task_host_hash_indices(host_hash) task_index = task_indices[local_rank] tas","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:5:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"4.3 总体逻辑 总体逻辑如下： network.BasicService ^ ^ | | +-------------------+ +-------------+ | | + + driver_service.BasicDriverService task_service.BasicTaskService ^ ^ | | | | | | | + +----------------+------------------+ HorovodRunTaskService | HorovodRunDriverService | | | | | | _all_task_addresses | | | | _task_addresses_for_driver | | | | _task_addresses_for_tasks | | | | _task_index_host_hash | | | | _task_host_hash_indices | | | +-----------------------------------+ ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:5:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"5 Task 服务 HorovodRunTaskService 提供了 Task 部分服务功能。整体逻辑是由几个函数共同完成。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:6:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"5.1 启动具体服务 _launch_task_servers 用来启动具体服务，其主要作用是：多线程运行，在每一个线程中，远程运行 horovod.runner.task_fn。 其中： 传入参数中，all_host_names 就是程序启动时候配置的所有host，比如 [“1.1.1.1”, “2.2.2.2”]； 使用了我们之前提到的 safe_shell_exec.execute 完成了安全运行保证； 使用我们前文提到的 get_remote_command 完成了远程命令的获取，即在命令之前加上了 ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no等等配置； 最终每个启动的命令举例如下： ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no 1.1.1.1 python -m horovod.runner.task_fn xxxxxxx； 使用 execute_function_multithreaded 在每一个 host 上运行，启动 task 服务； 具体代码如下： def _launch_task_servers(all_host_names, local_host_names, driver_addresses, settings): \"\"\" Executes the task server and service client task for registration on the hosts. :param all_host_names: list of addresses. for example, ['worker-0','worker-1'] ['10.11.11.11', '10.11.11.12'] :type all_host_names: list(string) :param local_host_names: names that are resolved to one of the addresses of local hosts interfaces. For example, set(['localhost', '127.0.0.1']) :type local_host_names: set :param driver_addresses: map of interfaces and their address and port for the service. For example: { 'lo': [('127.0.0.1', 34588)], 'docker0': [('172.122.10.1', 34588)], 'eth0': [('11.111.33.73', 34588)] } :type driver_addresses: map :param settings: the object that contains the setting for running horovod :type settings: horovod.runner.common.util.settings.Settings :return: :rtype: \"\"\" def _exec_command(command): host_output = io.StringIO() try: # 完成了安全运行保证 exit_code = safe_shell_exec.execute(command, stdout=host_output, stderr=host_output) finally: host_output.close() return exit_code args_list = [] num_hosts = len(all_host_names) for index in range(num_hosts): host_name = all_host_names[index] # all_host_names 就是程序启动时候配置的所有host，比如 [\"1.1.1.1\", \"2.2.2.2\"] command = \\ '{python} -m horovod.runner.task_fn {index} {num_hosts} ' \\ '{driver_addresses} {settings}' \\ .format(python=sys.executable, index=codec.dumps_base64(index), num_hosts=codec.dumps_base64(num_hosts), driver_addresses=codec.dumps_base64(driver_addresses), settings=codec.dumps_base64(settings)) if host_name not in local_host_names: # 完成了远程命令的获取，即在命令之前加上了 `ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no`等等配置 command = get_remote_command(command, host=host_name, port=settings.ssh_port, identity_file=settings.ssh_identity_file) args_list.append([command]) # Each thread will use ssh command to launch the server on one task. If an # error occurs in one thread, entire process will be terminated. Otherwise, # threads will keep running and ssh session -- and the the task server -- # will be bound to the thread. In case, the horovod process dies, all # the ssh sessions and all the task servers will die as well. # 使用 execute_function_multithreaded 在每一个 host 上运行，启动 task 服务 threads.execute_function_multithreaded(_exec_command, args_list, block_until_all_done=False) ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:6:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"5.2 具体服务逻辑 上段有：{python} -m horovod.runner.task_fn {index} {num_hosts} {driver_addresses} {settings}执行具体服务逻辑，所以我们介绍下 horovod.runner.task_fn。 _task_fn 函数完成了 生成了 HorovodRunTaskService 实例，赋值给 task； 使用 HorovodRunDriverClient . register_task 来向 Driver 服务注册task（自己）的地址； 使用 HorovodRunDriverClient . register_task_to_task_addresses 来向 Driver 服务注册自己在Ring上 下一个邻居的地址； 每一个 task 都做这个操作，最后就得到了在这个 ring cluster 之中的一个路由接口； 具体代码如下： def _task_fn(index, num_hosts, driver_addresses, settings): task = task_service.HorovodRunTaskService(index, settings.key, settings.nics) try: driver = driver_service.HorovodRunDriverClient( driver_addresses, settings.key, settings.verbose) # 向 Driver 服务注册task（自己）的地址 driver.register_task(index, task.addresses(), host_hash.host_hash()) task.wait_for_initial_registration(settings.start_timeout) # Tasks ping each other in a circular fashion to determine interfaces # reachable within the cluster. next_task_index = (index + 1) % num_hosts next_task_addresses = driver.all_task_addresses(next_task_index) # We request interface matching to weed out all the NAT'ed interfaces. next_task = task_service.HorovodRunTaskClient( next_task_index, next_task_addresses, settings.key, settings.verbose, match_intf=True, attempts=10) # 向 Driver 服务注册自己在Ring上 下一个邻居的地址 driver.register_task_to_task_addresses(next_task_index, next_task.addresses()) # Notify the next task that the address checks are completed. next_task.task_to_task_address_check_completed() # Wait to get a notification from previous task that its address checks # are completed as well. task.wait_for_task_to_task_address_check_finish_signal(settings.start_timeout) finally: task.shutdown() if __name__ == '__main__': index = codec.loads_base64(sys.argv[1]) num_hosts = codec.loads_base64(sys.argv[2]) driver_addresses = codec.loads_base64(sys.argv[3]) settings = codec.loads_base64(sys.argv[4]) _task_fn(index, num_hosts, driver_addresses, settings) ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:6:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"5.3 HorovodRunTaskService HorovodRunTaskService 主要的作用是提供了两个等待函数。因为具体路由操作是需要彼此通知，所以需要互相等待。 class HorovodRunTaskService(task_service.BasicTaskService): NAME_FORMAT = 'horovod task service #%d' def __init__(self, index, key, nics): super(HorovodRunTaskService, self).__init__( HorovodRunTaskService.NAME_FORMAT % index, index, key, nics) self.index = index self._task_to_task_address_check_completed = False def _handle(self, req, client_address): if isinstance(req, TaskToTaskAddressCheckFinishedSignal): self._wait_cond.acquire() try: self._task_to_task_address_check_completed = True finally: self._wait_cond.notify_all() self._wait_cond.release() return TaskToTaskAddressCheckFinishedSignalResponse(self.index) return super(HorovodRunTaskService, self)._handle(req, client_address) def wait_for_task_to_task_address_check_finish_signal(self, timeout): self._wait_cond.acquire() try: while not self._task_to_task_address_check_completed: self._wait_cond.wait(timeout.remaining()) timeout.check_time_out_for('Task to task address check') finally: self._wait_cond.release() class HorovodRunTaskClient(task_service.BasicTaskClient): def __init__(self, index, task_addresses, key, verbose, match_intf=False, attempts=3): super(HorovodRunTaskClient, self).__init__( HorovodRunTaskService.NAME_FORMAT % index, task_addresses, key, verbose, match_intf=match_intf, attempts=attempts) self.index = index def task_to_task_address_check_completed(self): resp = self._send(TaskToTaskAddressCheckFinishedSignal(self.index)) return resp.index 逻辑如下： _driver_fn + | | +---------------------------------------+-------------------------------------v | | | v | _launch_task_servers v + driver = HorovodRunDriverService | + +--------------+-------------------+ | | | | | | v v v +-------------------+---------------+ horovod.runner.task_fn ...... horovod.runner.task_fn | HorovodRunDriverService | + + | | | | | | | | | _all_task_addresses | | | | | v v | _task_addresses_for_driver | register_task +-----------+---------------+ +-------+--------------------+ | | | HorovodRunTaskService | | HorovodRunTaskService | | _task_addresses_for_tasks | \u003c--------------------------------+ | | | | | | | wait | | | _task_index_host_hash | | | \u003c------\u003e | | | | \u003c--------------------------------+ | | | | _task_host_hash_indices | register_task_to_task_addresses | | | | | | +---------------------------+ +----------------------------+ +-----------------------------------+ ` 图示: ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:6:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"6 总结 本文总结如下： 因为 Horovod 分布式训练 涉及到多个 hosts，所以如果要彼此访问，需要知道路由信息； 当所有 task 都启动，注册，probe 环中下一个worker 邻居完成 之后，DriverService 会得到路由信息（所有host之间的共有路由接口集合），返回给 Horovod 主体部分使用； network.BasicService 提供了网络服务功能； XXXService 都是通过 XXXClient作为接口才能访问； HorovodRunDriverService 和 HorovodRunTaskService 都最终继承了 network.BasicService，他们之间可以是异地运行交互。 HorovodRunTaskService 提供了 Task 部分服务功能，这些 task 需要注册到 Driver 之中（和Spark思路类似）。 HorovodRunDriverService 是对 BasicDriverService 的封装。BasicDriverService 就是 维护各种 task 地址以及相应关系，比如： _all_task_addresses ：记录了所有 task 的地址； _task_addresses_for_driver ：记录了所有 task 的地址，但是因为网卡接口有多种，这里选择与 本driver 地址匹配的地址； _task_addresses_for_tasks ：用来给某一个 task 分配一个地址，同时获取本 task 的一套网络接口； _task_index_host_hash ：每一个 task 有一个对应的 host hash。这个函数是 spark 相关会使用，具体是逐一通知 spark task 进入下一阶段。或者是为了获取某一个 host 对应的 host hash name； _task_host_hash_indices ：具体是被 rsh 使用，由 rank 得到 在 driver 中 task index 对应保持的 task address； SparkDriverService，SparkTaskService，ElasticDriver, Worker 都有什么区别和联系？ HorovodRunDriverService 这里只是用来得到路由信息，记录各种 Task 地址； SparkDriverService 除了记录路由和地址之外，还提交执行任务（Command），因为具体在哪一个Spark Executor启动之后，SparkDriverService 就需要知道 对应 SparkTaskService 的地址，这样才能知道提交到哪里； SparkTaskService 负责执行命令（抛弃了Spark Executor的逻辑，自己搞了一套），就是从 SparkDriverService 那里获得训练函数，然后启动 python 进程来执行； ElasticDriver 做得更多，因为还有弹性，需要容错； references: [1]. https://www.cnblogs.com/rossiXYZ/p/14882053.html [2]. https://www.zhihu.com/column/c_1491039346714746880 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_4/:7:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[4] -- 网络基础 \u0026 Driver","uri":"/posts/2022-10-08_horovod_4/"},{"categories":["Distributed Computing"],"content":"references: [1]. https://www.cnblogs.com/rossiXYZ/p/14881812.html ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:0:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"0 摘要 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，在业界得到了广泛应用。 本系列将通过源码分析来带领大家了解 Horovod。本文是系列第三篇，从 python 开始进入 Horovod 世界，看看 Horovodrun 做了什么。 前两篇链接如下： 深度学习分布式训练框架 Horovod (1) — 基础知识 深度学习分布式训练框架 horovod (2) — 从使用者角度切入 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:1:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"1 背景知识 首先介绍一些相关背景知识。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:2:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"1.1 分布式体系 在设计并行计算机时，最直接的方式就是多个计算单元共享一个内存。共享内存的编程在数据交换和访问上有较大的优势，程序编写起来更加简单。但在扩展性上有较大的瓶颈。 另一种方式为分布式内存。即每个计算单元有单独的内存，计算单元之间的数据访问通过互联网络去传输。这一架构在可移植性和扩展上会强很多，但消息的传递会成为程序设计中的难点。 将这两点结合，即是分布式共享内存并行计算机的架构，也是当今最常用的体系结构。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:2:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"1.2 并行任务通信 并行任务通信一般分为P2P(Point-to-point communication)和 Collective communication。 P2P通信这种模式只有一个sender和一个receiver，即点到点通信. Collective communication含多个sender多个receive Collective communication包含一些常见的原语 broadcast reduce，allreduce scatter，scatter reduce gather，allgather ring-base collectives ring-allreduce 传统Collective communication假设通信节点组成的topology是一颗fat tree，这样通信效率最高。但实际的通信topology可能比较复杂，并不是一个fat tree。因此一般用ring-based Collective communication。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:2:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"1.3 MPI MPI(Message Passing Interface) 是一种可以支持点对点和广播的通信协议，具体实现的库有很多，使用比较流行的包括 Open Mpi， Intel MPI 等等。 MPI 是一种消息传递编程模型。消息传递指用户必须通过显式地发送和接收消息来实现处理器间的数据交换。在这种并行编程中，每个控制流均有自己独立的地址空间，不同的控制流之间不能直接访问彼此的地址空间，必须通过显式的消息传递来实现。这种编程方式是大规模并行处理机(MPP)和机群(Cluster)采用的主要编程方式。由于消息传递程序设计要求用户很好地分解问题，组织不同控制流间的数据交换，并行计算粒度大，特别适合于大规模可扩展并行算法。 MPI 是基于进程的并行环境。进程拥有独立的虚拟地址空间和处理器调度，并且执行相互独立。MPI 设计为支持通过网络连接的机群系统，且通过消息传递来实现通信，消息传递是 MPI 的最基本特色。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:2:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"1.4 Open-MPI OpenMPI 是一种高性能消息传递库，最初是作为融合的技术和资源从其他几个项目（FT-MPI， LA-MPI， LAM/MPI， 以及 PACX-MPI），它是 MPI-2 标准的一个开源实现，由一些科研机构和企业一起开发和维护。因此，OpenMPI 能够从高性能社区中获得专业技术、工业技术和资源支持，来创建最好的 MPI 库。OpenMPI 提供给系统和软件供应商、程序开发者和研究人员很多便利。易于使用，并运行本身在各种各样的操作系统，网络互连，以及一批/调度系统。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:2:4","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"1.5 MPI 使用问题 因为MPI是分布式内存编程，在后面的开发中涉及节点间信息的传递。往往数据和程序是在多个节点上，所以需要保证执行命令时各节点之间信息的交换。 具体使用之中，就有两个问题: 这个多台机器Open-MPI是如何发现并建立连接的呢？ 多机多卡在训练过程中，传输环如何建立，这个也是决定了训练效率，那么Open-MPI如何去做呢？ 关于第一个问题： 设置SSH免密登录可以免去操作中密码的输入。各节点生成私钥和公钥后需要认证，此时可以保证本机免密登录。将各个子节点的公钥文件发送给主节点，然后分别加入到主节点的认证文件中，此时可以保证主节点对各个子节点的免密登录。最后将认证文件传回到每个子节点，从而保证各个子节点对其他节点之间的免密登录。 在 Open-MPI 启动的时候，可以指定--hostfile或者--host去指定要运行任务的 IP 或 Hostname，这样 Open-MPI 就会试图通过 ssh 免秘钥的方式试图去链接对方机器，并执行一系列命令，主要是为了同步环境变量、当前路径以及下发启动命令。 当然用户也可以通过其他方式给远程机器下发命令，这个可以通过环境变量OMPI_MCA_plm_rsh_agent指定。 关于第二个问题： 当所有的机器建立好连接，准备开始计算，为了能够最高效的去通信，Open-MPI中集成了组件——hwloc。该组件主要是为了单机硬件资源拓扑构建，进而构建最短路径通信。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:2:5","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"2 入口点 很多机器学习框架都会采用如下套路：shell脚本（可选），python端 和 C++端。 Shell脚本是启动运行的入口，负责解析参数，确认并且调用训练程序； Python是用户的接口，引入了C++库，封装了API，负责运行时和底层C++交互； C++实现底层训练逻辑； 以我们先看看 hordovodrun 脚本。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:3:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"2.1 如何运行 官方给出的 Hovorod 运行范例之一如下： horovodrun -np 2 -H localhost:4 --gloo python /horovod/examples/tensorflow2/tensorflow2_mnist.py 这里 -np 指的是进程的数量，localhost:4表示localhost节点上4个GPU。 注意，如果虚拟机只有一个核。想要强行地达到并行的效果，可以使用 -np参数，它会自动帮你把一个核心切成多份处理器，每一个分布式处理就是一个slot。 因此，我们可以从 horovodrun 这个命令入手看看。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:3:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"2.2 horovodrun 入口文件可以从 setup.py 看到，其就被映射成 horovod.runner.launch:run_commandline。 entry_points={ 'console_scripts': [ 'horovodrun = horovod.runner.launch:run_commandline' ] } 所以我们看看 run_commandline ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:3:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"2.3 run_commandline 该命令位于：horovod-master/horovod/runner/launch.py，我们摘录重要部分。 def run_commandline(): args = parse_args() _run(args) 于是进入到 _run 函数。可以看到，Horovod 会依据是否是弹性训练来选择不同的路径。我们在此系列中，会首先分析 非弹性训练 _run_static。 def _run(args): # if hosts are not specified, either parse from hostfile, or default as # localhost if not args.hosts and not args.host_discovery_script: if args.hostfile: args.hosts = hosts.parse_host_files(args.hostfile) else: # Set hosts to localhost if not specified args.hosts = 'localhost:{np}'.format(np=args.np) # Convert nics into set args.nics = set(args.nics.split(',')) if args.nics else None if _is_elastic(args): return _run_elastic(args) else: return _run_static(args) # 我们先看这里 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:3:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"2.4 非弹性训练 _run_static() 在 _run_static 之中做了如下操作： 首先解析各种参数，得到 settings； 会调用 driver_service.get_common_interfaces 获取网卡以及其他host的信息，依据这些信息会进行slot分配，这部分很复杂，具体我们会有专文讲解（下一篇）。 这里有一个问题：为什么要得到 host, slot, rank 之间的关系信息？由于工程上的考虑，底层 C++ 世界中对于 rank 的角色做了区分：rank 0 是 master，rank n 是 worker，所以这些信息需要决定并且传递给 C++世界； 会根据是否在参数中传递运行函数来决定采取何种路径，一般默认没有运行参数，所以会执行_launch_job 来启动训练 job； 具体代码如下： def _run_static(args): settings = hvd_settings.Settings(verbose=2 if args.verbose else 0, ssh_port=args.ssh_port, ssh_identity_file=args.ssh_identity_file, extra_mpi_args=args.mpi_args, tcp_flag=args.tcp_flag, binding_args=args.binding_args, key=secret.make_secret_key(), start_timeout=tmout, num_proc=args.np, hosts=args.hosts, output_filename=args.output_filename, run_func_mode=args.run_func is not None, nics=args.nics,...) # 首先解析各种参数，得到 settings fn_cache = None if not args.disable_cache: params = '' if args.np: params += str(args.np) + ' ' if args.hosts: params += str(args.hosts) + ' ' if args.ssh_port: params += str(args.ssh_port) if args.ssh_identity_file: params += args.ssh_identity_file parameters_hash = hashlib.md5(params.encode('utf-8')).hexdigest() fn_cache = cache.Cache(CACHE_FOLDER, CACHE_STALENESS_THRESHOLD_MINUTES, parameters_hash) # 获取网卡以及其他host的信息，依据这些信息会进行slot分配 all_host_names, _ = hosts.parse_hosts_and_slots(args.hosts) remote_host_names = network.filter_local_addresses(all_host_names) nics = driver_service.get_common_interfaces(settings, all_host_names, remote_host_names, fn_cache) if args.run_func: # get the driver IPv4 address driver_ip = network.get_driver_ip(nics) run_func_server = KVStoreServer(verbose=settings.verbose) # 启动内部KV服务器 run_func_server_port = run_func_server.start_server() put_data_into_kvstore(driver_ip, run_func_server_port, 'runfunc', 'func', args.run_func) # 把'func', args.run_func存储成KV command = [sys.executable, '-m', 'horovod.runner.run_task', str(driver_ip), str(run_func_server_port)] try: _launch_job(args, settings, nics, command) results = [None] * args.np for i in range(args.np): results[i] = read_data_from_kvstore(driver_ip, run_func_server_port,'runfunc_result', str(i)) return results finally: run_func_server.shutdown_server() else: command = args.command _launch_job(args, settings, nics, command) # 我们重点讲解这里 return None 目前逻辑如下： +-----------+ |horovodrun | +-----+-----+ | | v +--------+--------+ | run_commandline | +----+------+-----+ | | +---------+ +--------+ | | | | v v +-----+--------+ +----+--------+ | _run_elastic | | _run_static | | | | | +--------------+ +-------------+ 至此，我们已经分析完成 horovod 的入口，下面会分析具体如何启动 Job。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:3:4","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"3 运行训练 Job ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:4:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"3.1 _launch_job _launch_job 会根据配置或者安装情况来进行具体调用。我们看到有三种可能：gloo, mpi, js。 jsrun的资料很难找，所以我们重点看看 gloo, mpi 这两种。 def _launch_job(args, settings, nics, command): env = os.environ.copy() config_parser.set_env_from_args(env, args) def gloo_run_fn(): driver_ip = network.get_driver_ip(nics) gloo_run(settings, nics, env, driver_ip, command) def mpi_run_fn(): mpi_run(settings, nics, env, command) def js_run_fn(): js_run(settings, nics, env, command) run_controller(args.use_gloo, gloo_run_fn, args.use_mpi, mpi_run_fn, args.use_jsrun, js_run_fn, args.verbose) ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:4:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"3.2 run_controller run_controller 依然是一个中介函数，具体导入 gloo 或者 mpi。 def run_controller(use_gloo, gloo_run, use_mpi, mpi_run, use_jsrun, js_run, verbosity): if use_gloo: gloo_run() elif use_mpi: mpi_run() elif use_jsrun: js_run() else: if mpi_built(verbose=verbose): if lsf.LSFUtils.using_lsf() and is_jsrun_installed(): js_run() else: mpi_run() elif gloo_built(verbose=verbose): gloo_run() 目前逻辑如下： +-----------+ |horovodrun | +-----+-----+ | | v +--------+--------+ | run_commandline | +----+------+-----+ | | +---------+ +--------+ | | | | v v +-----+--------+ +----+--------+ | _run_elastic | | _run_static | | | | | +--------------+ +------+------+ | | v +------+------+ | _launch_job | | | +------+------+ | | v +---------+--------+ | run_controller | | | +----+----+-----+--+ | | | +-------------+ | +--------+ | | | | | | v v v +------+---+ +------+----+ +---+-----+ | gloo_run | | mpi_run | | js_run | | | | | | | +----------+ +-----------+ +---------+ 于是我们下面就分为两个分支介绍：gloo \u0026 mpi。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:4:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"4 Gloo 实现 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:5:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"4.1 Gloo 简介 Gloo 是 facebook出品的一个类似MPI的集合通信库（https://github.com/facebookincubator/gloo）。 集合通信库的主要特征是：大体上会遵照 MPI 提供的接口规定，实现了包括点对点通信（SEND,RECV等），集合通信（ REDUCE，BROADCAST，ALLREDUCE等）等相关接口，然后根据自己硬件或者是系统的需要，在底层实现上进行相应改动，保证接口的稳定和性能。 Gloo 为CPU和GPU提供了集合通信程序的优化实现。 它特别适用于GPU，因为它可以执行通信而无需使用GPUDirect 将数据传输到CPU的内存。 它还能够使用 NCCL 执行快速的节点内通信，并实现其自己的节点间例程计算。你不需要考虑内存数据的拷贝，只需要实现逻辑就可以。 Gloo 支持集合通信（collective Communication），并对其进行了优化。由于 GPU 之间可以直接进行数据交换，而无需经过 CPU 和内存，因此，在 GPU 上使用 gloo后端速度更快。 Horovod 为什么会选择 Gloo？个人认为除了其功能的全面性和性能之外，基于它可以二次开发是一个亮点，比如下面我们所说的 Rendezvous 功能就被 Horovod 用来实现弹性训练（我们后文有专门讲解）。 Gloo 和 MPI 都起到了同样类似作用： 一方面Horovod内集成了基于 Gloo 的AllReduce，类似于NCCL，都是用作梯度规约； 另一方面，Gloo 可以用来启动多个进程（Hovorod里用Rank表示），实现并行计算； 具体如下： +-----------------------+ +-----------------------+ +------------------------+ | gloo_run slot 1 | | gloo_run slot 2 | | gloo_run slot 3 | | | | | | | | +-------------------+ | | +------------------+ | | +------------------+ | | | python train.py | | | | python train.py | | | | python train.py | | +----+ +\u003c------+ +\u003c------+ +\u003c------+ | | | | | | | | | | | | | | | | +-------------------+ | | +------------------+ | | +------------------+ | | | | | | | | | | | +-----------------------+ +-----------------------+ +------------------------+ | | | | | | | v--------------------------------------------------------------------------------------\u003e Ring Allreduce on Gloo ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:5:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"4.2 Rendezvous 功能 4.2.1 Rendezvous 概念 在 Gloo 的文档中，如此说: The rendezvous process needs to happen exactly once per Gloo context. It makes participating Gloo processes exchange details for setting up their communication channels. For example, when the TCP transport is used, processes exchange IP address and port number details of listening sockets. Rendezvous can be executed by accessing a key/value store that is accessible by all participating processes. Every process is responsible for setting a number of keys and will wait until their peers have set their keys. The values stored against these keys hold the information that is passed to the transport layer. 大致意思是： Gloo 在每一个 Gloo context 之中有一个 rendezvous process，Gloo 利用它来交换通讯需要的细节。 Rendezvous 具体实现是可以依靠访问一个 KVstore 来完成。具体细节就是通过 KVstore 来进行交互。 以 Horovod 为例： Horovod 在进行容错 AllReduce 训练时，除了启动 worker 进程外，还会启动一个driver 进程。这个 driver 进程用于帮助 worker 调用 gloo 构造 AllReduce 通信环。 driver 进程中会创建一个带有 KVStore 的 RendezvousServer，driver 会将参与通信的 worker 的 ip 等信息存入 KVstore 中。 然后 worker 就可以调用 gloo 来访问 RendezvousServer 构造通信环了。 4.2.2 RendezvousServer 具体代码如下，可以看到是启动了RendezvousHTTPServer(就是继承拓展了 HTTPServer): class RendezvousServer: def __init__(self, verbose=0): self._httpd = None self._listen_thread = None self._verbose = verbose # Rendezvous function finds a available port, create http socket, # and start listening loop to handle request # self.httpd.init needs to be called after server start def start(self, handler_cls=RendezvousHandler): # 下面马上介绍 self._httpd, port = find_port( lambda addr: RendezvousHTTPServer( addr, handler_cls, self._verbose)) # start the listening loop self._listen_thread = in_thread(target=self._httpd.serve_forever) return port def init(self, host_alloc_plan): self._httpd.init(host_alloc_plan) def stop(self): self._httpd.shutdown() self._listen_thread.join() 4.2.3 KVStore KVStore 是由 KVStoreHandler 来体现，RendezvousHandler 继承了 KVStoreHandler，进而被 RendezvousServer 作为 handler 使用。 KVStoreHandler 精简版代码如下： class KVStoreHandler(SimpleHTTPRequestHandler): # Override PUT handler def do_PUT(self): paths = self.path.split('/') _, scope, key = paths # Get body length content_length = int(self.headers['Content-Length']) value = self.rfile.read(content_length) self._put_value(scope, key, value) self.send_status_code(OK) def _put_value(self, scope, key, value): with self.server.cache_lock: scope_dict = self.server.cache.setdefault(scope, {}) scope_dict[key] = value 4.2.4 底层使用 Rendezvous 具体如何使用？简要的说： Python世界构建了一个 RendezvousServer，其地址配置在环境变量（或者其他方式）中。 在 C++ 世界中，比如 horovod/common/gloo/gloo_context.h，horovod/common/gloo/gloo_context.cc 之中有使用。即得到 Python 配置的 RendezvousServer 的地址端口等，然后构建 gloo 所需的 context。 #define HOROVOD_HOSTNAME \"HOROVOD_HOSTNAME\" #define HOROVOD_RANK \"HOROVOD_RANK\" #define HOROVOD_SIZE \"HOROVOD_SIZE\" #define HOROVOD_LOCAL_RANK \"HOROVOD_LOCAL_RANK\" #define HOROVOD_LOCAL_SIZE \"HOROVOD_LOCAL_SIZE\" #define HOROVOD_CROSS_RANK \"HOROVOD_CROSS_RANK\" #define HOROVOD_CROSS_SIZE \"HOROVOD_CROSS_SIZE\" #define HOROVOD_ELASTIC \"HOROVOD_ELASTIC\" ctx = Rendezvous(HOROVOD_GLOO_GLOBAL_PREFIX, rendezvous_addr_env, rendezvous_port, rank, size, dev, timeout); local_ctx = Rendezvous(HOROVOD_GLOO_LOCAL_PREFIX + hostname, rendezvous_addr_env, rendezvous_port, local_rank, local_size, dev, timeout); cross_ctx = Rendezvous(HOROVOD_GLOO_CROSS_PREFIX + std::to_string(local_rank), rendezvous_addr_env, rendezvous_port, cross_rank, cross_size, dev, timeout); 逻辑如下，C++世界会从python世界的获取到RendezvousServer的 IP，port： +---------------------\u003e System Env +------------------+ | addr, port, ... addr, port, ... | | + | | | | | | | | | | | | | | | | | Python | C++ | | | | | | | | | | | | v +---------+---------------+ | +------------+--------+ | RendezvousServer | | |GlooContext | | | | | | | | | | | | | | | | | RendezvousHandler | | | Rendezvous | | | | | | +-------------------------+ | +---------------------+ | + ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:5:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"4.3 Horovd 的 gloo 入口 gloo_run 是 horovod 之中，gloo 模块的 相关入口。 注释说的很清楚：每一个 thread 将使用 ssh 命令在远程host之上启动训练job。 def gloo_run(settings, nics, env, server_ip, command): # Each thread will use ssh command to launch the job on each remote host. If an # error occurs in one thread, entire process will be terminated. Otherwise, # threads will keep running and ssh session. exec_command = _exec_command_fn(settings) launch_gloo(command, exec_command, settings, nics, env, server_ip) 就是用 launch_gloo 来运行 exec_command。 此时 command 参数类似 \"['python', 'train.py']\"。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:5:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"4.4 构建可执行环境 gloo_run 的第一部分是 exec_command = _exec_command_fn(settings)，就是基于各种配置来生成可以执行命令环境。如果是远程，就得生成相关远程可运行命令环境（包括切换目录，远程执行等等）。 4.4.1 _exec_command_fn 具体又可以分为两部分： 利用 get_remote_command 来生成相关远程可运行环境，比如在训练脚本前面加上 'ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no'； 调整输入输出，利用 safe_shell_exec.execute 来实现安全执行能力； 具体如下： def _exec_command_fn(settings): \"\"\" executes the jobs defined by run command on hosts. :param hosts_alloc: list of dict indicating the allocating info. For example, [{'Hostname':'worker-0', 'Rank': 0, 'Local_rank': 0, 'Cross_rank':0, 'Size':2, 'Local_size':1, 'Cross_size':2}, {'Hostname':'worker-1', 'Rank': 1, 'Local_rank': 0, 'Cross_rank':1, 'Size':2, 'Local_size':1, 'Cross_size':2} ] :type hosts_alloc: list(dict) :param remote_host_names: names that are resolved to one of the addresses of remote hosts interfaces. :param _run_command: command to execute \"\"\" def _exec_command(command, slot_info, events): index = slot_info.rank host_name = slot_info.hostname host_address = network.resolve_host_address(host_name) local_addresses = network.get_local_host_addresses() # 需要构建远程命令 if host_address not in local_addresses: local_command = quote('cd {pwd} \u003e /dev/null 2\u003e\u00261 ; {command}' .format(pwd=os.getcwd(), command=command)) command = get_remote_command(local_command, host=host_name, port=settings.ssh_port, identity_file=settings.ssh_identity_file) # Redirect output if requested # 调整输入输出，利用 safe_shell_exec.execute 来实现安全执行能力 stdout = stderr = None stdout_file = stderr_file = None if settings.output_filename: padded_rank = _pad_rank(index, settings.num_proc) output_dir_rank = os.path.join(settings.output_filename, 'rank.{rank}'.format(rank=padded_rank)) if not os.path.exists(output_dir_rank): os.mkdir(output_dir_rank) stdout_file = open(os.path.join(output_dir_rank, 'stdout'), 'w') stderr_file = open(os.path.join(output_dir_rank, 'stderr'), 'w') stdout = MultiFile([sys.stdout, stdout_file]) stderr = MultiFile([sys.stderr, stderr_file]) # 实现安全执行能力 exit_code = safe_shell_exec.execute(command, index=index, stdout=stdout, stderr=stderr, events=events,...) return exit_code, time.time() return _exec_command 4.4.2 get_remote_command 本函数是针对远程 host，获取如何在其上运行的方式。这个函数是比较新加入的，具体和 kubeflow mpi operator 也相关，以后有机会再分析。 SSH_COMMAND_PREFIX = 'ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no' def get_ssh_command(local_command, host, port=None, identity_file=None, timeout_s=None): port_arg = f'-p {port}' if port is not None else '' identity_file_arg = f'-i {identity_file}' if identity_file is not None else '' timeout_arg = f'-o ConnectTimeout={timeout_s}' if timeout_s is not None else '' return f'{SSH_COMMAND_PREFIX} {host} {port_arg} {identity_file_arg} {timeout_arg} {local_command}' def get_remote_command(local_command, host, port=None, identity_file=None, timeout_s=None): return f'{env_util.KUBEFLOW_MPI_EXEC} {host} {local_command}' if env_util.is_kubeflow_mpi() \\ else get_ssh_command(local_command, host, port, identity_file, timeout_s) 大致逻辑如下： command : python train.py + | | v +---------+-------------+ | | | get_remote_command | | | +---------+-------------+ | | v ssh -o ... python train.py + | | | v +---------+--------------+ |safe_shell_exec.execute | | | +------------------------+ ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:5:4","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"4.5 使用 gloo 执行命令 获取到了可执行环境 exec_command 与 执行命令 command 之后，就可以使用 gloo 来执行命令了。 每个 command 都是被 exec_command 来执行。 launch_gloo 来获取命令，各种配置信息，网卡信息（nics，比如 {’lo’}），host信息等，然后开始运行，就是开始运行我们的训练代码了，具体是： 建立 RendezvousServer，这个会被底层 Gloo C++ 环境使用到; host_alloc_plan = get_host_assignments 来根据host进行分配slot，就是horovod的哪个rank应该在哪个host上的哪个slot之上运行； get_run_command 获取到可执行命令； slot_info_to_command_fn 来得到在slot之上可执行的 slot command； 依据 slot_info_to_command_fn 构建 args_list，这个 list 之中，每一个arg就是一个 slot command； 多线程执行，在每一个 exec_command 之上执行每一个 arg（slot command）； 代码如下： def launch_gloo(command, exec_command, settings, nics, env, server_ip): \"\"\" Launches the given command multiple times using gloo. Each command is launched via exec_command. :param command: command to launch :param exec_command: means to execute a single command :param settings: settings for the distribution :param nics: common interfaces :param env: environment to use :param server_ip: ip to use for rendezvous server \"\"\" # Make the output directory if it does not exist if settings.output_filename: _mkdir_p(settings.output_filename) # start global rendezvous server and get port that it is listening on # 建立 RendezvousServer，这个会被底层 Gloo C++ 环境使用到 rendezvous = RendezvousServer(settings.verbose) # allocate processes into slots # 来根据host进行分配slot，就是horovod的哪个rank应该在哪个host上的哪个slot之上运行 hosts = parse_hosts(settings.hosts) host_alloc_plan = get_host_assignments(hosts, settings.num_proc) # start global rendezvous server and get port that it is listening on global_rendezv_port = rendezvous.start() rendezvous.init(host_alloc_plan) # 获取到可执行命令 run_command = get_run_command(command, server_ip, nics, global_rendezv_port) # 得到在slot之上可执行的 slot command slot_info_to_command = _slot_info_to_command_fn(run_command, env) event = register_shutdown_event() # 依据 slot_info_to_command_fn 构建 args_list，这个 list 之中，每一个arg就是一个 slot command args_list = [[slot_info_to_command(slot_info), slot_info, [event]] for slot_info in host_alloc_plan] # If an error occurs in one thread, entire process will be terminated. # Otherwise, threads will keep running. # 多线程执行，在每一个 exec_command 之上执行每一个 arg（slot command） res = threads.execute_function_multithreaded(exec_command, args_list, block_until_all_done=True) for name, value in sorted(res.items(), key=lambda item: item[1][1]): exit_code, timestamp = value 具体 HostInfo.from_string 信息如下： class HostInfo: def __init__(self, hostname, slots): self.hostname = hostname self.slots = slots @staticmethod def from_string(host_string): hostname, slots = host_string.strip().split(':') return HostInfo(hostname, int(slots)) 4.5.1.2 分配方案 get_host_assignments 会依据 host 和 process capacities (slots) 来给 Horovod 之中的进程分配，即给出一个 horovod rank 和 slot 的对应关系。设置了几个 np，就有几个 slot。 给出的分配方案类似如下，这样就知道了哪个rank对应于哪个host上的哪个slot： [ SlotInfo(hostname='h1', rank=0, local_rank=0, cross_rank=0, size=2, local_size=2, coress_size=1), SlotInfo(hostname='h2', rank=1, local_rank=0, cross_rank=0, size=2, local_size=2, coress_size=1), ] def get_host_assignments(hosts, min_np, max_np=None): \"\"\"Assign hosts with process capacities (slots) to ranks in the Horovod process. This function will try to allocate as many as possible processes on the same host to leverage local network. :param hosts: list of HostInfo objects describing host and slot capacity :type hosts: list[HostInfo] :param min_np: minimum number of processes to be allocated :param max_np: (optional) maximum number of processes to be allocated :return: a list of the allocation of process on hosts in a `SlotInfo` object. :rtype: list[SlotInfo] \"\"\" host_ranks = [] cross_ranks = collections.defaultdict(dict) rank = 0 # 依据 hosts 信息构建 rank, local rank, cross rank(hierarchical allreduce所需要) for host_info in hosts: ranks = [] for local_rank in range(host_info.slots): if rank == max_np: break ranks.append(rank) rank += 1 cross_ranks_at_local = cross_ranks[local_rank] cross_ranks_at_local[host_info.hostname] = len(cross_ranks_at_local) host_ranks.append((host_info, ranks)) world_size = rank # 给出一个 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:5:5","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"4.6 C++举例 我们给出一个底层代码，大家就进一步了解 Gloo 可以起到什么作用。 这个就是 Horovod 之中，rank 0 最终给其他 rank 发送构建好的 Tensor。 void GlooController::SendFinalTensors(ResponseList\u0026 response_list) { // Notify all nodes which tensors we'd like to reduce at this step. std::string encoded_response; ResponseList::SerializeToString(response_list, encoded_response); // Boardcast the response length int encoded_response_length = (int)encoded_response.length() + 1; { gloo::BroadcastOptions opts(gloo_context_.ctx); opts.setOutput(\u0026encoded_response_length, 1); opts.setRoot(RANK_ZERO); gloo::broadcast(opts); // 广播给其他rank } // Boardcast the response { gloo::BroadcastOptions opts(gloo_context_.ctx); opts.setOutput((uint8_t*)(encoded_response.c_str()), encoded_response_length); opts.setRoot(RANK_ZERO); gloo::broadcast(opts); // 广播给其他rank } } ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:5:6","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"5 Mpi 实现 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:6:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"5.1 openmpi 库 horovod 这里主要依赖 openmpi。 MPI：英文全称是Message Passing Interface，MPI是一个跨语言的通讯协议，用于编写并行计算机。支持点对点和广播。MPI是一个信息传递应用程序接口，包括协议和和语义说明，他们指明其如何在各种实现中发挥其特性。MPI的目标是高性能，大规模性，和可移植性。 openMPI：英文全称是open Message Passing Interface。openMPI是MPI的一种实现，一种库项目。 MPI在Hovorod的角色比较特殊： 一方面Horovod内集成了基于MPI的AllReduce，类似于NCCL，都是用作梯度规约； 另一方面，MPI可以用来在所有机器上启动多个进程(Hovorod里用Rank表示)，实现并行计算； ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:6:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"5.2 mpi_run 函数 此部分代码位于：horovod/runner/mpi_run.py。 首先摘录其关键代码如下，可以看出来其核心是运行 mpirun 命令。 # 我是下面大段代码中的关键代码！ mpirun_command = ( 'mpirun {basic_args} ' '-np {num_proc}{ppn_arg}{hosts_arg} ' '{binding_args} ' '{mpi_args} ' '{mpi_ssh_args} ' '{tcp_intf_arg} ' '{nccl_socket_intf_arg} ' '{output_filename_arg} ' '{env} {extra_mpi_args} {command}' .format(basic_args=basic_args, num_proc=settings.num_proc, ppn_arg=ppn_arg, hosts_arg=hosts_arg, binding_args=binding_args, mpi_args=' '.join(mpi_impl_flags), tcp_intf_arg=tcp_intf_arg, nccl_socket_intf_arg=nccl_socket_intf_arg, mpi_ssh_args=mpi_ssh_args, output_filename_arg=' '.join(output), env=env_list, extra_mpi_args=settings.extra_mpi_args if settings.extra_mpi_args else '', command=' '.join(quote(par) for par in command)) ) # Execute the mpirun command. if settings.run_func_mode: exit_code = safe_shell_exec.execute(mpirun_command, env=env, stdout=stdout, stderr=stderr) else: os.execve('/bin/sh', ['/bin/sh', '-c', mpirun_command], env) 就是依据各种配置以及参数来构建 mpirun 命令的所有参数，比如 ssh 的参数，mpi 参数，nccl 参数等等。 最后得到的 mpirun 命令举例如下： mpirun --allow-run-as-root --np 2 -bind-to none -map-by slot \\ -x NCCL_DEBUG=INFO -x LD_LIBRARY_PATH -x PATH \\ -mca pml ob1 -mca btl ^openib \\ python train.py 具体代码如下，具体是： # 上面代码是我之中的片段 def mpi_run(settings, nics, env, command, stdout=None, stderr=None): \"\"\" Runs mpi_run. Args: settings: Settings for running MPI. Note: settings.num_proc and settings.hosts must not be None. nics: Interfaces to include by MPI. env: Environment dictionary to use for running command. command: Command and arguments to run as a list of string. stdout: Stdout of the mpi process. Only used when settings.run_func_mode is True. stderr: Stderr of the mpi process. Only used when settings.run_func_mode is True. \"\"\" # 得到各种配置 mpi_impl_flags, impl_binding_args, mpi = _get_mpi_implementation_flags(settings.tcp_flag, env=env) impi = _IMPI_IMPL == mpi # 处理ssh参数 ssh_args = [] if settings.ssh_port: ssh_args += [f'-p {settings.ssh_port}'] if settings.ssh_identity_file: ssh_args += [f'-i {settings.ssh_identity_file}'] mpi_ssh_args = '' if ssh_args: joined_ssh_args = ' '.join(ssh_args) mpi_ssh_args = f'-bootstrap=ssh -bootstrap-exec-args \\\"{joined_ssh_args}\\\"' if impi else f'-mca plm_rsh_args \\\"{joined_ssh_args}\\\"' # 处理网络配置，网卡信息等 tcp_intf_arg = '-mca btl_tcp_if_include {nics}'.format( nics=','.join(nics)) if nics and not impi else '' nccl_socket_intf_arg = '-{opt} NCCL_SOCKET_IFNAME={nics}'.format( opt='genv' if impi else 'x', nics=','.join(nics)) if nics else '' # 处理host信息 # On large cluster runs (e.g. Summit), we need extra settings to work around OpenMPI issues host_names, host_to_slots = hosts.parse_hosts_and_slots(settings.hosts) if not impi and host_names and len(host_names) \u003e= _LARGE_CLUSTER_THRESHOLD: mpi_impl_flags.append('-mca plm_rsh_no_tree_spawn true') mpi_impl_flags.append('-mca plm_rsh_num_concurrent {}'.format(len(host_names))) # if user does not specify any hosts, mpirun by default uses local host. # There is no need to specify localhost. hosts_arg = '-{opt} {hosts}'.format(opt='hosts' if impi else 'H', hosts=','.join(host_names) if host_names and impi else settings.hosts) # 处理ppn配置 ppn_arg = ' ' if host_to_slots and impi: ppn = host_to_slots[host_names[0]] for h_name in host_names[1:]: ppn_arg = ' -ppn {} '.format(ppn) # 处理超时配置 if settings.prefix_output_with_timestamp and not impi: mpi_impl_flags.append('--timestamp-output') binding_args = settings.binding_args if settings.binding_args and not impi else ' '.join(impl_binding_args) # 配置需要root身份运行 basic_args = '-l' if impi else '--allow-run-as-root --tag-output' output = [] if settings.output_filename: output.append('-outfile-pattern' if impi else '--output-filename') output.append(settings.output_filename) # 构建环境信息列表 env_list = '' if impi else ' '.join( '-x %s' % key for key in sorted(env.keys()) if env_util.is_exportable(key)) # 构建最终的 MPI 命令 # Pass all the env variables to the mpirun command. mpirun_command = ( 'mpirun {basic_args} ' '-np {num_proc}{ppn_","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:6:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"5.3 mpirun命令 因为 mpi_run 使用的是 mpirun 命令来运行，所以我们介绍一下。 mpirun是MPI程序的启动脚本，它简化了并行进程的启动过程，尽可能屏蔽了底层的实现细节，从而为用户提供了一个通用的MPI并行机制。 在用mpirun命令执行并行程序时，参数-np指明了需要并行运行的进程个数。mpirun首先在本地结点上启动一个进程，然后根据/usr/local/share/machines.LINUX文件中所列出的主机，为每个主机启动一个进程。若进程数比可用的并行节点数多，则多余的进程将重新按照上述规则进行。按这个机制分配好进程后，一般会给每个节点分一个固定的标号，类似于身份证了，后续在消息传递中会用到。 这里需要说明的是，实际运行的 orterun(Open MPI SPMD / MPMD启动器; mpirun / mpiexec只是它的符号链接) 命令举例如下： mpirun -np 4 \\ -bind-to none -map-by slot \\ -x NCCL_DEBUG=INFO -x LD_LIBRARY_PATH -x PATH \\ -mca pml ob1 -mca btl ^openib \\ python train.py ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:6:3","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"6 总结 对比 gloo 和 mpi 的实现，我们还是能看出来区别。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:7:0","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"6.1 gloo gloo 只是一个库，需要 horovod 来完成命令分发功能。 gloo 需要 horovod 自己实现本地运行和远端运行方式，即 get_remote_command 函数 实现 'ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no'。 gloo 需要实现 RendezvousServer，底层会利用 RendezvousServer 进行通讯。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:7:1","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"6.2 mpi mpi 则功能强大很多，只要把命令配置成被 mpirun 包装，openmpi 就可以自行完成命令分发执行。说到底，horovod 是一个 mpirun 程序，即使运行了 tensor flow，也是一个mpi程序，可以互相交互。 references: [1]. https://www.cnblogs.com/rossiXYZ/p/14881812.html ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_3/:7:2","tags":["Horovod"],"title":"深度学习分布式训练框架 horovod[3] -- Horovodrun背后做了什么","uri":"/posts/2022-10-08_horovod_3/"},{"categories":["Distributed Computing"],"content":"0 摘要 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，在业界得到了广泛应用。 本系列将通过源码分析来带领大家了解 Horovod。系列大约有15 ～ 18 篇，本文是系列第二篇，从用户角度切入 Horovod。 前一篇参见如下： 深度学习分布式训练框架 Horovod[1] – 基础知识 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:1:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"1 Horovod 简介 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，支持TensorFlow，Keras，PyTorch和MXNet。Horovod 的名字来自于俄国传统民间舞蹈，舞者手牵手围成一个圈跳舞，与分布式 TensorFlow 流程使用 Horovod 互相通信的场景很像。 因为各个机器学习框架对于底层集合通信库（ nccl，openmpi，gloo 等等）的利用水平可能各不相同，使得他们无法充分利用这些底层集合通信库的威力。因而，hovorod 就整合这些框架，提供一个易用高效的解决方案。 Uber的工程师就是根据FaceBook的一篇paper：“Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour”和百度的一篇“Bringing HPC Techniques to Deep Learning” 改进并发布了开源框架Horovod。 Horovod 相比于百度的工作，并无学术上的贡献。但是 Horovod 扎实的工程实现，使得它受到了更多的关注。它最大的优势在于对 RingAllReduce 进行了更高层次的抽象，使其支持多种不同的框架。同时引入了 Nvidia NCCL，对 GPU 更加友好。 Horovod依赖于Nvidia的 NCCL2 做 All Reduce，依赖于MPI做进程间通信，简化了同步多 GPU 或多节点分布式训练的开发流程。由于使用了NCCL2，Horovod也可以利用以下功能：NVLINK，RDMA，GPUDirectRDMA，自动检测通信拓扑，能够回退到 PCIe 和 TCP/IP 通信。 我们需要几个问题来引导分析： Hovorod 怎么进行数据分割？ Hovorod 怎么进行训练代码分发？ Hovorod 启动时候，python 和 C++ 都做了什么？ 如何确保 Hovorod 启动时候步骤一致； ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:2:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"2 Hovorod 机制概述 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:3:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"2.1 Horovod 机制 Horovod使用数据并行化策略在GPU上分配训练。 在数据并行化中，作业中的每个GPU都会接收其自己的数据批处理的独立切片，即它的“批处理切片”。 每个GPU都使用自己分配到的数据来独立计算，进行梯度更新。 假如使用两个GPU，批处理大小为32，则第一个GPU将处理前16条记录的正向传播和向后传播，以及第二个GPU处理后16条记录的正向传播和向后传播。然后，这些梯度更新将在GPU之间平均在一起，最后应用于模型。 每一个迭代的操作方法如下： 每个 worker 将维护自己的模型权重副本和自己的数据集副本。 收到执行信号后，每个工作进程都会从数据集中提取一个不相交的批次，并计算该批次的梯度。 Workers 使用ring all-reduce算法来同步彼此的梯度，从而在本地所有节点上计算同样的平均梯度。 将每个设备上的梯度 tensor 切分成长度大致相等的 num_devices 个分片，后续每一次通信都将给下一个邻居发送一个自己的分片（同时从上一个邻居接受一个新分片）。 ScatterReduce 阶段：通过 num_devices - 1 轮通信和相加，在每个 device 上都计算出一个 tensor 分片的和，即每个 device 将有一个块，其中包含所有device 中该块中所有值的总和；具体如下： AllGather 阶段：通过 num_devices - 1 轮通信和覆盖，将上个阶段计算出的每个 tensor 分片的和 广播到其他 device；最终所有节点都拥有所有tensor分片和。具体如下： 在每个设备上合并分片，得到梯度和，然后除以 num_devices，得到平均梯度； 每个 worker 将 梯度更新 应用于其模型的本地副本。 执行下一个batch。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:3:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"3 示例代码 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:4:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"3.1 摘要代码 我们此处给出官网示例代码部分摘要，具体分析参见下面代码中的注释。 import tensorflow as tf import horovod.tensorflow.keras as hvd # Horovod: initialize Horovod. hvd.init() # 初始化 Horovod，启动相关线程和MPI线程 # Horovod: pin GPU to be used to process local rank (one GPU per process) # 依据 local rank 为不同的进程分配不同的GPU gpus = tf.config.experimental.list_physical_devices('GPU') for gpu in gpus: tf.config.experimental.set_memory_growth(gpu, True) if gpus: tf.config.experimental.set_visible_devices(gpus[hvd.local_rank()], 'GPU') (mnist_images, mnist_labels), _ = \\ tf.keras.datasets.mnist.load_data(path='mnist-%d.npz' % hvd.rank()) # 切分数据 dataset = tf.data.Dataset.from_tensor_slices( (tf.cast(mnist_images[..., tf.newaxis] / 255.0, tf.float32), tf.cast(mnist_labels, tf.int64)) ) dataset = dataset.repeat().shuffle(10000).batch(128) mnist_model = tf.keras.Sequential([ tf.keras.layers.Conv2D(32, [3, 3], activation='relu'), ...... tf.keras.layers.Dense(10, activation='softmax') ]) # Horovod: adjust learning rate based on number of GPUs. scaled_lr = 0.001 * hvd.size() # 根据Worker的数量增加学习率的大小 opt = tf.optimizers.Adam(scaled_lr) # Horovod: add Horovod DistributedOptimizer. # 把常规TensorFlow Optimizer通过Horovod包装起来，进而使用 ring-allreduce 来得到平均梯度 opt = hvd.DistributedOptimizer( opt, backward_passes_per_step=1, average_aggregated_gradients=True) # Horovod: Specify `experimental_run_tf_function=False` to ensure TensorFlow # uses hvd.DistributedOptimizer() to compute gradients. mnist_model.compile(loss=tf.losses.SparseCategoricalCrossentropy(), optimizer=opt, metrics=['accuracy'], experimental_run_tf_function=False) callbacks = [ hvd.callbacks.BroadcastGlobalVariablesCallback(0), # 广播初始化，将模型的参数从第一个设备传向其他设备，以保证初始化模型参数的一致性 hvd.callbacks.MetricAverageCallback(), hvd.callbacks.LearningRateWarmupCallback(initial_lr=scaled_lr, warmup_epochs=3, verbose=1), ] # Horovod: save checkpoints only on worker 0 to prevent other workers from corrupting them. # 只有设备0需要保存模型参数作为checkpoint if hvd.rank() == 0: callbacks.append(tf.keras.callbacks.ModelCheckpoint('./checkpoint-{epoch}.h5')) # Horovod: write logs on worker 0. verbose = 1 if hvd.rank() == 0 else 0 # Train the model. # Horovod: adjust number of steps based on number of GPUs. mnist_model.fit(dataset, steps_per_epoch=500 // hvd.size(), callbacks=callbacks, epochs=24, verbose=verbose) ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:4:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"3.2 horovodrun Horovod训练脚本未作为Python脚本启动。 例如，您不能使用python train.py运行此脚本。 需要采用特殊的CLI命令 horovodrun 来启动（训练代码 train.py 需要手动拷贝到各个节点上，且目录相同）： $ horovodrun -np 4 -H localhost:4 python train.py ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:4:2","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4 运行逻辑 我们按照顺序梳理，看看在程序初始化过程背后都做了什么。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.1 引入python文件 如下代码会引入各种相关python文件。 import tensorflow as tf import horovod.tensorflow.keras as hvd ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.2 初始化 in python python 世界的初始化位于 horovod-master/horovod/mxnet/mpi_ops.py 4.2.1 引入SO库 4.2.1.1 SO库 horovod/tensorflow/mpi_ops.py 之中会引入SO库。 比如 dist-packages/horovod/tensorflow/mpi_lib.cpython-36m-x86_64-linux-gnu.so。 SO库 就是 horovod 中 C++ 代码编译出来的结果。 def _load_library(name): \"\"\"Loads a .so file containing the specified operators. \"\"\" filename = resource_loader.get_path_to_datafile(name) library = load_library.load_op_library(filename) return library # Check possible symbol not found error from tensorflow version mismatch try: MPI_LIB = _load_library('mpi_lib' + get_ext_suffix()) except Exception as e: check_installed_version('tensorflow', tf.__version__, e) raise e else: check_installed_version('tensorflow', tf.__version__) 4.2.2.2 SO作用 引入库的作用是获取到 C++ 的函数，并且用 python 封装一下，这样就可以在 python 世界使用 C++代码了。 由下文可以看出来，python 的 _allreduce 函数就会把功能转发给 C++，由 MPI_LIB.horovod_allreduce 完成。 def _allreduce(tensor, name=None, op=Sum, prescale_factor=1.0, postscale_factor=1.0, ignore_name_scope=False): if name is None and not _executing_eagerly(): name = 'HorovodAllreduce_%s' % _normalize_name(tensor.name) return MPI_LIB.horovod_allreduce(tensor, name=name, reduce_op=op, prescale_factor=prescale_factor, postscale_factor=postscale_factor, ignore_name_scope=ignore_name_scope) 4.2.2 初始化配置 我们摘录了主要部分，就是初始化 _HorovodBasics，然后从 _HorovodBasics 内获取各种函数，变量和配置，比如是否编译了mpi，gloo等等. from horovod.common.basics import HorovodBasics as _HorovodBasics _basics = _HorovodBasics(__file__, 'mpi_lib') # import basic methods init = _basics.init size = _basics.size local_size = _basics.local_size rank = _basics.rank local_rank = _basics.local_rank mpi_built = _basics.mpi_built gloo_enabled = _basics.gloo_enabled ...... 4.2.3 hvd.init() 初始化 首先需要用 hvd.init() 来初始化，horovod 管理的所有状态都会传到 hvd 对象中。 # Horovod: initialize Horovod. hvd.init() 此处调用的是 HorovodBasics 中的函数，我们看看做了什么。 可以看到，这部分会一直深入到 C++世界，调用了大量的 MPI_LIB_CTYPES 函数，所以我们接下来就要进入到 C++的世界看看。 def init(self, comm=None): \"\"\"A function that initializes Horovod. \"\"\" atexit.register(self.shutdown) if not isinstance(comm, list): mpi_built = self.MPI_LIB_CTYPES.horovod_mpi_built() from mpi4py import MPI if MPI._sizeof(MPI.Comm) == ctypes.sizeof(ctypes.c_int): MPI_Comm = ctypes.c_int else: MPI_Comm = ctypes.c_void_p self.MPI_LIB_CTYPES.horovod_init_comm.argtypes = [MPI_Comm] comm_obj = MPI_Comm.from_address(MPI._addressof(comm)) self.MPI_LIB_CTYPES.horovod_init_comm(comm_obj) else: comm_size = len(comm) self.MPI_LIB_CTYPES.horovod_init( (ctypes.c_int * comm_size)(*comm), ctypes.c_int(comm_size)) 目前逻辑如下图： Import python files + | | v Import C++ SO files | | | v Create _HorovodBasics + | | v hvd.init() + Python | +------------------------------------------+ C++ | | v ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:2","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.3 初始化 in C++ 4.3.1 horovod_init_comm 在初始化的时候，Horovod 会： 调用 MPI_Comm_dup 获取一个 Communicator，这样就有了和 MPI 协调的基础。 然后调用 InitializeHorovodOnce。 void horovod_init_comm(MPI_Comm comm) { MPI_Comm_dup(comm, \u0026mpi_context.mpi_comm); InitializeHorovodOnce(nullptr, 0); } 4.3.2 InitializeHorovodOnce InitializeHorovodOnce 是初始化的主要工作，主要是： 依据是否编译了 mpi 或者 gloo，对各自的 context 进行处理，为 globalstate 创建对应的 controller； 启动了后台线程 BackgroundThreadLoop 用来在各个worker之间协调； void horovod_init(const int* ranks, int nranks) { InitializeHorovodOnce(ranks, nranks); } void InitializeHorovodOnce(const int* ranks, int nranks) { // Ensure background thread is only started once. if (!horovod_global.initialize_flag.test_and_set()) { horovod_global.control_operation = ParseControllerOpsFromEnv(); horovod_global.cpu_operation = ParseCPUOpsFromEnv(); #if HAVE_MPI // 依据是否编译了MPI进行处理 // Enable mpi is it's used either in cpu data transfer or controller if (horovod_global.cpu_operation == LibType::MPI || horovod_global.control_operation == LibType::MPI) { mpi_context.Enable(); } if (horovod_global.control_operation == LibType::MPI){ // 创建一个 MPIController 对象 horovod_global.controller.reset(new MPIController( horovod_global.response_cache, horovod_global.tensor_queue, horovod_global.timeline, horovod_global.parameter_manager, horovod_global.group_table, mpi_context)); horovod_global.controller-\u003eSetRanks(ranks, nranks); } #endif #if HAVE_GLOO // 依据是否编译了 GLOO 进行处理 // Enable gloo is it's used either in cpu data transfer or controller if (horovod_global.cpu_operation == LibType::GLOO || horovod_global.control_operation == LibType::GLOO) { gloo_context.Enable(); } if (horovod_global.control_operation == LibType::GLOO) { horovod_global.controller.reset(new GlooController( horovod_global.response_cache, horovod_global.tensor_queue, horovod_global.timeline, horovod_global.parameter_manager, horovod_global.group_table, gloo_context)); } #endif // Reset initialization flag // 启动后台线程 horovod_global.initialization_done = false; horovod_global.background_thread = std::thread( BackgroundThreadLoop, std::ref(horovod_global)); } // Wait to ensure that the background thread has finished initializing MPI. while (!horovod_global.initialization_done) { std::this_thread::sleep_for(std::chrono::milliseconds(1)); } } 4.3.3 HorovodGlobalState 在 C++ 世界，HorovodGlobalState 起到了集中管理各种全局变量的作用。 HorovodGlobalState 在 horovod 中是一个全局变量，其中的元素可以供不同的线程访问。HorovodGlobalState 在加载 C++ 的代码时候就已经创建了，同时创建的还有各种 context（mpi_context, nccl_context, gpu_context）。 Horovod 主要会在backgroundThreadLoop 中完成 HorovodGlobalState 不同元素初始化，比较重要的有： controller 管理总体通信控制流； tensor_queue 会处理从前端过来的通信需求（allreduce，broadcast 等)； // All the Horovod state that must be stored globally per-process. HorovodGlobalState horovod_global; #if HAVE_MPI MPIContext mpi_context; #endif #if HAVE_GLOO GlooContext gloo_context; #endif .... std::unique_ptr\u003cOperationManager\u003e op_manager; HorovodGlobalState 摘要如下： struct HorovodGlobalState { // Background thread running MPI communication. std::thread background_thread; // 后台线程，用来在各个worker之间协调 ParameterManager parameter_manager; // 维护后台总体参数配置 // Encapsulates the fusion buffers, handles resizing and auto-tuning of buffer // size. FusionBufferManager fusion_buffer; // 融合tensor，以便缩减通信开销 std::shared_ptr\u003cController\u003e controller; //管理总体通信控制流 TensorQueue tensor_queue; //处理从前端过来的通信需求（allreduce，broadcast 等） // Pointer to shared buffer for allgather void* shared_buffer = nullptr; // LRU cache of Responses ResponseCache response_cache; // Information on registered groups. GroupTable group_table; ~HorovodGlobalState() { // Make sure that the destructor of the background thread is safe to // call. If a thread is still joinable (not detached or complete) its // destructor cannot be called. if (background_thread.joinable()) { shut_down = true; background_thread.join(); } } }; 目前具体逻辑如下： Import python files + | | v Import C++ SO files | | | v Create _HorovodBasics + | | v hvd.init() + Python | +--------------------------------------------------------","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:3","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.3 hvd 概念 在用户代码中，接下来是rank概念。 hvd.local_rank() hvd.rank() 我们介绍下几个相关概念： Horovod为设备上的每个GPU启动了该训练脚本的一个副本。local rank就是分配给某一台计算机上每个执行训练的唯一编号（也可以认为是进程号或者GPU设备的ID号），范围是 0 到 n-1，其中 n 是该计算机上GPU设备的数量。 rank 可以认为是代表分布式任务里的一个执行训练的唯一全局编号（用于进程间通讯）。Rank 0 在Horovod中通常具有特殊的意义：它是负责此同步的设备。 在百度的实现中，不同 Rank 的角色是不一样的，Rank 0 会充当 coordinator 的角色。它会协调来自其他 Rank 的 MPI 请求，是一个工程上的考量。这一设计也被后来的 Horovod 采用。 Rank 0 也用来把参数广播到其他进程 \u0026 存储 checkpoint。 world_size：进程总数量，会等到所有world_size个进程就绪之后才会开始训练。 hvd.init 这部分的目的就是让并行进程们可以知道自己被分配的 rank / local rank 等信息，于是后续可以根据 local rank（所在节点上的第几张 GPU 卡） 来设置所需的显存分配。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:4","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.5 数据处理 接下来是数据处理。 dataset = tf.data.Dataset.from_tensor_slices( (tf.cast(mnist_images[..., tf.newaxis] / 255.0, tf.float32), tf.cast(mnist_labels, tf.int64)) ) dataset = dataset.repeat().shuffle(10000).batch(128) 这里有几点需要说明： 首先，训练的数据需要放置在任何节点都能访问的地方。 其次，Horovod 需要对数据进行分片处理，需要在不同机器上按Rank进行切分，以保证每个GPU进程训练的数据集是不一样的。 数据集本体需要出于数据并行性的需求而被拆分为多个分片，Horovod的不同工作节点都将分别读取自己的数据集分片。 从 PyTorch 示例脚本看得更加清楚。 # Horovod: use DistributedSampler to partition the training data. train_sampler = torch.utils.data.distributed.DistributedSampler( train_dataset, num_replicas=hvd.size(), rank=hvd.rank()) train_loader = torch.utils.data.DataLoader( train_dataset, batch_size=args.batch_size, sampler=train_sampler, **kwargs) DataLoader的采样器组件从要绘制的数据集中返回可迭代的索引。 PyTorch中的默认采样器是顺序的，返回序列0, 1, 2, …, n 。 Horovod使用其DistributedSampler覆盖了此行为，该DistributedSampler处理跨计算机的数据集分区。 DistributedSampler本身接受两个参数作为输入： hvd.size() (GPU的总数，例如16)和hvd.rank() (从总体列表中分配给该设备的ID，例如0…15)。 Pytorch使用的是数据分布式训练，每个进程实际上是独立加载数据的，所以需要加载相同数据集后用一定的规则根据rank来顺序切割获取不同的数据子集，DistributedSampler就是用来确保dataloader只会load到整个数据集的一个特定子集的做法(实际上不用Pytorch提供的DistributedSampler工具，自己做加载数据后切分word_size个子集按rank顺序拿到子集效果也是一样)。 同时为了能够按顺序划分数据子集，拿到不同部分数据，所以数据集不能够进行随机打散，所以用了参数 'shuffle': False。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:5","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.6 广播初始化变量 以下代码完成广播初始化的功能。 hvd.callbacks.BroadcastGlobalVariablesCallback(0) 这句代码保证的是 rank 0 上的所有参数只在 rank 0 初始化，然后广播给其他节点，即变量从第一个流程向其他流程传播，以实现参数一致性初始化。 下面就介绍下 Horvod 之中广播的使用。 4.6.1 广播定义 广播的具体实现是： class BroadcastGlobalVariablesCallbackImpl(object): def __init__(self, backend, root_rank, device='', *args): super(BroadcastGlobalVariablesCallbackImpl, self).__init__(*args) self.backend = backend self.root_rank = root_rank self.device = device self.broadcast_done = False def on_batch_end(self, batch, logs=None): if self.broadcast_done: return with tf.device(self.device): if hvd._executing_eagerly() and hasattr(self.model, 'variables'): # TensorFlow 2.0 or TensorFlow eager hvd.broadcast_variables(self.model.variables, root_rank=self.root_rank) hvd.broadcast_variables(self.model.optimizer.variables(), root_rank=self.root_rank) else: bcast_op = hvd.broadcast_global_variables(self.root_rank) self.backend.get_session().run(bcast_op) self.broadcast_done = True 4.6.2 broadcast_variables broadcast_variables 调用了 _make_broadcast_group_fn 完成功能，可以看到对于 执行图 的每个变量，调用了 broadcast。 def broadcast_variables(variables, root_rank): \"\"\"Broadcasts variables from root rank to all other processes. Arguments: variables: variables for broadcast root_rank: rank of the process from which global variables will be broadcasted to all other processes. \"\"\" broadcast_group = _make_broadcast_group_fn() return broadcast_group(variables, root_rank) 以及 @_cache def _make_broadcast_group_fn(): if _executing_eagerly(): # Eager mode will parallelize independent control flow def broadcast_group(variables, root_rank): for var in variables: var.assign(broadcast(var, root_rank)) return _make_subgraph(broadcast_group) else: # Graph mode requires an Op def broadcast_group(variables, root_rank): return tf.group(*[var.assign(broadcast(var, root_rank)) for var in variables]) return broadcast_group 4.6.3 调用 MPI broadcast 就是调用了 MPI 函数真正完成了功能。 def broadcast(tensor, root_rank, name=None, ignore_name_scope=False): \"\"\"An op which broadcasts the input tensor on root rank to the same input tensor on all other Horovod processes. The broadcast operation is keyed by the name of the op. The tensor type and shape must be the same on all Horovod processes for a given name. The broadcast will not start until all processes are ready to send and receive the tensor. Returns: A tensor of the same shape and type as `tensor`, with the value broadcasted from root rank. \"\"\" if name is None and not _executing_eagerly(): name = 'HorovodBroadcast_%s' % _normalize_name(tensor.name) return MPI_LIB.horovod_broadcast(tensor, name=name, root_rank=root_rank, ignore_name_scope=ignore_name_scope) 4.6.4 同步参数 在后台进程中，会根据情况定期同步参数。 bool RunLoopOnce(HorovodGlobalState\u0026 state) { // 业务逻辑功能 if (state.parameter_manager.IsAutoTuning()) { bool should_sync = state.parameter_manager.Update(tensor_names, total_tensor_size); // 看看是否需要同步，如果需要，就同步。 if (should_sync) { state.controller-\u003eSynchronizeParameters(); } } ...... } 同步参数代码也是调用了 Bcast 功能完成。 void Controller::SynchronizeParameters() { ParameterManager::Params param; if (is_coordinator_) { // rank 0 执行操作 param = parameter_manager_.GetParams(); } void* buffer = (void*)(\u0026param); size_t param_size = sizeof(param); Bcast(buffer, param_size, 0, Communicator::GLOBAL); if (!is_coordinator_) { // worker 执行操作 parameter_manager_.SetParams(param); } } ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:6","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.7 DistributedOptimizer 最后需要配置DistributedOptimizer，这就是关键点之一。 # Horovod: add Horovod DistributedOptimizer. opt = hvd.DistributedOptimizer( opt, backward_passes_per_step=1, average_aggregated_gradients=True) TF Optimizer 是模型训练的关键API，可以获取到每个OP的梯度并用来更新权重。HVD 在原始 TF Optimizer的基础上包装了hvd.DistributedOptimizer。 DistributedOptimizer包装器将原始优化器作为输入，将梯度计算委托给它。 即DistributedOptimizer会调用原始优化器进行梯度计算。这样，在集群中每台机器都会用原始优化器得到自己的梯度（Local Gradient）。 Horovod DistributedOptimizer接下来会使用all-reduce或all-gather来完成全局梯度归并，然后将这些平均梯度应用于所有设备。 我们梳理下其中的调用关系： hvd.DistributedOptimizer继承 keras Optimizer，在计算时候，依然由传入的原始优化器做计算。 在得到计算的梯度之后，调用 hvd.allreduce 或者 hvd.allgather 来计算。 最后实施这些平均之后的梯度。从而实现整个集群的梯度归并操作。 具体后文会详细介绍。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:7","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"4.8 未来可能 Horovod 目前架构的基础是：机器学习的模型参数在一张 GPU 上可以存下。 未来是否可以把模型分片结合进来，是一个很大的看点。 另外，如果模型的全连接层较多，则全连接层的强耦合性结合 allreduce 类似 bsp 的同步机制，还是会让网络通信时间成为瓶颈。因此，在 ring-allreduce 环境下，同步协议的改造，比如利用 SSP 来替换 BSP，或者利用梯度压缩来加快 allreduce 进程也是值得探索的方向。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:5:8","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"5 总结 针对文初提出的几个问题，我们现在回答如下： Hovorod 怎么进行数据分割？ 答案：有的框架可以自动做数据分割。如果框架不提供，则需要用户自己进行数据分割，以保证每个GPU进程训练的数据集是不一样的。 Hovorod 怎么进行模型分发？ 用户需要手动拷贝训练代码到各个节点上。 Hovorod 启动时候，python 和 C++ 都做了什么？ 答案：python 会引入 C++库，初始化各种变量和配置。C++部分会对 MPI，GLOO上下文进行初始化，启动后台进程处理内部通信。 如何确保 Hovorod 启动时候步骤一致； 答案： rank 0 上的所有参数只在 rank 0 初始化，然后广播给其他节点，即变量从第一个流程向其他流程传播，以实现参数一致性初始化。 下一篇文章将深入到python世界看看。 reference: [1].https://www.cnblogs.com/rossiXYZ/p/14856543.html ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_2/:6:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[2] -- 从使用者角度切入","uri":"/posts/2022-10-08_horovod_2/"},{"categories":["Distributed Computing"],"content":"0 摘要 Horovod 是Uber于2017年发布的一个易于使用的高性能的分布式训练框架，在业界得到了广泛应用。 本系列将通过源码分析来带领大家了解 Horovod。系列大约有15 ～ 18 篇，本文是系列第一篇，介绍相关背景知识。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:1:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"1 分布式并行训练 我们首先要介绍下分布式并行训练。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:2:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"1.1 分布式并行训练的必要 传统的模型训练中，迭代计算只能利用当前进程所在主机上的所有硬件资源，可是单机扩展性始终有限。而目前的机器学习有如下特点： 样本数量大 目前训练数据越来越多，在大型互联网场景下，每天的样本量可以达到百亿级别。 特征维度多 因为巨大样本量导致机器学习模型参数越来越多，特征维度可以达到千亿或者万亿级别。 训练性能要求高 虽然样本量和模型参数巨大，但是业务需要我们在短期内训练出一个优秀的模型来验证。 模型实时上线 对于推荐资讯类应用，往往要求根据用户最新行为及时调整模型进行预测。 因此，单机面对海量数据和巨大模型时是无能为力的，有必要把数据或者模型分割成为多份，在多个机器上借助不同主机上的硬件资源进行训练加速。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:2:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"1.2 分布式训练 本文所说的训练，指的是利用训练数据通过计算梯度下降的方式迭代地去优化神经网络参数，并最终输出网络模型的过程。在单次模型训练迭代中，会有如下操作： 首先利用数据对模型进行前向的计算。所谓的前向计算，就是将模型上一层的输出作为下一层的输入，并计算下一层的输出，从输入层一直算到输出层为止。 其次会根据目标函数，我们将反向计算模型中每个参数的导数，并且结合学习率来更新模型的参数。 而并行梯度下降的基本思想便是：多个处理器分别利用自己的数据来计算梯度，最后通过聚合或其他方式来实现并行计算梯度下降以加速模型训练过程。 比如两个处理器分别处理一半数据计算梯度 g_1, g_2，然后把两个梯度结果进行聚合更新，这样就实现了并行梯度下降。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:2:2","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"1.3 训练并行机制 1.3.1 三种机制 由于使用小批量算法，可以把宽度$(∝W)$和深度$(∝D)$的前向传播和反向传播分发到并行的处理器上，这样深度训练的并行机制主要有三种： 第一个是模型并行机制（按照网络结构分区）。 通常是针对一个节点无法存下整个模型的情况下，去对图进行拆分。 将模型参数进行分布式存储。计算机上每个计算可以建模为一个有向无环图（DAG），顶点是计算指令，边是数据依赖（数据流）。“基于图去拆分” 会根据每一层中的神经元（即四维张量中的C、H或W维）来把一张大的图拆分成很多部分，每个部分都会在很多设备上去计算。 或者可以这么理解：深度学习的计算主要是矩阵运算，有时候矩阵非常大无法放到显存中，就只能把超大矩阵拆分了放到不同卡上计算。 模型较后部分的计算必须等前面计算完成，因此不同节点间的计算实际是串行的。但每个部分计算互不妨碍，更像是流水线结构。 第二个是数据并行机制（按照输入样本分区）。 更多场景下我们模型规模不大，在一张 GPU 可以容纳，但是训练数据量会比较大，这时候就采用数据并行机制。 具体就是在多节点上并行分割数据和训练。 第三种不常用的并行机制是 流水线机制（按层分区）。 在深度学习中，流水线可以是指重叠的计算，即在一层和下一层之间（当数据准备就绪时）连续计算；或者根据深度划分DNN，将层分配给特定处理器。 流水线可以看作是数据并行的一种形式，因为元素（样本）是通过网络并行处理的，但也可以看作是模型并行，因为流水线的长度是由DNN结构决定的。 具体可见下图: 1.3.2 如何使用 数据的并行往往意味着计算性能的可扩展，而模型的并行往往意味着内存使用的可扩展。 需要注意的是：数据并行和模型并行也并不冲突，两者可以同时存在，而流水线机制也可以和模型并行一起混用。比如，DistBelief分布式深度学习系统结合了三种并行策略。训练在同时复制的多个模型上训练，每个模型副本在不同的样本上训练（数据并行），每个副本上，依据同一层的神经元（模型并行性）和不同层（流水线）上划分任务，进行分布训练。 另外也需要根据具体问题具体分析，比如现代卷积神经网络主要由两种层构成，他们具有不一样的属性和性能。 卷积层，占据了90% ~ 95% 的计算量，5% 的参数，但是对结果具有很大的表达能力。 全连接层，占据了 5% ~ 10% 的计算量， 95% 的参数，但是对于结果具有相对较小的表达的能力。 综上：卷积层计算量大，所需参数系数 W 少，全连接层计算量小，所需参数系数 W 多。因此对于卷积层适合使用数据并行，对于全连接层适合使用模型并行。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:2:3","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"1.4 数据并行训练 我们本系列主要讨论数据并行训练（其中的一种架构）. 数据并行训练只是一种逻辑架构。我们从沐神的书里面摘录： 假设机器上有k个GPU。给定要训练的模型，每个GPU将独立地维护一组完整的模型参数，尽管GPU上的参数值是相同且同步的。例如，下图演示了在k=2时使用数据并行的训练。 一般来说，训练过程如下： 在训练的任何迭代中，给定一个随机的小批量，我们将该小批量中的样本分成k个部分，并将它们均匀地分在多个GPU上。 每个GPU根据分配给它的小批量子集计算模型参数的损失和梯度。 将k个GPU中每个GPU的局部梯度聚合以获得当前的小批量随机梯度。 聚合梯度被重新分配到每个GPU。 每个GPU使用这个小批量随机梯度来更新它维护的完整的模型参数集。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:2:4","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"2 通信和架构 前面提到并行梯度下降的例子：两个处理器分别处理一般数据计算梯度 $g_1$, $g_2$，然后把两个梯度结果进行聚合，最后再把最新参数发给各个分布计算单元，这种训练算法叫模型一致性方法（consistent model methods）。这就涉及到了通信问题，即如何做聚合。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:3:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"2.1 方法和架构 一般有两种通信方法：Share memory 和 Message passing。 Share memory 就是所有处理器共享同一块内存，这样通信很容易，但是同一个节点内的处理器之间才可以共享内存，不同节点处理器之间无法共享内存。 Message passing 就是不同节点之间用消息（比如基于 TCP/IP 或者 RDMA）进行传递/通信，这样容易扩展，可以进行大规模训练。 因此我们知道，Message passing 才是解决方案，于是带来了问题：如何协调这些节点之间的通讯。 有两种架构： Client-Server架构: 一个 server 节点协调其他节点工作，其他节点是用来执行计算任务的 worker。 Peer-to-Peer架构：每个节点都有邻居，邻居之间可以互相通信。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:3:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"2.2 异步 vs 同步 异步 vs 同步 是通信的另外一个侧面。 在数据并行训练之中，各个计算设备分别根据各自获得的batch，前向计算获得损失，进而反向传播计算梯度。计算好梯度后，就涉及到一个梯度同步的问题：每个计算设备 都有根据自己的数据计算的梯度，如何在不同GPU之间维护模型的不同副本之间的一致性？ 如果不同的模型以某种方式最终获得不同的权重，则权重更新将变得不一致，并且模型训练将有所不同。 怎么做这个同步就是设计分布式机器学习系统的一个核心问题。 分布式训练的梯度同步策略可分为异步（asynchronous）梯度更新 和 同步（synchronous）梯度更新机制。 同步指的是所有的设备都是采用相同的模型参数来训练，等待所有设备的mini-batch训练完成后，收集它们的梯度然后取均值，然后执行模型的一次参数更新。 同步训练相当于通过聚合很多设备上的mini-batch形成一个很大的batch来训练模型，Facebook就是这样做的，但是他们发现当batch大小增加时，同时线性增加学习速率会取得不错的效果。 同步训练看起来很不错，但是实际上需要各个设备的计算能力要均衡，而且要求集群的通信也要均衡。 因为每一轮结束时算得快的节点都需等待算得慢的节点算完，再进行下一轮迭代。类似于木桶效应，一个拖油瓶会严重拖慢训练进度，所以同步训练方式相对来说训练速度会慢一些。这个拖油瓶一般就叫做 straggler。(缺点) 异步训练中，各个设备完成一个mini-batch训练之后，不需要等待其它节点，直接去更新模型的参数，这样总体会训练速度会快很多 异步训练的一个很严重的问题是梯度失效问题（stale gradients），刚开始所有设备采用相同的参数来训练，但是异步情况下，某个设备完成一步训练后，可能发现模型参数其实已经被其它设备更新过了，此时这个梯度就过期了，因为现在的模型参数和训练前采用的参数是不一样的。由于梯度失效问题，异步训练虽然速度快，但是可能陷入次优解（sub-optimal training performance）。 具体如图所示: 这两种更新方式各有优缺点： 异步更新可能会更快速地完成整个梯度计算。 同步更新 可以更快地进行一个收敛。 选择哪种方式取决于实际的应用场景。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:3:2","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"3 具体架构 接下来，我们看看几种具体架构实现，先给出一个总体说明： 名称 通信 架构 并行性 MapReduce 消息传递 client-server 批同步 Parameter Server 消息传递 client-server 异步 Decentralized Network 消息传递 P2P(Peer to Peer) 同步或异步 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:4:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"3.1 MapReduce MapReduce是Client-Server架构。以 Spark 为例看看是如何进行并行化： Spark Driver 就是 Server，Spark Executor 就是 Worker 节点，每一个梯度下降过程包含一个广播、map和一个 reduce 操作。 Server 定义了 map操作（就是具体的训练），也可以把信息广播到worker节点。 Worker 会执行 map 操作进行训练，在此过程中，数据被分给 worker 进行计算。 计算结束后，worker把计算结果传回 driver 处理，这个叫做reduce。 在 reduce 过程中，Server 节点对 worker 传来的计算结果进行聚合之后，把聚合结果广播到各个worker节点，进行下一次迭代。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:4:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"3.2 Parameter Server 参数服务器 Parameter server 也是一种client-server架构。和MapReduce不同在于 Parameter server 可以是异步的，MapReduce只有等所有map都完成了才能做reduce操作。 参数服务器架构中，计算设备被划分为参数服务器（PS）和worker。 参数服务器（server）。是中心化的组件，主要是负责模型参数的存储，平均梯度和交换更新。参数服务器可以按照不同比例的参数服务器和工作线程进行配置，每个参数服务器都有着不同的配置数据。 工作节点（worker）。每个工作节点会负责它领域内的数据分片所对应模型参数的更新计算（比如前向和反向传播这类计算密集的运算），同时它们又会向参数服务器去传递它所计算的梯度，由参数服务器来汇总所有的梯度，再进一步反馈到所有节点。 具体步骤如下： 所有的参数都存储在参数服务器中，而 工作节点（worker） 是万年打工仔。 工作节点 们只负责计算梯度，待所有计算设备完成梯度计算之后，把计算好的梯度发送给参数服务器，这样参数服务器收到梯度之后，执行一定的计算（梯度平均等）之后，就更新其维护的参数，做到了在节点之间对梯度进行平均，利用平均梯度对模型进行更新。 然后参数服务器再把更新好的新参数返回给所有的工作节点，以对每个节点中的模型副本应用一致化更新。 打工仔们会再进行下一轮的前后向计算。 逻辑如下： +----------------------------------------------+ | Parameter Server | | | | | | Compute : New P = P + Sum(Delta P ...) | | | | | | Parameter 1, Parameter 2, Parameter 3 ... | | | | | +--+----+----------+--+----------------+--+----+ ^ | ^ | ^ | | | | | | | Delta P | | Delta P| | Delta P| | +-----+ | | | | +------+ | +-----+ | | | | | | New P | | New P +------+ | | | | | | | New P | v | | | | | | v | v +-+-----------+ +-----+--+---+ +-----+--+---+ | Worker | | Worker | | Worker | | | | | | | | | | | ...... | | | Model | | Model | | Model | +------+------+ +------+-----+ +----+-------+ ^ ^ ^ | | | | | | +----+----+ +----+-----+ +--+-----+ | Data 1 | | Data 2 | | Data 3 | +---------+ +----------+ +--------+ 如图: 参数服务器既可以用在数据并行上，也可以被用到模型并行训练上。比如可以将模型切分为多个部分，存储在不同的PS Server节点上，并提供方便的访问服务，这是参数服务器的本质。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:4:2","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"3.3 Decentralized Network Decentralized Network 就是去中心化网络，其特点如下： 去中心化网络没有一个中心节点，属于 Peer-to-Peer 架构。 采用 message passing 进行通信，且节点只和邻居通信。 并行方式可以采用异步或者同步。 去中心化网络的收敛情况取决于网络连接情况： 连接越紧密，收敛性越快，当强连接时候，模型可以很快收敛； 如果不是强连接，它可能不收敛； ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:4:3","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"4 AllReduce 因为本系列是 Horovod，所以我们要先说说参数服务器的劣势，下一个系列我们再说参数服务器优势。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:5:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"4.1 参数服务器劣势 尽管参数服务器可以提升表现，但仍然面临几个问题： 确定工作者与参数服务器的正确比例：如果使用一个参数服务器，它可能会成为网络或计算瓶颈。 如果使用多个参数服务器，则通信模式变为“All-to-All”，这可能使网络饱和。 处理程序复杂性：参数服务器的概念较多，这通常导致陡峭的学习曲线和大量的代码重构，压缩了实际建模的时间。 硬件成本 : 参数服务器的引入也增加了系统的硬件成本。 人们发现，MPI_AllReduce 语义也可以很好地满足数据并行训练这一需要。 需要注意的是：AllReduce 既可以是去中心化，也可以是主从式的。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:5:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"4.2 并行任务通信分类 并行任务的通信一般可以分为 Point-to-point communication和 Collective communication。 P2P 这种模式只有一个sender和一个receiver，实现起来比较简单，比如NV GPU Direct P2P技术服务于单机多卡的单机卡间数据通信 。 Collective communication包含多个sender和多个receiver，一般的通信原理包括 broadcast，gather,all-gather，scatter，reduce，all-reduce，reduce-scatter，all-to-all等。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:5:2","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"4.3 MPI_AllReduce AllReduce(对m个独立参数进行规约，并将规约结果返回给所有进程), 其实是最显然和直接的分布式机器学习抽象，因为大部分算法的结构都是分布数据。在每个子集上面算出一些局部统计量，然后整合出全局统计量，并且再分配给各个节点去进行下一轮的迭代，这样一个过程就是AllReduce。 可以把每个 Worker 看作是 MPI 概念中的一个进程，比如可以用 4 个 Worker 组成了一个组，该组由 4 个进程组成。我们在这四个进程中对梯度进行一次 MPI_AllReduce。 根据 MPI_AllReduce 的语义，所有参与计算的进程都有结果，所以梯度就完成了分发。只要在初始化的时候，我们可以保证每个 Worker 的参数是一致的，那在后续的迭代计算中，参数会一直保持一致，因为梯度信息是一致的。 AllReduce 跟 MapReduce 有类似，但后者采用的是面向通用任务处理的多阶段执行任务的方式，而AllReduce则让一个程序在必要的时候占领一台机器，并且在所有迭代的时候一直跑到底，来防止重新分配资源的开销，这更加适合于机器学习的任务处理。 所以，MPI_AllReduce 的语义可以很好地解决深度学习中梯度同步的问题。但是到底能不能使用它，还是要看下层的实现对这一场景是否足够友好。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:5:3","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"5 ring-allreduce 百度提出使用新算法来平均梯度，取消 Reducer，并让这些梯度在所有节点之间交流，这被称为 ring-allreduce，他们使用 TensorFlow 也实现了这种算法（https://github.com/baidu-research/tensorflow-allreduce）。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:6:0","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"5.1 特点 Ring-Allreduce特点如下： Ring Allreduce 算法使用定义良好的成对消息传递步骤序列在一组进程之间同步状态（在这种情况下为张量）。 Ring-Allreduce 的命名中 Ring 意味着设备之间的拓扑结构为一个逻辑环形，每个设备都应该有一个左邻和一个右邻居，且本设备只会向它右邻居发送数据，并且从它的左邻居接受数据。 Ring-Allreduce 的命名中的 Allreduce 则代表着没有中心节点，架构中的每个节点都是梯度的汇总计算节点。 此种算法各个节点之间只与相邻的两个节点通信，并不需要参数服务器。因此，所有节点都参与计算也参与存储，也避免产生中心化的通信瓶颈。 相比PS架构，Ring-Allreduce 架构是带宽优化的，因为集群中每个节点的带宽都被充分利用。 在 ring-allreduce 算法中，每个 N 节点与其他两个节点进行 2 * (N-1) 次通信。在这个通信过程中，一个节点发送并接收数据缓冲区传来的块。在第一个N-1迭代中，接收的值被添加到节点缓冲区中的值。在第二个N-1迭代中，接收的值代替节点缓冲区中保存的值。百度的文章证明了这种算法是带宽上最优的，这意味着如果缓冲区足够大，它将最大化地利用可用的网络。 在深度学习训练过程中，计算梯度采用BP算法，其特点是后面层的梯度先被计算，而前面层的梯度慢于后面层，Ring-allreduce架构可以充分利用这个特点，在前面层梯度计算的同时进行后面层梯度的传递，从而进一步减少训练时间。 Ring架构下的同步算法将参数在通信环中依次传递，往往需要多步才能完成一次参数同步。在大规模训练时会引入很大的通信开销，并且对小尺寸张量（tensor）不够友好。对于小尺寸张量，可以采用批量操作（batch）的方法来减小通信开销。 综上所述，Ring-based AllReduce 架构的网络通讯量如果处理适当，不会随着机器增加而增加，而仅仅和模型 \u0026 网络带宽有关，这针对参数服务器是个巨大的提升。 ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:6:1","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"5.2 策略 Ring-based AllReduce 策略包括 Scatter-Reduce 和 AllGather 两个阶段。 首先是scatter-reduce，scatter-reduce 会逐步交换彼此的梯度并融合，最后每个 GPU 都会包含完整融合梯度的一部分，是最终结果的一个块。 假设环中有 N 个 worker，每个 worker 有长度相同的数组，需要将 worker 的数组进行求和。在 Scatter-Reduce 阶段，每个 worker 会将数组分成 N 份数据块，然后 worker 之间进行 N 次数据交换。在第 k 次数据交换时，第 i 个 worker 会将自己的 (i - k) % N 份数据块发送给下一个 worker。接收到上一个 worker 的数据块后，worker 会将其与自己对应的数据块求和。 然后是allgather。GPU 会逐步交换彼此不完整的融合梯度，最后所有 GPU 都会得到完整的最终融合梯度。 在执行完 Scatter-Reduce 后，每个 worker 的数组里都有某个数据块是最终求和的结果，现在需要将各数据块的最后求和结果发送到每个 worker 上。和 Scatter-Reduce 一样，也需要 N 次循环。在第 k 次循环时，第 i 个 worker 会将其第 (i+1-k)%N 个数据块发送给下一个 worker 。接收到前一个 worker 的数据块后，worker 会用接收的数据快覆盖自己对应的数据块。进行 N 次循环后，每个 worker 就拥有了数组各数据块的最终求和结果了。 以下部分来自 https://andrew.gibiansky.com/blog/machine-learning/baidu-allreduce/，这是我能找到最优秀的解读。 5.2.1 结构 环形结构如下，每个 GPU 应该有一个左邻居和一个右邻居；它只会向其右侧邻居发送数据，并从其左侧邻居接收数据。 5.2.2 scatter reduce scatter-reduce：会逐步交换彼此的梯度并融合，最后每个 GPU 都会包含完整融合梯度的一部分。 为简单起见，我们假设目标是按元素对单个大型浮点数数组的所有元素求和；系统中有 N 个 GPU，每个 GPU 都有一个相同大小的数组，在 allreduce 的最后环节，每个 GPU 都应该有一个相同大小的数组，其中包含原始数组中数字的总和。 5.2.2.1 分块 首先，GPU 将阵列划分为 N 个较小的块（其中 N 是环中的 GPU 数量）。 接下来，GPU 将进行 N-1 次 scatter-reduce 迭代。 在每次迭代中，GPU 会将其一个块发送到其右邻居，并将从其左邻居接收一个块并累积到该块中。每个 GPU 发送和接收的数据块每次迭代都不同。第 n 个 GPU 通过发送块 n 和接收块 n – 1 开始，然后逐步向后进行，每次迭代发送它在前一次迭代中接收到的块。 5.2.2.2 第一次迭代 在第一次迭代中，上图中的五个 GPU 将发送和接收以下块： GPU 发送 接收 0 块0 块4 1 块1 块0 2 块2 块1 3 块3 块2 4 块4 块3 scatter-reduce 的第一次迭代中的数据传输如下： 第一次发送和接收完成后，每个 GPU 都会有一个块，该块由两个不同 GPU 上相同块的总和组成。例如，第二个 GPU 上的第一个块将是该块中来自第二个 GPU 和第一个 GPU 的值的总和。 5.2.2.2 全部迭代 在后续迭代中，该过程继续直到最后。最终每个 GPU 将有一个块，这个块包含所有 GPU 中该块中所有值的总和。 下面系列图展示了所有数据传输和中间结果，从第一次迭代开始，一直持续到scatter-reduce完成。 iter 1： iter2： iter3： iter4： 所有 scatter-reduce 传输后的最终状态 5.2.3 Allgather 在 scatter-reduce 步骤完成后，在每个 GPU 的数组中都有某一些值（每个 GPU 有一个块）是最终值，其中包括来自所有 GPU 的贡献。为了完成 allreduce，GPU 必须接下来交换这些块，以便所有 GPU 都具有最终所需的值。 ring allgather 与 scatter-reduce 进行相同的处理（发送和接收的 N-1 次迭代），但是他们这次不是累积 GPU 接收的值，而只是简单地覆盖块。第 n 个 GPU 开始发送第 n+1 个块并接收第 n 个块，然后在以后的迭代中始终发送它刚刚接收到的块。 5.2.3.1 第一次迭代 例如，在我们的 5-GPU 设置的第一次迭代中，GPU 将发送和接收以下块： GPU 发送 接收 0 块1 块0 1 块2 块1 2 块3 块2 3 块4 块3 4 块0 块4 allgather 的第一次迭代中的数据传输如下。 第一次迭代完成后，每个 GPU 都会有最终数组的两个块。在接下来的迭代中，该过程继续一直到最后，最终每个 GPU 将拥有整个数组的完全累加值。 5.2.3.2 全部迭代 下面系列图展示了所有数据传输和中间结果，从第一次迭代开始，一直持续到全部收集完成。 Allgather 数据传输（迭代 1） Allgather 数据传输（迭代 2）如下： Allgather 数据传输（迭代 3）： Allgather 数据传输（迭代 4）： 所有全部转移后的最终状态。 5.2.4 Horovod 架构图 工作原理也可以借助Horovod的发布帖子 来看看。 5.2.5 百度思路 或者我们从百度的源码中也可以直接看到思路，现在摘录给大家。 具体代码参见 https://github.com/baidu-research/tensorflow-allreduce/commit/66d5b855e90b0949e9fa5cca5599fd729a70e874#diff-3d530d590e551619acd776cfe7eaff06R517 /* Perform a ring allreduce on the data. Allocate the necessary output tensor and * store it in the output parameter. * * Assumes that all MPI processes are doing an allreduce of the same tensor, * with the same dimensions. * * A ring allreduce is a bandwidth-optimal way to do an allreduce. To do the allreduce, * the nodes involved are arranged in a ring: * * .--0--. * / \\ * 3 1 * \\ / * *--2--* * * Each node always sends to the next clockwise node in the ring, and receives * from the previous one. * * The allreduce is done in two parts: a scatter-reduce and an allgather. In * the scatter reduce, a reduction is done, so that each node ends up with a * chunk of the final output tensor which has contributions from all other * nodes. In the allgather, those chunks are distributed among all the nodes, * so that all nodes have the entire output tensor. * * Both of these operations are done by dividing the input tensor into N * evenly sized chunks (where N is the number of nodes in the ring). * * The scatter-reduce is done in N-1 steps. In the ith step, node j will send * the (j - i)th chunk and receive the (j - i - 1)th chunk, adding it in to * its existing data for that chunk. For example, in the first iteration with * the ring depicted above, you will have the following transfers: * * Segment 0: Node 0 --\u003e Node 1 * Segment 1: Node 1 --\u003e Node 2 * Segment 2: Node 2 --\u003e Node 3 * Segment 3: Node 3 --\u003e Node 0 * * In the second iteration, you'll have ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:6:2","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["Distributed Computing"],"content":"5.3 区别 在中等规模模型情况下，all-reduce 更适合。当规模巨大时候则应该使用参数服务器。 参数服务器 适合的是高维稀疏模型训练，它利用的是维度稀疏的特点，每次 pull or push 只更新有效的值。但是深度学习模型是典型的dense场景，embedding做的就是把稀疏变成稠密。所以这种 pull or push 的不太适合。而 网络通信上更优化的 all-reduce 适合中等规模的深度学习。 又比如由于推荐搜索领域模型的 Embedding 层规模庞大以及训练数据样本长度不固定等原因，导致容易出现显存不足和卡间同步时间耗费等问题，所以 all-reduce 架构很少被用于搜索推荐领域。 至此，背景知识已经介绍完毕，下一篇我们开始介绍 Horovod 的使用。 reference: [1] https://www.cnblogs.com/rossiXYZ/p/14856464.html ","date":"2023-07-10","objectID":"/posts/2022-10-08_horovod_1/:6:3","tags":["Horovod"],"title":"深度学习分布式训练框架 Horovod[1] -- 基础知识","uri":"/posts/2022-10-08_horovod_1/"},{"categories":["hugo"],"content":" quote tips for hugo installation and new site creation. Commands for creating sites backend with hugo create a new markdown file hugo new posts/tech/name-of-file.md hugo new content/posts/tech/name-of-file.md create new site hugo new site name Install hugo Linux wget https://github.com/gohugoio/hugo/releases/download/v0.83.1/hugo_0.83.1_Linux-64bit.tar.gz tar -xf hugo_0.83.1_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ hugo version ","date":"2023-07-09","objectID":"/posts/hugo_command/:0:0","tags":["hugo"],"title":"Hugo_command","uri":"/posts/hugo_command/"},{"categories":["Node.js","JavaScript"],"content":"最近在写一个 Vue 插件，需要在项目中创建一些测试页面，由于都是些静态路由，就想到之前看到过的一个项目就是用 Node.js 来自动生成路由的，于是就借鉴过来改了一下。 ","date":"2023-06-14","objectID":"/posts/gen-router/:0:0","tags":["Node.js","JavaScript","Vue"],"title":"使用 Node.js 自动创建 Vue 的路由","uri":"/posts/gen-router/"},{"categories":["Node.js","JavaScript"],"content":"源码 const fs = require('fs') const os = require('os') const vueDir = './src/views/' const routerFile = './src/router.js' fs.readdir(vueDir, function (err, files) { if (err) { console.error('❌ Could not list the directory.', err) return } const routes = [] for (const filename of files) { if (filename.indexOf('.') \u003c 0) { continue } const [name, ext] = filename.split('.') if (ext !== 'vue') { continue } const routeName = name.replace(/-([a-z])/g, (_, match) =\u003e match.toUpperCase()) let routeDescription = '' const contentFull = fs.readFileSync(`${vueDir}${filename}`, 'utf-8') // get route description from first line comment const match = /\u003c!--\\s*(.*)\\s*--\u003e/g.exec(contentFull.split(os.EOL)[0]) if (match) { routeDescription = match[1].trim() } routes.push(` { path: '/${name === 'home' ? '' : name}', name: '${routeName}',${routeDescription ? `\\n description: '${routeDescription}',` : ''} component: () =\u003e import(/* webpackChunkName: \"${routeName}\" */ '@/views/${filename}'), },`) } const result = `// This file is automatically generated by gen-router.js, please do not modify it manually！ import VueRouter from 'vue-router' import Vue from 'vue' Vue.use(VueRouter) const routes = [ ${routes.join(os.EOL)} ] const router = new VueRouter({ mode: 'hash', routes, }) export default router ` fs.writeFile(routerFile, result, 'utf-8', (err) =\u003e { if (err) throw err console.log(`✅ Router generated successfully in ${routerFile}`) }) }) 生成效果如下： // This file is automatically generated by gen-router.js, please do not modify it manually！ import VueRouter from 'vue-router' import Vue from 'vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'home', description: 'Home', component: () =\u003e import(/* webpackChunkName: \"home\" */ '@/views/home.vue'), }, ] const router = new VueRouter({ mode: 'hash', routes, }) export default router ","date":"2023-06-14","objectID":"/posts/gen-router/:1:0","tags":["Node.js","JavaScript","Vue"],"title":"使用 Node.js 自动创建 Vue 的路由","uri":"/posts/gen-router/"},{"categories":["Node.js","JavaScript"],"content":"参考 sunzsh/vue-el-demo ","date":"2023-06-14","objectID":"/posts/gen-router/:2:0","tags":["Node.js","JavaScript","Vue"],"title":"使用 Node.js 自动创建 Vue 的路由","uri":"/posts/gen-router/"},{"categories":["Git"],"content":"问题描述 在使用 SourceTree 提交代码的时候，会出现 husky 命令失败的问题（通过命令行提交代码没有问题），如下图所示： 看错误，是一个 catch 参数的问题，在新版本的 Node 中，catch 参数是可以省略的，但是在旧版本中，catch 参数是必须的。 由于使用了 nvm 管理 Node 版本，项目中的 Node 是正常的，但是 SourceTree 使用的是系统的 Node，所以会出现这个问题。 ","date":"2023-06-12","objectID":"/posts/sourcetree-husky/:1:0","tags":["Git","husky","Mac"],"title":"解决 SourceTree 提交时候 husky 命令失败问题","uri":"/posts/sourcetree-husky/"},{"categories":["Git"],"content":"解决方案 知道了问题的原因，解决起来就很简单了，只需要将 SourceTree husky hook 阶段的 Node 版本切换到项目中的 Node 版本即可。 配置 .huskyrc 文件，内容如下： echo \"export PATH=\\\"$(dirname $(which node)):\\$PATH\\\"\" \u003e ~/.huskyrc 如果你使用了 zsh 和 nvm, 建议在 $ZSH_CUSTOM 目录下添加一个自定义 zsh 脚本。 这个脚本会在你进入包含了 .nvmrc 文件目录中自动切换 node 版本，切换版本后修正 ~/.huskyrc 的 path 内容。 vim $ZSH_CUSTOM/nvm_custom.zsh # https://github.com/nvm-sh/nvm#manual-install export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] \u0026\u0026 \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion # https://github.com/nvm-sh/nvm#deeper-shell-integration autoload -U add-zsh-hook load-nvmrc() { local node_version=\"$(nvm version)\" local nvmrc_path=\"$(nvm_find_nvmrc)\" if [ -n \"$nvmrc_path\" ]; then local nvmrc_node_version=$(nvm version \"$(cat \"${nvmrc_path}\")\") if [ \"$nvmrc_node_version\" = \"N/A\" ]; then nvm install elif [ \"$nvmrc_node_version\" != \"$node_version\" ]; then nvm use fi elif [ \"$node_version\" != \"$(nvm version default)\" ]; then echo \"Reverting to nvm default version\" nvm use default fi # fix husky hook # ref: https://github.com/typicode/husky/issues/390#issuecomment-762213421 echo \"export PATH=\\\"$(dirname $(which node)):\\$PATH\\\"\" \u003e ~/.huskyrc } add-zsh-hook chpwd load-nvmrc load-nvmrc # https://github.com/nvm-sh/nvm#use-a-mirror-of-node-binaries export NVM_NODEJS_ORG_MIRROR=https://mirrors.ustc.edu.cn/node/ ","date":"2023-06-12","objectID":"/posts/sourcetree-husky/:2:0","tags":["Git","husky","Mac"],"title":"解决 SourceTree 提交时候 husky 命令失败问题","uri":"/posts/sourcetree-husky/"},{"categories":["Git"],"content":"参考 https://wxhboy.cn/2022/04/12/解决SourceTree提交时候husky命令失败问题/ https://github.com/typicode/husky/issues/390#issuecomment-762213421 https://github.com/typicode/husky/issues/904#issuecomment-862184954 https://github.com/nvm-sh/nvm#deeper-shell-integration ","date":"2023-06-12","objectID":"/posts/sourcetree-husky/:3:0","tags":["Git","husky","Mac"],"title":"解决 SourceTree 提交时候 husky 命令失败问题","uri":"/posts/sourcetree-husky/"},{"categories":["CSS","JavaScript"],"content":"新建 Vue2 项目 通过 vue-cli 创建一个叫 v2-tailwind 的项目： vue create vue2-tailwind 根据需要选择其他的功能插件，例如：Babel, Router, Vuex, CSS Pre-processors, Linter。 关于 ESLint 当在 Vue 创建项目时，你可以根据自己的需求选择不同的 ESLint 配置。以下是一些常见的选项及其优缺点和注意事项： ESLint with error prevention only: 优点：这个配置只会帮助你防止代码中的错误，它的规则相对宽松。适用于刚开始使用 ESLint 或者希望避免太多约束的开发者。 缺点：由于规则相对宽松，可能无法完全确保代码风格的一致性。 注意事项：如果你想要更严格的代码检查，可以考虑其他配置。 ESLint + Airbnb config: 优点：Airbnb 的配置非常严格，能够帮助你遵循最佳实践和编写高质量的代码。此外，它也包含了许多 ES6+ 的规则。 缺点：由于其严格性，初学者可能需要花费更多时间来解决 ESLint 报告的问题。 注意事项：在使用此配置时，请确保你理解并接受 Airbnb 的代码规范。 ESLint + Standard config: 优点：Standard 的配置旨在提供一个相对简单、一致的代码风格，适合那些喜欢“零配置”的开发者。 缺点：这个配置可能不适用于所有项目，因为它有自己的代码风格要求。 注意事项：如果你的团队或项目已经有自己的编码规范，使用 Standard 配置可能会导致不一致。 ESLint + Prettier: 优点：Prettier 是一个自动格式化工具，可以与 ESLint 结合使用，以确保代码风格的一致性。这可以提高代码可读性，并减少在代码审查过程中关注格式问题的时间。 缺点：Prettier 可能会覆盖某些 ESLint 规则，所以需要花一些时间确保配置正确。 注意事项：为了避免冲突，请确保 ESLint 和 Prettier 的规则正确配置。 总之，在选择 ESLint 配置时，需要根据你的团队、项目需求和个人偏好来权衡。选择适当的配置可以帮助你提高代码质量并保持一致的代码风格。 ","date":"2023-06-03","objectID":"/posts/v2-tailwind/:1:0","tags":["tailwindcss","Vue"],"title":"Vue2 + tailwindcss 初始化","uri":"/posts/v2-tailwind/"},{"categories":["CSS","JavaScript"],"content":"安装 tailwindcss 打开项目，安装 tailwindcss： cd vue2-tailwind # 安装 tailwindcss 低版本及相关插件 npm install tailwindcss@npm:@tailwindcss/postcss7-compat @tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9 然后创建配置文件： # 创建 postcss.config.js, tailwind.config.js npx tailwindcss init -p module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, } } module.exports = { purge: [ \"./src/App.vue\", \"./src/views/**/*.{vue,js,ts,jsx,tsx}\", \"./src/components/**/*.{vue,js,ts,jsx,tsx}\", ], darkMode: 'class', // or 'media' or 'class' mode: 'jit', // 是否开启 jit 模式，开启以后编译会更快，当然，tailwindcss 版本需要在 2.1 以上 theme: { extend: {}, }, variants: { extend: {}, }, plugins: [], } 最后在 main.js 中引入 tailwindcss import \"tailwindcss/tailwind.css\" ","date":"2023-06-03","objectID":"/posts/v2-tailwind/:2:0","tags":["tailwindcss","Vue"],"title":"Vue2 + tailwindcss 初始化","uri":"/posts/v2-tailwind/"},{"categories":["CSS","JavaScript"],"content":"启动项目 启动项目，修改模板中的 class 进行测试。 npm run serve \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv class=\"bg-gray-100\"\u003e \u003cdiv class=\"container mx-auto\"\u003e \u003cdiv class=\"flex justify-center items-center h-screen\"\u003e \u003cdiv class=\"text-4xl text-gray-700\"\u003eHello Vue2 + tailwindcss\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e ","date":"2023-06-03","objectID":"/posts/v2-tailwind/:3:0","tags":["tailwindcss","Vue"],"title":"Vue2 + tailwindcss 初始化","uri":"/posts/v2-tailwind/"},{"categories":["HTML"],"content":"记录使用 HTML 原生方案实现图片的懒加载。 ","date":"2023-02-12","objectID":"/posts/native-img-loading-lazy/:0:0","tags":["HTML","eager","lazy","loading"],"title":"浏览器 IMG 图片原生懒加载 loading=\"lazy\"","uri":"/posts/native-img-loading-lazy/"},{"categories":["HTML"],"content":"语法规范 HTML loading 属性适用于 img 和 iframe，语法规范见 HTML Standard - Lazy loading attributes。 关键词 状态 描述 lazy 懒惰的 用于延迟获取资源，直到满足某些条件。 eager 渴望的 用于立即获取资源；默认状态。 属性的 缺失值默认值 和 无效值默认值 都是 Eager状态。 ","date":"2023-02-12","objectID":"/posts/native-img-loading-lazy/:1:0","tags":["HTML","eager","lazy","loading"],"title":"浏览器 IMG 图片原生懒加载 loading=\"lazy\"","uri":"/posts/native-img-loading-lazy/"},{"categories":["HTML"],"content":"实际应用 基于 FixIt 主题 版本大于 v0.2.18 的博客网站使用就是原生的懒加载方案，大致如下： \u003cimg loading=\"lazy\" src=\"./example.jpg\" data-title=\"title text\" data-alt=\"alt text\" onload=\"this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';\" onerror=\"this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['data-title','data-alt','onerror','onload']){this.removeAttribute(a);}\" /\u003e 为了达到 loading 的效果，以上代码中在 onload 后会给图片加上一个 data-lazyloaded 属性，所以我们可以这样来写 css 以达到显示 loading 图标的效果： img[loading='lazy']:not([data-lazyloaded]) { background: url(loading.svg) no-repeat center; } 设置 data-title 和 data-alt 是因为移动浏览器大多数只要有 title 或 alt 就会显示图片的替代字符，所以等到图片加载完或加载失败后再回填。 ","date":"2023-02-12","objectID":"/posts/native-img-loading-lazy/:2:0","tags":["HTML","eager","lazy","loading"],"title":"浏览器 IMG 图片原生懒加载 loading=\"lazy\"","uri":"/posts/native-img-loading-lazy/"},{"categories":["HTML"],"content":"懒加载特性的研究 以下结论来自 浏览器 IMG 图片原生懒加载 loading=”lazy”实践指南 « 张鑫旭-鑫空间-鑫生活 总结部分。 Lazy loading 加载数量与屏幕高度有关，高度越小加载数量越少，但并不是线性关系. Lazy loading 加载数量与网速有关，网速越慢，加载数量越多，但并不是线性关系。 Lazy loading 加载没有缓冲，滚动即会触发新的图片资源加载。 Lazy loading 加载在窗口 resize 尺寸变化时候也会触发，例如屏幕高度从小变大的时候。 Lazy loading 加载也有可能会先加载后面的图片资源，例如页面加载时滚动高度很高的时候。 ","date":"2023-02-12","objectID":"/posts/native-img-loading-lazy/:3:0","tags":["HTML","eager","lazy","loading"],"title":"浏览器 IMG 图片原生懒加载 loading=\"lazy\"","uri":"/posts/native-img-loading-lazy/"},{"categories":["HTML"],"content":"参考链接 Lazy loading - Web 性能 | MDN Lazy loading via attribute for images \u0026 iframes 兼容性 ","date":"2023-02-12","objectID":"/posts/native-img-loading-lazy/:4:0","tags":["HTML","eager","lazy","loading"],"title":"浏览器 IMG 图片原生懒加载 loading=\"lazy\"","uri":"/posts/native-img-loading-lazy/"},{"categories":["Browser"],"content":"浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画 每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 渲染的第一步是解析 HTML。 解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。 如果主线程解析到link位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 如果主线程解析到script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 渲染的下一步是样式计算。 主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。 在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px 这一步完成后，会得到一棵带有样式的 DOM 树。 接下来是布局，布局完成后会得到布局树。 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。 大部分时候，DOM 树和布局树并非一一对应。 比如display:none的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 下一步是分层 主线程会使用一套复杂的策略对整个布局树中进行分层。 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。 再下一步是绘制 主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。 合成线程首先对每个图层进行分块，将其划分为更多的小区域。 它会从线程池中拿取多个线程来完成分块工作。 分块完成后，进入光栅化阶段。 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。 光栅化的结果，就是一块一块的位图 最后一个阶段就是画了 合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。 变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。 合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 ","date":"2023-02-05","objectID":"/posts/browser-rendering/:1:0","tags":["Browser","JavaScript","HTML","CSS"],"title":"浏览器渲染原理","uri":"/posts/browser-rendering/"},{"categories":["Browser"],"content":"什么是 reflow？ reflow 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。 浏览器在反复权衡下，最终决定获取属性立即 reflow。 ","date":"2023-02-05","objectID":"/posts/browser-rendering/:2:0","tags":["Browser","JavaScript","HTML","CSS"],"title":"浏览器渲染原理","uri":"/posts/browser-rendering/"},{"categories":["Browser"],"content":"什么是 repaint？ repaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。 ","date":"2023-02-05","objectID":"/posts/browser-rendering/:3:0","tags":["Browser","JavaScript","HTML","CSS"],"title":"浏览器渲染原理","uri":"/posts/browser-rendering/"},{"categories":["Browser"],"content":"为什么 transform 的效率高？ 因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段 由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。 ","date":"2023-02-05","objectID":"/posts/browser-rendering/:4:0","tags":["Browser","JavaScript","HTML","CSS"],"title":"浏览器渲染原理","uri":"/posts/browser-rendering/"},{"categories":["Spec"],"content":" 以下参考来源：阮一峰的 中文技术文档的写作规范 英语世界里，文档非常受重视，许多公司和组织都有自己的文档规范，清楚地规定写作要求，比如微软、MailChimp、Apple、Yahoo、docker、Struts 等等（维基百科有一份完整的清单）。中文的也有不少，但都不令人满意，要么太简单，要么不太适用。 对于开发者来说，在工作中也需要适当地产出一些技术文档，但是很多人都不知道怎么写文档，都是凭着感觉写。 对于开发的系统、软件而言，系统用词的准确性和统一性也显得十分重要。 参考上面的规范，于是有了下面一份中文技术文档的写作规范。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:0:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"标题 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:1:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"层级 标题分为四级。 一级标题：文章的标题 二级标题：文章主要部分的大标题 三级标题：二级标题下面一级的小标题 四级标题：三级标题下面某一方面的小标题 下面是示例。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 注：最多支持六级，但是同论文写作一样，层级太深，会使得整体显得杂乱无章，当确实需要更深层级时，应另起新篇单独论述。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:1:1","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"原则 （1）一级标题下，不能直接出现三级标题。 示例：下面的文章结构，缺少二级标题。 # 一级标题 ### 三级标题 （2）标题要避免孤立编号（即同级标题只有一个）。 示例：下面的文章结构，二级标题 A只包含一个三级标题，完全可以省略三级标题 A。 ## 二级标题 A ### 三级标题 A ## 二级标题 B （3）下级标题不重复上一级标题的名字。 示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。 ## 概述 ### 概述 （4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。 如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。 示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。 结构一 ### 三级标题 #### 四级标题 A #### 四级标题 B #### 四级标题 C 结构二 ### 三级标题 **（1）A** **（2）B** **（3）C** ","date":"2023-02-04","objectID":"/posts/document-style-guide/:1:2","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"文本 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:2:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"字间距 （1）全角中文字符与半角英文字符之间，应有一个半角空格。 错误：本文介绍如何快速启动Windows系统。 正确：本文介绍如何快速启动 Windows 系统。 （2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。 正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。 正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。 半角的百分号，视同阿拉伯数字。 正确：今年我国经济增长率是6.5%。 正确：今年我国经济增长率是 6.5%。 （3）英文单位若不翻译，单位前的阿拉伯数字与单位符号之间，应留出适当的空隙。 例1：一部容量为 16 GB 的智能手机 例2：1 h = 60 min = 3,600 s （4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。 错误：他的电脑是 MacBook Air 。 正确：他的电脑是 MacBook Air。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:2:1","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"句子 （1）避免使用长句。 不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20 ～ 29 个字的句子，可以接受；30 ～ 39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。 错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。 正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。 逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。 （2）尽量使用简单句和并列句，避免使用复合句。 并列句：他昨天生病了，没有参加会议。 复合句：那个昨天生病的人没有参加会议。 （3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。 错误：请确认没有接通装置的电源。 正确：请确认装置的电源已关闭。 （4）避免使用双重否定句。 错误：没有删除权限的用户，不能删除此文件。 正确：用户必须拥有删除权限，才能删除此文件。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:2:2","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"写作风格 （1）尽量不使用被动语态，改为使用主动语态。 错误：假如此软件尚未被安装， 正确：假如尚未安装这个软件， （2）不使用非正式的语言风格。 错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！ 正确：无法参加本次活动，我深感遗憾。 （3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。 错误：这是唯二的快速启动的方法。 正确：这是仅有的两种快速启动的方法。 （4）用对“的”、“地”、“得”。 她露出了开心的笑容。 （形容词＋的＋名词） 她开心地笑了。 （副词＋地＋动词） 她笑得很开心。 （动词＋得＋副词） （5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。 错误：从管理系统可以监视中继系统和受其直接控制的分配系统。 正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。 （6）名词前不要使用过多的形容词。 错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。 正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:2:3","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"英文处理 （1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。 英文：...information stored in random access memory (RAMs)... 中文：⋯⋯存储在随机存取存储器（RAM）里的信息⋯⋯ （2）外文缩写可以使用半角圆点(.)表示缩写。 U.S.A. Apple, Inc. （3）表示中文时，英文省略号（...）应改为中文省略号（⋯⋯）。 英文：5 minutes later... 中文：5 分钟过去了⋯⋯ （4）英文书名或电影名改用中文表达时，双引号应改为书名号。 英文：He published an article entitled \"The Future of the Aviation\". 中文：他发表了一篇名为《航空业的未来》的文章。 （5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。 IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。 （6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。 “American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。 “online transaction processing”（在线事务处理）不是专有名词，不应大写。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:2:4","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"段落 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:3:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"原则 一个段落只能有一个主题，或一个中心句子。 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为中心句子服务。 一个段落的长度不能超过七行，最佳段落长度小于等于四行。 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。 段落之间使用一个空行隔开。 段落开头不要留出空白字符。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:3:1","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"引用 引用第三方内容时，应注明出处。 One man’s constant is another man’s variable. — Alan Perlis 如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。 本文转载自 WikiQuote 使用外部图片时，必须在图片下方或文末标明来源。 本文部分图片来自 Wikipedia ","date":"2023-02-04","objectID":"/posts/document-style-guide/:3:2","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"数值 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:4:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"半角数字 阿拉伯数字一律使用半角形式，不得使用全角形式。 错误：这件商品的价格是１０００元。 正确：这件商品的价格是 1000 元。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:4:1","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"千分号 数值为千位以上，应添加千分号（半角逗号）。 XXX 公司的实收资本为 ￥1,258,000 人民币。 对于 4 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于 4 位以上的数值，应添加千分号。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:4:2","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"货币 货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。 $1,000 1,000 美元 英文的货币名称，建议参考国际标准 ISO 4217。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:4:3","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"数值范围 表示数值范围时，用波浪线（～）或一字线（—）连接。参见《标点符号》一节的“连接号”部分。 带有单位或百分号时，两个数字建议都要加上单位或百分号。 132 kg～234 kg 67%～89% ","date":"2023-02-04","objectID":"/posts/document-style-guide/:4:4","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"变化程度的表示法 数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。 增加到过去的两倍 （过去为一，现在为二） 增加了两倍 （过去为一，现在为三） 数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。 降低到百分之八十 （定额是一百，现在是八十） 降低了百分之八十 （原来是一百，现在是二十） 不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:4:5","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"标点符号 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"原则 （1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。 （2）如果整句为英文，则该句使用英文/半角标点。 （3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。 （4）点号（句号、逗号、顿号、分号、冒号）不得出现在标题的末尾，而标号（引号、括号、破折号、省略号、书名号、着重号、间隔号、叹号、问号）可以。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:1","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"句号 （1）中文语句的结尾处应该用全角句号（。）。 （2）句子末尾用括号加注时，句号应在括号之外。 错误：关于文件的输出，请参照第 1.3 节（见第 26 页。） 正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:2","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"逗号 （1）逗号（，）表示句子内部的一般性停顿。 （2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:3","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"顿号 （1）句子内部的并列词，应该用全角顿号(、) 分隔，而不用逗号，即使并列词是英语也是如此。 错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 （2）英文句子中，并列词语之间使用半角逗号（,）分隔。 例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components. （3）中文句子内部的并列词，最后一个尽量使用（和）来连接，使句子读起来更加连贯，下面两个句子都可以，第二个更优。 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里，以及百度等。 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:4","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"分号 （1）分号（；）表示复句内部并列分句之间的停顿。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:5","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"引号 （1）引用时，应该使用全角双引号（“ ”），注意前后双引号不同。 例句：许多人都认为客户服务的核心是“友好”和“专业”。 （2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（‘ ’），注意前后单引号不同。 例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。” ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:6","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"括号 （1）补充说明时，使用全角圆括号（（）），括号前后不加空格。 例句：请确认所有的连接（电缆和接插件）均安装牢固。 （2）几种括号的中英文名称。 英文 中文 { } braces 或 curly brackets 大括号 [ ] square brackets 或 brackets 方括号 \u003c \u003e angled brackets 尖括号 ( ) parentheses 圆括号 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:7","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"冒号 （1）全角冒号（：）常用在需要解释的词语后边，引出解释和说明。 例句：请确认以下几项内容：时间、地点、活动名称和来宾数量。 （2）表示时间时，应使用半角冒号（:）。 例句：早上 8:00 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:8","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"省略号 （1）省略号（⋯⋯）表示语句未完、或者语气的不连续。 （2）省略号占两个汉字空间、包含六个省略点，不要使用。。。或...等非标准形式。 （3）省略号不应与“等”这个词一起使用。 错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。 正确：我们为会餐准备了各色水果，有香蕉、苹果、梨⋯⋯ 正确：我们为会餐准备了香蕉、苹果、梨等各色水果。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:9","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"感叹号 （1）应该使用平静的语气叙述，尽量避免使用感叹号（！）。 （2）不得多个感叹号连用，比如！！和!!!。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:10","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"破折号 （1）破折号————一般用于进一步解释。 （2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。 例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。 例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:11","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"连接号 （1）连接号用于连接两个类似的词。 （2）以下场合应该使用直线连接号（-），占一个半角字符的位置。 两个名词的复合 图表编号 例句：氧化-还原反应 例句：图 1-1 （3）数值范围（例如日期、时间或数字）应该使用波浪连接号（～）或一字号（—），占一个全角字符的位置。 例句：2009 年～2011 年 注意，波浪连接号前后两个值都建议加上单位。 （4）波浪连接号也可以用汉字“至”代替。 例句：周围温度：-20 °C 至 -10 °C ","date":"2023-02-04","objectID":"/posts/document-style-guide/:5:12","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"文档体系 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:6:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"结构 软件手册是一部完整的书，建议采用下面的结构。 简介（Introduction）：[必备] [文件] 提供对产品和文档本身的总体的、扼要的说明 快速上手（Getting Started）：[可选] [文件] 如何最快速地使用产品 入门篇（Basics）：[必备] [目录] 又称“使用篇”，提供初级的使用教程 环境准备（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件 安装（Installation）：[可选] [文件] 软件的安装方法 设置（Configuration）：[必备] [文件] 软件的设置 进阶篇（Advanced)：[可选] [目录] 又称“开发篇”，提供中高级的开发教程 API（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍 FAQ：[可选] [文件] 常见问题解答 附录（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容 Glossary：[可选] [文件] 名词解释 Recipes：[可选] [文件] 最佳实践 Troubleshooting：[可选] [文件] 故障处理 ChangeLog：[可选] [文件] 版本说明 Feedback：[可选] [文件] 反馈方式 下面是两个真实范例，可参考。 Redux 手册 Atom 手册 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:6:1","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"文件名 文档的文件名不得含有空格。 文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。 错误：名词解释.md 正确：glossary.md 文件名建议只使用小写字母，不使用大写字母。 错误：TroubleShooting.md 正确：troubleshooting.md 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 文件名包含多个单词时，单词之间建议使用半角的连词线（-）分隔。 不佳：advanced_usage.md 正确：advanced-usage.md ","date":"2023-02-04","objectID":"/posts/document-style-guide/:6:2","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Spec"],"content":"参考链接 产品手册中文写作规范, by 华为 写作规范和格式规范, by DaoCloud 技术写作技巧在日汉翻译中的应用, by 刘方 简体中文规范指南, by lengoo 文档风格指南, by LeanCloud 豌豆荚文案风格指南, by 豌豆荚 中文文案排版指北, by sparanoid 中文排版需求, by W3C 为什么文件名要小写？, by 阮一峰 Google Developer Documentation Style Guide, by Google 出版物上数字用法的规定（国家标准 GBT15835－2011） GB 3100-1993 国际单位制及其应用 markdownlint, VSCode 插件 pangu.js, 盘古之白系列插件 ","date":"2023-02-04","objectID":"/posts/document-style-guide/:7:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Browser"],"content":"最近在抖音上刷到很多次 袁进老师 的前端视频，然后就听了一下他的前端大师课，感觉了解一些浏览器原理后，原来工作中的一些疑问也自然解开了。 ","date":"2023-01-11","objectID":"/posts/event-loop/:0:0","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"浏览器的进程模型 ","date":"2023-01-11","objectID":"/posts/event-loop/:1:0","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"何为进程？ 程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程 进程 每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。 ","date":"2023-01-11","objectID":"/posts/event-loop/:1:1","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"何为线程？ 有了进程后，就可以运行程序的代码了。 运行代码的「人」称之为「线程」。 一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。 如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。 线程 ","date":"2023-01-11","objectID":"/posts/event-loop/:1:2","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"浏览器有哪些进程和线程？ 浏览器是一个多进程多线程的应用程序，浏览器内部工作极其复杂。 为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。 浏览器进程 可以在浏览器的任务管理器中查看当前的所有进程 其中，最主要的进程有： 浏览器进程 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。 网络进程 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。 渲染进程（本篇重点讲解的进程） 渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。 将来该默认模式可能会有所改变，有兴趣的同学可参见 chrome 官方说明文档 ","date":"2023-01-11","objectID":"/posts/event-loop/:1:3","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"渲染主线程是如何工作的？ 渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于： 解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把页面画 60 次 执行全局 JS 代码 执行事件处理函数 执行计时器的回调函数 …… 思考题：为什么渲染进程不适用多个线程来处理这些事情？ 要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？ 比如： 我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？ 我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？ 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？ …… 渲染主线程想出了一个绝妙的主意来处理这个问题：排队 消息队列 在最开始的时候，渲染主线程会进入一个无限循环 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务 这样一来，就可以让每个任务有条不紊的、持续的进行下去了。整个过程，被称之为事件循环（消息循环）。 ","date":"2023-01-11","objectID":"/posts/event-loop/:2:0","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"若干解释 ","date":"2023-01-11","objectID":"/posts/event-loop/:3:0","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"何为异步？ 代码在执行过程中，会遇到一些无法立即处理的任务，比如： 计时完成后需要执行的任务 —— setTimeout、setInterval 网络通信完成后需要执行的任务 – XHR、Fetch 用户操作后需要执行的任务 – addEventListener 如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」 同步策略 渲染主线程承担着极其重要的工作，无论如何都不能阻塞！ 因此，浏览器选择异步来解决这个问题 异步策略 使用异步的方式，渲染主线程永不阻塞 面试题：如何理解 JS 的异步？ 参考答案： JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。 而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。 ","date":"2023-01-11","objectID":"/posts/event-loop/:3:1","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"JS 为何会阻碍渲染？ 先看代码 \u003ch1\u003eMr.Yuan is awesome!\u003c/h1\u003e \u003cbutton\u003echange\u003c/button\u003e \u003cscript\u003e var h1 = document.querySelector('h1'); var btn = document.querySelector('button'); // 死循环指定的时间 function delay(duration) { var start = Date.now(); while (Date.now() - start \u003c duration) {} } btn.onclick = function () { h1.textContent = '袁老师很帅！'; delay(3000); }; \u003c/script\u003e 点击按钮后，会发生什么呢？ \u003c复制代码自行演示\u003e ","date":"2023-01-11","objectID":"/posts/event-loop/:3:2","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Browser"],"content":"任务有优先级吗？ 任务没有优先级，在消息队列中先进先出 但消息队列是有优先级的 根据 W3C 的最新解释： 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint 随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法 在目前 chrome 的实现中，至少包含了下面的队列： 微队列：用户存放需要最快执行的任务，优先级「最高」 延时队列：用于存放计时器到达后的回调任务，优先级「中」 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」 多队列演示图 添加任务到微队列的主要方式主要是使用 Promise、MutationObserver，例如： // 立即把一个函数添加到微队列 Promise.resolve().then(() =\u003e {}); 浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑。 面试题：阐述一下 JS 的事件循环 参考答案： 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。 面试题：JS 中的计时器能做到精确计时吗？为什么？ 参考答案： 不行，因为： 计算机硬件没有原子钟，无法做到精确计时 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差 ","date":"2023-01-11","objectID":"/posts/event-loop/:3:3","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Debug"],"content":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效的解决办法","date":"2022-12-15","objectID":"/posts/homebrew-npm/","tags":["Homebrew","npm","npx","Mac"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["Debug"],"content":" 问题 前面一段时间，安装了 Homebrew, 但是今天切换 node 版本到 system version (8.10.0) 后，发现虽然 node 版本切换成功，但是 node 版本对应的 npm 和 npx 版本不相符，下面记录一下问题排查过程。 ","date":"2022-12-15","objectID":"/posts/homebrew-npm/:0:0","tags":["Homebrew","npm","npx","Mac"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["Debug"],"content":"罪魁祸首 首先定位到这次问题的根本原因是安装 Homebrew 导致的，这点可以很快也很明确地定位到，因为以前安装 Homebrew 也遇到了这个问题，但是当时的做法是卸载 Homebrew 避免冲突。 ","date":"2022-12-15","objectID":"/posts/homebrew-npm/:1:0","tags":["Homebrew","npm","npx","Mac"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["Debug"],"content":"Why 分析为啥会冲突，Homebrew 安装的工程中也会默认一部分依赖的二进制文件，npm 和 npx 也在其中，所以这导致了 Homebrew 的安装 npm 和 npx 覆盖了系统中 node 的 npm 和 npx 进而导致 node 和 npm 版本不一致，无法使用 npm 启动项目。 ","date":"2022-12-15","objectID":"/posts/homebrew-npm/:2:0","tags":["Homebrew","npm","npx","Mac"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["Debug"],"content":"Where 找一下目前 npm 和 npx 的二进制文件在哪。 nvm use system node -v # 8.10.0 which npm # /opt/homebrew/bin/npm which npx # /opt/homebrew/bin/npx ","date":"2022-12-15","objectID":"/posts/homebrew-npm/:3:0","tags":["Homebrew","npm","npx","Mac"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["Debug"],"content":"How 很明显前面的猜测是对的，那就打开这个目录看看： open /opt/homebrew/bin 找到 npm 和 npx，把他们重命名为 npm-brew 和 npx-brew, 这样通过别名也保留 Homebrew 的 npm 和 npx. 修改完后，重启终端，再看看 npm 和 npx 是否生效： nvm use system node -v # 8.10.0 which npm # /usr/local/bin/npm which npx # /usr/local/bin/npx npm -v npx -v 一切正常了，可以用 npm 继续启动原来的项目了。 ","date":"2022-12-15","objectID":"/posts/homebrew-npm/:4:0","tags":["Homebrew","npm","npx","Mac"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["Go"],"content":"记录 GO 及 Beego 框架安装及基础配置。 ","date":"2022-08-31","objectID":"/posts/beego-install/:0:0","tags":["Beego","Go"],"title":"Beego 安装及配置","uri":"/posts/beego-install/"},{"categories":["Go"],"content":"安装 Go 官网下载安装包：https://golang.google.cn/dl/ 通过二进制文件快速安装，默认安装目录：/usr/local/go 配置环境变量 vim ~/.bash_profile # golang export GOROOT=/usr/local/go export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN export GOPATH=$HOME/go export GOPROXY=https://goproxy.cn # Go work bin export PATH=$PATH:$GOPATH/bin ","date":"2022-08-31","objectID":"/posts/beego-install/:1:0","tags":["Beego","Go"],"title":"Beego 安装及配置","uri":"/posts/beego-install/"},{"categories":["Go"],"content":"安装 Beego Beego repository Beego docs Beego new docs Beego 的安装需要在新建项目且 go mod init \u003cmodule_name\u003e之后，在项目下执行，具体参考 beego#quick-start。 ","date":"2022-08-31","objectID":"/posts/beego-install/:2:0","tags":["Beego","Go"],"title":"Beego 安装及配置","uri":"/posts/beego-install/"},{"categories":["Go"],"content":"安装 bee bee repository 注意：arm64 架构的 mac (M1 ～系列)，下载安装 bee 时最好，使用 Rosetta 打开终端，不然无法下载 darwin_arm64 的依赖，如果已经安装了，可以使用 Rosetta 打开终端后，运行 bee update 升级，升级完后将终端复原。 bee 工具安装，go install 安裝指定版本的 bee 工具，例如： go install github.com/beego/bee/v2@latest 安装成功后，可以在 $GOPATH/bin 下看到 bee 的可执行文件。 检验 bee 工具是否安装成功： bee version 创建一个新的 Beego 项目 bee new hello cd hello go mod tidy bee run ","date":"2022-08-31","objectID":"/posts/beego-install/:3:0","tags":["Beego","Go"],"title":"Beego 安装及配置","uri":"/posts/beego-install/"},{"categories":["Spec"],"content":" 摘要 版本格式：MAJOR.MINOR.PATCH，版本号递增规则如下： MAJOR: 主版本号，当你做了不兼容的 API 修改 MINOR: 次版本号，当你做了向下兼容的功能性新增 PATCH: 修订号，当你做了向下兼容的问题修正 先行版本号及版本编译信息可以加到 MAJOR.MINOR.PATCH 的后面，作为延伸。 ","date":"2022-08-13","objectID":"/posts/semver/:0:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"格式 基本的语法格式如下，更多请参考 Backus–Naur Form Grammar for Valid SemVer Versions \u003cvalid semver\u003e ::= \u003cversion core\u003e | \u003cversion core\u003e \"-\" \u003cpre-release\u003e | \u003cversion core\u003e \"+\" \u003cbuild\u003e | \u003cversion core\u003e \"-\" \u003cpre-release\u003e \"+\" \u003cbuild\u003e 范例： 代码状态 等级 规则 版本样例 首次发布 新品发布 以 1.0.0 开始 1.0.0 bug 修复，向后兼容 补丁版本发布 变更第三位数字 1.0.1 新功能，向后兼容 次版本发布 变更第二位数字，并且第三位数字重置为 0 1.1.0 重大变更，不向后兼容 主版本发布 变更第一位数字，并且第二位，第三位数字重置为 0 2.0.0 “v1.2.3” 是一个语义化版本号吗？ “v1.2.3” 并不是的一个语义化的版本号。 但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。 在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。 比如：git tag v1.2.3 -m \"Release version 1.2.3\" 中，标签是 “v1.2.3”，语义化版本号是 “1.2.3”。 ","date":"2022-08-13","objectID":"/posts/semver/:1:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"规范 以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。 语义化版本控制规范（SemVer） 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -\u003e 1.10.0 -\u003e 1.11.0。 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 修订号 Z（x.y.Z | x \u003e 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。 次版本号 Y（x.Y.z | x \u003e 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用（deprecated）时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。 主版本号 X（X.y.z | X \u003e 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本的优先层级指的是不同版本在排序时如何比较。 判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。 由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。 例如：1.0.0 \u003c 2.0.0 \u003c 2.1.0 \u003c 2.1.1。 当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。 例如：1.0.0-alpha \u003c 1.0.0。 有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定： 只有数字的标识符以数值高低比较。 有字母或连接号时则逐字以 ASCII 的排序来比较。 数字的标识符比非数字的标识符优先层级低。 若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。 例如：1.0.0-alpha \u003c 1.0.0-alpha.1 \u003c 1.0.0-alpha.beta \u003c 1.0.0-beta \u003c 1.0.0-beta.2 \u003c 1.0.0-beta.11 \u003c 1.0.0-rc.1 \u003c 1.0.0 ","date":"2022-08-13","objectID":"/posts/semver/:2:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"版本阶段 Base: 设计阶段，只有相应的设计没有具体的功能实现 Alpha: 软件的初级版本，基本功能已经实现，但存在较多的 bug Bate: 相对于 Alpha 已经有了很大的进步，消除了严重的 BUG，但还存在一些潜在的 BUG，还需要不断测试 RC: 该版本已经相当成熟了，基本上不存在导致错误的 Bug，与即将发行的正式版本相差无几 RELEASE: 最终发布版本，没有太大的问题 最终发布版本（RELEASE）之前的所有版本，都称为先行版本（pre-release）。 ","date":"2022-08-13","objectID":"/posts/semver/:3:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"FAQ ","date":"2022-08-13","objectID":"/posts/semver/:4:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"其他相关 ","date":"2022-08-13","objectID":"/posts/semver/:5:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"npm SemVer 通常我们发布一个包到 npm 仓库时，我们的做法是先修改 package.json 为某个版本，然后执行 npm publish 命令。手动修改版本号的做法建立在你对 SemVer 规范特别熟悉的基础之上，否则可能会造成版本混乱。npm 和 yarn 两个包管理都提供了 SemVer 规范的版本控制命令： npm-version yarn version npm 发包基础命令： # 1. 创建一个新的包 npm init # 2. 查看是否官方源 npm config get registry # 3. 登录 npm login # 4. 发布 npm publish # 版本变化 major.minor.patch npm version patch # 升级补丁版本 npm version minor # 升级小版号 npm version major # 升级大版号 # 下架 [-force] npm unpublish 全局设置版本号前缀 # https://docs.npmjs.com/cli/v8/using-npm/config#tag-version-prefix npm config set tag-version-prefix \"\" # 全局设置版本更新 commit 提交信息 # https://docs.npmjs.com/cli/v8/using-npm/config#message npm config set message \"Chore(release): %s\" 或者设置项目的 .npmrc 或者 .yarnrc # .npmrc tag-version-prefix=\"\" message=\"Chore(release): %s\" # .yarnrc version-tag-prefix \"\" version-git-message \"Chore(release): %s\" package.json 版本控制规则使用了一些些符号： ^ ~ \u003e \u003e= \u003c \u003c= = - || 这些规则的详情如下： ^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。 ~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。 \u003e: 接受高于指定版本的任何版本。 \u003e=: 接受等于或高于指定版本的任何版本。 \u003c=: 接受等于或低于指定版本的任何版本。 \u003c: 接受低于指定版本的任何版本。 =: 接受确切的版本。 -: 接受一定范围的版本。例如：2.1.0 - 2.6.2。 ||: 组合集合。例如 \u003c 2.1 || \u003e 2.6。 可以合并其中的一些符号，例如 1.0.0 || \u003e=1.1.0 \u003c1.2.0，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。 还有其他的规则： 无符号：仅接受指定的特定版本（例如 1.2.1）。 latest: 使用可用的最新版本。 ","date":"2022-08-13","objectID":"/posts/semver/:5:1","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"版本保留 对于大型软件，每个版本都有使用价值时，应保留所有历史版本 对于始终以最新版本为准的软件，则可保留至少最近的 10 个次版本 ","date":"2022-08-13","objectID":"/posts/semver/:5:2","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec"],"content":"参考 Semantic Versioning 2.0.0 使用 npm 的语义版本控制 ","date":"2022-08-13","objectID":"/posts/semver/:6:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec","Git"],"content":"Commit messages are short descriptions of changes to a repository. We should follow certain standards to effectively describe changes, such as the Conventional Commits specification based on the Angular convention that is most used on GitHub, or each development team can simplify and formulate their own commit specification. This is not only conducive to the automatic generation of Changelog in the later stage, but more importantly, when a bug occurs, the entire warehouse can be quickly checked, the problem point can be accurately located, and the version can be reverted. ","date":"2022-08-12","objectID":"/posts/commit-spec/:0:0","tags":["Git"],"title":"Commit Message Spec","uri":"/posts/commit-spec/"},{"categories":["Spec","Git"],"content":"Format [{emoji} ]{type}[({module})]: {subject within 50 words}[ (#{issue/pull request})] example: 🎉 Feat: add shortcode fixit-encryptor shortcode (#123) ⬆️ Chore(libs): update Artalk from 2.2.12 to 2.3.4 (#150) ","date":"2022-08-12","objectID":"/posts/commit-spec/:1:0","tags":["Git"],"title":"Commit Message Spec","uri":"/posts/commit-spec/"},{"categories":["Spec","Git"],"content":"Emoji https://gitmoji.dev vscode plugin utools plugin GitEmoji ","date":"2022-08-12","objectID":"/posts/commit-spec/:2:0","tags":["Git"],"title":"Commit Message Spec","uri":"/posts/commit-spec/"},{"categories":["Spec","Git"],"content":"Message Emoji Type Example Description (No Ambiguous) 🎉 ✨ Feat Feat: add {feature} new feature 🚚 Feat: adjust/migrate {feature name}, {change details} For the adjustment feature, it is necessary to describe the current situation (before) and after adjustment (after) 🔥 Feat: delete {feature name}, {deletion reason} If the feature is deleted, the reason for deletion must be explained 🐛 🚧 🚨 Fix Fix: fix {bug description} Fix known bugs 🎨 💄 ✏️ Style Style: Typesetting/CSS style {optimizing content} Changes that do not affect code operation, such as code layout and style change ♻️ Refactor Refactor: override {feature name} It is neither a new function nor a code change to fix a bug. Simply rewriting the code of a function does not affect the function result ⚡ Perf Perf: improve performance {function name}, {improve content} Optimize code performance ⏪ Revert Revert: restore version {commit message of restore version} Restore the version of one commit ✏ ✏️ Docs Docs: revise comments/update documents Adjustment of documents and notes 🔧 Chore Chore: update plugin version Changes in the construction process or auxiliary tools ","date":"2022-08-12","objectID":"/posts/commit-spec/:3:0","tags":["Git"],"title":"Commit Message Spec","uri":"/posts/commit-spec/"},{"categories":["JavaScript"],"content":"总结一下最近 electron 开发遇到的问题和一些重要知识点。 ","date":"2022-08-12","objectID":"/posts/electron-summary/:0:0","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"简介 如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的开源框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。 ","date":"2022-08-12","objectID":"/posts/electron-summary/:1:0","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"知识点 ","date":"2022-08-12","objectID":"/posts/electron-summary/:2:0","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"进程 electron 由两种进程组成，包括主进程和 0 个或 n 个渲染进程。 主进程：承担应用的生命周期（包括启动，退出，准备，正在切换到后台，正在切换到前台等，还负责与原生操作系统 API 通信） 渲染进程：做 web 页面的 ui，渲染进程之间独立在各自的单线程，渲染进程之间相互隔离，不能直接访问操作系统，需要通信到主线程，在通过主线程操作访问操作形态，一个 BrowserWindow 实例即为一个渲染进程 ","date":"2022-08-12","objectID":"/posts/electron-summary/:2:1","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"技术栈 electron 整合了 Node 和浏览器的所有能力，可以随意发挥这些技术栈的特点。由于固定浏览器内核，可以无需考虑兼容性地使用 html/js/css 新特性。 ","date":"2022-08-12","objectID":"/posts/electron-summary/:2:2","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"安装 安装 electron 时，可能因为网络问题导致下载失败，需要使用镜像仓库来下载。 # 设置 electron 镜像仓库 # https://registry.npmmirror.com/-/binary/electron # 13.1.7 版本 下载链接可能会拼错导致 404，要设置成 https://registry.npmmirror.com/-/binary/electron/v npm config set electron_mirror=https://npmmirror.com/mirrors/electron/ M1 Mac 安装较低版本 electron 时可能会报错，Failed to find Electron v xxx for darwin-arm64，因为这些版本的 electron 不支持 darwin-arm64 架构。Apple 针对未适配的 X64 应用提供了 Rosetta2 转换器，安装 darwin-x64 版本的 electron 在 Intel 模式下运行即可，参考。 ","date":"2022-08-12","objectID":"/posts/electron-summary/:2:3","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"remote 不要频繁使用 remote, 更多应该手动进行和主进程之间的通信。 使用时需在窗口创建时设置 webPreferences.enableRemoteModule 为 true。 旧版本的 electron.remote 已经弃用，应该使用依赖 electron/remote 代替。 使用了旧版本的 remote 时会有控制台警告信息： (electron) The remote module is deprecated. Use https://github.com/electron/remote instead. 获取当前窗口：remote.getCurrentWindow() ","date":"2022-08-12","objectID":"/posts/electron-summary/:2:4","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"问题点 ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:0","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"打开外部浏览器 electron 的 shell 模块，可以使用 shell.openExternal(url) 在默认浏览器打开链接。 ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:1","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"防抖与节流 防抖：短期内大量触发事件时，只执行最后一次。 function debounce(fn) { let timer = null; return function () { clearTimeOut(timer); timer = setTimeOut(() =\u003e { fn.applay(this, arguments); }, 300); }; } 节流：短期内大量触发事件时，只执行第一次。 function throttle(fn) { let timer = null; return function () { if (timer) return; timer = setTimeOut(() =\u003e { fn.applay(this, arguments); timer = null; }, 300); }; } ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:2","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"devTools 初始化窗口时设置 webPreferences.devTools 为 true，然后通过 mainWindow.webContents.openDevTools() 打开开发者工具。 如果只在开发环境启用开发者工具，则需要设置 webPreferences.devTools 为 process.env.NODE_ENV === 'development' ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:3","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"启动白屏 在创建窗口时设置 show: false，在 ready-to-show 事件之后执行 mainWindow.show()， 可见官方文档 优雅地显示窗口。 启动前 loading 额外创建一个 loading 窗口，该窗口可设置为透明只包含 loading 图标和文字，在 mainWindow.show() 后关闭。 启动后 loading 如果使用了 Vue 框架，在 Vue 初始化之前窗口虽然出现了，但是内容时空白的，可以在 Vue 实例 #app 里写一个 loading, Vue 加载完后会覆盖掉。 \u003cdiv id=\"app\"\u003e \u003c!-- Display the loading icon and text until Vue initialization is complete --\u003e \u003cstyle type=\"text/css\"\u003e html, body { height: 100%; margin: 0; } body { display: flex; } #app { margin: auto; display: flex; align-items: center; } @media (prefers-color-scheme: dark) { body { color: #fff; background-color: #202124; } } \u003c/style\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" style=\"margin:auto;background:0 0\" width=\"60\" height=\"60\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid\" display=\"block\" \u003e \u003ccircle cx=\"50\" cy=\"50\" r=\"20\" stroke-width=\"4\" stroke=\"#a5a5a5\" stroke-dasharray=\"31.416 31.416\" fill=\"none\" stroke-linecap=\"round\" transform=\"rotate(67.21 50 50)\" \u003e \u003canimateTransform attributeName=\"transform\" type=\"rotate\" repeatCount=\"indefinite\" dur=\"1s\" keyTimes=\"0;1\" values=\"0 50 50;360 50 50\" /\u003e \u003c/circle\u003e \u003c/svg\u003e \u003cspan\u003e加载中 ...\u003c/span\u003e \u003c/div\u003e ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:4","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"阻止窗口关闭 可以在关闭前一些事件里做拦截，比如：onbeforeunload 等，详见 实例事件。 ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:5","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"手动关闭窗口 当自定义关闭时，使用 mainWindow.destroy() 来关闭窗口，因为使用 mainWindow.close() 时，windows 系统打开开发者工具时会出现无法关闭窗口的情况。 ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:6","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"全局快捷键 当 electron 版本较低时，比如 13.1.7，会出现在 mac 系统上复制粘贴等常用快捷键失效的问题。可通过设置菜单并绑定快捷键的方式解决。 const main = [ { label: '', submenu: [ { label: '关于', role: 'about' }, { label: '关闭', role: 'close' }, { label: '退出', role: 'quit' } ] }, { label: '编辑', submenu: [ { label: '撤销', role: 'undo' }, { label: '恢复', role: 'redo' }, { type: 'separator' }, { label: '剪切', role: 'cut' }, { label: '复制', role: 'copy' }, { label: '粘贴', role: 'paste' }, { type: 'separator' }, { label: '全选', role: 'selectAll' } ] } ]; const dev = [ { label: '开发者', submenu: [ { label: '刷新', role: 'reload' }, { label: '强制刷新', role: 'forcereload' }, { type: 'separator' }, { label: '开发者工具', role: 'toggledevtools' } ] } ]; if (process.env.NODE_ENV === 'development') { main.push(...dev); } export default main; import memuConfig from './menu'; import { Menu } from 'electron'; if (process.platform === 'darwin') { const menu = Menu.buildFromTemplate(memuConfig); Menu.setApplicationMenu(menu); } ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:7","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"electron-builder 下载时，可能因为网络问题导致下载失败，可设置 GitHub 下载镜像。 # GitHub 仓库下载地址前缀镜像 # disturl=https://registry.npmmirror.com/-/binary/ 或者去 GitHub 手动下载，然后解压到缓存目录： macOS: ~/Library/Caches/electron-builder/ linux: ~/.cache/electron-builder/ windows: %LOCALAPPDATA%\\electron-builder\\cache\\ mac 上缓存目录如下，其他可 参考 ▸ nsis/ ▸ nsis-resources-3.4.1/ ▸ nsis-3.0.4.1/ ▸ winCodeSign/ ▸ winCodeSign-2.6.0/ ▸ wine/ ▸ wine-4.0.1-mac/ windows 打包 windows 系统打包配置，当没有配置签名时，sign 字段应删除或者配置为 null，否则可能导致打包时报错。 { \"win\": { \"icon\": \"static/icons/icon.ico\", \"verifyUpdateCodeSignature\": false, \"target\": \"nsis\", \"sign\": null } } 注：win11 打包在 win10 上可能运行不了，最好使用 win10 打包或者 mac 打包指定系统和位数。 macOS 打包 问题：mac 升级之后 electron 打包报错 Exit code: ENOENT. spawn /usr/bin/python ENOENT 解决：网上搜到的下载 python 2.7 是治标不治本，正确做法是升级 electron-builder 到 23.0.2 或更高版本，参考 electron-builder#6726 参考链接 Electron-Mac 应用的签名步骤说明 ","date":"2022-08-12","objectID":"/posts/electron-summary/:3:8","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"记录一下前端实现页面加密的思路。 ","date":"2022-08-08","objectID":"/posts/encryption-fe/:0:0","tags":["JavaScript","加密"],"title":"前端页面内容加密总结","uri":"/posts/encryption-fe/"},{"categories":["JavaScript"],"content":"加密基础知识 ","date":"2022-08-08","objectID":"/posts/encryption-fe/:1:0","tags":["JavaScript","加密"],"title":"前端页面内容加密总结","uri":"/posts/encryption-fe/"},{"categories":["JavaScript"],"content":"双向加密 可还原的加密算法，可以逆向解密。 对称加密（单密钥加密） 采用单钥密码系统的加密方法，同一个密钥同时用作信息的加密和解密。 密钥生成算法有 DES、3DES、AES。 非对称加密（公开密钥系统） 两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 公钥/私钥加密/签名，用私钥/公钥解密/验证签名。 密钥生成算法有 RSA（公钥、私钥）、DSA（公钥、私钥、数字签名）。 ","date":"2022-08-08","objectID":"/posts/encryption-fe/:1:1","tags":["JavaScript","加密"],"title":"前端页面内容加密总结","uri":"/posts/encryption-fe/"},{"categories":["JavaScript"],"content":"单向加密 不可还原的加密算法（暴力撞库除外），常见的算法有：MD5、SHA1、SHA256、SHA512。 ","date":"2022-08-08","objectID":"/posts/encryption-fe/:1:2","tags":["JavaScript","加密"],"title":"前端页面内容加密总结","uri":"/posts/encryption-fe/"},{"categories":["JavaScript"],"content":"页面内容加密 内容加密算法 通过比对密码和输入的 md5 值来判断密码是否输入正确 密码验证通过后，开始解密内容 拿到正确的输入值的 sha256 值的部分内容 然后按照加密规则解秘内容 这里利用 Set 进行事件管理，简单模拟了 addEventListener 和 removeEventListener 的操作。并提供了两个事件：decrypted 和 reset，详见 fixit-decryptor.js。 ","date":"2022-08-08","objectID":"/posts/encryption-fe/:2:0","tags":["JavaScript","加密"],"title":"前端页面内容加密总结","uri":"/posts/encryption-fe/"},{"categories":["Node.js","JavaScript"],"content":" 问题 腾讯云云函数从 2022 年 6 月 1 日开始收费了，差不多每个月 12 块，对于可能几个月都用不上一次云函数刷新缓存的人来说，有点太贵了。 使用 Node.js 和 GitHub Actions 刷新 CDN 的方式，可以节省不少钱。 ","date":"2022-08-07","objectID":"/posts/qcloudcdn/:0:0","tags":["CDN","GitHub Actions","Node.js"],"title":"Node.js + GitHub Actions 自动刷新 CDN","uri":"/posts/qcloudcdn/"},{"categories":["Node.js","JavaScript"],"content":"安装依赖 npm install qcloud-cdn-node-sdk ","date":"2022-08-07","objectID":"/posts/qcloudcdn/:1:0","tags":["CDN","GitHub Actions","Node.js"],"title":"Node.js + GitHub Actions 自动刷新 CDN","uri":"/posts/qcloudcdn/"},{"categories":["Node.js","JavaScript"],"content":"编写脚本 vim .scripts/qcloudcdn.js /** * Refresh Qcloud CDN cache * @command `node qcloudcdn.js $SECRET_ID $SECRET_KEY` */ const qcloudSDK = require('qcloud-cdn-node-sdk'); // Get the config from https://console.qcloud.com/capi qcloudSDK.config({ secretId: process?.argv[2], secretKey: process?.argv[3] }); qcloudSDK.request( 'RefreshCdnDir', { // See https://cloud.tencent.com/document/api/228/3947 'dirs.0': 'https://lruihao.cn/' }, (res) =\u003e { res.code \u0026\u0026 console.log(res); } ); ","date":"2022-08-07","objectID":"/posts/qcloudcdn/:2:0","tags":["CDN","GitHub Actions","Node.js"],"title":"Node.js + GitHub Actions 自动刷新 CDN","uri":"/posts/qcloudcdn/"},{"categories":["Node.js","JavaScript"],"content":"增加快捷指令 打开 package.json 增加 scripts: { \"scripts\": { \"qcloudcdn\": \"node .scripts/qcloudcdn.js $SECRET_ID $SECRET_KEY\" } } 运行方式： SECRET_ID=\u003csecretId\u003e SECRET_KEY=\u003csecretKey\u003e npm run qcloudcdn Mac OS 环境变量配置（可选） vim ~/.bash_profile # Qcloud secret key-value export SECRET_ID=\u003csecretId\u003e export SECRET_KEY=\u003csecretKey\u003e source ~/.bash_profile 然后，在本地可简化指令为 npm run qcloudcdn 或者 yarn qcloudcdn。 等同于 SECRET_ID=$SECRET_ID SECRET_KEY=$SECRET_KEY npm run qcloudcdn ","date":"2022-08-07","objectID":"/posts/qcloudcdn/:3:0","tags":["CDN","GitHub Actions","Node.js"],"title":"Node.js + GitHub Actions 自动刷新 CDN","uri":"/posts/qcloudcdn/"},{"categories":["Node.js","JavaScript"],"content":"配置 GitHub Actions 在原有 GitHub Actions 中部署后增加一个步骤： - name: Refresh Qcloud CDN cache env: SECRET_ID: ${{ secrets.SECRET_ID }} SECRET_KEY: ${{ secrets.SECRET_KEY }} run: npm run qcloudcdn 在仓库 Settings \u003e Secrets \u003e Actions 中增加两个 Secret: SECRET_ID 和 SECRET_KEY，原来有配置过的就不用了，比如，我原来的叫 COS_SECRET_ID 和 COS_SECRET_ID，那修改上面配置 env 中的变量名即可。 最后上传代码，以后更新仓库时就会自动刷新 CDN 缓存了。 ","date":"2022-08-07","objectID":"/posts/qcloudcdn/:4:0","tags":["CDN","GitHub Actions","Node.js"],"title":"Node.js + GitHub Actions 自动刷新 CDN","uri":"/posts/qcloudcdn/"},{"categories":["Node.js","JavaScript"],"content":"参考资料 Qcloud_CDN_API/nodejs 本方案使用的旧的 API 请求方式，如果失效，可以参考新的 API，见 SDK 中心。 ","date":"2022-08-07","objectID":"/posts/qcloudcdn/:5:0","tags":["CDN","GitHub Actions","Node.js"],"title":"Node.js + GitHub Actions 自动刷新 CDN","uri":"/posts/qcloudcdn/"},{"categories":["OS"],"content":"换行符（通常称为行尾、行尾 (EOL)、下一行 (NEL) 或换行符）是字符编码规范（例如，ASCII、EBCDIC）中的控制字符或控制字符序列，用于表示一行文本的结尾和新文本的开头。 周五下班的时候想在 windows 电脑上跑一下 FixIt 看看有没有什么 bug, 然后就发现了 typyit shortcode 开头多出一行空行，mermaid shortcode 则直接语法报错了。 看了一下代码明明有 trim \\n 处理，而且 Vercel 打包和 Mac 上运行打包都没问题。debug 了一下才发现 Windows 系统上的换行是 \\r\\n, 而 Mac 系统上的换行是 \\n。于是查了一下不同系统的换行符的差异问题。 ","date":"2022-08-07","objectID":"/posts/newline/:0:0","tags":["newline"],"title":"不同系统的换行符的差异","uri":"/posts/newline/"},{"categories":["OS"],"content":"历史 简单来说，回车换行这些说法是从打字机那个时代开始叫的，然后在不同的标准下换行符有不同的表现符号。 Windows 系统设计遵循了 CR + LF 的约定，而 Unix 系统则遵循了 LF 的约定，之后的 类 Unix (Linux, macOS) 系统也遵循了 LF 的约定。 当然也有异类，老版的 mac 系统使用 CR 作为换行符。 ","date":"2022-08-07","objectID":"/posts/newline/:1:0","tags":["newline"],"title":"不同系统的换行符的差异","uri":"/posts/newline/"},{"categories":["OS"],"content":"表示 CR 回车：\\r LF 换行：\\n 操作系统 换行符号 Windows \\r\\n Unix、Linux、MacOS \\n classic Mac OS \\r ","date":"2022-08-07","objectID":"/posts/newline/:2:0","tags":["newline"],"title":"不同系统的换行符的差异","uri":"/posts/newline/"},{"categories":["OS"],"content":"问题 由于这个差异，会导致文本类的文件在跨系统浏览时会产生一些差异，比如说，Mac 的文本文件在 Windows 打开会全部挤在一行等等。 对于开发人员来说，这很有可能导致某些程序失效，比如正则去除空行等等。 甚至因此，Linux 系统下提供有两个命令用来进行 Windows 和 Unix 文件的转化：dos2unix和 unix2dos。 ","date":"2022-08-07","objectID":"/posts/newline/:3:0","tags":["newline"],"title":"不同系统的换行符的差异","uri":"/posts/newline/"},{"categories":["OS"],"content":"参考 Newline ","date":"2022-08-07","objectID":"/posts/newline/:4:0","tags":["newline"],"title":"不同系统的换行符的差异","uri":"/posts/newline/"},{"categories":["Grocery"],"content":"ohmyzsh 自带了很多主题，也有很多没有收录的扩展主题，我就想要个简约的主题，但是每个都差点意思，干脆改一个主题。 ","date":"2022-07-31","objectID":"/posts/ohmyzsh-custom/:0:0","tags":null,"title":"自定义 ohmyzsh 主题","uri":"/posts/ohmyzsh-custom/"},{"categories":["Grocery"],"content":"自定义主题 复制默认主题，当作模板： cd ~/.oh-my-zsh cat themes/robbyrussell.zsh-theme \u003e custom/custom.zsh-theme vim custom/custom.zsh-theme 然后修改里面的内容： if [[ -z $ZSH_THEME_CUSTOM_PREFIX ]]; then ZSH_THEME_CUSTOM_PREFIX=\"\u003e\" fi PROMPT=\"%(?:%{$fg_bold[blue]%}$ZSH_THEME_CUSTOM_PREFIX:%{$fg_bold[red]%}$ZSH_THEME_CUSTOM_PREFIX)\" PROMPT+=' %{$fg[blue]%}%c%{$reset_color%} $(git_prompt_info)' ZSH_THEME_GIT_PROMPT_PREFIX=\"%{$fg_bold[green]%}git:(%{$fg[magenta]%}\" ZSH_THEME_GIT_PROMPT_SUFFIX=\"%{$reset_color%} \" ZSH_THEME_GIT_PROMPT_DIRTY=\"%{$fg[green]%}) %{$fg[yellow]%}✗\" ZSH_THEME_GIT_PROMPT_CLEAN=\"%{$fg[green]%})\" ","date":"2022-07-31","objectID":"/posts/ohmyzsh-custom/:1:0","tags":null,"title":"自定义 ohmyzsh 主题","uri":"/posts/ohmyzsh-custom/"},{"categories":["Grocery"],"content":"配置 vim ~/.zshrc ZSH_THEME=custom 然后重启终端即可。 ","date":"2022-07-31","objectID":"/posts/ohmyzsh-custom/:2:0","tags":null,"title":"自定义 ohmyzsh 主题","uri":"/posts/ohmyzsh-custom/"},{"categories":["OS"],"content":"记录 linux 系统下文件权限相关的内容，Mac OS 下类似。 ","date":"2022-07-30","objectID":"/posts/linux-permission/:0:0","tags":["linux","Mac","他山之石"],"title":"linux 文件权限","uri":"/posts/linux-permission/"},{"categories":["OS"],"content":"查看文件权限 查看 linux 系统下的文件权限，可以使用 ll 命令或者 ls 命令 带 -l（长列表选项） ➜ ~ ll total 160 drwx------@ 8 liruihao staff 256B Jul 5 14:47 Applications drwx------@ 10 liruihao staff 320B Jul 27 11:31 Desktop drwx------+ 7 liruihao staff 224B Jun 17 15:01 Documents drwx------@ 22 liruihao staff 704B Jul 29 16:35 Downloads drwx------@ 94 liruihao staff 2.9K Jul 23 19:02 Library drwx------ 4 liruihao staff 128B Nov 13 2021 Movies drwx------+ 6 liruihao staff 192B Nov 18 2021 Music drwx------+ 9 liruihao staff 288B Apr 26 10:25 Pictures drwxr-xr-x+ 5 liruihao staff 160B Nov 14 2021 Public drwxr-xr-x 5 liruihao staff 160B Jul 29 17:48 file-share drwxr-xr-x 3 liruihao staff 96B Jul 26 17:17 node_modules -rw-r--r-- 1 liruihao staff 27B Jun 24 13:47 package-lock.json drwxr-xr-x 20 liruihao staff 640B Jul 29 22:20 workspace -rw-r--r-- 1 liruihao staff 86B Jul 26 17:17 yarn.lock 文件列表信息分为：文件类型、权限、链接数、所属用户、所属用户组、文件大小、最后修改时间、文件名。 ","date":"2022-07-30","objectID":"/posts/linux-permission/:1:0","tags":["linux","Mac","他山之石"],"title":"linux 文件权限","uri":"/posts/linux-permission/"},{"categories":["OS"],"content":"文件类型 linux 一共有 7 种文件类型，分别如下： -: 普通文件 d: 目录文件 l: 链接文件 b: 块设备文件 p: 管道文件 c: 字符设备文件 s: 套接口文件/数据接口文件 后四种是特殊文件 ","date":"2022-07-30","objectID":"/posts/linux-permission/:2:0","tags":["linux","Mac","他山之石"],"title":"linux 文件权限","uri":"/posts/linux-permission/"},{"categories":["OS"],"content":"文件权限对应关系 权限 含义 对应数字 r 读权限 4 w 写权限 2 x 执行权限 1 读、写、运行三项权限用数字表示就是 r=4,w=2,x=1。所以，-rw-r--r-- 用数字表示成 644。 权限字段 -rwxrwxrwx 的内容总共会有 10 个 -，第一个表示文件类型，如该文件是文件 (-表示），文件夹 (d 表示）, 连接文件 (l 表示），后面 9 个按照每三位为一组分。 drwxr-xr-x 5 liruihao staff 160B Jul 29 17:48 file-share d: 代表文件夹 rwx: 代表文件所有者 (u 表示）权限，这里是 liruihao，liruihao 对该文件拥有读写执行权限。 r-x: 代表所属（g 表示）的权限，这里同组用户拥有对该文件读和执行的权限。 r-x: 代表其他用户（o 表示）的权限，这里和上面权限一样。 ","date":"2022-07-30","objectID":"/posts/linux-permission/:3:0","tags":["linux","Mac","他山之石"],"title":"linux 文件权限","uri":"/posts/linux-permission/"},{"categories":["Memo"],"content":"记录一下使用 Mac 作为生产工具开发的一些基本配置和经验。 ","date":"2022-07-29","objectID":"/posts/config4mac/:0:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"配置文件 Mac 上有很多配置文件都可以用来保存环境变量等配置，根据自己的理解记录了四个文件的用途： # etc/profile 系统配置文件 # etc/.bash_profile 系统环境变量配置 # ~/.bash_profile 个人环境变量配置 # ~/.zshrc zsh 的配置文件 # $ZSH_CUSTOM/*.zsh 自定义 zsh 脚本，在 zsh 启动时会自动执行 编辑最多的应该是 ~/.bash_profile 和 ~/.zshrc, 基本上建议所有的个人配置都放在 ~/.bash_profile 中，然后在 ~/.zshrc 最后执行 source ~/.bash_profile, 这样也方便将自己的个人环境变量配置备份。 ","date":"2022-07-29","objectID":"/posts/config4mac/:1:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"常用命令 # 安装/卸载 homebrew install.sh/uninstall.sh /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # 注意：安装 Homebrew 会下载 node, 请做好 node 环境被破坏的准备 # 显示隐藏文件 true/false or cmd+shift+. defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder # 释放端口 lsof -i:$your_port # 1. 查看使用端口进程 kill -9 $your_PID # 2. 释放进程 ","date":"2022-07-29","objectID":"/posts/config4mac/:2:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"Node # 设置阿里镜像 npm config set registry=https://registry.npmmirror.com # npm config set registry https://registry.npmjs.org # GitHub 仓库下载地址前缀镜像 # disturl=https://registry.npmmirror.com/-/binary/ # 全局安装的依赖 npm install -g npm@8.13.1 npm install -g cnpm npm install -g @vue/cli npm install -g nvm npm install -g nrm npm install -g yarn npm install -g yrm # npm 参数 --ignore-scripts # 忽略脚本错误 --force # 会无视冲突，并强制获取远端 npm 库资源，即使本地有资源也会覆盖掉 --legacy-peer-deps # 安装时忽略所有 peerDependencies，忽视依赖冲突，采用 npm 版本 4 到版本 6 的样式去安装依赖，已有的依赖不会覆盖 # 清除缓存 npm cache clean --force rm -rf node_modules rm -rf package-lock.json npm install # nvm nvm alias default [node_version] # 设置默认版本 # 检查过时依赖 npm outdated # 安全更新 npm update # ncu 更新检查工具 # https://blog.51cto.com/u_13028258/5115637?b=totalstatistic npm install -g npm-check-updates ## 检查 ncu ncu vue ## 更新 ncu -u ncu -u vue electron 相关配置 # 设置 electron 镜像仓库 # https://registry.npmmirror.com/-/binary/electron # 13.1.7 版本 下载链接可能会拼错导致 404，要设置成 https://registry.npmmirror.com/-/binary/electron/v npm config set electron_mirror=https://npmmirror.com/mirrors/electron/ ","date":"2022-07-29","objectID":"/posts/config4mac/:3:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"SourceTree Custom actions Script target: /bin/bash Parameters: /Users/liruihao/workspace/.shell/sync_tags.sh 技巧 根据不同的 shell 程序选择不同的文件后缀名，并给文件增加可执行权限： zsh: .zsh bash: .sh #! /bin/bash # 同步远程仓库标签分支脚本 git tag -l | xargs git tag -d # git fetch origin --prune # git fetch origin --tags git fetch origin --prune --prune-tags #! /bin/bash # 同步所有子模组 git submodule update --remote --merge #! /bin/zsh # ssh 配置但无法连接时 ssh-agent -s ssh-add ~/.ssh/Lruihao-Github # 私钥路径 技巧 开机启动时系统会去自动读取 id_rsa 的私钥来启动 SSH 链接，若不是默认命令就会失败需要手动执行上诉命令启动，可添加到开机自启动。 SourceTree 相关文章 解决 SourceTree 提交时候 husky 命令失败问题 ","date":"2022-07-29","objectID":"/posts/config4mac/:4:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"Terminal Terminal: 系统自带 Shell: zsh 美化: ohmyzsh 修改启动语 vim $PREFIX/etc/motd ","date":"2022-07-29","objectID":"/posts/config4mac/:5:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"sublime-text 3 # Terminal 启用 sublime 别名 subl ## 1.设置软链（推荐） sudo ln -s \"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl ## 2.设置别名 vim ~/.bash_profile alias subl=\"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\" source ~/.bash_profile # 每打开一个命令窗口，需要先让命令生效 ","date":"2022-07-29","objectID":"/posts/config4mac/:6:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"开机自启动 系统偏好设置 -\u003e 用户与群组 -\u003e 登录项 -\u003e 增删可执行文件 (需配置默认启动软件) 将 shell 命令添加到 /System/Library/StartupItems/ 或 /Library/StartupItems/ 文件夹（测试无效） ","date":"2022-07-29","objectID":"/posts/config4mac/:7:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"备份 # ------------------------------------- # This configuration is for Lruihao. # https://lruihao.cn/posts/config4mac/ # ------------------------------------- export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 # workspace export WORKSPACE=\"$HOME/workspace\" # alias alias subl=\"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\" alias mysql=/usr/local/mysql/bin/mysql alias mysqladmin=/usr/local/mysql/bin/mysqladmin alias incr=\"source $WORKSPACE/.shell/incr*.zsh\" alias typora=\"open -a typora\" # maven export M2_HOME=$HOME/Applications/apache-maven-3.8.5 export PATH=$PATH:$M2_HOME/bin # jenv export PATH=\"$HOME/.jenv/bin:$PATH\" eval \"$(jenv init -)\" # java export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_321.jdk/Contents/Home export JAVA_17_HOME=/Library/Java/JavaVirtualMachines/jdk-17.0.2.jdk/Contents/Home export JAVA_HOME=$JAVA_8_HOME # 设置一个中间变量，为了方便多个 JDK 版本时更换 JAVA_HOME export PATH=$JAVA_HOME/bin:$PATH:. # 冒号前代表 JDK 目录下的 bin 目录，冒号后代表当前目录 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar # jmeter export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4.1 export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar # platform-tools of Android SDK export PATH=$PATH:$HOME/Applications/platform-tools # Electron-Mac app development export CSC_LINK=$WORKSPACE/mac_app_dev/Mac.p12 export CSC_KEY_PASSWORD=xxxxxxxxx # yarn export PATH=\"$HOME/.yarn/bin:$HOME/.config/yarn/global/node_modules/.bin:$PATH\" # zsh custom plugin # https://mimosa-pudica.net/zsh-incremental.html # source $WORKSPACE/.shell/incr*.zsh # Qcloud secret key-value export SECRET_ID=\"\" export SECRET_KEY=\"\" # golang export GOROOT=/usr/local/go export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN export GOPATH=$HOME/go export GOPROXY=https://goproxy.cn # Go work bin export PATH=$PATH:$GOPATH/bin # sass_embedded export PATH=$PATH:$HOME/Applications/sass_embedded # https://github.com/nvm-sh/nvm#manual-install export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] \u0026\u0026 \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion # https://github.com/nvm-sh/nvm#deeper-shell-integration autoload -U add-zsh-hook load-nvmrc() { local node_version=\"$(nvm version)\" local nvmrc_path=\"$(nvm_find_nvmrc)\" if [ -n \"$nvmrc_path\" ]; then local nvmrc_node_version=$(nvm version \"$(cat \"${nvmrc_path}\")\") if [ \"$nvmrc_node_version\" = \"N/A\" ]; then nvm install elif [ \"$nvmrc_node_version\" != \"$node_version\" ]; then nvm use fi elif [ \"$node_version\" != \"$(nvm version default)\" ]; then echo \"Reverting to nvm default version\" nvm use default fi # fix husky hook # ref: https://github.com/typicode/husky/issues/390#issuecomment-762213421 echo \"export PATH=\\\"$(dirname $(which node)):\\$PATH\\\"\" \u003e ~/.huskyrc } add-zsh-hook chpwd load-nvmrc load-nvmrc # https://github.com/nvm-sh/nvm#use-a-mirror-of-node-binaries export NVM_NODEJS_ORG_MIRROR=https://mirrors.ustc.edu.cn/node/ 先添加一些基础配置 basic.vim \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" =\u003e Custom config for Lruihao \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Enable mouse set mouse=a \" Enable line-number set number ","date":"2022-07-29","objectID":"/posts/config4mac/:8:0","tags":["Git","Mac","Node.js"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["Memo"],"content":"作为非安卓专业开发，无需下载 Android SDK， 仅下载 Android SDK 中的 platform-tools 命令行工具即可，并配置好环境变量。 ","date":"2022-07-05","objectID":"/posts/adb-for-mac/:0:0","tags":["Android","ADB"],"title":"Mac 配置 ADB","uri":"/posts/adb-for-mac/"},{"categories":["Memo"],"content":"安装 platform-tools ","date":"2022-07-05","objectID":"/posts/adb-for-mac/:1:0","tags":["Android","ADB"],"title":"Mac 配置 ADB","uri":"/posts/adb-for-mac/"},{"categories":["Memo"],"content":"配置环境变量 open .bash_profile 写入以下内容 # platform-tools of Android SDK export PATH=$PATH:$HOME/Applications/platform-tools source .bash_profile Windows 系统打开高级设置，配置 PATH 变量，增加一条路径即可。 ","date":"2022-07-05","objectID":"/posts/adb-for-mac/:2:0","tags":["Android","ADB"],"title":"Mac 配置 ADB","uri":"/posts/adb-for-mac/"},{"categories":["Memo"],"content":"ADB 命令 通过 USB 连接手机和电脑，执行以下命令 # 1. 打开手机 tcpip 5555 端口 adb tcpip 5555 # 2. 查看手机网络 IP adb shell ifconfig # 3. 在电脑上 ping 手机网络 IP # 4. adb connect [Android IP] Android 调试桥 (adb) awesome-adb ","date":"2022-07-05","objectID":"/posts/adb-for-mac/:3:0","tags":["Android","ADB"],"title":"Mac 配置 ADB","uri":"/posts/adb-for-mac/"},{"categories":["Memo"],"content":"注意 windows 系统下的文件（夹）命名所采用的是 GBK 编码，而 linux 是采用的 UTF-8 编码，使用 adb 的 push 和 pull 命令时由于编码方式的不同会产生错误，因此需要修改 adb 的源代码来支持编码转换。 ","date":"2022-07-05","objectID":"/posts/adb-for-mac/:4:0","tags":["Android","ADB"],"title":"Mac 配置 ADB","uri":"/posts/adb-for-mac/"},{"categories":["JavaScript"],"content":" 前言 前端框架轮替变化越来越快，JavaScript 也在不断地升级迭代，越来越多的新特性让我们的代码写起来变得简洁有趣。 每隔一段时间就该重新认识一下 JS，这篇文章会介绍 6 种新特性，一起研究一下吧。 ","date":"2022-05-01","objectID":"/posts/js-rediscover/:0:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["JavaScript"],"content":"数组方法 some, every, find, filter, map 共同点：这几个方法都不会改变原始数组。 some some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试，它返回一个布尔值。 数组中有至少一个元素通过回调函数的测试就会返回 true，所有元素都没有通过回调函数的测试返回值才会为 false。 arr.some(callback(element[, index[, array]])[, thisArg]) [2, 5, 8, 1, 4].some((x) =\u003e x \u003e 10); // false [12, 5, 8, 1, 4].some((x) =\u003e x \u003e 10); // true 技巧 some() 不会对空数组进行检测，空数组返回 false every 助记：every() 和 some() 功能相反 every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试，它返回一个布尔值。 如果回调函数的每一次返回都为 truthy 值，返回 true ，否则返回 false。 arr.every(callback(element[, index[, array]])[, thisArg]) [12, 5, 8, 130, 44].every((x) =\u003e x \u003e= 10); // false [12, 54, 18, 130, 44].every((x) =\u003e x \u003e= 10); // true 技巧 every() 不会对空数组进行检测，空数组返回 true Find 助记：功能和 some() 类似，some() 返回布尔值，find() 返回找到的元素 find() 方法返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined。 arr.find(callback[, thisArg]) const array1 = [5, 12, 8, 130, 44]; const found = array1.find((element) =\u003e element \u003e 10); console.log(found); // expected output: 12 引用 另请参见 findIndex() 方法，它返回数组中找到的元素的索引，而不是其值。 如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用 Array.prototype.indexOf() 或 Array.prototype.includes()。 filter 助记：如字面意思，它是一个筛子，会筛选出满足条件的元素 filter() 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。 返回值是一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter((word) =\u003e word.length \u003e 6); console.log(result); // expected output: Array [\"exuberant\", \"destruction\", \"present\"] map 助记：功能和 filter() 类似，filter() 返回筛选的元素，map() 返回筛选的结果值 map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 返回值是一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map((x) =\u003e x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] ","date":"2022-05-01","objectID":"/posts/js-rediscover/:1:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["JavaScript"],"content":"使用 Object.hasOwn 替代 in 操作符 有时，我们想知道对象上是否存在某个属性，一般会使用 in 操作符或 obj.hasOwnProperty，但它们都有各自的缺陷。 in 如果指定的属性位于对象或其原型链中，in 运算符将返回 true。 const Person = function (age) { this.age = age; }; Person.prototype.name = 'fatfish'; const p1 = new Person(24); console.log('age' in p1); // true console.log('name' in p1); // true 注意这里 obj.hasOwnProperty hasOwnProperty 方法会返回一个布尔值，表示对象自身属性中是否具有对应的值（原型链上的属性不会读取）。 const Person = function (age) { this.age = age; }; Person.prototype.name = 'fatfish'; const p1 = new Person(24); console.log(p1.hasOwnProperty('age')); // true console.log(p1.hasOwnProperty('name')); // fasle 注意这里 obj.hasOwnProperty 已经可以过滤掉原型链上的属性，但在某些情况下，它还是不安全。 Object.create(null).hasOwnProperty('name'); // Uncaught TypeError: Object.create(...).hasOwnProperty is not a function Object.hasOwn 别急，我们可以使用 Object.hasOwn 来避免这两个问题，这比 obj.hasOwnProperty 方法更加方便、安全。 let object = { age: 24 }; Object.hasOwn(object, 'age'); // true let object3 = Object.create(null); Object.hasOwn(object3, 'age'); // false ","date":"2022-05-01","objectID":"/posts/js-rediscover/:2:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["JavaScript"],"content":"使用 “#” 声明私有属性 以前，我们一般用 _ 表示私有属性，但它并不靠谱，还是会被外部修改。 class Person { constructor(name) { this._money = 1; this.name = name; } get money() { return this._money; } set money(money) { this._money = money; } showMoney() { console.log(this._money); } } const p1 = new Person('fatfish'); console.log(p1.money); // 1 console.log(p1._money); // 1 p1._money = 2; // 依旧可以从外部修改_money 属性，所以这种做法并不安全 console.log(p1.money); // 2 console.log(p1._money); // 2 使用 # 实现真正私有属性 class Person { #money = 1; constructor(name) { this.name = name; } get money() { return this.#money; } set money(money) { this.#money = money; } showMoney() { console.log(this.#money); } } const p1 = new Person('fatfish'); console.log(p1.money); // 1 // p1.#money = 2 // 没法从外部直接修改 p1.money = 2; console.log(p1.money); // 2 console.log(p1.#money); // Uncaught SyntaxError: Private field '#money' must be declared in an enclosing class ","date":"2022-05-01","objectID":"/posts/js-rediscover/:3:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["JavaScript"],"content":"有用的数字分隔符 可以使用 _ 分隔数字，当然也可以用于计算 // ✅ 更加易于阅读 const newSixBillion = 6000_000_000; // ❌ 难以阅读 const originSixBillion = 6000000000; console.log(newSixBillion === originSixBillion); // expected output: true const sum = 1000 + 6000_000_000; // expected output: 6000001000 技巧 另外，我们写时间时，24*60*60*1000 的可读性也是远大于 86400000 的。 ","date":"2022-05-01","objectID":"/posts/js-rediscover/:4:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["JavaScript"],"content":"“?.”, “??”, “??=” 的使用 可选链 ?. 以前我们为了简化 if else，通常会写出这样的代码 const obj = null; console.log(obj \u0026\u0026 obj.name); const $title = document.querySelector('.title'); const title = $title ? title.innerText : undefined; 使用 ?. 简化 \u0026\u0026 和三元运算符 const obj = null; console.log(obj?.name); const $title = document.querySelector('.title'); const title = $title?.innerText; 空值合并运算符 ?? 之前给变量赋默认值时，我们一般会用 || 来写，比如 let foo = 1; let bar = foo || 2; console.log(bar); // 1 let foo = 0; let bar = foo || 2; console.log(bar); // 2 注意这里 所以，|| 有时候并不是很安全，所以我们不得不加判断 let foo = 0; let bar = foo !== undefined ? foo : 2; console.log(bar); // 0 现在使用 ?? 可以使代码更加优雅 let foo = 1; let bar = foo ?? 2; console.log(bar); // 1 let foo = 0; let bar = foo ?? 2; console.log(bar); // 0 空值赋值运算符 ??= let foo = 0; foo ??= 2; console.log(foo); // 0 let foo = 1; foo ??= 2; console.log(foo); // 1 很好理解，这里的 foo ??= 2 等价于 foo = foo ?? 2 ","date":"2022-05-01","objectID":"/posts/js-rediscover/:5:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["JavaScript"],"content":"使用 BigInt 支持大数计算 JS 中超过 Number.MAX_SAFE_INTEGER 的数字计算将是不安全的。 Example: Math.pow(2, 53) === Math.pow(2, 53) + 1; // true // Math.pow(2, 53) =\u003e 9007199254740992 // Math.pow(2, 53) + 1 =\u003e 9007199254740992 使用 BigInt 完全可以避免这个问题 BigInt(Math.pow(2, 53)) === BigInt(Math.pow(2, 53)) + BigInt(1); // false // BigInt(Math.pow(2, 53)) =\u003e 9007199254740992n // BigInt(Math.pow(2, 53)) + BigInt(1) =\u003e 9007199254740993n 要创建一个 BigInt，可以在一个整数的末尾添加字符n，或者调用函数 BigInt()。 let foo = BigInt(1); // 1n let bar = BigInt(2); // 2n console.log(foo \u003e bar); // false console.log(1n \u003e 2n); // false 学无止境，与未来的自己共勉 ","date":"2022-05-01","objectID":"/posts/js-rediscover/:6:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["CSS"],"content":"关于 CSS 和 Scss 变量运算那些事","date":"2022-04-30","objectID":"/posts/css-scss-var/","tags":["CSS","Scss"],"title":"关于 CSS 和 Scss 变量运算那些事","uri":"/posts/css-scss-var/"},{"categories":["CSS"],"content":"问题分析 昨天在开发 FixIt 的时候，在 Scss 中写 max(foo, bar) 函数比较不同的单位变量时报错了，但是在 CSS 中使用 max 或者 min 函数函数比较不同的单位变量是没有问题的。 造成这一问题的原因是，在 Scss 中，也实现了 max 和 min 函数，但是在 Scss 中，不同单位的变量是不能进行运算的，所以使得在 Scss 中直接使用 max 或者 min 函数会提示单位不同的报错。（同类 Less 中的变量运算是支持不同单位的） 知道造成问题的原因后，解决这个问题就很简单了，有很多种方法，有些方法感觉像在卡 BUG，有点意思，记录一下。 ","date":"2022-04-30","objectID":"/posts/css-scss-var/:1:0","tags":["CSS","Scss"],"title":"关于 CSS 和 Scss 变量运算那些事","uri":"/posts/css-scss-var/"},{"categories":["CSS"],"content":"奇思淫技 由于 Scss 区分大小写而 CSS 不区分，所以为了不让 Scss 中的函数覆盖 CSS 的函数，我们可以使用除了 max 以外的 23 - 1 种写法，这样就能使用原生 CSS 的 max 函数来比较了，就不会报错了。 .foo { padding-left: MAX(10vh, 3.5rem); } 使用 Scss 没有的 CSS 函数 clamp: clamp(MIN, VAL, MAX) 其实就是表示 max(MIN, min(VAL, MAX)) .foo { padding-left: clamp($header-height, 10vh, 10vh); } 使用 unquote($string) 函数让 Scss 删除字符串最前和最后的单引号或双引号 .foo { padding-left: unquote('max(10vh, #{$header-height})'); } ","date":"2022-04-30","objectID":"/posts/css-scss-var/:2:0","tags":["CSS","Scss"],"title":"关于 CSS 和 Scss 变量运算那些事","uri":"/posts/css-scss-var/"},{"categories":["CSS"],"content":"By the way 如果需要在 CSS 函数内部恢复 Scss 解析（引用 Scss 变量），只需用 #{...} 包围 Scss 代码。 $header-height: 3.5rem !default; .foo { margin: calc(10vh - $header-height); } 上面的 Scss 将解析成 以下无效的 CSS 代码： .foo { margin: calc(10vh - $header-height); } 用 #{...} 包围 Scss 变量 $header-height: 3.5rem !default; .foo { margin: calc(10vh - #{$header-height}); } ","date":"2022-04-30","objectID":"/posts/css-scss-var/:3:0","tags":["CSS","Scss"],"title":"关于 CSS 和 Scss 变量运算那些事","uri":"/posts/css-scss-var/"},{"categories":["Study"],"content":" quote Getting Things Done (GTD) is a personal productivity system developed by David Allen and published in a book of the same name. GTD is described as a time management system. Allen states “there is an inverse relationship between things on your mind and those things getting done”. Reference #20 ","date":"2021-12-22","objectID":"/posts/gtd/:0:0","tags":["GTD"],"title":"Getting Things Done for ios App Reminders and Github issues","uri":"/posts/gtd/"},{"categories":["Study"],"content":"理解 简而言之原则就是： 搜集 (Collections Box) 处理 组织 Next actions Projects Waiting for Someday 检查 ","date":"2021-12-22","objectID":"/posts/gtd/:1:0","tags":["GTD"],"title":"Getting Things Done for ios App Reminders and Github issues","uri":"/posts/gtd/"},{"categories":["Study"],"content":"Apple Reminders app 按照以上原则就可以把 Apple 的提醒事项建 5 个大分类， 日常各种想法收集到收集箱， 空闲下来后再组织，分到不同时间点去做， 然后就要自律地去执行处理，做完回顾检查是否都完成。 还可以通过标签更加细分我们的 idea, 配合日历使用让生活学习更高效。 ","date":"2021-12-22","objectID":"/posts/gtd/:2:0","tags":["GTD"],"title":"Getting Things Done for ios App Reminders and Github issues","uri":"/posts/gtd/"},{"categories":["Study"],"content":"Github 收集：选择 repository -\u003e 建 issue 处理：解决并关闭 issue 组织： Labels Projects Milestone Lable Description bug Something isn’t working documentation Improvements or additions to documentation duplicate e or pull request already exists enhancement New feature or request good first issue Good for newcomers help wanted Extra attention is needed invalid This doesn’t seem right priority Something to deal with first question Further information is requested study Self learning plan wontfix This will not be worked on ","date":"2021-12-22","objectID":"/posts/gtd/:3:0","tags":["GTD"],"title":"Getting Things Done for ios App Reminders and Github issues","uri":"/posts/gtd/"},{"categories":["Study"],"content":"总结 之前在 Foxconn 工作，因为工作电脑、个人电脑、手机可以做到互不干扰，本来想的是把工作、学习 (Free Code) 和 生活 的计划完全分开。 但是换工作后用自己的电脑，工作和 Free Code 就有了交集，换 mac 后，由于苹果生态的原因，不可避免生活计划也加入其中，形成一个三者互相交错的 Venn 图，所以简单分一下： 工作、生活 苹果生态：日历、提醒、备忘录 （标签区分） 学习 Github (collection, backup), Blog (summarize) ","date":"2021-12-22","objectID":"/posts/gtd/:4:0","tags":["GTD"],"title":"Getting Things Done for ios App Reminders and Github issues","uri":"/posts/gtd/"},{"categories":["Memo"],"content":" 插件地址 https://github.com/robinchenyu/imagepaste ","date":"2021-10-05","objectID":"/posts/subl_imgpaste2/:0:0","tags":["Markdown","Sublime"],"title":"Sublime 剪贴板图片粘贴插件 —— Markdown 必备","uri":"/posts/subl_imgpaste2/"},{"categories":["Memo"],"content":"功能 支持 Windows/Linux 系统下，实现对剪切板图像的处理调用 (Ctrl+Shift+V) 默认使用 JPG 的方式保存，可以显著减小图片的存储体积。 对剪切板图像保存到本地并在 Markdown 文本中插入链接地址 对剪切板中的图像地址，直接插入到 Markdown 文本中 ","date":"2021-10-05","objectID":"/posts/subl_imgpaste2/:1:0","tags":["Markdown","Sublime"],"title":"Sublime 剪贴板图片粘贴插件 —— Markdown 必备","uri":"/posts/subl_imgpaste2/"},{"categories":["Memo"],"content":"食用说明 首先下载 zip 到本地，放到 sublime 安装目录的 xxx\\sublime\\Data\\Packages 中，注意不是 xxx\\sublime\\Packages 下哦。 记得要把 subl_imgpaste2-master 的 -master 删除掉。接着重新打开 sublime, 选择 Preferences-\u003ePackage Settings-\u003eImaPaste2-\u003esettings-Default 输入如下内容： { \"caption\": \"ImagePaste: Paste Image From Clipboard\", \"command\": \"image_paste\", \"image_dir_name\": \"images/\" # 图片保存目录 } 然后就可以愉快的使用截图，然后在 sublime 里使用 ctrl+shift+v 粘贴 Markdown 格式的图片。默认会自动根据 md 文件名在同级目录下新建文件夹，图片就默认保存在那。如图： VScode 也有更好用的插件：Past Image \"pasteImage.defaultName\": \"YY_X\", \"pasteImage.path\": \"${currentFileDir}/images/\" ","date":"2021-10-05","objectID":"/posts/subl_imgpaste2/:2:0","tags":["Markdown","Sublime"],"title":"Sublime 剪贴板图片粘贴插件 —— Markdown 必备","uri":"/posts/subl_imgpaste2/"},{"categories":["Memo"],"content":" 卡片式链接已整合到 FixIt 主题 https://github.com/Lruihao/FixIt 回顧 之前在使用 hexo 的時候也有用到，模仿知乎卡片式链接 和之前的相比，優化之前是后加載，由 JS 在 瀏覽器處理， 使用 shortcodes 方式后，則是在 GO 構建頁面的時候處理，效能上會好很多。 ","date":"2021-10-05","objectID":"/posts/hugo-cardlink/:0:0","tags":["Shortcodes","hugo"],"title":"Hugo 添加知乎卡片式链接 Shortcodes","uri":"/posts/hugo-cardlink/"},{"categories":["Memo"],"content":"源碼 基於 LoveIt 主題的 Link Shortcodes, 主要改到以下幾個文件，完整提交記錄 assets/css/custom.scss assets/css/partial/cardlink.scss # 卡片式鏈接樣式 layouts/partials/plugin/cardlink.html # 卡片式鏈接模板 layouts/shortcodes/cardlink.html static/images/card-link-bg.jpg ","date":"2021-10-05","objectID":"/posts/hugo-cardlink/:1:0","tags":["Shortcodes","hugo"],"title":"Hugo 添加知乎卡片式链接 Shortcodes","uri":"/posts/hugo-cardlink/"},{"categories":["Memo"],"content":"使用 使用參數见 FixIt 擴展 Shortcodes - Link {{\u003c cardlink href=\"https://github.com/Lruihao/hugo-blog/commit/089c303693e806bff855ecf3fee110baa62b870b\" content=\"知乎卡片式链接 Git 記錄\" \u003e}} 💡 注：FixIt 已合併 shortcode cardlink 到 shortcode link，只需添加 card=true {{\u003c link href=\"https://github.com/Lruihao/FixIt\" content=\"卡片式链接已整合到 FixIt 主题\" card=true \u003e}} 信息 我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3o5dmfzf0xkwk ","date":"2021-10-05","objectID":"/posts/hugo-cardlink/:2:0","tags":["Shortcodes","hugo"],"title":"Hugo 添加知乎卡片式链接 Shortcodes","uri":"/posts/hugo-cardlink/"},{"categories":["Memo"],"content":" 工作上一直常用繁體，最近臨帖也都寫的繁體，所以博客的語言也想換成繁體，但是 LoveIt 主題沒有支持中文繁體。就只好自己添加了。 ","date":"2021-10-05","objectID":"/posts/hugo-i18n-zh-tw/:0:0","tags":["hugo","i18n"],"title":"Hugo i18n 添加中文繁體翻譯","uri":"/posts/hugo-i18n-zh-tw/"},{"categories":["Memo"],"content":"翻譯 屬於直譯，有些詞語可能並不符合現在臺灣或者香港那邊的說法。比如，分類好像臺灣常說歸類吧 新建 i18n/zh-TW.toml # Translations for Traditional Chinese # 簡體中文的翻譯 # https://gohugo.io/content-management/multilingual/#translation-of-strings # === baseof == [backToTop] other = \"回到頂部\" [viewComments] other = \"查看評論\" # === baseof == # === Post === [posts] other = \"文章\" # === Post === # === Taxonomy === [allSome] other = \"所有{{ .Some }}\" [tag] other = \"標籤\" [tags] other = \"標籤\" [category] other = \"分類\" [categories] other = \"分類\" [years] other = \"年度總結\" # === Taxonomy === # === Pagination === [more] other = \"更多\" # === Pagination === # === partials/header.html === [selectLanguage] other = \"選擇語言\" [switchTheme] other = \"切換主題\" # === partials/header.html === # === partials/footer.html === [poweredBySome] other = \"由 {{ .Hugo }} 強力驅動 | 主題 - {{ .Theme }}\" # === partials/footer.html === # === partials/comment.html === [valineLang] other = \"zh-TW\" [valinePlaceholder] other = \"你的評論 ...\" [facebookLanguageCode] other = \"zh-TW\" # === partials/comment.html === # === partials/assets.html === [search] other = \"搜索\" [searchPlaceholder] other = \"搜索文章標題或內容 ...\" [clear] other = \"清空\" [cancel] other = \"取消\" [noResultsFound] other = \"沒有找到結果\" [lunrLanguageCode] other = \"zh\" [lunrLanguageLib] other = \"lib/lunr/lunr.zh.js\" [lunrSegmentitLib] other = \"lib/lunr/lunr.segmentit.js\" [copyToClipboard] other = \"複製到剪貼板\" [cookieconsentMessage] other = \"本網站使用 Cookies 來改善您的流覽體驗。\" [cookieconsentDismiss] other = \"同意\" [cookieconsentLink] other = \"瞭解更多\" # === partials/assets.html === # === partials/plugin/share.html === [shareOn] other = \"分享到\" # === partials/plugin/share.html === # === posts/single.html === [contents] other = \"目錄\" [publishedOnDate] other = \"發佈於 {{ .Date }}\" [includedInCategories] other = \"收錄於 {{ .Categories }}\" [wordCount] other = \"約 {{ .Count }} 字\" [readingTime] other = \"預計閱讀 {{ .Count }} 分鐘\" [views] other = \"次閱讀\" [author] other = \"作者\" [updatedOnDate] other = \"更新於 {{ .Date }}\" [readMarkdown] other = \"閱讀原始文檔\" [back] other = \"返回\" [home] other = \"主頁\" [readMore] other = \"閱讀全文\" # === posts/single.html === # === 404.html === [pageNotFound] other = \"頁面沒找到\" [pageNotFoundText] other = \"抱歉，您要查找的頁面不存在。\" # === 404.html === # === shortcodes/admonition.html === [note] other = \"注意\" [abstract] other = \"摘要\" [info] other = \"信息\" [tip] other = \"技巧\" [success] other = \"成功\" [question] other = \"問題\" [warning] other = \"警告\" [failure] other = \"失敗\" [danger] other = \"危險\" [bug] other = \"Bug\" [example] other = \"示例\" [quote] other = \"引用\" # === shortcodes/admonition.html === # === shortcodes/version.html === [new] other = \"新增\" [changed] other = \"更改\" [deleted] other = \"刪除\" # === shortcodes/version.html === ","date":"2021-10-05","objectID":"/posts/hugo-i18n-zh-tw/:1:0","tags":["hugo","i18n"],"title":"Hugo i18n 添加中文繁體翻譯","uri":"/posts/hugo-i18n-zh-tw/"},{"categories":["Memo"],"content":"配置 打開 config.toml defaultContentLanguage = \"zh-tw\" ","date":"2021-10-05","objectID":"/posts/hugo-i18n-zh-tw/:2:0","tags":["hugo","i18n"],"title":"Hugo i18n 添加中文繁體翻譯","uri":"/posts/hugo-i18n-zh-tw/"},{"categories":["Memo"],"content":" 過程 以前的 hexo 博客是自己寫的友鏈模板，換到 hugo 後想著在網上隨便找一個範本用著就好，然而並沒有自己想要的 layout, 幾乎都是使用 shortcodes 的，代碼風格有點問題且 shortcodes 作為友鏈添加的方式是真的麻煩。就只好自己寫羅。 友情鏈接模板已整合到 FixIt 主題 https://github.com/Lruihao/FixIt 友情鏈接範本 https://lruihao.cn/friends/ ","date":"2021-10-05","objectID":"/posts/hugo-friends/:0:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["Memo"],"content":"創建模板 開始之前去看了 hugo 的官網，再看了一下 go 模板的語法。 新建 layouts/friends/single.html {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- $params := .Scratch.Get \"params\" -}} \u003cdiv class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated pulse faster\"\u003e{{- .Title -}}\u003c/h1\u003e {{- /* Subtitle */ -}} {{- with $params.subtitle -}} \u003ch2 class=\"single-subtitle\"\u003e{{ . }}\u003c/h2\u003e {{- end -}} {{- /* Friend links */ -}} {{- $loading := resources.Get \"svg/loading.svg\" | minify -}} \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003clink rel=\"stylesheet\" href=\"/friends/css/_friends.css\" /\u003e \u003cdiv class=\"friend-links\"\u003e {{ range $index, $friend := .Site.Data.friends }} \u003ca class=\"friend-link\" title=\"{{ $friend.description }}\" href=\"{{ $friend.url | safeURL }}\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\" \u003e {{ if $friend.avatar }} \u003cimg class=\"friend-avatar lazyload\" src=\"{{ $loading.RelPermalink }}\" data-src=\"{{ $friend.avatar }}\" alt=\"{{ $friend.nickname }}\" /\u003e {{ else }} \u003csvg class=\"friend-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{ add 1 $index }}\"\u003e\u003c/use\u003e \u003c/svg\u003e {{ end }} \u003cspan class=\"friend-nickname\" title=\"{{ $friend.nickname }}\"\u003e@{{ $friend.nickname }}\u003c/span\u003e \u003c/a\u003e {{ end }} \u003c/div\u003e {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/div\u003e {{- end -}} ","date":"2021-10-05","objectID":"/posts/hugo-friends/:1:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["Memo"],"content":"模板樣式 新建文件 _friends.css /** * @Description: Style of layout named 'Friend links'. * @Author: lruihao.cn * @Updated: 2021/9/20 19:26 */ .friend-links { margin-top: 1rem; display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; } @media (max-width: 576px) { .friend-links { justify-content: space-around; } } .friend-link { width: 150px; height: 200px; font-size: 1rem; text-align: center; background: rgba(255, 255, 255, 0.3); box-sizing: border-box; box-shadow: 3px 3px 5px #aaa; border-radius: 5px; border: none; transition-duration: 0.3s; margin-bottom: 1rem; display: flex; flex-direction: column; justify-content: space-between; } .friend-link:hover { background: #fff; transform: scale(1.03); box-shadow: 0 0 3px #aaa; } .friend-avatar { object-fit: cover; object-position: center; width: 100% !important; height: 150px !important; border-radius: 5px; margin: 0; padding: 0; } .friend-nickname { display: block; position: relative; color: #2bbc8a; font-weight: bold; max-width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; line-height: 18px; margin-bottom: 1rem; } .friend-nickname:hover { color: #d480aa; } ","date":"2021-10-05","objectID":"/posts/hugo-friends/:2:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["Memo"],"content":"友鏈頁面 hugo new friends/index.md 將 _friends.css 放到 content/friends/css/ 打開友鏈頁面 content/friends/index.md --- title: '友鏈' date: 2021-09-19T12:33:48+08:00 type: 'friends' --- ","date":"2021-10-05","objectID":"/posts/hugo-friends/:3:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["Memo"],"content":"數據 新建數據文件 data/friends.yml, 數據格式為： # - nickname: 标题 # avatar: 头像 # url: 站点 # description: 描述 - nickname: Lruihao avatar: https://gravatar.loli.net/avatar/3f985efb5907ca52944a3cd7edd51606?d=wavatar\u0026v=1.3.10 url: https://lruihao.cn description: 不怕萬人阻擋，只怕自己投降 ","date":"2021-10-05","objectID":"/posts/hugo-friends/:4:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["Memo"],"content":"結語 這樣每次添加友鏈或者刪除友鏈衹要操作數據文件 friends.yml 就好，乾淨又衛生！ 友鏈頁面 content/friends/index.md 繼承了基礎頁面的功能，內容評論等 ","date":"2021-10-05","objectID":"/posts/hugo-friends/:5:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["Memo"],"content":"使用 Shell 腳本管理 Hugo 本地博客","date":"2021-10-04","objectID":"/posts/hugo-admin/","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":" 摘要 在使用 hugo 寫博客的過程中會使用到一些命令，包括 Git 的使用也會用到 Git 命令，但是這些命令我感覺知道就好，沒必要因輸入命令而增加寫博客和部署博客的額外工作。 自然要想辦法簡化這些過程，Git 還好有 SourceTree 等工具，Hugo 卻沒有，也懶得去網絡上找類似以前 hexo 有 hexo-admin 的插件可以讓大家在瀏覽器寫博客，因為我覺得這和靜態博客初衷背道而馳，於是我就折中方案，寫了一個滿足日常需求的 Shell 腳本，生成管理本地博客。 ","date":"2021-10-04","objectID":"/posts/hugo-admin/:0:0","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"實現 一共六個腳本，放在 hugo-site/_localadmin/ 下 _localadmin/ ├── auto_push.sh # 自動化提交源碼 ├── hugo_builder.sh # 構建 hugo 命令 ├── hugo_main.sh # 主介面入口 ├── hugo_server.sh # 啟動本地服務 ├── post_generator.sh # 創建文章 └── public_async.sh # 同步 public 子模組 ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:0","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"post_generator.sh 輸入文章名稱 （建議使用英文） 文章是否會插入圖片等資源 （默認：否） #!/bin/bash #author: Lruihao cd .. read -p \"Please enter the article name: \" postName if [ -z $postName ];then echo \"The article name is required!\" else read -p \"Will there be pictures in this article? [y/n]...\" choice if [ $choice = \"y\" ];then hugo new posts/$postName/index.md else hugo new posts/$postName.md fi fi ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:1","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"hugo_server.sh cd .. hugo server --disableFastRender ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:2","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"hugo_builder.sh cd .. hugo --minify ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:3","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"public_async.sh cd .. git submodule update --remote git add public git commit -m \"Feat: Update public module commit id\" ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:4","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"auto_push.sh 不輸入 Git 提交訊息會使用腳本中默認訊息 Docs: 『菠菜眾長』内容更新 YYYY-MM-DD week hh:mm::ss #!/bin/bash #author: Lruihao cd .. # 是否需要每次提交自動更新子模組 # git submodule update --remote # git add public # git commit -m \"Feat: Update public module commit id\" git add . read -p \"Please enter commit message: \" commitMsg if [ -z $commitMsg ];then commitMsg=\"Docs: 『菠菜眾長』内容更新 $(date +'%F %a %T')\" fi git commit -m \"$commitMsg\" git push ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:5","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"hugo_main.sh 可單獨執行子腳本也可以通過主介面來選擇序號執行 #!/bin/bash #author: Lruihao echo \"Please enter the serial number to work\" echo \"--------------------------------------\" echo \"1. post generator\" echo \"2. hugo server\" echo \"3. hugo build\" echo \"4. public async\" echo \"5. auto push\" echo \"--------------------------------------\" echo \"Press Ctrl+C to stop\" read num case $num in 1) sh post_generator.sh ;; 2) sh hugo_server.sh ;; 3) sh hugo_builder.sh ;; 4) sh public_async.sh ;; 5) sh auto_push.sh ;; *) echo \"There is no such serial number\" ;; esac echo \"Press any key to continue...\" read x clear sh hugo_main.sh ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:6","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":"使用 將 hugo_main.sh 建立桌面快捷鍵 雙擊 hugo_main.sh 進入根據提示使用即可 由於一般寫博客會便邊寫邊預覽，所以一般開兩個主介面窗口，如下圖： 一個選擇 2 啟動本地服務 一個用於生成文章，部署文章等 Hugo Admin ","date":"2021-10-04","objectID":"/posts/hugo-admin/:2:0","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo","Git"],"content":" 解決痛點 Github Actions 真是靜態博客的福音，有了它 hugo, hexo 等博客構建過程可以丟給 Github 的服務器幫我們做了。 也就是説實現了在線寫靜態博客的需求。 ","date":"2021-10-04","objectID":"/posts/github-actions/:0:0","tags":["hugo","GitHub Actions","Git","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo","Git"],"content":"準備 工作流程涉及到兩個倉庫和一個 cos 桶，例如： Lruihao/hugo-blog # Blog source repository Lruihao/lruihao.github.io # GitHub pages repository blog-1256932288 # COS bucket ","date":"2021-10-04","objectID":"/posts/github-actions/:1:0","tags":["hugo","GitHub Actions","Git","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo","Git"],"content":"Github Actions ","date":"2021-10-04","objectID":"/posts/github-actions/:2:0","tags":["hugo","GitHub Actions","Git","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo","Git"],"content":"創建 workflows 任務 創建 hugo-site/.github/workflows/deploy.yml, 這個文件會寫一些命令告訴 Github 在我們提交源碼的時候，它要幫我們做哪些事情。 name: Auto Deploy hugo on: [push] jobs: Explore-GitHub-Actions: runs-on: ubuntu-latest steps: - name: Check out repository code uses: actions/checkout@v2 with: submodules: recursive # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true - name: Build Hugo static files run: hugo --minify - name: Deploy to Github Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.GP_DEPLOY_KEY }} external_repository: Lruihao/lruihao.github.io publish_branch: main publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} - name: Install coscmd run: sudo pip install coscmd - name: Configure coscmd env: COS_SECRET_ID: ${{ secrets.COS_SECRET_ID }} COS_SECRET_KEY: ${{ secrets.COS_SECRET_KEY }} COS_BUCKET_NAME: blog-1256932288 # Change for yourself COS_BUCKET_REGION: ap-chengdu # Change for yourself run: coscmd config -a $COS_SECRET_ID -s $COS_SECRET_KEY -b $COS_BUCKET_NAME -r $COS_BUCKET_REGION - name: Deploy to COS Bucket run: coscmd upload -r -s --delete -f public/ / ","date":"2021-10-04","objectID":"/posts/github-actions/:2:1","tags":["hugo","GitHub Actions","Git","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo","Git"],"content":"配置 Github Pages 密鑰 為了讓 Lruihao/hugo-blog 提交代碼后自動部署到 Lruihao/lruihao.github.io, 需要生成一對 ssh key. ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) 打開 Lruihao/hugo-blog 倉庫的 settings, 再点击 Secrets, 然後添加 private key, name 为 GP_DEPLOY_KEY 打開 Lruihao/lruihao.github.io, 点击 Deploy keys, 添加 public key, name 隨意，Allow write access 一定要勾上，否則無法提交 ","date":"2021-10-04","objectID":"/posts/github-actions/:2:2","tags":["hugo","GitHub Actions","Git","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo","Git"],"content":"配置 COS 密鑰 打開 Lruihao/hugo-blog 倉庫的 settings, 再点击 Secrets, 然後添加 COS 桶的 secret_id 和 secret_key: COS_SECRET_ID COS_SECRET_KEY 至此，Github Pages 和 COS 都已經可以通過 Github Actions 自動部署了，有部署記錄后， 打開 Lruihao/hugo-blog -\u003e Actions 可以看到構建過程和結果，構建失敗也會收到 Github 發給你的郵件。 ","date":"2021-10-04","objectID":"/posts/github-actions/:2:3","tags":["hugo","GitHub Actions","Git","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo","Git"],"content":"COS 自動同步 （備用） 本小節內容和 Github Actions 無關，僅作為 COS 備用上傳方式。 COSBrowser 下載 COS 官方軟件 COSBrowser 點開右上角 工具箱 選擇 文件同步 選擇 本地文件夹 eg. hugo-site/public 選擇 存储桶目录 同步类型：單次同步、自動同步、定時同步 同步前先執行 hugo 構建命令，eg. hugo --minify 有 Github actions 選單次同步就好，在 Github 不好用時可用。 ","date":"2021-10-04","objectID":"/posts/github-actions/:3:0","tags":["hugo","GitHub Actions","Git","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo"],"content":" 电脑升级 win 11 后，分盘操作存在 bug, 然后又不小心把装代码的盘格式化了，虽然都有备份到 github, 但是当时为了省事，hexo Node 安装的很多以来插件都没有备份，现在又下载不到了，所以 hexo 博客没办法完整复原，另外，早就觉得基于 Node 的 hexo 实在有些臃肿，且博客内容多了以后部署太慢，就干脆乘机换了好了，经过一段时间寻找，最终选择了基于 Go 的 hugo, 记录一下迁移过程及待办事项。 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:0:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"Hugo 准备 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"概念 Hugo is a fast and modern static site generator written in Go, and designed to make website creation fun again. 那 hugo 基于编译语言 GO 构建，对于静态页面的构建肯定是碾压 hexo 的存在，其官方标语也是很直白 \"The world’s fastest framework for building websites\", 作为先后使用过 hexo 和 hugo 的我来说，这确实名副其实。 gohugo ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:1","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"安装 hugo 提供了很多种安装方式，Git, Docker, Binary. 个人电脑使用二进制安装是最方便快捷的，无需安装其他依赖。 到 Hugo Releases 下载对应的 windows 操作系统版本的 Hugo 二进制文件，玩就要玩全的，所以我就选择了扩展版本，此次选择的最新版为 hugo_extended_0.88.1_Windows-64bit.zip, 然后自行解压安装即可。 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:2","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"生成站点 使用 Hugo 快速生成站点，比如希望生成到 /path/to/site 路径： hugo new site /path/to/site 站点目录结构： ▸ archetypes/ # 配置文章模板，相当于 hexo 的 scaffolds ▸ content/ # 文章页面内容，相当于 hexo 的 source ▸ data/ # 可存放一些 yaml, json, toml 格式的数据 ▸ layouts/ # 页面布局源码，改造主题可不动主题源码 ▸ static/ # 静态文件存放 config.toml # 站点配置文件，相当于 hexo 的 _config.yml ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:3","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"创建文章 注： 路径要写以 content/ 为根目录的相对路径 hugo new path/fileName ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:4","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"添加主题 添加主题的方式选用 Git 子模组的形式，为了日后快速升级，避免在使用 hexo 中因大量魔改 next 主题而导致难以升级的困扰。 精挑细选最终选择了 LoveIt =\u003e FixIt git init git submodule add https://github.com/Lruihao/FixIt.git themes/FixIt 在 config.toml 添加 theme = “LoveIt” theme = \"FixIt\" ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:5","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"在本地启动网站 使用以下命令启动网站： hugo serve --disableFastRender 去查看 http://localhost:1313 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:6","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"hugo build 使用以下命令生成静态文件，然后自己可手动选择部署到 github pages 或 COS 等服务器 hugo --minify ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:7","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"写作指北 FixIt 主题文档 - 基本概念 FixIt 主题文档 - 内容 FixIt 主题文档 - 内置 Shortcodes FixIt 主题文档 - 扩展 Shortcodes ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:2:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"Todo list 本站源码备份 https://github.com/Lruihao/hugo-blog 原来 hexo 做了大量的美化和扩展功能，迁移到 hugo 想尽可能多的保留。取之精华，去其糟粕。 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:3:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"Base 迁移 hexo 所有文章内容 迁移 hexo 所有页面内容 留言页面 网友打赏支持页面，整合到留言页面 重写关于页面，一切从简 友情链接页面 重写 404 页面 站点时间和不蒜子计数改到 hello-world 页面 cos-album 和 🍚 饭醉团伙 🍷 整合到博客 cos-album/ #7 (wontfix) 新增 demo/, 以子模组的形式存放前端 demo, serverless 记账本等 （保持原本博客的纯粹性） 博客 valine 评论，阅读数迁移，可用 leancloud API 写代码转化（但似乎没必要） 博客 SEO 优化迁移 baidu_urls.txt Github actions 自动部署到 Github pages 和 COS 脚本编写 hugo 本地管理 shell 脚本工具编写 知乎卡片式链接 改成 hugo shortcodes, 取名 cardlink zxm/沐目体 归档 :( #6 安装 沐目体 压缩 沐目体 fontspider 沐目体 post 修订 typyit 配合 随机诗词和网易云热评 API 实时预览功能 base on Vuejs [恋爱叙事体] love 归档 [光] 归档 hugo 内容加密研究 #3 Lruihao/hugo-blog/README.md 撰写，MIT, 发布 1.0.0 版本做完整备份，base on theme version 更换 gravatar 头像 #4 博客在线编辑器研究 github1s 等 #5 [baidu_urls.txt]:↩︎ 生成百度链接集合小技巧，关掉归档分页，在归档页面控制台执行以下代码即可获得所有文章链接 let urls = []; for (let a of document.querySelectorAll('.archive-item a')) { urls.push(a.href); } console.log(urls.join('\\n')); FixIt 主题已支持自动输出 baidu_urls.txt 文件 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:3:1","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["Memo"],"content":"Theme FixIt hugo LoveIt 主题整体优化，必要时建 PR 或 issue 到 LoveIt 仓库 (LoveIt 已停更一年多） 先把自己发现和 LoveIt 原 repo 的 issue 尽可能的修复，修改的原则是：不改动原项目代码， 唯一途径就是在站点相同的目录用新增的方式替代修改、删除操作。 之后再等等看作者是否还会更新，如已做大量的更改，再做考虑整合为一个新的主题。 为了更好的完善博客功能以及修复 BUG 已创建新的主题 FixIt (fork from LoveIt) Hugo theme FixIt https://github.com/Lruihao/FixIt 进度更新至 #8 CSS 优化，背景，元素圆角化，外圆内方，居中对齐等 沐目体引入 TOC 序号生成 Fix: 无标题时也会生成目录的 BUG subtitle 等细节优化 Fix: typeit 打印代码时跑版的问题 Fix: 文章 h1 标题多行跑版 Code Review ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:3:2","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":null,"content":"Lruihao's friends","date":"2021-09-19","objectID":"/friends/","tags":null,"title":"友情鏈接","uri":"/friends/"},{"categories":null,"content":"  Subscribe ours https://lruihao.cn/friends/opml.xml ","date":"2021-09-19","objectID":"/friends/:0:0","tags":null,"title":"友情鏈接","uri":"/friends/"},{"categories":null,"content":"基本資訊 - nickname: 菠菜眾長 avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: 不怕萬人阻擋，只怕自己投降 ","date":"2021-09-19","objectID":"/friends/:1:0","tags":null,"title":"友情鏈接","uri":"/friends/"},{"categories":null,"content":"友情提醒 Notice 互換友鏈請按以上格式在評論留言。（僅限個人非商業部落格/網站）  網站失效、停止維護、內容不當都可能被取消連結！ 那些不尊重他人勞動成果，轉載不加出處的，或惡意行為的網站，還請您不要來進行交換了。 ","date":"2021-09-19","objectID":"/friends/:2:0","tags":null,"title":"友情鏈接","uri":"/friends/"},{"categories":null,"content":"互联网的广大朋友们，欢迎光临我的小博客！欢迎留言！","date":"2021-09-13","objectID":"/guestbook/","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":" Welcome 关于 FixIt 主题 的问题，请移步 FixIt 官网 相关文章哦～ 温馨提示，音乐自动播放，请带好耳机～ From playlist, Powered By mmt-netease 给博主买杯卡布奇诺～ 赞赏 支付宝 微信 ","date":"2021-09-13","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":"关于我 不卑不亢，不矜不伐，戒骄戒躁 不嗔不怒，不爭不弃，独善其身 自我期許： 用我所學，學我所用。保持謙遜，保持探索欲，砥礪前行。 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"訂閱 ","date":"2021-09-07","objectID":"/about/:2:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"致謝 感謝大家的支持 🙏 给博主买杯卡布奇诺～ 赞赏 支付宝 微信 francs 通过 支付宝 打赏了 ¥50.00大学生时期，第一次收到别人的支持，内心表示受宠若惊又非常开心。非常感谢老哥的支持！2018-09-28 francs 通过 QQ 打赏了 ¥8.80今天学校运动会没课，睡到 9 点多起来看到 QQ 收到一个红包，感谢支持！2018-10-26 francs 通过 QQ 打赏了 ¥8.802018-11 ✘昌升 通过 支付宝 打赏了 ¥10.00上课的时候听到了支付宝清脆的支付宝到账 10 元的声音！2018-12-04 ✘昌升 通过 支付宝 打赏了 ¥18.002018-12-04 ✘昌升 通过 微信 打赏了 ¥2.00来自 231****047#qq.com2019-03-19 ✘喜洲 通过 QQ 打赏了 ¥20.20来自 101****0732020-01-17 ✘✘松 通过 支付宝 打赏了 ¥2.002022-12-02 13:01:48 ✘✘波 通过 支付宝 打赏了 ¥20.00留言：“感谢帮忙解决 FixIt 的问题”2023-02-13 10:01:58 K*n 通过 微信 打赏了 ¥50.002023-03-17 14:05:49 D*n 通过 微信 打赏了 ¥11.11留言：“加油”2023-03-17 14:57:41 乐语 通过 微信 打赏了 ¥5.00留言：“很好用的主题，谢谢作者💪”2023-04-03 17:49:12 建议去世 通过 微信 打赏了 ¥20.00留言：“主题不错”2023-04-17 10:35:26 🐟 通过 微信 打赏了 ¥1.00留言：“感谢fixit作者”2023-05-24 15:49:46 ","date":"2021-09-07","objectID":"/about/:3:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["CSS"],"content":" Sass 和 Less 都屬於 CSS 前置處理器，CSS 前置處理器定義了一種新的語言，其基本思想是，用一種專門的程式設計語言，為 CSS 增加了一些程式設計的特性，將 CSS 作為目標生成檔，然後開發者就只要使用這種語言進行 CSS 的編碼工作。 轉化成通俗易懂的話來說就是 “用一種專門的程式設計語言，進行 Web 頁面樣式設計，再通過編譯器轉化為正常的 CSS 檔，以供專案使用”。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:0:0","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"為什麼，什麼時候要使用 CSS 前置處理器？ (Why, When) CSS 有具體以下幾個缺點： 語法不夠強大，比如無法嵌套書寫，導致模組化開發中需要書寫很多重複的選擇器 沒有變數和合理的樣式複用機制，使得邏輯上相關的屬性值必須以字面量的形式重複輸出，導致難以維護 這就導致了我們在工作中無端增加了許多工作量。而使用 CSS 前置處理器可大大提高了我們的開發效率： 提供 CSS 缺失的樣式層複用機制 減少冗餘碼 提高樣式代碼的可維護性。 但是，CSS 的好處在於簡便、隨時隨地被使用和調試。這就使得預編譯 CSS 步驟的加入具有以下缺點： 開發工作流中多了一個環節，調試也變得更麻煩 預編譯很容易造成後代選擇器的濫用 所以我們在實際項目中衡量預編譯方案時，還是得想想，比起帶來的額外維護開銷，CSS 前置處理器有沒有解決更大的麻煩。 系統級框架開發 （大型複雜的樣式設計） 持續維護 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:1:0","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Less、Sass/Scss 是什麼？ (What) ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:2:0","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Less 是一種動態樣式語言。對 CSS 賦予了動態語言的特性，如變數、繼承、運算、函數。 Less 既可以在用戶端上運行 （支援 IE 6+, Webkit, Firefox)，也可在服務端運行。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:2:1","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Sass 是一種動態樣式語言，Sass 語法屬於縮排語法， 比 CSS 比多出好些功能（如變數、嵌套、運算，混入 (Mixin)、繼承、顏色處理，函數等），更容易閱讀。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:2:2","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Sass 與 Scss 的關係 Sass 的縮排語法，對於寫慣 CSS 的前端開發者來說很不直觀，也不能將 CSS 代碼加入到 Sass 裡面，因此 Sass 語法進行了改良，Sass 3 就變成了 Scss(Sassy CSS)。與原來的語法相容，只是用{}取代了原來的縮進。Sass 相當於 Scss 的嚴格模式。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:2:3","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Sass 和 Less 的比較 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:3:0","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"相同點 Less 和 Sass 在語法上有些共性，比如下面這些： 混入 (Mixins)——class 中的 class 參數混入——可以傳遞參數的 class，就像函數一樣 嵌套規則——Class 中嵌套 class，從而減少重複的代碼 運算——CSS 中用上數學 顏色功能——可以編輯顏色 名字空間 (namespace)——分組樣式，從而可以被調用 作用域——局部修改樣式 JavaScript 賦值——在 CSS 中使用 JavaScript 運算式賦值 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:3:1","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"不同點 實現方式 Less 是基於 JavaScript，是在用戶端處理的 Sass 是基於 Ruby 的，是在伺服器端處理的 關於變數在 Less 和 Sass 中的唯一區別就是 Less 用@，Sass 用$ less 中的變量運算可帶、可不帶單位，Sass 需要帶單位元 語法不同，請詳見 Less、Sass 官網 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:3:2","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"選用 Less 還是 Sass ? 無論是學習資料，討論情況，以及項目使用情況 Sass/Scss 都優於 Less，比如 Bootstrap 4 就使用的 Sass, 但是 Less 的使用更加簡單，使用門檻也較低，內網開發的情況，Less 則更加適合。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:4:0","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["JavaScript"],"content":"簡介 Lightbox （燈箱），用来放大显示图片覆盖于当前页面之上。其是用 CSS 来定义图片容器，用一幅半透明的 png 图片实现渐变阴暗的效果。 一般的網頁，圖片是使用 img 標籤寫在 HTML 頁面中，圖片點擊并不會放大，想放大看圖片要麼方法整個網頁，要麼複製圖片鏈接新開窗口，操作繁瑣，而使用 Lightbox 的網站可以点击缩略图浮层显示大图，放大後可点击键盘 ←、→ 键切换图片，也可以鼠标点击左右箭头切换。按下键盘 Esc 键或者点击关闭按钮可輕鬆關閉圖層，圖片流覽的體驗度是遠遠大於未使用的 Lightbox 的網站。 ","date":"2021-06-21","objectID":"/posts/lightbox/:1:0","tags":["Lightbox","JavaScript"],"title":"Lightbox","uri":"/posts/lightbox/"},{"categories":["JavaScript"],"content":"實現思路 大概思路就在每个图片的点击事件中添加图层与图片副本。 /** * @author github.com@flymysql */ let container = document.documentElement || document.body; let img, div, src, btnleft, btnright; var imgid = 0; let x, y, w, h, tx, ty, tw, th, ww, wh; let closeMove = function () { if (div == undefined) { return false; } div.style.opacity = 0; img.style.height = h + 'px'; img.style.width = w + 'px'; img.style.left = x + 'px'; img.style.top = y - container.scrollTop + 'px'; // 延迟移除 dom setTimeout(function () { div.remove(); img.remove(); btnright.remove(); btnleft.remove(); }, 100); }; let closeFade = function () { if (div == undefined) { return false; } div.style.opacity = 0; img.style.opacity = 0; // 延迟移除 dom setTimeout(function () { div.remove(); img.remove(); btnright.remove(); btnleft.remove(); }, 100); }; let style = function () { btnleft.style.cssText = ` position:fixed; border-radius: 50%;; left:${x - 20}px; top:${y - container.scrollTop + h / 2}px; width:50px; height:50px; border: 0px; background-color: rgba(200,200,200,0.8); font-size: 20px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnright.style.cssText = ` position:fixed; border-radius: 50%; left:${x + w + 20}px; top:${y - container.scrollTop + h / 2}px; width:50px; border: 0px; height:50px; font-size: 20px; background-color: rgba(200,200,200,0.8); z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnleft.innerText = '\u003c'; btnright.innerText = '\u003e'; img.style.cssText = ` position:fixed; border-radius: 12px; left:${x}px; top:${y - container.scrollTop}px; width:${w}px; height:${h}px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); opacity:0; `; }; // 监听滚动关闭层 document.addEventListener('scroll', function () { closeFade(); }); document.querySelectorAll('img').forEach((v) =\u003e { if (v.parentNode.localName != 'a') { v.id = imgid; imgid++; v.addEventListener('click', function (e) { // 注册事件 // 记录小图的位置个大小 x = e.target.offsetLeft; y = e.target.offsetTop; w = e.target.offsetWidth; h = e.target.offsetHeight; src = e.target.src; id = e.target.id; // 创建遮罩层 div = document.createElement('div'); div.style.cssText = ` position:fixed; left:0; top:0; bottom:0; right:0; background-color: rgba(25,25,25,0.8); z-index:99999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; document.body.appendChild(div); setTimeout(function () { div.style.opacity = 1; }, 0); // （此处可以加 loading) // 创建副本 img = new Image(); btnright = document.createElement('button'); btnleft = document.createElement('button'); img.src = src; style(); btnleft.onclick = function () { if (id === 0) { alert('已经是第一张了！'); return; } var left = document.getElementById(id - 1); img.src = left.src; x = left.offsetLeft; y = left.offsetTop; w = left.offsetWidth; h = left.offsetHeight; style(); id--; }; btnright.onclick = function () { id++; if (id \u003e= imgid) { alert('已经是最后一张了！'); return; } var right = document.getElementById(id); img.src = right.src; x = right.offsetLeft; y = right.offsetTop; w = right.offsetWidth; h = right.offsetHeight; style(); }; img.onload = function () { document.body.appendChild(img); document.body.appendChild(btnright); document.body.appendChild(btnleft); // 浏览器宽高 wh = window.innerHeight; ww = window.innerWidth; // 目标宽高和坐标 if (w / h \u003c ww / wh) { th = wh - 80; tw = ((w / h) * th) \u003e\u003e 0; tx = (ww - tw) / 2; ty = 40; } else { tw = ww * 0.8; th = ((h / w) * tw) \u003e\u003e 0; tx = ww * 0.1; ty = (wh - th) / 2; } // 延迟写入否则不会有动画 setTimeout(function () { img.style.opacity = 1; img.style.height = th + 'px'; img.style.width = tw + 'px'; img.style.left = tx + 'px'; img.style.top = ty + 'px'; btnleft.style.left = tx - 90 + 'px'; btnleft.style.top = ty + th / 2 + 'px'; btnright.style.left = tx + tw + 40 + 'px'; btnright.style.top = ty + th / 2 + 'px'; // 点击隐藏 div.onclick = img.onclick = closeMove; }, 10); }; }); //end event } }); //end forEach ","date":"2021-06-21","objectID":"/posts/lightbox/:2:0","tags":["Lightbox","JavaScript"],"title":"Lightbox","uri":"/posts/lightbox/"},{"categories":["JavaScript"],"content":"fancybox fancybox 是一個完善的 lightbox 插件 jQuery lightbox script for displaying images, videos and more. Touch enabled, responsive and fully customizable. ","date":"2021-06-21","objectID":"/posts/lightbox/:3:0","tags":["Lightbox","JavaScript"],"title":"Lightbox","uri":"/posts/lightbox/"},{"categories":["JavaScript"],"content":"Quick start Add latest jQuery and fancyBox files \u003cscript src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003clink href=\"/path/to/jquery.fancybox.min.css\" rel=\"stylesheet\" /\u003e \u003cscript src=\"/path/to/jquery.fancybox.min.js\"\u003e\u003c/script\u003e Create links \u003ca data-fancybox=\"gallery\" href=\"big_1.jpg\"\u003e \u003cimg src=\"small_1.jpg\" /\u003e \u003c/a\u003e \u003ca data-fancybox=\"gallery\" href=\"big_2.jpg\"\u003e \u003cimg src=\"small_2.jpg\" /\u003e \u003c/a\u003e Enjoy! ","date":"2021-06-21","objectID":"/posts/lightbox/:3:1","tags":["Lightbox","JavaScript"],"title":"Lightbox","uri":"/posts/lightbox/"},{"categories":["Projects","JavaScript"],"content":"Usage ","date":"2021-05-23","objectID":"/projects/cell-watermark/:0:0","tags":["watermark","JavaScript"],"title":"Cell Watermark","uri":"/projects/cell-watermark/"},{"categories":["Projects","JavaScript"],"content":"Browser Clone source git clone git@github.com:Lruihao/watermark.git Load Watermark \u003cscript type=\"text/javascript\" src=\"./src/watermark.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"./src/watermark.min.js\"\u003e\u003c/script\u003e \u003c!-- Or CDN --\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/cell-watermark@1.0.3/src/watermark.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/cell-watermark@1.0.3/src/watermark.min.js\"\u003e\u003c/script\u003e Initialization document.addEventListener('DOMContentLoaded', function () { new Watermark({ content: \"cell-watermark\" }) }); ","date":"2021-05-23","objectID":"/projects/cell-watermark/:1:0","tags":["watermark","JavaScript"],"title":"Cell Watermark","uri":"/projects/cell-watermark/"},{"categories":["Projects","JavaScript"],"content":"NPM Install npm i cell-watermark Import import Watermark from 'cell-watermark' /* Or */ var Watermark = require(\"cell-watermark\") Class: Watermark ","date":"2021-05-23","objectID":"/projects/cell-watermark/:2:0","tags":["watermark","JavaScript"],"title":"Cell Watermark","uri":"/projects/cell-watermark/"},{"categories":["Projects","JavaScript"],"content":"Watermark(options) new Watermark(options) Parameters: Name Type Description options Object The options of watermark（Properties） Properties: Name Type Attributes Default Description content String \u003coptional\u003e watermark’s text appendTo String \u003coptional\u003e ‘body’ parent of watermark’s container width Number \u003coptional\u003e 150 watermark’s width. unit: px height Number \u003coptional\u003e 20 watermark’s height. unit: px rowSpacing Number \u003coptional\u003e 60 row spacing of watermarks. unit: px colSpacing Number \u003coptional\u003e 30 col spacing of watermarks. unit: px rotate Number \u003coptional\u003e 15 watermark’s tangent angle. unit: deg opacity Number \u003coptional\u003e 0.1 watermark’s transparency fontSize Number \u003coptional\u003e 0.85 watermark’s fontSize. unit: rem fontFamily String \u003coptional\u003e ‘inherit’ watermark’s fontFamily Author: Lruihao ","date":"2021-05-23","objectID":"/projects/cell-watermark/:3:0","tags":["watermark","JavaScript"],"title":"Cell Watermark","uri":"/projects/cell-watermark/"},{"categories":["Projects","JavaScript"],"content":"Methods upload(content) Upload watermark’s text content Parameters: Name Type Description content String watermark’s text render(options) Rerender watermark Parameters: Name Type Description options Object The options of watermark（Properties） destroy() Force destroy watermark ","date":"2021-05-23","objectID":"/projects/cell-watermark/:3:1","tags":["watermark","JavaScript"],"title":"Cell Watermark","uri":"/projects/cell-watermark/"},{"categories":["Memo"],"content":"程式碼的持續優化 對一個入門的工程師來說，掌握程式語法與模仿範例實作是基本的能力。那有了這樣的基本能之後，要如何寫出更好的程式呢？怎樣才能夠成為一個「優秀」的新手工程師呢？事實上，寫出會動的程式不難，但想寫出好的程式其實是需要刻意練習的。大部分的人會建議要「多練習、多實作」，但我認為在大量練習之外，適時的「優化程式」也是提升「程式碼品質」重要的關鍵。而在「優化程式」可以分成兩個角度： 程式執行效能更好 程式碼結構更精簡 程式執行效能就是從速度跟空間來思考，執行時間越短、變數佔用空間越小。而程式碼結構則會從可讀性和精簡來衡量，例如：變數的命名有沒有意義、程式碼有沒有冗余、繁瑣的部分等等。只不過新手很容易停留在寫出程式的喜悅以及受到固有的解題思考，而忽略優化的過程。 透過「Code Review」是推薦新手的方法，經由反饋與討論來找出程式中可優化的空間。 ","date":"2021-03-04","objectID":"/posts/codereview/:1:0","tags":["codereview"],"title":"Code Review 怎麼做？新手工程師如何提升「程式碼品質」","uri":"/posts/codereview/"},{"categories":["Memo"],"content":"Code Review 的關注點 以我自己的經驗來說，Review 一份專案的時候會關注： 程式能不能正常操作，有没有什么明显的错误？（低標） 程式碼當中有沒有奇怪的地方？（優化） 第一個關注點是程式碼的低標，結果正確與可正常運行一定是最重要的。如果程式無法運行動或存在很明顯的問題，那再多的優化都沒有意義。除了確保執行之外，同時也會檢查一下是否有低級的邏輯失誤或是安全性的疑慮，像是資料庫沒有正確關閉或密碼明碼沒有加密之類的問題。 第二個關注點是「程式碼品質提升」的部分，我會把它定義成程式運作上沒有問題，但看起來很不舒服或執行效率很差的部分。大致上可以從以下幾點下手： 命名有沒有意義/不一致 資料庫的正規化情況 是否存在特別複雜的程式片段（例如多次的資料庫查詢、多層的迴圈使用） 重複的程式碼有沒有定義成 function 冗長的程式碼能不能拆分成 function 不過一次的 Code Review 建議著重在 3 - 5 個優化地方，比較容易聚焦在優化的品質。根據時程的壓力，決定 Code Review 迭代的次數。 ","date":"2021-03-04","objectID":"/posts/codereview/:2:0","tags":["codereview"],"title":"Code Review 怎麼做？新手工程師如何提升「程式碼品質」","uri":"/posts/codereview/"},{"categories":["Memo"],"content":"從架構的規劃到細節的優化 在拿到一份程式碼時，通常會先掃過一眼程式的檔案結構，是否有不該上傳的檔案或缺漏。 以這個例子來說，第一眼會覺得檔案配置蠻結構化的。但再多看一點會發現存在幾個冗餘的檔案，例如：-filesqqqq、diff，甚至 /icon 資料夾也不該放在最上層。 進入程式的第一步先從 package.json 檔案開始，確認一下專案的基本資訊是否完整、使用到的套件與版本，以及程式的進入點是什麼。然後打開進入點的檔案（通常會命名成 app 或 main），通常有幾個點需要注意：「套件的載入順序」會建議從第三方套件 → 自定義的模組 → 程式內的變數這樣順序定義；「善用 MVC 的架構」將非主程式的部分依照功能拆分模組，避免檔案資訊量太雜亂。接著就會從 Router → Controller → Service → View 的流程一個一個功能，以下分享一些存在優化空間的程式碼： 善用工具，已有的工具，不用自己手刻 變數名稱不建議用大寫開頭（通常是用在 Class 的命名） 保持優化的空間與彈性 「優化其實是一種取捨」，不需要也不應該追求一步到位。開發往往都是在品質跟產出做取捨，初期可以把開發目標放在「先求可以動，再求持續優化」的節奏上。新手需要在意的點有幾下兩點： 很容易把重點全部放在程式碼的產出上而忽略的程式碼的品質。 停留在做出成果的喜悅，而停滯了優化的步調。 因此，會建議在開發當下就「多想」兩秒鐘，感覺可優化但來不及的部分先在旁邊加個註解提醒自己。另外也養成一段時間回頭看之前的程式碼的習慣，試著刻意找出可以優化改進的部分。專案的提交可能會有期限，但程式碼的優化沒有盡頭。面對相同的專案與程式碼，唯有透過不停的迭代優化才能打造更好的程式，同時也見證了你和程式一起變得更好的過程。所以建立逐步優化的空間，養成持續提升程式碼品質的習慣，才是一個新手工程師需要修煉的心法。 ","date":"2021-03-04","objectID":"/posts/codereview/:3:0","tags":["codereview"],"title":"Code Review 怎麼做？新手工程師如何提升「程式碼品質」","uri":"/posts/codereview/"},{"categories":["Projects","瞎折腾"],"content":"起因 起因 事情是這樣，年前和朋友一起合租了一個房子，然後捏，生活嘛，除了開心，當然是乾飯最大啦！ 自然就會有購物，買菜等日常消費，那就要記賬，一開始是各自記在手機的便簽上，最後再算一下； 三個人，一共七种組合消費，排除各自消費的三種情況，也有四種 (AB, AC, BC, ABC)。好麻煩啊！！！ ","date":"2021-03-02","objectID":"/projects/bill-note/:1:0","tags":["JavaScript","leancloud","Vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["Projects","瞎折腾"],"content":"經過 作為一個程序猿，怎麼能接受這麼麻煩的記賬方式呢，拿起筆就開始畫，於是有了下面這張圖的公式。簡單說明一下就是： 設前面說的四種組合為：X1, X2, X3, X4，個人實際付款總額為：Y1, Y2, Y3，那麼帶入未知數，我們就可以算出每個人最後結算時的錢：S1, S2, S3， 綜上所述，很好理解，當 S \u003e= 0 時，收紅包，當 S \u003c 0 時，發紅包。 OK，一個簡單的初中方程式已經到位了，下一步，思考一下，用什麼來運作這個這個方程。來，先跑個題，春節期間，不是每天都要在騰訊文檔上填表記錄活動軌跡嗎？ 再回來，那不如就用 excel 實現吧，三個人都可以在手機上編輯。好的，說做就做。 一頓操作，10 minutes later… 只新建了一個 excel 文件，O.o! 不會 excel，果斷放棄，另尋他路。 ","date":"2021-03-02","objectID":"/projects/bill-note/:2:0","tags":["JavaScript","leancloud","Vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["Projects","瞎折腾"],"content":"結果 回到本職，那不如寫個網站吧，可是畢業後，學生機服務器也過期了，怎麼搞？那就寫個純前端的，數據呢存哪裡？ 別急，重新擼一擼需求先： 存取消費數據 計算每月，實付（總分），應付以及最後計算結算金額 按月查詢，月結賬單 三人皆可編輯 主要就是存取數據這點，沒有服務器，數據庫怎麼實現？ valine 可以實現無後端，那我是不是也可以，leancloud 文檔走一波，然後“數據表”設計一下，其實是 leancloud-storage Object ，於是有了以下東西，源碼放在 Github bill-note http://github.com/Lruihao/bill-note ","date":"2021-03-02","objectID":"/projects/bill-note/:3:0","tags":["JavaScript","leancloud","Vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["Projects","瞎折腾"],"content":"數據設計 去 leancloud 创建一个应用，再新增一个 Bill Class, 补充一下字段： name type description pay Number 消费金额 pay_description String 消费描述 pay_type String 消费类型 pay_user String 付款人 ","date":"2021-03-02","objectID":"/projects/bill-note/:3:1","tags":["JavaScript","leancloud","Vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["Projects","瞎折腾"],"content":"主要邏輯 初始化 set for yourself. AV.init({ appId: '', appKey: '', serverURL: '' }); 存數據 //記賬提交按鈕事件監聽 document.querySelector('.submit').addEventListener('click', function (event) { event.preventDefault(); let formPay = document.querySelector('#form-pay'); let bill = new AV.Object('Bill'); bill.set('pay', Number(formPay.pay.value)); bill.set('pay_type', Number(formPay.pay_type.value)); bill.set('pay_user', Number(formPay.pay_user.value)); bill.set('pay_description', formPay.pay_description.value); bill.save().then( (object) =\u003e { formPay.reset(); }, function (error) { console.log(JSON.stringify(error)); alert('保存失敗'); } ); }); 取數據 /** * 獲取歷史消費記錄數據 * @param [start=0] 開始位置 * @param [count=15] 每次查詢筆數 */ function getBillData(start = 0, count = 15) { queryBill .descending('createdAt') .skip(start * count) .limit(count) .find() .then(function (response) { let billLength = response.length; if (billLength \u003e 0) { billVm.noMore = billLength !== count ? true : false; for (bill of response) { billVm.bills.push({ pay: bill.attributes.pay, payType: payType[bill.attributes.pay_type], payUser: payUser[bill.attributes.pay_user], payDescription: bill.attributes.pay_description, payDt: new Date(bill.createdAt).toLocaleString() }); } } else { billVm.noMore = true; } }); } /** * 獲取月賬單數據 * @param month 年月份 fmt: yyyy-MM */ function getMonthBill(month) { let dateTime = `${month} 00:00:00`; let startMonth = new Date(dateTime); let nextMonth = new Date(new Date(dateTime).setMonth(startMonth.getMonth() + 1)); let startDateQuery = new AV.Query('Bill'); startDateQuery.greaterThanOrEqualTo('createdAt', startMonth); let endDateQuery = new AV.Query('Bill'); endDateQuery.lessThan('createdAt', nextMonth); let MonthBillQuery = AV.Query.and(startDateQuery, endDateQuery); MonthBillQuery.find().then(function (response) { billVm.monthBill = { payType0: 0, payType1: 0, payType2: 0, payType3: 0, payUser0: 0, payUser1: 0, payUser2: 0 }; for (bill of response) { let { pay, pay_type, pay_user } = bill.attributes; billVm.monthBill[`payType${pay_type}`] += pay; billVm.monthBill[`payUser${pay_user}`] += pay; } }); } ","date":"2021-03-02","objectID":"/projects/bill-note/:3:2","tags":["JavaScript","leancloud","Vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["Projects","瞎折腾"],"content":"技術棧 leancloud-storage Vue.js HTML,CSS,JS ","date":"2021-03-02","objectID":"/projects/bill-note/:3:3","tags":["JavaScript","leancloud","Vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["Projects","瞎折腾"],"content":"總結 簡單總結一下，登录功能不做，安不安全自己说了算。删除修改功能也不做，直接上 leancloud 操作，css 美化的样式也不写，干净又卫生！ 然后衍生一下，什么过年斗地主，天炸，麻将，字牌记账系统那不也是同理可得嘛！ over! 效果 ","date":"2021-03-02","objectID":"/projects/bill-note/:4:0","tags":["JavaScript","leancloud","Vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["Projects"],"content":" 基于 Laravel7 开发，Markdown 语法的个人独立博客。Cell Blog, 也是我的毕业设计作品，目前已開源。 ","date":"2020-07-25","objectID":"/projects/cell-blog/:0:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 功能介绍与安装","uri":"/projects/cell-blog/"},{"categories":["Projects"],"content":"功能 支持 Markdown, 文章实时预览效果 支持多种编程语言代码高亮 编辑器图片上传 后台上传文件管理 文章搜索 文章分类 文章标签 热门文章 随机格言 文章管理（发布，评论开关，排序） 自定义导航（显示开关，排序） 自定义页面（发布开关） 友情链接（显示开关，排序） COS 桶相册 丰富的博客配置（方便扩展，支持自定义 JS 脚本） 不蒜子计数 Leancloud 计数 Valine 评论插件 文章分享插件 ","date":"2020-07-25","objectID":"/projects/cell-blog/:1:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 功能介绍与安装","uri":"/projects/cell-blog/"},{"categories":["Projects"],"content":"截图 ","date":"2020-07-25","objectID":"/projects/cell-blog/:2:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 功能介绍与安装","uri":"/projects/cell-blog/"},{"categories":["Projects"],"content":"安装 注意事项：PHP 取消禁用函数putenv()和symlink()，安装fileinfo扩展。 下载 git clone https://github.com/Lruihao/cell-blog.git 进入站点 cd cell-blog 生成。env cp .env.example .env 编辑。env 环境配置 APP_URL=http://localhost #使用本地文件系统存储文件时，必须填写正确地址 APP_DEBUG=false #关闭调试 DB_HOST= #数据库地址 DB_PORT=3306 #数据库端口 DB_DATABASE= #数据库名称 DB_USERNAME= #数据库用户 DB_PASSWORD= #数据库密码 打开app\\Providers\\AppServiceProvider.php, 注释SystemController:load() 防止后续步骤报错 public function boot() { Schema::defaultStringLength(191); //SystemController::load(); } 安装项目依赖 composer install 生成 key php artisan key:generate 运行数据迁移和后台数据填充 php artisan admin:install已包含数据迁移命令php artisan migrate G:\\cell-blog\\app\\Admin directory already exists !无需理会，继续执行剩下命令即可。 php artisan admin:install php artisan admin:import media-manager php artisan db:seed 默认下使用了本地文件系统，创建 storage 目录在 public 的软链接 php artisan storage:link 打开app\\Providers\\AppServiceProvider.php, 取消注释SystemController:load() public function boot() { Schema::defaultStringLength(191); SystemController::load(); } 将博客网站根目录指向入口 public 目录 如果使用 Nginx，要设置伪静态 location / { try_files $uri $uri/ /index.php?$query_string; } 启动服务后，在浏览器打开http://localhost/admin/, 使用用户名admin和密码admin登录。 ","date":"2020-07-25","objectID":"/projects/cell-blog/:3:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 功能介绍与安装","uri":"/projects/cell-blog/"},{"categories":["Projects"],"content":"License Cell Blog is open-sourced software licensed under the MIT license. ","date":"2020-07-25","objectID":"/projects/cell-blog/:4:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 功能介绍与安装","uri":"/projects/cell-blog/"},{"categories":["Memo"],"content":" Cell Blog 开发记录，项目地址 ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:0:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"搭建 php 环境 安装 wampserver 安装 composer 更换 aliyun 源 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:1:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"新建 laravel 项目 composer create-project --prefer-dist laravel/laravel cell-blog \"7.*\" 或者 composer global require laravel/installer laravel new blog ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:2:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"下载 debugbar composer require barryvdh/laravel-debugbar --dev ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:3:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"修改语言时区 修改 config/app.php，将 local 的值 en 改成 zh-CN(laravel-admin 自带 zh-CN)： ## 时区 'timezone' =\u003e 'Asia/Shanghai', ## 语言 'locale' =\u003e 'zh-CN', ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:4:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"配置数据库 首先确保安装好了 laravel，并且数据库连接设置正确。 APP_URL=http://cell.blog DB_CONNECTION=mysql DB_HOST=127.0.0.1 DB_PORT=3307 DB_DATABASE=cell_blog DB_USERNAME=root DB_PASSWORD=123456 ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:5:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"下载 laravel-admin cd cell-blog composer require encore/laravel-admin 卸载命令composer remove xxx 然后运行下面的命令来发布资源： php artisan vendor:publish --provider=\"Encore\\Admin\\AdminServiceProvider\" 在该命令会生成配置文件config/admin.php，可以在里面修改安装的地址、数据库连接、以及表名，建议都是用默认配置不修改。 然后运行下面的命令完成安装： php artisan admin:install 运行这个命令的时候，如果遇到了下面的错误： SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 1000 bytes (SQL: alter tableusersadd uniqueusers_email_unique(email)) 参考这个 issue 来解决 https://github.com/z-song/laravel-admin/issues/1541 在app\\Providers\\AppServiceProvider.php添加默认值 \u003c?php namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Schema; //add fixed sql class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { Schema::defaultStringLength(191); //add fixed sql } /** * Register any application services. * * @return void */ public function register() { // } } 启动服务后，在浏览器打开 http://localhost/admin/ , 使用用户名 admin 和密码 admin 登录。 报错Disk [admin] not configured, please add a disk config in config/filesystems.php 在config/filesystems.php中 disks 处添加以下配置后执行php artisan storage:link来创建软链接（windows 和 linux 的软链接不一样不能直接复制！） 宝塔执行时删除禁用函数 putenv(),symlink() 'admin' =\u003e [ 'driver' =\u003e 'local', 'root' =\u003e storage_path('app/public/system'), 'url' =\u003e env('APP_URL').'/storage/system', 'visibility' =\u003e 'public', ], 或 'admin' =\u003e [ 'driver' =\u003e 'local', 'root' =\u003e public_path('uploads'), 'url' =\u003e env('APP_URL').'/public/uploads/', 'visibility' =\u003e 'public', ], ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:6:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"下载 dcat-admin composer require dcat/laravel-admin 然后运行下面的命令来发布资源： php artisan admin:publish 在该命令会生成配置文件config/admin.php，可以在里面修改安装的地址、数据库连接、以及表名，建议都是用默认配置不修改。 然后运行下面的命令完成安装： php artisan admin:install ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:7:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"迁移文件创建表 php artisan make:migration create_articles_table php artisan make:migration create_tags_table php artisan make:migration create_categories_table php artisan make:migration create_article_tags_table php artisan make:migration create_navigations_table php artisan make:migration create_friendship_links_table php artisan make:migration create_pages_table php artisan make:migration create_systems_table php artisan make:migration create_mottoes_table 运行迁移 php artisan migrate ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:8:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"创建模型 model php artisan make:model Models/Article php artisan make:model Models/Category php artisan make:model Models/Tag php artisan make:model Models/Navigation php artisan make:model Models/FriendshipLink php artisan make:model Models/Page php artisan make:model Models/System php artisan make:model Models/Motto ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:9:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"创建控制器 php artisan admin:make ArticleController --model=App\\Models\\Article php artisan admin:make CategoryController --model=App\\Models\\Category php artisan admin:make TagController --model=App\\Models\\Tag php artisan admin:make NavigationController --model=App\\Models\\Navigation php artisan admin:make FriendshipLinkController --model=App\\Models\\FriendshipLink php artisan admin:make PageController --model=App\\Models\\Page php artisan admin:make SystemController --model=App\\Models\\System php artisan admin:make MottoController --model=App\\Models\\Motto ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:10:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"添加后台路由 app/Admin/routes.php $router-\u003eresource('articles', ArticleController::class); $router-\u003eresource('categories', CategoryController::class); $router-\u003eresource('tags', TagController::class); $router-\u003eresource('navigations', NavigationController::class); $router-\u003eresource('friendship-links', FriendshipLinkController::class); $router-\u003eresource('pages', PageController::class); $router-\u003eresource('systems', SystemController::class); $router-\u003eresource('mottoes', MottoController::class); ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:11:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"editormd 安装 editormd github 图像问题 ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:12:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"存放本地表情 public\\vendor\\laravel-admin-ext\\editormd\\editormd-1.5.0\\images\\emojis 修改 editormd.js 及 editormd.min.js // Emoji graphics files url path editormd.emoji = { path : \"/iamges/emojis/\", ext : \".png\" }; ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:12:1","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"图片上传 csrf 419 错误 可以在VerifyCsrfToken.php中添加白名单跳过验证，或者手动添加 csrf 验证器： 修改 image-dialog.js 的var dialogContent 参考 if (settings.crossDomainUpload) { action += \"\u0026callback=\" + settings.uploadCallbackURL + \"\u0026dialog_id=editormd-image-dialog-\" + guid; } //添加 csrf 验证 var csrfToken = $('meta[name=\"csrf-token\"]').attr('content'); var csrfField = \"\"; if (csrfToken) { csrfField = \"\u003cinput type='hidden' name='_token' value='\" + csrfToken + \"' /\u003e\"; } ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:12:2","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"markdown 转 HTML https://www.zhiqiexing.com/119.html Laravel Markdown 安装 composer require graham-campbell/markdown php artisan vendor:publish 扩展表格 composer require league/commonmark config/markdown.php 'extensions' =\u003e [ League\\CommonMark\\Extension\\TaskList\\TaskListExtension::class, ], ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:13:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"Eloquent 模型事件 Eloquent 模型可以触发事件，允许你在模型生命周期中的多个时间点调用如下这些方法：retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, restoring, restored。事件允许你在一个指定模型类每次保存或更新的时候执行代码。 retrieved 事件会在从数据库中获取已存在模型时触发。当一个新模型被首次保存的时候，creating 和 created 事件会被触发。如果一个模型已经在数据库中存在并调用 save 方法，updating/updated 事件会被触发，无论是创建还是更新，saving/saved 事件都会被触发。 ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:14:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"添加后台验证码 依赖 php 扩展fileinfo 添加验证码 ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:15:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"Media manager composer require laravel-admin-ext/media-manager php artisan admin:import media-manager ’extensions’ =\u003e [ ‘media-manager’ =\u003e [ // Select a local disk that you configured in config/filesystem.php ‘disk’ =\u003e ‘public’ ], ], ## 给 laravel-admin 增加锁屏功能 composer require laravel-admin-ext/lock-screen 'route' =\u003e [ 'prefix' =\u003e 'demo', 'namespace' =\u003e 'App\\\\Admin\\\\Controllers', // 在中间件数组中加上'admin.lock' 'middleware' =\u003e ['web', 'admin', 'admin.lock'], ], ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:16:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"前台设计 创建控制器 php artisan make:controller HomeController php artisan make:controller ArticleController php artisan make:controller CategoryController php artisan make:controller TagController php artisan make:controller PageController ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:17:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Memo"],"content":"后台 img 灯箱 https://github.com/laravel-admin-extensions/grid-lightbox composer require laravel-admin-ext/grid-lightbox php artisan vendor:publish --tag=laravel-admin-grid-lightbox ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:18:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["瞎折腾","Python"],"content":" 使用 python 模拟浏览器行为刷 csdn 访问量，脚本仅做学习，请勿滥用~ 直接丢代码，把代码挂到服务器上可以策马奔腾~，也可以生成二进制文件放到 Windows 桌面上随时使用~ 打包 exe 参考 #!/usr/bin/python # -*- coding: utf-8 -*- __author__ = 'lruihao.cn' import urllib.request import re import time from bs4 import BeautifulSoup opener = urllib.request.build_opener() opener.addheaders = [('User-agent', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36')] def get_article_url(page,name): endurl = \"/\"+name+\"/article/details/........\" print(name) p = re.compile(endurl) url = \"http://blog.csdn.net/\"+name+\"/article/list/\"+str(page) # 使用 build_opener() 是为了让 python 程序模仿浏览器进行访问 html = opener.open(url).read().decode('utf-8') allfinds = p.findall(html) return allfinds #print('allfinds',allfinds) def start_do(allfinds): urlBase = \"http://blog.csdn.net\" # 需要将网址合并的部分 # 页面中的网址有重复的，需要使用 set 进行去重复 mypages = list(set(allfinds)) for i in range(len(mypages)): mypages[i] = urlBase + mypages[i] print('要刷的网页有：') for index, page in enumerate(mypages): print(str(index), page) # 设置每个网页要刷的次数 brushNum = 1 # 所有的页面都刷 print('下面开始刷了哦：') for index, page in enumerate(mypages): for j in range(brushNum): try: pageContent = opener.open(page).read().decode('utf-8') # 使用 BeautifulSoup 解析每篇博客的标题 soup = BeautifulSoup(pageContent) blogTitle = str(soup.title.string) blogTitle = blogTitle[0:blogTitle.find('-')] print(str(j), blogTitle) except urllib.error.HTTPError: print('urllib.error.HTTPError') time.sleep(3) # 出现错误，停几秒先 except urllib.error.URLError: print('urllib.error.URLError') time.sleep(3) # 出现错误，停几秒先 time.sleep(0.5) # 正常停顿，以免服务器拒绝访问 def main(name): for page in range(1,5): print(\"************第\"+str(page)+\"页*************\") endurl = get_article_url(page,name) start_do(endurl) if __name__ == '__main__': name = input(\"输入你的 csdn 用户名：\") if name==\"\": name = \"qq_39520417\" #cheung99857 while 1: main(name) print(\"开始休息 ...\") time.sleep(40) 主函数也可以这样写实现同时刷多人的访问量，人多可以适当减少休眠时间，当然有兴趣的可以尝试一下多线程~ if __name__ == '__main__': # 多用户 names = [\"qq_39520417\",\"cheung99857\"] while 1: for name in names: main(name) print(\"开始休息 ...\") # 控制休眠时间相当于控制刷新的速度 time.sleep(30) ","date":"2020-03-26","objectID":"/posts/csdnvisiter/:0:0","tags":["Python"],"title":"使用 Python 刷 csdn 访问量","uri":"/posts/csdnvisiter/"},{"categories":["OS"],"content":"基本语法 \u003c秒\u003e \u003c分钟\u003e \u003c小时\u003e \u003c日期 day-of-month\u003e \u003c月份\u003e \u003c星期 day-of-week\u003e Cron 表达式是一个具有时间含义的字符串，字符串以 5 个空格隔开，分为 6 个域，格式为 X X X X X X。其中 X 是一个域的占位符。单个域有多个取值时，使用半角逗号，隔开取值。每个域可以是确定的取值，也可以是具有逻辑意义的特殊字符。 ","date":"2020-03-25","objectID":"/posts/cron/:1:0","tags":["linux","shell","Cron"],"title":"Cron 表达式的基本语法","uri":"/posts/cron/"},{"categories":["OS"],"content":"域取值 位置 字段 约束 取值 可使用的特殊符号 1 秒 必须 0-59 , - * / 2 分钟 必须 0-59 , - * / 3 小时 必须 0-23（0 为午夜） , - * / 4 日期 必须 1-31 , - * ? / L W 5 月份 必须 1-12 或者 JAN-DEC , - * / 6 星期 必须 1-7 或者 SUN-SAT (1 代表星期一） , - ? / L # ","date":"2020-03-25","objectID":"/posts/cron/:2:0","tags":["linux","shell","Cron"],"title":"Cron 表达式的基本语法","uri":"/posts/cron/"},{"categories":["OS"],"content":"特殊符号 符号 含义 示例 * 所有可能的值。 在月域中，*表示每个月；在星期域中，*表示星期的每一天。 , 列出枚举值。 在分钟域中，5,20表示分别在 5 分钟和 20 分钟触发一次。 - 范围。 在分钟域中，5-20表示从 5 分钟到 20 分钟之间每隔一分钟触发一次。 / 指定数值的增量。 在分钟域中，0/15表示从第 0 分钟开始，每 15 分钟。在分钟域中3/20表示从第 3 分钟开始，每 20 分钟。*/ 和 0/ 相同 ? 不指定值，仅日期和星期域支持该字符。 当日期或星期域其中之一被指定了值以后，为了避免冲突，需要将另一个域的值设为?。 L 单词 Last 的首字母，表示最后一天，仅日期和星期域支持该字符。说明 指定L字符时，避免指定列表或者范围，否则，会导致逻辑问题。 在日期域中，L表示某个月的最后一天。在星期域中，L表示一个星期的最后一天，也就是星期日（SUN）。如果在L前有具体的内容，例如，在星期域中的6L表示这个月的最后一个星期六。 W 除周末以外的有效工作日，在离指定日期的最近的有效工作日触发事件。W字符寻找最近有效工作日时不会跨过当前月份，连用字符LW时表示为指定月份的最后一个工作日。 在日期域中5W，如果 5 日是星期六，则将在最近的工作日星期五，即 4 日触发。如果 5 日是星期天，则将在最近的工作日星期一，即 6 日触发；如果 5 日在星期一到星期五中的一天，则就在 5 日触发。 # 确定每个月第几个星期几，仅星期域支持该字符。 在星期域中，4#2表示某月的第二个星期四。 ","date":"2020-03-25","objectID":"/posts/cron/:3:0","tags":["linux","shell","Cron"],"title":"Cron 表达式的基本语法","uri":"/posts/cron/"},{"categories":["OS"],"content":"举个栗子 🌰 表达式 说明 0 0/5 * * * ? 每隔 5 分钟执行一次 10 0/5 * * * ? 每隔 5 分钟执行一次，每次执行都在分钟开始的 10 秒，例如 10:00:10、10:05:10 等等。 0 30 10-13 ? * WED,FRI 每周三和每周五的 10:30、11:30、12:30、13:30 执行。 0 0/30 8-9 5,20 * ? 每个月的 5 号和 20 号的 8 点和 10 点之间每隔 30 分钟执行一次，也就是 8:00、8:30、9:00 和 9:30。 0 15 10 ? * * 每天上午 10:15 执行任务 0 15 10 * * ? 每天上午 10:15 执行任务 0 0 12 * * ? 每天中午 12:00 执行任务 0 0 10,14,16 * * ? 每天上午 10:00 点、下午 14:00 以及下午 16:00 执行任务 0 0/30 9-17 * * ? 每天上午 09:00 到下午 17:00 时间段内每隔半小时执行任务 0 * 14 * * ? 每天下午 14:00 到下午 14:59 时间段内每隔 1 分钟执行任务 0 0-5 14 * * ? 每天下午 14:00 到下午 14:05 时间段内每隔 1 分钟执行任务 0 0/5 14 * * ? 每天下午 14:00 到下午 14:55 时间段内每隔 5 分钟执行任务 0 0/5 14,18 * * ? 每天下午 14:00 到下午 14:55、下午 18:00 到下午 18:55 时间段内每隔 5 分钟执行任务 0 0 12 ? * WED 每个星期三中午 12:00 执行任务 0 15 10 15 * ? 每月 15 日上午 10:15 执行任务 0 15 10 L * ? 每月最后一日上午 10:15 执行任务 0 15 10 ? * 6L 每月最后一个星期六上午 10:15 执行任务 0 15 10 ? * 6#3 每月第三个星期六上午 10:15 执行任务 0 10,44 14 ? 3 WED 每年 3 月的每个星期三下午 14:10 和 14:44 执行任务 ","date":"2020-03-25","objectID":"/posts/cron/:4:0","tags":["linux","shell","Cron"],"title":"Cron 表达式的基本语法","uri":"/posts/cron/"},{"categories":["瞎折腾","Python"],"content":" 信息 这件事还得从一只蝙蝠说起 … 算了，昨天下午 3 点半，我还在王者峡谷 Timing, 突然潇 X 巴哥打了个电话给我说关于自动打卡的想法 … 哎，反正就是由于疫情需要每天健康打卡汇报给学校，然后每天提交一样的太麻烦了，就想写个程序自动打卡 … 我和潇 X 巴哥确定思路后兵分两路： 他用 java 写个后台自动刷多人的，再弄个网页给用户填写账号密码保存在数据库； 我想的就很直接，只刷一个人的，python 模拟浏览器登录后打卡，再设置定时任务（多人则设定多个）； ","date":"2020-03-25","objectID":"/posts/daka/:0:0","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["瞎折腾","Python"],"content":"Windows 运行效果 打卡成功 重复打卡 定时任务日志 ","date":"2020-03-25","objectID":"/posts/daka/:1:0","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["瞎折腾","Python"],"content":"核心代码 适用湖南工程学院的打卡系统。 请勿滥用代码提交不实健康信息，隐瞒疫情将受到相关法律处理！ 完整代码 def lajaDaka(): # 登录 r1 = requests.post(login_url, data=login,headers=headers,verify=False) if r1.status_code == 200: print(time.strftime(\"%Y:%m:%d:%H:%M\", time.localtime())) print(login[\"username\"] + \" 登录成功！\") # 拿到登录后的 cookie 并添加到 header 中 header1 = r1.headers headers[\"Cookie\"] = header1[\"Set-Cookie\"] else: return # 打卡 r2 = requests.post(daka_url, data=daka,headers=headers,verify=False) response2=r2.json() if r2.status_code != 200: print(\"打卡失败！\") return if response2[\"result\"] == True: print(\"打卡成功！\") else: print(response2[\"errorInfoList\"][0][\"message\"]) if __name__==\"__main__\": lajaDaka() ","date":"2020-03-25","objectID":"/posts/daka/:2:0","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["瞎折腾","Python"],"content":"自动运行 ","date":"2020-03-25","objectID":"/posts/daka/:3:0","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["瞎折腾","Python"],"content":"Windows 适用 python 代码控制休眠时间 if __name__==\"__main__\": while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) # 设置每天 8 点发送 if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 脚本将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后打卡\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 脚本将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后打卡\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"软件明天开始将在每天 8 点发送数据！\") lajaDaka() time.sleep(24*60*60-int(now_min)*60) ","date":"2020-03-25","objectID":"/posts/daka/:3:1","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["瞎折腾","Python"],"content":"linux（云服务器） 搭建 python 环境下载依赖后，使用 shell 脚本定时执行。 python /home/python/yiban_daka/daka.py CRON 表达式的基本语法 ","date":"2020-03-25","objectID":"/posts/daka/:3:2","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["瞎折腾","Python"],"content":"潇 x 巴哥的 java web 版本 符合程序员的应该有的简洁和方便，干净又卫生！ http://39.105.174.214/index.html java web 版 ","date":"2020-03-25","objectID":"/posts/daka/:4:0","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["MySQL"],"content":" SQL 增删改查 (CRUD) 语句与常用函数总结。 ","date":"2020-01-16","objectID":"/posts/sql/:0:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"SQL Introduction 一般我们对数据库的操作主要分为四种，增** C**(CREATE)、删** D**(DELETE)、改** U**(UPDATE)、查** R**(READ)，所以，我就从** CRUD **这四个方面来制作查询表。 开发规则： 尽量减少对数据库的访问次数，且不能查询无用的数据，浪费效能（例如：我只要男生的数据，你把所有人的数据都查询出来）。 属于SQL语法的要使用大写 （SELECT, WHERE, INSERT etc…）。 属于使用者自己定义的要使用小写（表名、列名 etc…）。 表名与列名前后使用 ` 包起来，防止与关键字冲突（例如： INSERT INTO `user` VALUES(‘a’,‘b’); ）。 禁止使用 Table Join。 禁止使用 Oracle Trigger。 禁止使用 SELECT * （为了加强代码可读性）。 不能将查询数据库的 SQL 放在循环中查询。 ","date":"2020-01-16","objectID":"/posts/sql/:1:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"新增（CREATE） 功能 语句 创建数据库 CREATE DATABASE \u003c数据库名\u003e; 创建数据表 CREATE TABLE \u003c表名\u003e (\u003c列名 1\u003e \u003c数据类型\u003e \u003c约束条件\u003e,\u003c列名 2\u003e \u003c数据类型\u003e \u003c约束条件\u003e,\u003c列名 3\u003e \u003c数据类型\u003e \u003c约束条件\u003e,......\u003c该表的的约束条件 1\u003e \u003c该表的的约束条件 2\u003e...); 插入数据 INSERT INTO \u003c表名\u003e （列名 1, 列名 2,...) VALUES （值 1, 值 2,...);（每列都有数据插入时，可省略列名。但是为了代码的可读性，不建议如此操作。） 增加列 ALTER TABLE \u003c表名\u003e ADD \u003c列名\u003e \u003c数据类型\u003e \u003c约束条件\u003e AFTER \u003c前一列列名\u003e;（默认插入到最后一列） ","date":"2020-01-16","objectID":"/posts/sql/:2:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"删除（DELETE） 功能 语句 删除数据库 DROP DATABASE \u003c数据库名\u003e; 删除数据表 DROP TABLE \u003c表名\u003e; 清空表数据 DELETE FROM \u003c表名\u003e; 或者 TRUNCATE TABLE \u003c表名\u003e; 删除行数据 DELETE FROM \u003c表名\u003e WHERE \u003c条件\u003e; 删除列数据 ALTER TABLE \u003c表名\u003e DROP \u003c列名\u003e; ","date":"2020-01-16","objectID":"/posts/sql/:3:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"修改（UPDATE） 功能 语句 修改数据库名 RENAME DATABASE \u003c旧名称\u003e TO \u003c新名称\u003e; 修改表名 RENAME TABLE \u003c旧名称\u003e TO \u003c新名称\u003e; 修改数据 UPDATE \u003c表名\u003e SET \u003c列名 1\u003e = \u003c新值 1\u003e,\u003c列名 2\u003e = \u003c新值 2\u003e WHERE \u003c条件\u003e; 修改列名 ALTER TABLE \u003c表名\u003e CHANGE \u003c旧列名\u003e \u003c新列名\u003e \u003c数据类型\u003e \u003c约束条件\u003e; 注意：重命名数据库与数据表一般不推荐使用，若想测试，请先备份好自己的数据库~ ","date":"2020-01-16","objectID":"/posts/sql/:4:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"查询（ R E A D ） 功能 语句 查询所有数据库 SHOW DATABASES; 查询指定数据库中所有表名 USE \u003c数据库名\u003e; 然后 SHOW TABLES;或者 SHOW TABLES FROM \u003c数据库名\u003e; 查询表中所有列信息 SHOW COLUMNS FROM \u003c表名\u003e; 查询表中所有数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e; 查询表中某个数据 SELECT \u003c列名\u003e FROM \u003c表名\u003e; 查询表中指定多个数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e WHERE \u003c条件\u003e; 查询表中指定一个数据 SELECT \u003c列名\u003e FROM \u003c表名\u003e WHERE \u003c条件\u003e; 查询指定范围数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e WHERE \u003c某列名\u003e BETWEEN \u003c某列名范围值-小\u003e AND \u003c某列名范围值-大\u003e; 字符串模式匹配查询 SELECT \u003c列名\u003e FROM \u003c表名\u003e WHERE name LIKE 'Y%';（查询以 Y 开头的，更多匹配方式自行百度哦~。） 指定多个值数据查询 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e WHERE \u003c某列名\u003e IN ('\u003c某列名值 1\u003e','\u003c某列名值 2\u003e','\u003c某列名值 3\u003e',...); 查询结果排序 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e ORDER BY \u003c某列名\u003e DESC;（此处为递减排列，默认为递增ASC） 查询指定几笔数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e LIMIT n,m;（从n到m笔数据） 分群查询 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,...,\u003c函数\u003e FROM \u003c表名\u003e GROUP BY \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,...;（常搭配函数有：SUM()、AVG()、COUNT()、MAX()、MIN()） ","date":"2020-01-16","objectID":"/posts/sql/:5:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"常用函数 函数名 用途 ABS（数值） ABS 函数（求绝对值） MOD（被除数，除数） MOD 函数（求余） ROUND（对象数值，保留小数的位数） ROUND 函数（四舍五入） 字符串 1 ΙΙ 字符串 2 ΙΙ 函数（拼接） LENGTH（字符串） LENGTH 函数（求字符串长度） LOWER（字符串） LOWER 函数（小写转换） UPPER（字符串） UPPER 函数（大写转换） REPLACE（对象字符串，替换前的字符串，替换后的字符串） REPLACE 函数（字符串的替换） SUBSTRING （对象字符串，截取的起始位置，截取的字符数） SUBSTRING 函数（字符串的截取） CURRENT_DATE CURRENT_DATE 函数（当前日期） CURRENT_TIME CURRENT_TIME 函数（当前时间） CURRENT_TIMESTAMP CURRENT_TIMESTAMP 函数（当前日期和时间） EXTRACT（日期元素 FROM 日期） EXTRACT 函数（截取日期元素） CAST（转换前的值 AS 想要转换的数据类型） CAST 函数（类型转换） COALESCE（数据 1, 数据 2, 数据 3….) COALESCE 函数（将 NULL 转换为其他值） 补充：CASE 表达式。 CASE WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e ...... ELSE \u003c表达式\u003e END ","date":"2020-01-16","objectID":"/posts/sql/:6:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"其他知识 ","date":"2020-01-16","objectID":"/posts/sql/:7:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"常见数据类型 ","date":"2020-01-16","objectID":"/posts/sql/:7:1","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"别名 给表设置别名，让 SQL 更简洁。例如： SELECT \u003ccol-1\u003e,\u003ccol-2\u003e,\u003ccol-3\u003e,... FROM \u003ctable1\u003e \u003calias-a\u003e,\u003ctable2\u003e \u003calias-b\u003e WHERE \u003calias-a\u003e.\u003cid\u003e = \u003calias-b\u003e.\u003cid\u003e; 列名也可以设置别名。例如： SELECT \u003ccol-1\u003e \u003calias-a\u003e,\u003ccol-2\u003e \u003calias-b\u003e,\u003ccol-3\u003e \u003calias-c\u003e,... FROM \u003ctable\u003e; 或者 SELECT \u003ccol-1\u003e AS \u003calias-a\u003e,\u003ccol-2\u003e AS \u003calias-b\u003e,\u003ccol-3\u003e AS \u003calias-c\u003e,... FROM \u003ctable\u003e; ","date":"2020-01-16","objectID":"/posts/sql/:7:2","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["MySQL"],"content":"总结 以上整理的内容均为基础内容，更多进阶知识还需各位自行 Google。 ","date":"2020-01-16","objectID":"/posts/sql/:8:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["Projects","JavaScript"],"content":" 信息 cos 桶相册，终于！！终于来了！！，idea 来自 [兰州小红鸡 - 给 hexo 静态博客添加动态相册功能]， 功能虽好，但是还是先友情提示！ 开放 API 是一个很危险的操作，意味着你的 cos 桶里面的所有资源包括目录结构都暴露的整个世界中，所以建议不要放一些比较私密的照片，保护自己的隐私，提防不良用心之人。下面就开始吧！ ","date":"2019-11-24","objectID":"/projects/cos-album/:0:0","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"创建腾讯云 cos 存储桶 就创建一个 COS 就好了！有几点注意事项： 权限设置为共有读私有写 policy 权限设置整个桶的读操作 跨域访问 CORS 设置，自己随意 ","date":"2019-11-24","objectID":"/projects/cos-album/:1:0","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"上传照片 首先我这个 cos 相册，相册分类就是文件夹分类，所以 cos 桶里面先新建不同的文件夹，文件夹名称就是相册名称， 每个相册里面需要放置一张名称为**“封面.jpg”**的图片作为该相册的封面。 ","date":"2019-11-24","objectID":"/projects/cos-album/:2:0","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"上传工具 COSBrowser GUI 工具，桌面/移动版 【官方、推荐】 COSCMD 命令行工具 【官方】 PicGo 图床上传工具 【第三方、推荐】 ","date":"2019-11-24","objectID":"/projects/cos-album/:2:1","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"食用方式 cos album 相册源码下载地址，别忘点赞哈 http://github.com/Lruihao/cos-album 首先，下载源码，引入 cos-album.css 和 cos-album.js 然后，在你的 js 中 new 一个 Cosalbum 对象 ( xmlLink 后不需要添加/) ","date":"2019-11-24","objectID":"/projects/cos-album/:3:0","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"Step1 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"cos-album.min.css?v=1.1.2\"\u003e \u003cscript type=\"text/javascript\" src=\"cos-album.min.js?v=1.1.2\"\u003e\u003c/script\u003e ","date":"2019-11-24","objectID":"/projects/cos-album/:3:1","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"Step2 \u003cscript type=\"text/javascript\"\u003e new Cosalbum({ 'xmlLink': 'https://img-xxxxxxxxxx.cos.ap-chengdu.myqcloud.com', 'prependTo': '.cos-album', 'viewNum': 8, 'imgUrl': '//img.lruihao.cn' }); \u003c/script\u003e ","date":"2019-11-24","objectID":"/projects/cos-album/:3:2","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"Params param type default description xmlLink String 需要解析的騰訊云 COS 桶 XML 鏈接 prependTo String ‘body’ 可選解析相冊到某個節點 viewNum Number 4 每個相冊顯示的照片數目 copyUrl String href CDN 链接，雙擊複製 URL Since: 1.1.6 imgType String [‘jpg’, ‘jpeg’, ‘png’, ‘gif’, ‘svg’] 图片類型 Since: 1.1.6 videoType String [‘mp4’, ‘mp3’, ‘avi’, ‘mov’, ‘qt’] 視頻類型 Since: 1.1.6 viewport 视个人情况添加。 hexo 中使用时 css 和 js 都需要做适当调整，配合加密功能使用等等，这里不再展开。 注：代码设定不加载根目录文件，所以可以利用静态服务把源码部署在根目录，配合 PicGo、COSBrowser 上传来搭建个人图床。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003ecos-album\u003c/title\u003e \u003c!-- \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e --\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"cos-album.css\" /\u003e \u003cscript type=\"text/javascript\" src=\"cos-album.js\" defer\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e new Cosalbum({ xmlLink: 'https://img-xxxxxxxxxx.cos.ap-chengdu.myqcloud.com', prependTo: '.cos-album', viewNum: 8, copyUrl: '//img.lruihao.cn' }); \u003c/script\u003e \u003c!-- 你的其他内容，如评论等 --\u003e \u003c/body\u003e \u003c/html\u003e cos-album demo ","date":"2019-11-24","objectID":"/projects/cos-album/:3:3","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Projects","JavaScript"],"content":"changelog 2020-9-28 22:46 升級：相冊封裝成類，可以更方便 new 出來 優化：相冊圖片樣式優化 2019-11-24 10:52:34 修改整理了一下代码，分割功能为函数，并写了注释，更加方便 伸手党! ","date":"2019-11-24","objectID":"/projects/cos-album/:4:0","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["Spec","计算机网络"],"content":" RESTful 是一种系统开发设计风格、原则。可视情况调整，以下参考来源 RFC5789 ","date":"2019-11-14","objectID":"/posts/restful/:0:0","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"Noun 一般资源 通用于一律使用复数名词 例如：/books 或 /books/123。但有部分人认为应该使用单数名词，因为： /book/123 看似比 /books/123 合理。但想想文件系统的目录命名（例如 /Users 或 /Documents)，其实用复数也没问题。复数可以保持 API endpoint 的一致性，所以一般资源建议用复数。 唯一资源：对 client 而言只有一份的资源 通用于单数名词 例如：user 是指目前验证的使用者，使用者永远只能同时登入一个使用者 ","date":"2019-11-14","objectID":"/posts/restful/:1:0","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"Http Method MethodIdempotentSafeCRUDOO生活动词用途GETYYReadgetget取得资料list列出资料POSTCreateaddcreate建立一个可以完全独立存在的实体add增加一个必须依赖于某个实体的实体PUTYUpdatesetreplace取代一个关系，已存在时先删除后建立，不存在时直接建立add附加唯一关系，两个关系实体可以互相独立存在，且已经存在PATCHedit编辑某个实体DELETEDeleteremoveremove delete删除某个实体 Safe：该操作不会改变伺服器端的资源状态（而且结果可以被 cache），属于 Safe 的操作必定属于 Idempotent Idempotent (幂等性)：该操作不管做 1 遍或做 n 遍，都会得到同样的资源状态结果（但不一定得到同样的返回值，例如第 2 次 DELETE 请求可能回传 404），因此 client 端可以放心 retry ","date":"2019-11-14","objectID":"/posts/restful/:2:0","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"GET Safe：每次执行操作时，GET 只有读取 Resource，不会改变到任何的 Resource （资源，资料） Idempotent：每次执行操作时，GET 只有读取 Resource，不会改变到任何的 Resource （资源，资料），所以任何资源的任何状态都是一样的 ","date":"2019-11-14","objectID":"/posts/restful/:2:1","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"POST 每次执行操作时，POST 都会建立一个 Resource （资源，资料） Create：建立一个可以完全独立存在的实体 范例：建立使用者 执行第一次时：建立一个 name = “李四” 的 user，但其 id = 1，执行第二次时：建立一个 name = “李四” 的 user，但其 id = 2，发送同样的请求，可每次都是不同的 Resource 建立使用者前不需要建立任何的东西，就可以建立使用者了，使用者是可以完全独立的存在 POST /users HTTP/1.1 Host: 127.0.0.1 { \"name\": \"李四\" } Add：增加一个必须依赖于某个实体的实体 资料结构：一对多的关系 范例：Add a public key on behalf of a user 增加一个代表使用者的公钥 (Gitea API) 增加这个公钥之前，使用者必须存在，公钥必须归属于某个使用者之下，公钥跟姓名一样，使用相同电脑的公钥就会相同，但不表示是同一个使用者，故公钥也会有自己的 ID 我每次增加公钥时，都将生成不同的公钥 ID POST /api/v1/admin/users/{username}/keys HTTP/1.1 Host: gitea.com { \"key\": \"string\", \"read_only\": true, \"title\": \"string\" } ","date":"2019-11-14","objectID":"/posts/restful/:2:2","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"PUT Idempotent：每次执行操作时，PUT 都会取代 Resource，不管操作几次，使用者获取得 Resource 结果都是一样的 Replace：不论资源如何，最终的资源状态都是一样的，Resource 已存在时，或许不理会、或许先删除后建立（取代）Resource 不存在时，直接建立 Add：添加唯一关系，建立这个唯一关系前，两个关连实体都必须存在。在没有建立关系前，两个关连实体都可以互相独立存在 资料结构：多对多，且两个关连实体的 PK，同时也是关系实体的 PK、FK 范例：增加使用者与角色的关系 增加使用者跟角色的关系前，使用者跟角色都必须存在；增加使用者跟角色的关系前，使用者跟角色可以独立存在， 使用者 12262 跟 角色 2 的关系最多只能有一条关系（ 使用者 12262 有 角色 2)，最少没有关系（使用者 12262 没有 角色 2 ) ，执行第二次操作时，使用者 12262 跟 角色 2 的从属关系仍然存在，也不会跑出第二条 使用者 12262 跟 角色 2 的从属关系 PUT user/{account}/roles HTTP/1.1 Host: 127.0.0.1 { \"role_id\": \"2\" } 范例：Follow a user 关注一个使用者 (Gitea API) 增加关注关系时，关注者与被关注者（都是使用者） 都必须存在；关注者 12262 跟被关注者 12231 的关系最多只能有一条关系（12262 关注 12231），最少没有关系（12262 不关注 12231），执行第二次操作时，关注者 12262 跟被关注者 12231 的关注关系仍然存在，也不会跑出第二条关注者 12262 跟被关注者 12231 的关注关系 PUT /api/v1/user/following/{username} HTTP/1.1 Host: gitea.com ","date":"2019-11-14","objectID":"/posts/restful/:2:3","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"PATCH Edit：编辑可独立存在、且已经存在的实体，也就是产生新版本的实体，可能会影响其他 Resource 范例：编辑使用者 编辑使用者，使用者已经存在，且我们可能有纪录编辑时间、编辑人、编辑 IP，所以每次的编辑都会造成不一样的结果 第一次编辑使用者，更新时间变为 08:00，编辑人 12262，IP 172.18.0.66 第二次编辑使用者，更新时间变为 09:00，编辑人 12263，IP 172.18.0.67 PATCH /users/{account} HTTP/1.1 Host: 127.0.0.1 { \"username\": \"李四\", \"age\": \"18\", \"gender\": \"male\" } ","date":"2019-11-14","objectID":"/posts/restful/:2:4","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"DELETE Idempotent：每次执行操作时，DELETE 都会删除相同的东西 范例：删除使用者 第一次删除使用者 12262，删除使用者 12262, 第二次删除使用者 12262，还是删除使用者 12262，只不过使用者 12262 不存在了 DELETE /users/{account} HTTP/1.1 Host: 127.0.0.1 ","date":"2019-11-14","objectID":"/posts/restful/:2:5","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"HTTP Status Code HTTP 状态码（HTTP Status Code）是用以表示网页服务器 HTTP 响应状态的 3 位数字代码。所有状态码的第一个数字代表了响应的五种状态之一。除非另有说明，状态码是 HTTP/1.1 标准（RFC 7231）的一部分。 而关于 RESTful API 的请求状态，通常有以下两种设计方案： 方案一：使用 HTTP 状态码来表示请求状态，200 时返回的内容就是数据 方案二：所有接口都返回 200 ，在响应内容里约定错误码或错误信息 在实际应用中，应据具体情景及需要进行选择与调整。 方案优劣比较方案一优点对服务端来说较为简单方便缺点客户端难以根据状态码处理复杂问题方案二优点方便对返回资料进行统一处理和细微性的控制缺点相当于放弃了 HTTP 状态码的语义 ","date":"2019-11-14","objectID":"/posts/restful/:3:0","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Spec","计算机网络"],"content":"常用 HTTP 状态码 Code Message 用途 1XX Informational response 此类状态码通常代表的响应都是信息性的，告诉客户端可以进行下一步操作。 100 Continue 表示服务端已接收到请求头，客户端可以继续发送请求体（如 POST 请求）。 101 Switching Protocols 表示服务端支持更优协议，让客户端在服务端更换协议后重新访问。 2XX Successful 此类状态码通常代表请求已成功被服务端接收、理解并接受。 200 OK 表示请求成功。 201 Created 表示请求已被实现，通常是在成功创建了某个资源。 202 Accepted 表示请求已被服务端接收，但尚未进行处理。 204 No Content 表示请求成功，但不会返回任何内容。 205 Reset Content 表示请求成功，但不会返回任何内容，并且要求客户端重置表单。 3XX Redirect 此类状态码通常代表本次请求需要客户端采取进一步操作才能完成。通常用于重定向。 300 Multiple Choices 表示请求的资源有多个供可选择，客户端可自行选择一个进行请求的重定向。 301 Moved Permanently 表示请求的资源已经永久地移动到了新位置，并且将在 Location 域中携带该资源新的 URI。 304 Not Modified 表示请求的资源无发生修改，将不会返回任何资源。 4XX Client Error 此类状态码通常代表客户端可能出现了错误。 400 Bad Request 表示客户端发出的请求有误（格式、大小、无效的…)，服务端不能/ 不会处理该请求。 401 Unauthorized 表示客户端未能提供必要的验证，服务端拒绝提供资源。 403 Forbidden 表示服务端理解了该请求，但客户端没有足够权限以访问，遂拒绝提供该资源。 404 Not Found 表示服务端无法找到请求的资源，其可能已经暂时（永久）失效。 408 Request Timeout 表示请求超时。 409 Conflict 表示请求的资源发送了冲突，通常是 PUT 请求。 410 Gone 表示请求的资源已经永久失效，客户端不应再次请求。 411 Length Required 表示服务端拒绝在没有定义 Content-Length 头的情况下接收该请求。 5XX Server Error 此类状态码通常代表由于服务端的原因，导致无法完成请求。 500 Internal Server Error 表示由于服务端遇到意料之外的变故，导致无法完成请求。 501 Not Implemented 表示服务端不支持完成请求所需的功能，导致无法完成请求。 502 Bad Gateway 表示作为网关或代理的服务段在执行请求时，从上游服务器获得了无效的响应。 503 Service Unavailable 表示由于某些原因（服务器超载或系统维护等），导致暂时无法完成请求。 504 Gatewy Timeout 表示作为网关或代理的服务段在执行请求时，未能及时从上游服务器获得响应。 505 HTTP Version Not Supported 表示服务端不支持请求的 HTTP 协议版本，导致无法完成请求。 以上内容参考自https://zh.wikipedia.org/zh-cn/HTTP状态码， 需要查看完整 HTTP 状态码请点击 https://www.rfc-editor.org/rfc/rfc9110.html#name-status-codes ","date":"2019-11-14","objectID":"/posts/restful/:3:1","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["PHP"],"content":" php 主动推送站点链接到百度站长，神马站长进行 SEO。 ","date":"2019-09-28","objectID":"/posts/phppushurl/:0:0","tags":["PHP"],"title":"php 同时主动推送链接到百度，神马等站长平台","uri":"/posts/phppushurl/"},{"categories":["PHP"],"content":"代码 把需要提交的链接和各站长 api 分别放在两个 txt 文件里面，然后运行 php 文件进行提交，不同站长提交成功一般返回的都是 200 状态码。 \u003c?php //链接存放路径和站长 api 文件存放路径 $urls_path = \"H:\\\\lruihao.cn\\\\public\\\\baidu_urls.txt\"; $apis_path = \"G:\\\\Demo\\\\lrh01\\\\zhanzhang_api.txt\"; //将文件每一行读到一个数组里面去 $urls = file($urls_path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); $apis = file($apis_path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); for($x=0;$x\u003ccount($apis);$x++){ $ch = curl_init(); $options = array( CURLOPT_URL =\u003e $apis[$x], CURLOPT_POST =\u003e true, CURLOPT_RETURNTRANSFER =\u003e true, CURLOPT_POSTFIELDS =\u003e implode(\"\\n\", $urls), CURLOPT_HTTPHEADER =\u003e array('Content-Type: text/plain'), ); curl_setopt_array($ch, $options); $result = curl_exec($ch); echo \"API: \u003cbr/\u003e\u0026emsp;\".$apis[$x].\"\u003cbr/\u003e\"; echo \"result: \u003cbr/\u003e\u0026emsp;\".$result.\"\u003chr/\u003e\"; } ?\u003e ","date":"2019-09-28","objectID":"/posts/phppushurl/:1:0","tags":["PHP"],"title":"php 同时主动推送链接到百度，神马等站长平台","uri":"/posts/phppushurl/"},{"categories":["PHP"],"content":"提交结果 ","date":"2019-09-28","objectID":"/posts/phppushurl/:2:0","tags":["PHP"],"title":"php 同时主动推送链接到百度，神马等站长平台","uri":"/posts/phppushurl/"},{"categories":["PHP"],"content":"普通方法 首先采用fopen()函数打开文件，得到返回值的就是资源类型。接着采用 while 循环一行行地读取文件，然后输出每行的文字。feof()判断是否到最后一行，fgets()读取一行文本。 \u003c?php //首先采用“fopen”函数打开文件，得到返回值的就是资源类型。 $file_handle = fopen(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\备忘录。txt\",\"r\"); if ($file_handle){ //接着采用 while 循环一行行地读取文件，然后输出每行的文字 while (!feof($file_handle)) { //判断是否到最后一行 $line = fgets($file_handle); //读取一行文本 echo $line; //输出一行文本 echo \"\u003cbr /\u003e\"; //换行 } } fclose($file_handle);//关闭文件 ?\u003e readfile（）函数，返回一整个 String echo readfile(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\备忘录。txt\"); ","date":"2019-09-28","objectID":"/posts/phpfile/:1:0","tags":["PHP"],"title":"php 按行读取文件信息","uri":"/posts/phpfile/"},{"categories":["PHP"],"content":"快速方法 file()函数把整个文件读入一个数组中。 数组中的每个元素都是文件中相应的一行，包括换行符在内。 语法 file(path,include_path,context) 参数 描述 path 必需。规定要读取的文件。 include_path 可选参数include_path 可以是以下一个或多个常量：**FILE_USE_INCLUDE_PATH在 include_path 中查找文件。FILE_IGNORE_NEW_LINES在数组每个元素的末尾不要添加换行符FILE_SKIP_EMPTY_LINES**跳过空行 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。 \u003c?php $filepath=\"H:\\\\lruihao.cn\\\\public\\\\baidu_urls.txt\"; echo \"\u003chr/\u003e\"; //将文件每一行读到一个数组里面去 $texts = file($filepath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); var_dump($texts); ?\u003e ","date":"2019-09-28","objectID":"/posts/phpfile/:2:0","tags":["PHP"],"title":"php 按行读取文件信息","uri":"/posts/phpfile/"},{"categories":["PHP"],"content":"结果 ","date":"2019-09-28","objectID":"/posts/phpfile/:3:0","tags":["PHP"],"title":"php 按行读取文件信息","uri":"/posts/phpfile/"},{"categories":["JavaScript"],"content":" 使用javascript计算博客等网站的运行时间。 话不多说，直接贴码！ function createTime() { var now = new Date(); var run = new Date('05/28/2018 20:01:01'); //總的秒數 var runTime = (now - run) / 1000, days = Math.floor(runTime / 60 / 60 / 24), hours = Math.floor(runTime / 60 / 60 - 24 * days), minutes = Math.floor(runTime / 60 - 24 * 60 * days - 60 * hours), seconds = Math.floor((now - run) / 1000 - 24 * 60 * 60 * days - 60 * 60 * hours - 60 * minutes); //前置零 if (String(hours).length === 1) { hours = '0' + hours; } if (String(minutes).length === 1) { minutes = '0' + minutes; } if (String(seconds).length === 1) { seconds = '0' + seconds; } /*document.querySelector(\".run-times\").innerHTML = days + \"\u0026thinsp; 天\u0026thinsp;\" + hours + \"\u0026thinsp; 时\u0026thinsp;\" + minutes + \"\u0026thinsp; 分\u0026thinsp;\" + seconds + \"\u0026thinsp; 秒\"; */ document.querySelector('.run-times').innerHTML = 'RunTime: ' + days + ',' + hours + ':' + minutes + ':' + seconds + ''; } //setInterval(\"createTime()\", 500); if (!document.hidden) { var siteTime = setInterval('createTime()', 500); } else { clearInterval(siteTime); } /** * HTML 写法 \u003cspan class=\"run-times\" title=\"网站运行时间\"\u003e载入时分秒 ...\u003c/span\u003e \u003cp class=\"run-times\" title=\"主頁运行时间\"\u003eRunTime Loading...\u003c/p\u003e */ ","date":"2019-09-19","objectID":"/posts/site-time/:0:0","tags":["JavaScript"],"title":"设置网站运行时间","uri":"/posts/site-time/"},{"categories":["JavaScript"],"content":" 注意 JS 的加载分为两个部分：下载和执行。 浏览器在执行 HTML 的时候如果遇到\u003cscript\u003e时会停止页面的渲染，去下载和执行 js 的文件直接遇见\u003c/scirpt\u003e会继续渲染页面。故浏览器在执行 js 文件的时候浏览器表现为一片空白，为了解决这个问题 ECMAScript 定义了 defer 和 async 两个属性用于控制 JS 的下载和执行。 ","date":"2019-09-08","objectID":"/posts/async-defer/:0:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"不带任何属性 同步模式，又称阻塞模式，我们平时使用的最多的一种方式。当浏览器解析到\u003cscript\u003e标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，是个同步阻塞的过程。 一般建议把\u003cscript\u003e标签放在\u003cbody\u003e结尾处，这样尽可能减少页面阻塞。 而如果想要异步执行 script，则可以给其加上 async 或 defer 属性。 \u003cscript\u003e ","date":"2019-09-08","objectID":"/posts/async-defer/:1:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"defer defer 属性在 HTML 解析期间异步下载文件，并且只在 HTML 解析完成后才执行它。对于 defer，我们可以理解是将外链的 js 放在了页面底部。js 的加载不会阻塞页面的渲染和资源的加载。不过 defer 会按照原本的 js 的顺序执行，所以如果前后有依赖关系的 js 可以放心使用。 \u003cscript defer\u003e ","date":"2019-09-08","objectID":"/posts/async-defer/:2:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"async async 属性会在 HTML 解析期间异步下载文件，并在完成下载后立即暂停 HTML 解析器去执行 script 中的代码。在执行过程中浏览器处于阻塞状态，响应不了任何需求。如果 js 前后有依赖性，用 async，就很有可能出错。 \u003cscript async\u003e ","date":"2019-09-08","objectID":"/posts/async-defer/:3:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"区别 ","date":"2019-09-08","objectID":"/posts/async-defer/:4:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"相同点 加载文件时不阻塞页面渲染 对于 inline 的 script 无效（只适用有src的外部 js） 使用这两个属性的脚本中不能调用 document.write 方法 有脚本的 onload 的事件回调 ","date":"2019-09-08","objectID":"/posts/async-defer/:4:1","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"区别点 html4.0 中定义了 defer；html5.0 中定义了 async 浏览器支持不同 每一个 async 属性的脚本都在它下载结束之后立刻执行，同时会在 window 的 load 事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个 defer 属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在 document 的 DOMContentLoaded 之前执行。 ","date":"2019-09-08","objectID":"/posts/async-defer/:4:2","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"那么这三种方式各在什么情况下使用呢？ 通常来说，尽可能使用async，然后是defer，最后不使用属性。 并遵循以下规则： 如果脚本是模块化的，并且不依赖于任何脚本，则使用async。 如果脚本依赖于或依赖于另一个脚本，则使用defer。 如果脚本很小并且有async脚本依赖该脚本，则不加属性。 ","date":"2019-09-08","objectID":"/posts/async-defer/:5:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"兼容性 Internet Explorer 10、Firefox、Opera、Chrome 和 Safari 支持 async 属性。 所有主流浏览器都支持 defer 属性。 ","date":"2019-09-08","objectID":"/posts/async-defer/:6:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"参考 https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html https://www.jianshu.com/p/17dc82bf08f1 ","date":"2019-09-08","objectID":"/posts/async-defer/:7:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["Memo"],"content":"Sublime Text3 快捷键一览表 ","date":"2019-08-15","objectID":"/posts/sublime-text3/:0:0","tags":["Sublime","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Memo"],"content":"tab 转 space 打开 Settings, 加入几行配置 { \"color_scheme\": \"Packages/Color Scheme - Default/Monokai.sublime-color-scheme\", \"font_size\": 14, \"ignored_packages\": [ \"Vintage\" ], \"theme\": \"Adaptive.sublime-theme\", + \"expand_tabs_on_save\": true, + \"tab_size\": 2, + \"translate_tabs_to_spaces\": true } ","date":"2019-08-15","objectID":"/posts/sublime-text3/:1:0","tags":["Sublime","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Memo"],"content":"选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 ","date":"2019-08-15","objectID":"/posts/sublime-text3/:2:0","tags":["Sublime","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Memo"],"content":"编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的 CSS 属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 ","date":"2019-08-15","objectID":"/posts/sublime-text3/:3:0","tags":["Sublime","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Memo"],"content":"搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是 sublime 允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用 sublime text 或插件的功能，例如使用 package 安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 ","date":"2019-08-15","objectID":"/posts/sublime-text3/:4:0","tags":["Sublime","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Memo"],"content":"显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认 1 屏（非小键盘的数字） Alt+Shift+2 左右分屏-2 列 Alt+Shift+3 左右分屏-3 列 Alt+Shift+4 左右分屏-4 列 Alt+Shift+5 等分 4 屏 Alt+Shift+8 垂直分屏-2 屏 Alt+Shift+9 垂直分屏-3 屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 ","date":"2019-08-15","objectID":"/posts/sublime-text3/:5:0","tags":["Sublime","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Memo"],"content":"安裝 官方下載點 ","date":"2019-08-15","objectID":"/posts/netbeans/:1:0","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"擴充功能 ","date":"2019-08-15","objectID":"/posts/netbeans/:2:0","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"安裝擴充功能 下載擴充套件包 官方套件庫 或者在 NetBeans IDE 裏面下載插件（方便） 開啟 NetBeans→Tools→Plugins→Downloaded→Add Plugins 選擇要安裝的擴充套件包 ","date":"2019-08-15","objectID":"/posts/netbeans/:2:1","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"啟用已安裝的擴充功能 開啟 NetBeans→Tools→Plugins→Installed 選擇要啟用的套件 (*.npm) 點擊 Activate ","date":"2019-08-15","objectID":"/posts/netbeans/:2:2","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"匯入設定 開啟 NetBeans→Tools→Options 點擊 Import 匯入設定 選擇要匯入的套件包 (*.zip) ","date":"2019-08-15","objectID":"/posts/netbeans/:2:3","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"常用設定 ","date":"2019-08-15","objectID":"/posts/netbeans/:3:0","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"程式碼排版 在程式開發中，程式碼排版很重要。一個好的排版利於開發人員程式閱讀，也便於後期維護人員閱讀。 在 NetBeans 中設置程式碼排版 打開 NetBeans-\u003eTools-\u003eOptions-\u003eEditor-\u003eFormatting； Language 選擇 All Languages，勾選\"Expand Tabs to Spaces\", 用兩個空格鍵代替 Tab 鍵，首行留兩個 Tab 鍵。 點擊 Apply 或 Ok 完成設置。具體設置及效果如下圖所示： ","date":"2019-08-15","objectID":"/posts/netbeans/:3:1","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"程式碼樣板 程式碼樣板可以幫助你快速書寫程序，不必繁瑣地聲明函數或其他代碼塊，更專注與邏輯的書寫。 在 NetBeans 中設置程式碼樣板 打開 NetBeans→Tools→Options→Editor→Code Templates； 選擇你所用的語言（這裡以 JavaScript 為例）； 點擊\"New\"新建屬於你的或修改原有的程式碼樣板（例子僅為演示）； 在編程中應用它。 ","date":"2019-08-15","objectID":"/posts/netbeans/:3:2","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"前端壓縮 下載擴充套件netbeans minify 或者 minifierBeans 開啟 NetBeans→Tools→Plugins→Downloaded→Add Plugins 選擇你下載的擴充套件開啟 開啟 NetBeans→Tools→options ","date":"2019-08-15","objectID":"/posts/netbeans/:3:3","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"快捷鍵 键位 作用 Ctrl+/ 注释一行（或选中部分） Ctrl+X 剪切一行（或选中部分） Ctrl+E 删除一行（或选中部分） Shift+Alt+上下方向键 移动当前行 Ctrl+Shift+上下方向键 复制当前行（该操作并非复制到粘贴板） Shift+Alt+F 整理代码 TAB 代碼自動補全/缩进/選中文字同時缩进 Shift+TAB 選中文字同時取消缩进 Ctrl+F 查找某个字 Ctrl+Shift+F 整个项目中查找某个字 Ctrl+H 替换某个字 Ctrl+Enter 增加空白行，光标不动。 Ctrl+(0~7) 打开各种小窗口 Shift+方向键 選中文字 Ctrl+Alt+Space 代码输入提示，不习惯的可以设置为 (Alt+/)，超级好用！！！ Ctrl+Shift+F5 调试当前程序 Shift+F6 运行当前程序 F6 运行主程序 Alt+Enter 显示程式 bug 建议或者警示等 NetBeans 中常用的快捷鍵 ↑： 三種複製行方法 复制一行：Ctrl + Shift + 上下方向键（该操作并非复制到粘贴板）； 复制一行：在该行任何地方连续三击选中一样，然后 Ctrl + C 即可复制一行。； 复制一行（使用宏）: 编辑-开始录制宏 (Home,Shift + End,Ctrl + C)-停止录制宏-设置宏名称（如 select-entire-line)-设置快捷键（如 Ctrl + Alt + C)； 也可自己修改快捷鍵 (Tools→Options→Keympa), 如下圖 {% asset_img quickkey.png quickkey %} ","date":"2019-08-15","objectID":"/posts/netbeans/:3:4","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"遠程開發 (FTP) 工作为例 新建项目 打开软件，进入新建项目页面（File-New Project），新建 php 项目，选择第一个（PHP-PHP Application） 项目名和地址自己选择（注意，选择地址后需在地址最后面加上\"/项目名\"） FTP 设置 点击下一步，进入 FTP 设置，Run As 选择 Remote Web Site(FTP,SFTP) Project URL 填写http://127.0.0.1/training/工号 Manage 设置 点击 Manage, 进入页面。名字自取。Host Name 填写：127.0.0.1 Encryption 选择 Pure FTP,User Name 和 Password（填写工号/课务系统登录密码） Initial Directory 填写_training 点击 Test Connection 测试是否连接成功 其他设置 Upload Directory, 上传目录不填，直接上传至个人根目录 Upload File 改为保存时上传文件（On Save） ","date":"2019-08-15","objectID":"/posts/netbeans/:3:5","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Memo"],"content":"Chrome with NetNeans Connector 打開 chrome 中的應用程式商店（使用 chrome 瀏覽器點擊下方鏈接即可） chrome 應用程式商店 在搜索框中輸入 NetNeans Connector 后搜索，然後點擊右邊的加到 Chrome 即可，安裝成功后右上角會顯示 NetBeans 圖標。 開啟 netbeans 選擇 Run→Set Project Browser→ 選中 Chrome with NetBeans Connector 選擇 default 下的 Customize → 選擇 Browser → 選擇 Browser 下 Chrome with NetBeans Connector 即可 ","date":"2019-08-15","objectID":"/posts/netbeans/:3:6","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Spec"],"content":"精神 绝不写死代码，硬编码 不留不要用的、垃圾代码 ","date":"2019-08-15","objectID":"/posts/dev-rules/:1:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"Git Master 的 BUG 必须最少且趋近于零，为最稳定的版本 每次 Commit 信息应该准确填写。不可模棱两可，eg: 修复 BUG、增加功能 禁止 Commit IDE 的 project data，e.g: .vscode 禁止上传垃圾代码 更多规则详见文档 Commit 规范 ","date":"2019-08-15","objectID":"/posts/dev-rules/:2:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"分支（Branch） 命名规则：应以此分支主要目的命名（修复什么 BUG，新增特定功能） 合并后的分支应该删除 ","date":"2019-08-15","objectID":"/posts/dev-rules/:2:1","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"commit 遵循一个功能一个 commit 的原则 ","date":"2019-08-15","objectID":"/posts/dev-rules/:2:2","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"Restful 资源名词站在 API 的角度思考 复数名词：可以复数笔数据，回传结果为 Array 举例：GET/users 取得多笔使用者资料 刪除，放在复数名词內，让 Router 保持一致性 增加，放在复数名詞內，让 Router 保持一致性 单数名词：仅取得单笔数据，必须指定 PK，两两一组，回传结果为 Object 举例：GET/user/{accont} 取得单笔使用者资料，必须指定 PK URL 中一律不带 id 参数 正确范例： calendar_manager/calendar/29 错误范例： calendar_manager/calendar/29?id=29 更多规则详见文档 RESTful ","date":"2019-08-15","objectID":"/posts/dev-rules/:3:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"命名 命名应根据内容做有意义的命名，让后续维护人员可以顾名思义！ 即使不会发生错误，代码英文大小写也需明确区分。 ","date":"2019-08-15","objectID":"/posts/dev-rules/:4:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"语意 类型 命名规则 说明 属性 (Attribute, Property) 名词 user_name、userName 方法 (Method, Function) 动词 + 名词 getUserName、get_user_name 常見的动词有：get、set、update、delete、remove ","date":"2019-08-15","objectID":"/posts/dev-rules/:4:1","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"字母与分隔 语言 变量 (Variable, Parameter, Argument) 常量 (Constant) 面向对象 - 类名 (Class Name) 面向对象 - 成员 (mebmer) HTML 全部小写，不同单词以「-」分隔 e.g: user-id CSS、SCSS 全部小写，不同单词以「-」分隔，CSS 变量以「–」开头，SCSS 变量以「$」开头 e.g: .user-id、–header-height、$header-height JavaScript 驼峰式命名法 首字小写，不同单字「首字以大写」分隔 e.g: userId 全部大写，不同单字以「_」分隔 MAX_COUNT 驼峰式命名法 首字大写，不同单字「首字以大写」分隔 一个文件放一个 Class, 文件名即为 Class Name e.g: User 驼峰式命名法 公有 (public) : 首字小写，不同单词「首字以大写」分隔 e.g: name, getName 私有 (private): _公有命名规则 e.g: _name,_getName Vue Java PHP 全部小写，不同单词以「_」分隔 e.g: user_id Python SQL 由使用者定义的：表名、字段名 全部小写，不同单词以「_」分隔 SQL 语法、函数全部大写 e.g: SELECT、INSERT INTO ","date":"2019-08-15","objectID":"/posts/dev-rules/:4:2","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"通用 代码编写 每个函数应该使用块注释，注释应包含函数功能说明、参数说明。规则见：JSDoc、JavaDoc 不必要的代码不要写，也应禁止放到注释里面！ if-else 的 {} 严禁省略 代码规范、代码排版等可通过 eslint 等工具做统一处理 ","date":"2019-08-15","objectID":"/posts/dev-rules/:5:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"正确写法 public function test () { // do something if (a === b) { // do something } } ","date":"2019-08-15","objectID":"/posts/dev-rules/:5:1","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"错误写法 public function test () { // do something if (a === b) { // do something } } 代码排版 任何代码应该以 2 个 space 为一个缩进做好排版、不可使用 tab 函数 (Function, Methd) 函数声明时需在函数上方加上函数注释，注释应包含函数说明、参数内容（参数类型、参数英文名称、参数说明）、返回值内容（返回值类型、返回值说明） 类 (Class) 一个类（Class）的声明只能存在一个文件 类（Class）的声明文件，文件名必须为类名 其他 连接本地任何其他资源（图片、文件、网站）皆使用相对路径，禁止使用绝对路径，非本地资源除外 ","date":"2019-08-15","objectID":"/posts/dev-rules/:6:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"HTML ","date":"2019-08-15","objectID":"/posts/dev-rules/:7:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"代码编写 禁止在 HTML 使用 \u003cstyle\u003e、\u003cscript\u003e，一律使用外部档案引用方式引用 CSS、JavaScript 文件 HTML 标签需成双成对，有头有尾 块级标签：\u003ctag\u003e\u003c/tag\u003e 单标签：\u003ctag /\u003e 禁止使用已被 HTML 舍弃的旧标签、属性，如： \u003c!-- html tag --\u003e \u003ccenter\u003e \u003cfont\u003e \u003cbasefont\u003e \u003cs\u003e \u003cstrike\u003e \u003cu\u003e \u003clisting\u003e \u003cplaintext\u003e \u003cxmp\u003e \u003c!-- html attribute --\u003e align bgcolor color ","date":"2019-08-15","objectID":"/posts/dev-rules/:7:1","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"CSS CSS 的定义应该独立一个 CSS 文件，禁止使用 \u003cstyle\u003e 或 style 属性直接在 HTML 中定义样式。 ","date":"2019-08-15","objectID":"/posts/dev-rules/:8:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"JavaScript 禁止使用 HTML 字串，一律使用 Dom 产生 HTML, e.g: document.createDocumentFragment() ","date":"2019-08-15","objectID":"/posts/dev-rules/:9:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"注释 JavaScript 注释应该遵循 JSDoc 的标准撰写 全局变量 (Global) /* global ZT */ 常量 (Constant) /** * 常量說明 * @type {常量类型} */ Example /** * 请求地址 * @type {String} */ const REQUEST_URL = 'http://localhost:8080'; 函數、方法 (Function, Method) /** * 函数用途说明 * @param {参数类型} 参数名称参数说明 * @param {参数类型} [选择性参数名称] 参数说明 * @param {参数类型} [选择性参数名称=参数预设值] 参数说明 * @returns {返回值类型} 返回值说明 */ Example /** * 取得使用者 * @param {Int} userId 使用者 ID * @param {Object} [options] 其他选项 * @param {String} [options.query='a'] 查询关键词 默认为 'a' * @returns {Object} 使用者资料 */ function getUser(userId, options) { // do something return user; } ","date":"2019-08-15","objectID":"/posts/dev-rules/:9:1","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"Vue 待补充 ","date":"2019-08-15","objectID":"/posts/dev-rules/:10:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"Java Java 注释应该遵循 JavaDoc 的标准撰写 待补充 ","date":"2019-08-15","objectID":"/posts/dev-rules/:11:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"PHP ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"前端参数取得 参数取得需通过 filter_input 函数取得，不得使用 _GET 、_POST ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:1","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"输出到前台 参数命名必须为：全部小写，不同单字以「_」分隔 ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:2","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"注解 PHP 注解应该遵循 PHPDoc 的标准撰写 ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:3","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"成员变量 (Member) 成员变量只的是 Class 内的成员变数，我们都会要求替成员变量增加注解说明。通常 Function 的变量除非太特别否则都不需要特别注解说明。 /** * 成员变量說明 * @type {类型} */ Example /** * 使用者 ID * @type {String} */ $userId = 'Hello'; ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:4","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"函数、方法 (Function, Method) /** * 函数用途说明 * @param 参数型态 参数名称 参数说明 * @option 参数选项类型 参数选项名称 参数选项说明 * @uses 全局变量 全域变数说明 * @returns 返回值类型 返回值说明 */ Example /** * 取得使用者 * @param int userId 使用者 ID * @param object options 其他选项 * @option string options['query'] 查询关键字 * @uses $_POST['role_id'] 从前端以 POST 取得角色 ID * @returns object 使用者资料 */ function getUser ($userId, $options) { // do something return $user; }; ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:5","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"Python 待补充 ","date":"2019-08-15","objectID":"/posts/dev-rules/:13:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"Database 禁止使用 Table Join。 禁止使用 Oracle Trigger。 禁止将查询数据库的 SQL 放在循环中查询 ","date":"2019-08-15","objectID":"/posts/dev-rules/:14:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"SQL 撰写 属于 SQL 语法使用大写（SELECT，WHERE，INSERT etc..） 属于使用者自己定义的使用小写（表名 table name，字段名 column name etc..） 表名、字段名前后需加上 ` Example INSERT INTO `user` VALUES('a', 'b'); ","date":"2019-08-15","objectID":"/posts/dev-rules/:14:1","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Spec"],"content":"统一用词 系统中常用词，例如弹出框按钮、搜索框等，仅为举例，不限与此。 用词 统一 最后、最终 最后 关闭、Cancel、取消 取消 存储、保存、修改、OK、确定 确定 搜寻、查询、查找、搜索 搜索 ","date":"2019-08-15","objectID":"/posts/dev-rules/:15:0","tags":["Git","REST","HTML","CSS","Scss","JavaScript","Vue","Java","PHP","Python"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["PHP"],"content":" 简单模仿了一个评论模板，当然肯定是没有博客的 valine 这么强大的 hhhh， PHP 表单安全性的重要提示 $_SERVER[\"PHP_SELF\"]变量能够被黑客利用！ 如果页面中使用了PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）。 比如说注入 js 脚本等，valine 以前的版本也有过这样的漏洞。 跨站点脚本（Cross-site scripting，XSS）是一种计算机安全漏洞类型，常见于 Web 应用程序。XSS 能够使攻击者向其他用户浏览的网页中输入客户端脚本。 可以像 valine 一样在用户输入完后保留输入，还有一些正则控制输入提示等简单功能。UI 就丑爆了算了。 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cstyle\u003e .error {color: #FF0000;} .main{ width: 20%; height: 100%; border: 1px #000 solid; padding: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c?php // 定义变量并设置为空值 $nameErr = $emailErr = $genderErr = $websiteErr = \"\"; $name = $email = $gender = $comment = $website = \"\"; if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { if (empty($_POST[\"name\"])) { $nameErr = \"Name is required\"; } else { $name = test_input($_POST[\"name\"]); // 检查名字是否包含字母和空格 if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) { $nameErr = \"Only letters and white space allowed\"; } } if (empty($_POST[\"email\"])) { $emailErr = \"Email is required\"; } else { $email = test_input($_POST[\"email\"]); // 检查电邮地址语法是否有效 if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) { $emailErr = \"Invalid email format\"; } } if (empty($_POST[\"website\"])) { $website = \"\"; } else { $website = test_input($_POST[\"website\"]); // 检查 URL 地址语言是否有效（此正则表达式同样允许 URL 中的下划线） if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+\u0026@#\\/%?=~_|!:,.;]*[-a-z0-9+\u0026@#\\/% =~_|]/i\",$website)) { $websiteErr = \"Invalid URL\"; } } if (empty($_POST[\"comment\"])) { $comment = \"\"; } else { $comment = test_input($_POST[\"comment\"]); } if (empty($_POST[\"gender\"])) { $genderErr = \"Gender is required\"; } else { $gender = test_input($_POST[\"gender\"]); } } function test_input($data) { $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data; } ?\u003e \u003cdiv class=\"main\"\u003e \u003ch2\u003ePHP 验证实例\u003c/h2\u003e \u003cform method=\"post\" action=\"\u003c?php echo htmlspecialchars($_SERVER['PHP_SELF']);?\u003e\"\u003e 姓名：\u003cinput type=\"text\" name=\"name\" value=\"\u003c?php echo $name;?\u003e\"\u003e \u003cspan class=\"error\"\u003e* \u003c?php echo $nameErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 性别： \u003cinput type=\"radio\" name=\"gender\" \u003c?php if (isset($gender) \u0026\u0026 $gender==\"女性\") echo \"checked\";?\u003e value=\"女性\"\u003e女性 \u003cinput type=\"radio\" name=\"gender\" \u003c?php if (isset($gender) \u0026\u0026 $gender==\"男性\") echo \"checked\";?\u003e value=\"男性\"\u003e男性 \u003cspan class=\"error\"\u003e* \u003c?php echo $genderErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 电邮：\u003cinput type=\"text\" name=\"email\" value=\"\u003c?php echo $email;?\u003e\"\u003e \u003cspan class=\"error\"\u003e* \u003c?php echo $emailErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 网址：\u003cinput type=\"text\" name=\"website\" value=\"\u003c?php echo $website;?\u003e\"\u003e \u003cspan class=\"error\"\u003e\u003c?php echo $websiteErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 评论：\u003ctextarea name=\"comment\" rows=\"5\" cols=\"40\"\u003e\u003c?php echo $comment;?\u003e\u003c/textarea\u003e \u003cbr\u003e\u003cbr\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"提交\"\u003e \u003ch2\u003e你的输入是：\u003c/h2\u003e \u003c?php echo $name.\"\u003cbr/\u003e\"; echo $gender.\"\u003cbr/\u003e\"; echo $email.\"\u003cbr/\u003e\"; echo $website.\"\u003cbr/\u003e\"; echo $comment.\"\u003cbr/\u003e\"; ?\u003e \u003cbr/\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-07-19","objectID":"/posts/phpform/:0:0","tags":["PHP"],"title":"简单评论模块--php 表单练习","uri":"/posts/phpform/"},{"categories":["PHP"],"content":" 练习 php 函数的基本使用。 注： 必选参数在可选参数的前面。 可在函数中定义函数，需要先调用外层函数才能调用内层函数。 \u003c?php /* 创建表格 */ function createTable($rows,$cols,$bgcolor='pink',$content='x'){ $table = \"\u003ctable border='1' bgcolor='{$bgcolor}' cellpadding='10' cellspacing='0' width='50%' \u003e\"; for($i=1;$i\u003c=$rows;$i++){ $table.=\"\u003ctr\u003e\"; for($j=1;$j\u003c=$cols;$j++){ $table.=\"\u003ctd\u003e{$content}\u003c/td\u003e\"; } $table .=\"\u003c/tr\u003e\"; } $table.=\"\u003c/table\u003e\"; return $table; } echo createTable(5,5,'pink','hello lruihao'); ?\u003e ","date":"2019-07-15","objectID":"/posts/phpfunc/:0:0","tags":["PHP"],"title":"php 函数学习","uri":"/posts/phpfunc/"},{"categories":["Memo"],"content":" 使用 WAMPServer 时自定义网站根目录。 ","date":"2019-07-12","objectID":"/posts/wamproot/:0:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Memo"],"content":"WAMPServer 自定义网站根目录 ","date":"2019-07-12","objectID":"/posts/wamproot/:1:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Memo"],"content":"修改 apache 配置文件 打开httpd.conf文件搜索documentroot后，找到路径修改为自定义的。 再打开httpd-vhost.conf文件修改对应的路径。 修改完配置文件需要重启所有服务！ ","date":"2019-07-12","objectID":"/posts/wamproot/:1:1","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Memo"],"content":"修改 wampmanager 文件 在 wampserver 安装路径根目录知道wampmanager.ini和wampmanager.tpl两个文件。搜索menu.left, 然后也修改为自定义的路径。 然后退出，重启软件！ ","date":"2019-07-12","objectID":"/posts/wamproot/:1:2","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Memo"],"content":"编写 php 文件测试 \u003c?php echo \"hello world\"; ?\u003e ","date":"2019-07-12","objectID":"/posts/wamproot/:1:3","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Memo"],"content":"WAMPServer 多站点配置 打开httpd-vhost.conf文件，复制原有的几行配置文件，粘贴修改路径和域名等配置。比如 ## Virtual Hosts # \u003cVirtualHost *:80\u003e ServerName localhost ServerAlias localhost DocumentRoot \"g:/Demo\" \u003cDirectory \"g:/Demo\"\u003e Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local \u003c/Directory\u003e \u003c/VirtualHost\u003e \u003cVirtualHost *:80\u003e ServerName test01.com DocumentRoot \"g:/Demo/test01\" \u003c/VirtualHost\u003e \u003cVirtualHost *:80\u003e ServerName test02.com DocumentRoot \"g:/Demo/test02\" \u003c/VirtualHost\u003e 再打开C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件最后添加类似于云服务器的域名解析，进行本地域名解析，当输入域名时优先从本地申请资源。 ... ## For example: # ## 102.54.94.97 rhino.acme.com ## source server ## 38.25.63.10 x.acme.com ## x client host ## localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 127.0.0.1 steamcommunity.com 192.168.28.1 windows10.microdone.cn 127.0.0.1 localhost ::1 localhost 127.0.0.1 test01.com 127.0.0.1 test02.com ","date":"2019-07-12","objectID":"/posts/wamproot/:2:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Memo"],"content":"WAMPServer 自拟定端口 WAMP 服务我安装了好几次，每次因为修改配置文件搞崩了。第一次装的时候发现 80 端口被占用了，因为以前玩了一下 Windows 的 IIS，暂停 IIS 的网站，再使用命令或者直接在控制面板关掉就好了。 如果不使用 80 多为默认端口，比如修改为 8080，还是在httpd.conf文件里修改。搜索80都改成8080然后，Ctrl+S 保存，重新启动 WampServer 在浏览器地址栏输入localhost:8000 #监听端口 Listen 0.0.0.0:8080 Listen [::0]:8080 ServerName localhost:8080 使用 Notepad++打开 C:\\wamp 目录下的 wampmanager.ini 和 wampmanager.tpl Ctrl+F 查找 localhost 将其全部替换为localhost:8000 然后，Ctrl+S 保存，重新启动 WampServer ","date":"2019-07-12","objectID":"/posts/wamproot/:3:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Python"],"content":" 后面几天讲的有点杂，简单记录一下知识点。 ","date":"2019-06-21","objectID":"/posts/pysx2/:0:0","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"6.19 这些知识点在课上都只是简单的提到了一下。 比如一些库的使用与安装都不会再课上详细讲解，需要课后再去研究。 ","date":"2019-06-21","objectID":"/posts/pysx2/:1:0","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"切片操作 列表切片操作 ","date":"2019-06-21","objectID":"/posts/pysx2/:1:1","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"字符串 python 原始字符串 print(r\"D:\\three\\two\") 长字符串 用三个单引号或者双引号包裹，前后呼应，成双成对。 用、换行字符表示字符未结束 ","date":"2019-06-21","objectID":"/posts/pysx2/:1:2","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"格式化输出 format \"=={}==\"，{}表示占位符，其前后字符保持原样输出。 #TempConvert.py TempStr = input(\"请输入带有符号的温度值：\") if TempStr[-1] in ['F','f']: C = (eval(TempStr[0:-1]) - 32)/1.8 print(\"转换后的温度是{:.2f}C\".format(C)) elif TempStr[-1] in ['C','c']: F = 1.8*eval(TempStr[0:-1]) + 32 print(\"转换后的温度是{:.2f}F\".format(F)) else: print(\"输入格式错误\") ","date":"2019-06-21","objectID":"/posts/pysx2/:1:3","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"多变量赋值与交换（斐波那契数列） python 3.x 版本 end=\"\" 可使输出不换行 print(x, end=\"\") #斐波那契数列 a, b = 1,1 while a \u003c 500: ## 输出不大于 500 的序列 print(a,end=\",\") a,b = b,a + b #交换变量 ","date":"2019-06-21","objectID":"/posts/pysx2/:1:4","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"笑傲江湖统计字符 (dict, 文件流） 统计《笑傲江湖》小说中出现的所有中文字符及标点符号的数量，每个字符及数目间用冒号:隔开，例如\"笑：1024\"，将所有字符及数量的对应采用逗号分隔，以 CSV 文件格式保存到“笑傲江湖--字符统计。txt”文件中。注意，统计字符不包括空格和回车。 csv 文件格式： ‘,’逗号连接元素 fi = open(\"data/笑傲江湖-网络版。txt\",\"r\",encoding=\"utf-8\") fo = open(\"data/笑傲江湖-字符统计。txt\",\"w\",encoding=\"utf-8\") txt = fi.read() #打开文件 #txt d = {} for c in txt: d[c] = d.get(c,0)+1 del d[' '] #删除字典中的空格和回车的键值对 del d['\\n'] ls = [] for key in d: ls.append(\"{}:{}\".format(key,d[key])) fo.write(\",\".join(ls)) fi.close() fo.close() ","date":"2019-06-21","objectID":"/posts/pysx2/:1:5","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"numpy 模块 … ","date":"2019-06-21","objectID":"/posts/pysx2/:1:6","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"pandas 模块 … ","date":"2019-06-21","objectID":"/posts/pysx2/:1:7","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"6.20 ","date":"2019-06-21","objectID":"/posts/pysx2/:2:0","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"matplotlib 绘图 import matplotlib.pyplot as plt import numpy as np x = np.arange(-5,5,0.01) y = 2**x+1 plt.plot(x,y) plt.title(\"y=2^x+1\",fontsize=24) plt.xlabel(\"X\",fontsize=14) plt.ylabel(\"Y\",fontsize=14) plt.tick_params(axis=\"both\",labelsize=14) plt.show() ","date":"2019-06-21","objectID":"/posts/pysx2/:2:1","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"爬虫 举了一个金融界，炒股，获取数据的爬虫 （今天没仔细听课，这数据爬过什么意思，咱不懂，咱也不敢问！） #! /usr/bin/env python #-*- encoding: utf-8 -*- #author pythontab.com import numpy as np import matplotlib.pyplot as plt import pandas as pd import pandas_datareader.data as web import datetime #import tushare as ts df_stockload = web.DataReader(\"000001.SS\", \"yahoo\", datetime.datetime(2017,1,1), datetime.date.today()) #print(type(datetime.datetime.now().strftime('%Y-%m-%d'))) #df_stockload = ts.get_hist_data('sh',start='2017-01-01',end=datetime.datetime.now().strftime('%Y-%m-%d')) print (df_stockload.columns)#查看列名 print (df_stockload.index)#查看索引 print (df_stockload.describe())#查看各列数据描述性统计 #绘制移动平均线 df_stockload.Close.plot(c='b') df_stockload.Close.rolling(window=30).mean().plot(c='r') #pd.rolling_mean(df_stockload.Close,window=30).plot(c='r') df_stockload.Close.rolling(window=60).mean().plot(c='g') #pd.rolling_mean(df_stockload.Close,window=60).plot(c='g') plt.legend(['Close','30ave','60ave'],loc='best') plt.show() Index(['High', 'Low', 'Open', 'Close', 'Volume', 'Adj Close'], dtype='object') DatetimeIndex(['2017-01-03', '2017-01-04', '2017-01-05', '2017-01-06', '2017-01-09', '2017-01-10', '2017-01-11', '2017-01-12', '2017-01-13', '2017-01-16', ... '2019-06-05', '2019-06-06', '2019-06-10', '2019-06-11', '2019-06-12', '2019-06-13', '2019-06-14', '2019-06-19', '2019-06-20', '2019-06-21'], dtype='datetime64[ns]', name='Date', length=596, freq=None) High Low Open Close Volume \\ count 596.000000 596.000000 596.000000 596.000000 5.960000e+02 mean 3076.147753 3039.201569 3056.960338 3060.169056 5.098201e+06 std 269.276147 273.757358 271.612122 272.072346 1.199107e+08 min 2488.479004 2440.906982 2446.019043 2464.363037 8.820000e+04 25% 2845.308228 2800.168762 2825.239502 2827.754822 1.375250e+05 50% 3153.184937 3118.613525 3134.300537 3139.085449 1.666500e+05 75% 3280.115234 3244.825256 3265.322021 3268.600342 2.091250e+05 max 3587.031982 3534.195068 3563.639893 3559.465088 2.927580e+09 Adj Close count 596.000000 mean 3060.169056 std 272.072346 min 2464.363037 25% 2827.754822 50% 3139.085449 75% 3268.600342 max 3559.465088 ","date":"2019-06-21","objectID":"/posts/pysx2/:2:2","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"6.21 ","date":"2019-06-21","objectID":"/posts/pysx2/:3:0","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"类 比第一天稍微仔细一点讲了一下类，有点需要注意： self相当于this表示当前对象 python 类的所有函数的第一个参数都要写self参数，self 也可以是其他的比如lrh等字符替代，但是必须保持一致。 __表示私有的 class 的定义可以不加 (),() 内可写继承的父类 ","date":"2019-06-21","objectID":"/posts/pysx2/:3:1","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"GUI 设计 wxPython pip install wxPython import wx import wx #导入 wxPython 库 class Panel(wx.Panel): def __init__(self,parent): wx.Panel.__init__(self,parent=parent, id=-1) pass class Frame(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent = None, title = u'量化软件', size=(1000,600), style=wx.DEFAULT_FRAME_STYLE^wx.MAXIMIZE_BOX) self.DispPanel= Panel(self) pass class App(wx.App): def OnInit(self): self.frame = Frame() self.frame.Show() self.SetTopWindow(self.frame) return True if __name__ == '__main__': app = App() app.MainLoop() import wx app = wx.App() window = wx.Frame(None, title=\"wxPython 你好！\", size=(400, 300)) panel = wx.Panel(window) label = wx.StaticText(panel, label=\"Hello World\", pos=(100, 100)) window.Show(True) app.MainLoop() ","date":"2019-06-21","objectID":"/posts/pysx2/:3:2","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"talib 库的安装 下载 whl 文件 pip install TA_Lib-0.4.17-cp37-cp37m-win_amd64.whl pip install TA-Lib ","date":"2019-06-21","objectID":"/posts/pysx2/:3:3","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"选择排序递归版 def SelectSort(L): L=L[:] if len(L)\u003c=1: return L min = 0 for i in range(1,len(L)): if L[i]\u003cL[min]: min = i L[min],L[0] = L[0],L[min] return [L[0]]+SelectSort(L[1:]) L = [5,2,3,6,1,9,8,10,0] print(SelectSort(L)) [0, 1, 2, 3, 5, 6, 8, 9, 10] ","date":"2019-06-21","objectID":"/posts/pysx2/:3:4","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"机房上机系统（自我实践） import time class student(): def __init__(self,stu_no=\"\",stu_name=\"\",stu_xi=\"\",stu_time=\"\"): self.stu_no = stu_no self.stu_name = stu_name self.stu_xi = stu_xi self.stu_time = stu_time def print(self): print(\"学号：\"+self.stu_no+\"\\t 姓名：\"+self.stu_name+\"\\t 系别：\"+self.stu_xi+\"\\t 机时 (h)：\"+self.stu_time) def get_stu_name(self): return self.stu_name def get_stu_time(self): return int(self.stu_time) def set_stu_time(self,add_time): self.stu_time = add_time def menu(): print(\"\\t 机房上机系统 V0.1\") print(\"********************************\") print(\"\\t—\u003e1. 录入学生信息\") print(\"\\t—\u003e2. 上机\") print(\"\\t—\u003e3. 下机\") print(\"\\t—\u003e4. 缴费\") print(\"\\t—\u003e5. 退出\") print(\"********************************\") select = eval(input(\"请输入序号：\")) while select not in [1,2,3,4,5]: print(\"输入错误，请重新输入！\") select = eval(input(\"请输入序号：\")) return select def get_time(): #获取当前时间 return time.strftime(\"%H:%M:%S\", time.localtime()) def main(): ## 全局变量 text = [] ## 上机记录列表 start_time = \"\" end_time = \"\" sum = 0 ## 本系统按小时计费，不足一小时按一小时算 people = student() online_flag = False down_flag = False input_flag = False while True: select = menu() ## 启用菜单 if select == 1: if input_flag: print(\"已录入，无需重复操作，缴费请输入 4:\") continue else: input_flag = True stu_no = input(\"请输入学号：\") stu_name = input(\"请输入姓名：\") stu_xi = input(\"请输入系别：\") stu_time = input(\"请输入机时：\") people = student(stu_no,stu_name,stu_xi,stu_time) people.print() continue elif select == 2: if not input_flag: print(\"未录入学生信息，请录入！\") continue if not online_flag: online_flag = True start_time = get_time() start_num = int(start_time[0:2]) #print(start_num) text.append(\"上机时间：\"+start_time) print(\"已上机！上机时间为：\"+start_time) continue else: print(\"已上机！上机时间为：\"+start_time) continue elif select == 3: if not online_flag: print(\"还未上机，请上机！\") continue else: end_time = get_time() end_num = int(end_time[0:2]) sum = end_num - start_num sum = sum if(sum\u003e=0) else sum+24 sum = sum+1 if(sum==0) else sum print(\"已下机！下机时间为：\"+end_time+\"\\n 上机时长 (h)：\"+str(sum)+\"\\t 剩余机时 (h)：\"+str(people.get_stu_time()-sum)) text.append(\"下机时间：\"+end_time+\"\\n 上机时长 (h)：\"+str(sum)+\"\\t\"+people.get_stu_name()+\"剩余机时 (h)：\"+str(people.get_stu_time()-sum)) people.set_stu_time(str(people.get_stu_time()-sum)) down_flag = True continue elif select == 4: if not input_flag: print(\"未录入学生信息，请录入！\") continue else: people.print() add_time = eval(input(\"请输入机时：\")) people.set_stu_time(str(add_time+people.get_stu_time())) people.print() else: if down_flag: print(\"3s 后退出系统，感谢使用！\") time.sleep(3) ## 延迟 3s，显示提示文字 break ## 退出系统 写入文件 else: print(\"请下机！\") continue #写入 computer.txt 文件 fo = open(\"D:\\\\computer.txt\",\"w\",encoding=\"utf-8\") fo.write(\"\\n\".join(text)) fo.close() if __name__==\"__main__\": main() ","date":"2019-06-21","objectID":"/posts/pysx2/:3:5","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"量化交易代码分析与调试 由于 python 的版本问题和一些库的导入问题所以还未调试成功，先挂上代码。以后改篇再论。 #! /usr/bin/env python #-*- encoding: utf-8 -*- #author pythontab.com import wx import wx.adv import numpy as np import pandas as pd import pandas_datareader.data as web import matplotlib import matplotlib.pyplot as plt from matplotlib.figure import Figure import matplotlib.dates as mdates import mpl_finance as mpf from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas import matplotlib.gridspec as gridspec#分割子图 import datetime import talib import csv,os import codecs from RedefPanelMod import MPL_Panel_Base,Loop_Panel_Base from StockDataMod import GetStockDatPro from IndicatStrateMod import Excave_Indic_Base, QuantPickTimeSys,FactorPickStockAng plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签 plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 class UserDialog(wx.Dialog):## user-defined def __init__(self,parent,text): wx.Dialog.__init__(self,parent,-1,u\"选股提示\",size=(400,500),style=wx.CAPTION|wx.CLOSE_BOX|wx.MAXIMIZE_BOX|wx.MINIMIZE_BOX) sizer = wx.BoxSizer(wx.VERTICAL) pstock_Text = wx.StaticText(self, -1, u'选股策略筛选结果') pstock_Text.SetFont(wx.Font(18,wx.DEFAULT,wx.NORMAL,wx.BOLD)) pstock_sure = wx.TextCtrl(self, -1, \"角度值：\\n\",size=(350,300),style = wx.TE_MULTILINE|wx.TE_READONLY)#多行|只读 pstock_sure.SetFont(wx.Font(10,wx.DEFAULT,wx.NORMAL,wx.BOLD)) okbtn = wx.Button(self,wx.ID_OK,u\"确认\") okbtn.SetDefault() sizer.Add(pstock_Text,flag=wx.ALIGN_CENTER) sizer.Add(pstock_sure,flag=wx.ALIGN_CENTER) sizer.Add(okbtn,flag=wx.ALIGN_CENTER) self.SetSizer(sizer) for i in text:pstock_sure.AppendText(i) class Frame(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent = None, title = u'量化软件', size=(1500,800), style=wx.DEFAULT_FRAME_STYLE^wx.MAXIMIZE_BOX) #创建显示区面板 self.DispPanel = MPL_Panel_Base(self) self.BackPanel = Loop_Panel_Base(self) self.am = self.DispPanel.am self.vol = self.DispPanel.vol self.devol = self.DispPanel.devol self.macd = self.DispPanel.macd #创建参数区面板 self.ParaPanel = wx.Panel(self,-1) paraInput_Box = wx.StaticBox(self.ParaPanel, -1, u'参数输入') paraInput_Sizer = wx.StaticBoxSizer(paraInput_Box, wx.VERTICAL) self.StNameCodedict = {u\"开山股份\":\"300257.SZ\",u\"浙大网新\":\"600797.SS\",u\"水晶光电\":\"002273.SZ\", u\"高鸿股份\":\"000851.SZ\"} #初始化股票代码变量 self.stockName_Val = u\"开山股份\" self.stockCode_Val = self.StNameCodedict[self.stockName_Val] self.stockName_CMBO = wx.ComboBox(self.ParaPanel, -1,self.stockName_Val, choices = list(self.StNameCodedict.keys()), style = wx.CB_READONLY|wx.CB_DROPDOWN) #股票名称 stockCode_Text = wx.StaticText(self.ParaPanel, -1, u'股票名称') #策略选取 strate_Text = wx.StaticText(self.ParaPanel, -1, u'策略名称') strate_Combo_Val = [u\"双趋势融合\", u\"阿尔法\", u\"布林带\"] self.pickstrate_Val = u\"双趋势融合\" self.pickstrate_CMBO = wx.ComboBox(self.ParaPanel, -1, self.pickstrate_Val, choices = strate_Combo_Val, style = wx.CB_READONLY|wx.CB_DROPDOWN) #策略名称 #日历控件选择数据周期 self.dpcEndTime = wx.adv.DatePickerCtrl(self.ParaPanel, -1,style = wx.adv.DP_DROPDOWN|wx.adv.DP_SHOWCENTURY|wx.adv.DP_ALLOWNONE)#结束时间 self.dpcStartTime = wx.adv.DatePickerCtrl(self.ParaPanel, -1,style = wx.adv.DP_DROPDOWN|wx.adv.DP_SHOWCENTURY|wx.adv.DP_ALLOWNONE)#起始时间 DateTimeNow = wx.DateTime.Now()#wx.DateTime 格式\"03/03/18 00:00:00\" #DateTimeNow = datetime.datetime.fromtimestamp(wx.DateTime.Now().GetTicks()) #DateTimeNow = datetime.datetime.fromtimestamp(DateTimeNow) self.dpcEndTime.SetValue(DateTimeNow) DateTimeNow.SetYear(DateTimeNow.year-1) self.dpcStartTime.SetValue(DateTimeNow) stockData_Text = wx.StaticText(self.ParaPanel, -1, u'日期 (Start-End)') #初始化时间变量 dateVal = self.dpcStartTime.GetValue() self.stockSdate_Val = datetime.datetime(dateVal.year,dateVal.month+1,dateVal.day) dateVal = self.dpcEndTime.GetValue() self.stockEdate_Val = datetime.datetime(dateVal.year,dateVal.month+1,dateVal.day) paraInput_Sizer.Add(stockCode_Text,proportion=0,flag=wx.EXPAND|wx.ALL,border=2) paraInput_Sizer.Add(self.stockName_CMBO, 0, wx.EXPAND|wx.ALL|wx.CENTER, 2) paraInput_Sizer.Add(stockData_Text,proportion=0,flag=wx.EXPAND|wx.ALL","date":"2019-06-21","objectID":"/posts/pysx2/:3:6","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":" 以前和前一段时间自己也学习了一下 python，也写了几个小爬虫； 这次正好又课程安排了为期两周的综合实训，主要是“用 python 做量化交易” 进行了两天，讲的都是一些基本的东西，以前也接触过，所以很容易理解。还讲了一些软件，pycharm，anaconda,sublime 等大都也都用过。anaconda 倒是第一次接触。 ","date":"2019-06-18","objectID":"/posts/pysx1/:0:0","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"6.17 print(\"Hello World!\") 讲了一下变量和 python 的特色什么的。 还讲了模块定义def和类定义 class zxm(): def __init__(self): self.x=0 self.y=0 def move_up(self): self.y +=1 my_zxm=zxm() print(my_zxm) \u003c__main__.zxm object at 0x000001D99CFEF668\u003e ","date":"2019-06-18","objectID":"/posts/pysx1/:1:0","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"6.18 ","date":"2019-06-18","objectID":"/posts/pysx1/:2:0","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"输入输出 print 输出 input 输入 eval 执行一个字符串表达式，并返回表达式的值 x=eval(input(\"请输入 x 的值：\")) y=eval(input(\"请输入 y 的值：\")) z=(x**2+y**2)**0.5 print(z) # 导入复数数学模块 import cmath num = int(input(\"请输入一个数字：\")) num_sqrt = cmath.sqrt(num) print('{0} 的平方根为 {1:0.3f}+{2:0.3f}j'.format(num ,num_sqrt.real,num_sqrt.imag)) ","date":"2019-06-18","objectID":"/posts/pysx1/:2:1","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"数据类型 今天还讲了一下数据类型 字符串： \"\" '' 元组 tuple(2,3) 列表 list[2,3] 字典 dict{Key:Value} 集合{} x=[1,10] type(x)#判断元素类型 list ","date":"2019-06-18","objectID":"/posts/pysx1/:2:2","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"循环判断 for x in range(1,10,2): # (start,stop,step) pass # pass 不做任何事情，一般用做占位语句 for letter in 'Python': if letter == 'h': pass print('这是 pass 块') print('当前字母 :'+ letter) print(\"Good bye!\") 当前字母 :P 当前字母 :y 当前字母 :t 这是 pass 块 当前字母 :h 当前字母 :o 当前字母 :n Good bye! ","date":"2019-06-18","objectID":"/posts/pysx1/:2:3","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"str() 、 import 导库 x=10 print(\"整数转字符串\"+str(x)) import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Google 翻译意思是： 美丽胜过丑陋。显式优于隐式。简单比复杂更好。复杂比复杂更好。Flat 优于嵌套。稀疏优于密集。可读性很重要。特殊情况不足以打破规则。虽然实用性胜过纯洁。错误不应该默默地传递。除非明确沉默。面对模棱两可，拒绝猜测的诱惑。应该有一个最好只有一个明显的方法来做到这一点。虽然这种方式起初可能并不明显，除非你是荷兰人。现在比永远好。虽然现在永远不会比正确好。如果实施很难解释，这是一个坏主意。如果实现很容易解释，那可能是个好主意。命名空间是一个很棒的主意，让我们做更多的事情吧！ ","date":"2019-06-18","objectID":"/posts/pysx1/:2:4","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"turtle 绘图库（内置模块）","date":"2019-06-18","objectID":"/posts/pysx1/:2:5","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Grocery"],"content":" 黑盒测试着重测试软件功能，它并不涉及程序的内部结构和内容特性，主要根据规格说明，只依靠被测试程序的输入和输出之间关系或程序的功能来设计测试用例。 白盒测试则清楚程序内部的结构以及是如何运作的，因此白盒测试需要对系统内部的结构和工作原理有一个清楚的了解。 ","date":"2019-05-26","objectID":"/posts/judgetriangle/:0:0","tags":["黑盒测试","C"],"title":"判断三角形的黑盒测试","uri":"/posts/judgetriangle/"},{"categories":["Grocery"],"content":"程序 #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #define N 2\u003c\u003c25 int a=N,b=N,c=N,d=N; void shuru(); void panduan(int a1,int b1,int c1); int main() { char se; shuru(); panduan(a,b,c); while(1) { printf(\"是否要继续 y or n :\"); scanf(\"%c\",\u0026se); if(se=='\\n') scanf(\"%c\",\u0026se); switch(se) { case 'y': shuru(); panduan(a,b,c); break; case 'n': return 0; } } } void shuru() { printf(\"Please enter 三角形三边 (a,b,c)\\n\"); while(!scanf(\"%d,%d,%d,%d\",\u0026a,\u0026b,\u0026c,\u0026d)){//判断非数字字符 fflush(stdin);//清理缓存 a=N;b=N;c=N;d=N; printf(\"输入错误、n\"); } fflush(stdin); while((a\u003c1||a\u003e100)||(b\u003c1||b\u003e100)||(c\u003c1||c\u003e100)||d!=N) { if(b==N||c==N||d!=N) printf(\"输入错误、n\");//边数为 1、2、4 条 else if(a==0||b==0||c==0) printf(\"边长不能为 0\\n\"); else if(a\u003c0||b\u003c0||c\u003c0) printf(\"边长不能为负、n\"); else printf(\"Please enter 1-100 之间的整数、n\"); a=N;b=N;c=N;d=N; while(!scanf(\"%d,%d,%d,%d\",\u0026a,\u0026b,\u0026c,\u0026d)){//判断非数字字符 fflush(stdin);//清理缓存 a=N;b=N;c=N;d=N; printf(\"输入错误、n\"); } fflush(stdin); } } void panduan(int a1,int b1,int c1) { if(a1+b1\u003ec1\u0026\u0026b1+c1\u003ea1\u0026\u0026a1+c1\u003eb1) { if(a1==b1\u0026\u0026a1==c1) printf(\"等边三角形、n\"); else if(a1==b1||a1==c1||b1==c1) printf(\"等腰三角形、n\"); else printf(\"一般三角形、n\"); } else printf(\"非三角形、n\"); } ","date":"2019-05-26","objectID":"/posts/judgetriangle/:1:0","tags":["黑盒测试","C"],"title":"判断三角形的黑盒测试","uri":"/posts/judgetriangle/"},{"categories":["Grocery"],"content":"测试 测试 1 测试 2 测试 3 ","date":"2019-05-26","objectID":"/posts/judgetriangle/:2:0","tags":["黑盒测试","C"],"title":"判断三角形的黑盒测试","uri":"/posts/judgetriangle/"},{"categories":["Memo"],"content":" 目前 HustOj 在 GitHUb 地址是：https://github.com/zhblue/hustoj 安装时注意 ubuntu 版本，没条件的可以在自己 ubuntu 上尝试，或者虚拟机上（关注公众号回复ubuntu16.04获取 iso 镜像文件），也可以在云实验室的云服务器上做做实验。 更多说明及 ACM/NOIP 题库下载见官网博客 代码的那些事|程序员回忆录 ","date":"2019-05-17","objectID":"/posts/hustoj/:0:0","tags":["hustoj","ACM","ubuntu","linux"],"title":"HustOJ 基础搭建教程","uri":"/posts/hustoj/"},{"categories":["Memo"],"content":"快速安装 OJ 下载 wget https://raw.githubusercontent.com/zhblue/hustoj/master/trunk/install/install-ubuntu16+.sh 安装 sudo bash install-ubuntu16+.sh 等待中一路回车，当提示 done！ 则表示安装成功： ","date":"2019-05-17","objectID":"/posts/hustoj/:1:0","tags":["hustoj","ACM","ubuntu","linux"],"title":"HustOJ 基础搭建教程","uri":"/posts/hustoj/"},{"categories":["Memo"],"content":"使用 HustOJ 打开网页/IP 地址 注册 admin 用 admin 作为用户名注册一个用户，将会自动成为管理员。 注册成功，会提示： 登录后台 登录账号，并点击右上角的管理： 添加测试题目 在后台选择添加题目，添加成功： 然后再提交代码测试判题机。 ","date":"2019-05-17","objectID":"/posts/hustoj/:2:0","tags":["hustoj","ACM","ubuntu","linux"],"title":"HustOJ 基础搭建教程","uri":"/posts/hustoj/"},{"categories":["Memo"],"content":"说明 安装后几个重要配置文件的位置 /home/judge/etc/judge.conf /home/judge/src/web/include/db_info.inc.php /etc/php5/fpm/php.ini 或 /etc/php7.0/fpm/php.ini /etc/nginx/sites-enabled/default ","date":"2019-05-17","objectID":"/posts/hustoj/:3:0","tags":["hustoj","ACM","ubuntu","linux"],"title":"HustOJ 基础搭建教程","uri":"/posts/hustoj/"},{"categories":["ACM"],"content":" 二进制最大公约数算法避免了欧几里得算法（辗转相除法）的大量取模操作，有效减少了时间消耗，且更为方便。 ","date":"2019-05-17","objectID":"/posts/gcd-bit/:0:0","tags":["欧几里得","数学","数论","C"],"title":"最大公约数（二进制算法）","uri":"/posts/gcd-bit/"},{"categories":["ACM"],"content":"原理 本算法基于以下事实： 对于两个数的最大公约数 gcd(m, n)，有 m\u003cn 时，gcd(m, n)=gcd(n, m) m 偶 n 偶时，gcd(m, n)=2*gcd(m/2, n/2) m 偶 n 奇时，gcd(m, n)=gcd(m/2, n) m 奇 n 偶时，gcd(m, n)=gcd(m, n/2) m 奇 n 奇时，gcd(m, n)=gcd(n, m-n) 采用递归即可。 ","date":"2019-05-17","objectID":"/posts/gcd-bit/:1:0","tags":["欧几里得","数学","数论","C"],"title":"最大公约数（二进制算法）","uri":"/posts/gcd-bit/"},{"categories":["ACM"],"content":"实现 inline int GCD(int x,int y) { int i,j; if(x==0) return y; if(y==0) return x; for(i=0;0==(x\u00261);++i)x\u003e\u003e=1; // 去掉所有的 2 for(j=0;0==(y\u00261);++j)y\u003e\u003e=1; // 去掉所有的 2 if(j\u003ci) i=j; while(1){ if(x\u003cy)x^=y,y^=x,x^=y; // 若 x \u003c y 交换 x, y if(0==(x-=y)) return y\u003c\u003ci; // 若 x == y， gcd == x == y （就是在辗转减，while(1) 控制） while(0==(x\u00261))x\u003e\u003e=1; // 去掉所有的 2 } } int get_lcm(int a,int b)///获得最小公倍数 { int x=a; int y=b; while(b) { int t=a; a=b; b=t%b; } return x/a*y; } ","date":"2019-05-17","objectID":"/posts/gcd-bit/:2:0","tags":["欧几里得","数学","数论","C"],"title":"最大公约数（二进制算法）","uri":"/posts/gcd-bit/"},{"categories":["Grocery"],"content":" ImgURL 是一个开源、免费的图床程序，ImgURL 2.x 之后对环境要求更高，尤其是 ImageMagick 组件的支持，很多朋友不清楚怎样安装这个组件，这篇文章分享宝塔面板安装 ImgURL 2.x 图床的过程（包括 ImgURL 2.x 需要的各种组件） 阅读原文 ","date":"2019-05-16","objectID":"/posts/imgurl/:0:0","tags":["ImgURL","宝塔面板"],"title":"宝塔面板安装 ImgURL 图床","uri":"/posts/imgurl/"},{"categories":["Grocery"],"content":"准备工作 已经安装宝塔面板 在宝塔后台创建一个站点 下载 ImgURL 2.x 上传到站点根目录并解压 ","date":"2019-05-16","objectID":"/posts/imgurl/:1:0","tags":["ImgURL","宝塔面板"],"title":"宝塔面板安装 ImgURL 图床","uri":"/posts/imgurl/"},{"categories":["Grocery"],"content":"设置伪静态 如果您宝塔面板安装的 Apache 则不需要再设置伪静态，直接跳过这个步骤，如果使用的 Nginx 环境，请继续往下看。 找到对应的站点 - 点击后面设置按钮 - 伪静态 - 添加下面的伪静态规则 location / { try_files $uri $uri/ /index.php?$query_string; } location ~* \\.(db3|json)$ { deny all; } location ~* ^/(temp|upload|imgs|data|application|static|system)/.*.(php|php5)$ { return 403; } ","date":"2019-05-16","objectID":"/posts/imgurl/:2:0","tags":["ImgURL","宝塔面板"],"title":"宝塔面板安装 ImgURL 图床","uri":"/posts/imgurl/"},{"categories":["Grocery"],"content":"安装 fileinfo \u0026 imagemagick 在宝塔后台 - 软件管理 - 找到您站点对应的 PHP 版本 - 设置 PHP - 安装扩展 - 勾选fileinfo和imagemagick，如下截图。 ","date":"2019-05-16","objectID":"/posts/imgurl/:3:0","tags":["ImgURL","宝塔面板"],"title":"宝塔面板安装 ImgURL 图床","uri":"/posts/imgurl/"},{"categories":["Grocery"],"content":"安装 ImgURL 2.x 其它所需扩展宝塔默认已经支持，重点是安装fileinfo和imagemagick，扩展安装完毕后就可以访问您自己的域名安装 ImgURL 了，如果正常会看到 ImgURL 安装界面。 ","date":"2019-05-16","objectID":"/posts/imgurl/:4:0","tags":["ImgURL","宝塔面板"],"title":"宝塔面板安装 ImgURL 图床","uri":"/posts/imgurl/"},{"categories":["Grocery"],"content":"其它说明 如果安装遇到任何问题，请留言反馈或到 3T 官方社区 进行反馈 ImgURL 更多使用说明请参考帮助文档：https://dwz.ovh/imgurldoc ","date":"2019-05-16","objectID":"/posts/imgurl/:5:0","tags":["ImgURL","宝塔面板"],"title":"宝塔面板安装 ImgURL 图床","uri":"/posts/imgurl/"},{"categories":["Python"],"content":" 用 python 模拟 post 请求获取“麻小科技”示例酒店后台的数据，再打包发送至指定的微信群或者好友。 要求每天早上 8 点定时把每个酒店的数据发送至每个酒店的微信工作群。 ","date":"2019-05-11","objectID":"/posts/mx2wx/:0:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python 实战：模拟 post 请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["Python"],"content":"背景 麻小科技： 麻小科技全名深圳市麻小科技有限公司，成立于 2017 年 1 月。是我高一的时候参加Peer 夏令营带我们一个玩的“老师”和他的朋友的创业公司，说老师有点奇怪，我们都是直接叫名字的，比如大家都叫我瑞豪，我也就叫他文捷哥，简称捷哥吧。他们公司主要的开发模式是，小程序前端+php 后端，然后做的是酒店小程序，为每个酒店定制小程序。这些小程序可以贴在客房中给访客提供一些服务，大大节省了成本也提高了效率。 然后每个酒店小程序都有独立的后台，后台会记录一些点击需求的数据。现在他们有一个需求需要把每个酒店小程序后台的数据在每天早上 9 点发送至对应酒店的微信群。 ","date":"2019-05-11","objectID":"/posts/mx2wx/:1:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python 实战：模拟 post 请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["Python"],"content":"实现代码 缓存登录信息，短时间类无需重复登录，仅第一次需要扫码登录（相当于微信网页版），后面的登录只需在手机上确认登录信息。 #!/usr/bin/python import requests import json import time from wxpy import * ## 基本信息填写： ## 酒店 id，酒店名称及群名列表数据，格式：[\"xxx\",\"xxx\",\"xxx\"] ## 使用时请将以下三个列表一一对应 hotel=[\"xxxx\",\"xxxx\"] ## 酒店后台数据接口二级域名，已匿名 hotel_name=[\"增城宾馆\",\"百丽酒店\"] grouplist = [\"麻小\",\"富强民主文明和谐自由平等公正法治\"] ## post 请求发送的数据 postData = { ## 'username':'test', ## 'password':'123456', } def get_data(): result = [] #结果列表 i = 0 #计数器 for each in hotel: url=\"http://\"+each+\".maxiaokeji.com/xxx/xxxxxxx/xxx\" ## 为保护隐私及权益，这里不提供接口 r = requests.post(url,data=postData) ## print(r.text) ## 把结果转化为 json 字符串 response=json.dumps(r.json(),indent=4,ensure_ascii=False) #sort_keys=True ## 把 json 转换为 dict 字典作为中间结果，再取出昨日数据 midresult=json.loads(response) result.append(\"早上好！\"+hotel_name[i]+\"小程序昨日数据如下：\\n 访问数：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type1\"])+\"\\n 房间数：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type2\"])+\"\\n 需求量：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type3\"])+\"\\n 商品点击量：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type4\"])) i+=1 ## print(result) return result def wechat_send(bot,result): ## my_friend = bot.friends().search('lrh')[0] ## my_friend.send(result) i = 0 ## 计数器 for group in grouplist: my_group = bot.groups().search(group)[0] #依次搜索每一个群名称，每次一个 my_group.send(result[i]) print(result[i]) print(\"已发送至群：\"+group) i+=1 def main(bot): ## 设置最大休眠时间，防止程序长时间占用系统资源 while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) ## 设置每天 8 点发送 if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"软件明天开始将在每天 8 点发送数据！\") result=get_data() ## 获取数据 wechat_send(bot,result) ## 发送数据 time.sleep(86400-int(now_min)*60) if __name__==\"__main__\": bot = Bot(cache_path=True) ## 初始化机器人，扫码登陆 main(bot); ","date":"2019-05-11","objectID":"/posts/mx2wx/:2:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python 实战：模拟 post 请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["Python"],"content":"测试结果 ","date":"2019-05-11","objectID":"/posts/mx2wx/:3:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python 实战：模拟 post 请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["Python"],"content":"程序打包 使用 pyinstaller 工具打包成可执行文件即可。（可执行文件不可跨平台运行，分平台打包） 目前该程序已经上线测试中 … 暂未反馈问题 ","date":"2019-05-11","objectID":"/posts/mx2wx/:4:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python 实战：模拟 post 请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["Python"],"content":"收获 第一次参与实际公司的项目开发，虽然只是一个小的需求设计，但是我在这个过程中也学到了很多，比如通过实际一两周的编程对 Python 的熟悉度远远好过以前在实验室看的一个月视频。 还有就是在此次开发中，也感受到了实际项目开发的团队合作重要性，刚开始拿到这个需求，由于我对 python 和后台，以及数据接口这些基本的操作都不懂，就拿数据获取来说，我一开始一位要自己模拟登陆后台（已知密码），一顿操作、百度等等失败告终，后来涛哥给了一个数据接口，加上涛哥耐心指点，我才终于拿到了数据。 还有在多人合作的项目中，为保持代码的可读性，要尽量的多些注释，还有函数方法的命名尽量具备可读性。比如我代码中的wechat_send()，一开始的命名是wxfs()，经捷哥指正我才改过来的。 ","date":"2019-05-11","objectID":"/posts/mx2wx/:5:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python 实战：模拟 post 请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["Grocery"],"content":" \u003c!--[if !IE]\u003e\u003c!--\u003e 除 IE 外都可识别 \u003c!--\u003c![endif]--\u003e \u003c!--[if IE]\u003e 所有的 IE 可识别 \u003c![endif]--\u003e \u003c!--[if IE 6]\u003e 仅 IE6 可识别 \u003c![endif]--\u003e \u003c!--[if lt IE 6]\u003e IE6 以及 IE6 以下版本可识别 \u003c![endif]--\u003e \u003c!--[if gte IE 6]\u003e IE6 以及 IE6 以上版本可识别 \u003c![endif]--\u003e \u003c!--[if IE 7]\u003e 仅 IE7 可识别 \u003c![endif]--\u003e \u003c!--[if lt IE 7]\u003e IE7 以及 IE7 以下版本可识别 \u003c![endif]--\u003e \u003c!--[if gte IE 7]\u003e IE7 以及 IE7 以上版本可识别 \u003c![endif]--\u003e \u003c!--[if IE 8]\u003e 仅 IE8 可识别 \u003c![endif]--\u003e \u003c!--[if IE 9]\u003e 仅 IE9 可识别 \u003c![endif]--\u003e 项目范例说明 ![if !IE]The NOT operator. This is placed immediately in front of the feature, operator, or subexpression to reverse the Boolean meaning of the expression. NOT 运算符。这是摆立即在前面的功能，操作员，或子表达式扭转布尔表达式的意义。lt [if lt IE 5.5] The less-than operator. Returns true if the first argument is less than the second argument. 小于运算符。如果第一个参数小于第二个参数，则返回 true。 lte[if lte IE 6]The less-than or equal operator. Returns true if the first argument is less than or equal to the second argument. 小于或等于运算。如果第一个参数是小于或等于第二个参数，则返回 true。 gt[if gt IE 5]The greater-than operator. Returns true if the first argument is greater than the second argument. 大于运算符。如果第一个参数大于第二个参数，则返回 true。 gte [if gte IE 7]The greater-than or equal operator. Returns true if the first argument is greater than or equal to the second argument. 大于或等于运算。如果第一个参数是大于或等于第二个参数，则返回 true。 ( )[if !(IE 7)]Subexpression operators. Used in conjunction with boolean operators to create more complex expressions. 子表达式运营商。在与布尔运算符用于创建更复杂的表达式。\u0026[if (gt IE 5)\u0026(lt IE 7)]The AND operator. Returns true if all subexpressions evaluate to true AND 运算符。如果所有的子表达式计算结果为 true，返回 true|[if (IE 6)|(IE 7)]The OR operator. Returns true if any of the subexpressions evaluates to true. OR 运算符。返回 true，如果子表达式计算结果为 true。 \u003c!--[if lt IE 9]\u003e 加载 CSS1 \u003c!--[else]\u003e 加载 CSS2 \u003c![endif]--\u003e 这样有效是有效，但是用 HTML VALIDATOR 里，报错，因为这个不符合 XHTML 1.1 的规范， 如果把 ELSE 语句去掉，则正确。 加载 CSS2 \u003c!--[if lt IE 9]\u003e 加载 CSS1（可以把要重写的写在这里）. \u003c![endif]--\u003e ","date":"2019-05-10","objectID":"/posts/ifzhushi/:0:0","tags":["HTML","他山之石"],"title":"条件注释判断浏览器版本\u003c!--[if lt IE 9]\u003e;","uri":"/posts/ifzhushi/"},{"categories":["Python"],"content":" 第一次运行根据程序执行时间，判断程序休眠的时间，尽最大可能休眠，节省系统资源。 第二次运行后直接休眠一天，到每天早上 8 点执行任务。 （该程序需要一直挂着，保持网络不断） import time while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"启动时北京时间为：\" + time.strftime(\"%H:%M\", time.localtime()), \"\\t 软件将在每天 8 点发送数据！\") # 以下为定时任务 print(\"数据\") time.sleep(86400-int(now_min)*60) ","date":"2019-05-09","objectID":"/posts/pysettime/:0:0","tags":["Python","Cron"],"title":"python 设置程序每天 8 点定时执行任务","uri":"/posts/pysettime/"},{"categories":["Python"],"content":" 用过命令pip install pyinstaller安装失败，此包依赖于 pywin32，安装前需要先pip install pywin32, 我安装了还是出错，稍微百度了一下也没有看到解决办法。 这里通过手动下载安装解决的，记录一下。 ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:0:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Python"],"content":"下载 去官网下载 pyinstaller 安装包：https://pypi.org/project/PyInstaller/#files ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:1:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Python"],"content":"解压 我这里解压到E:\\应用、Python37\\Lib\\site-packages\\PyInstaller-3.4 ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:2:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Python"],"content":"安装 cmd 也进入到上面的路径下，然后执行Python setup.py install，等待安装完毕 ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:3:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Python"],"content":"pyinstaller 简介 pyinstaller 将 Python 脚本打包成可执行程序，使在没有 Python 环境的机器上运行。 最新版是 pyinstaller 3.4，可运行在 Windows，Mac 和 Linux 操作系统下。 但它不是跨编译的，也就是说在 Windows 下用 PyInstaller 生成的 exe 只能运行在 Windows 下，在 Linux 下生成的只能运行在 Linux 下。 ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:4:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Python"],"content":"打包 打包的 app 里并不包含任何源码，但将脚本的 .pyc 文件打包了。 基本语法： pyinstaller options myscript.py 常用的可选参数如下： --onefile 将结果打包成一个可执行文件 --onedir 将所有结果打包到一个文件夹中，该文件夹包括一个可执行文件和可执行文件执行时需要的依赖文件（默认） --paths=DIR 设置导入路径 --distpath=DIR 设置将打包的结果文件放置的路径 --specpath=DIR 设置将 spec 文件放置的路径 --windowed 使用 windows 子系统执行，不会打开命令行（只对 windows 有效） --nowindowed 使用控制台子系统执行（默认）（只对 windows 有效） --icon=\u003cFILE.ICO\u003e 将 file.ico 添加为可执行文件的资源（只对 windows 有效） 如pyinstaller --paths=\"D:\\\" test.py ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:5:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Python"],"content":"CSDN 访问量脚本实例 比如，拿以前写的一个刷 csdn 访问量工具 csdn.py（放在桌面上），代码详见 在 cmd 进入桌面路径，输入如下命令 pyinstaller --onefile --nowindowed csdn.py ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:6:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Java"],"content":" 实现一个简单的基于单线程的资源下载器，如图所示，用户可以任意指定下载资源的链接地址，系统根据该地址判断资源是否存在，如果存在，则将该资源下载到本地。 ","date":"2019-05-08","objectID":"/posts/singlethreaddown/:0:0","tags":["GUI","URLConnection","HTTP","Java"],"title":"java 实现一个单线程的资源下载器","uri":"/posts/singlethreaddown/"},{"categories":["Java"],"content":"GUI 设计基本流程 先记录一下 GUI 设计的基本流程： 根据需要从相应的顶层容器继承（如果创建窗体就继承 JFrame，对话框就继承 JDialog），新建一个子类。 然后设置顶层容器的属性，包括大小、位置、标题和关闭事件等。 设置界面上 GUI 组件的事件响应。 public void actionPerformed(ActionEvent e) {} 向顶层容器上添加 GUI 组件，并设置布局。（通常利用 JPanel 组件先作为微型容器） 创建新建子类的实例，调用 setVisible(true) 方法显示页面。（也可以直接在子类中设置 setVisible(true)） ","date":"2019-05-08","objectID":"/posts/singlethreaddown/:1:0","tags":["GUI","URLConnection","HTTP","Java"],"title":"java 实现一个单线程的资源下载器","uri":"/posts/singlethreaddown/"},{"categories":["Java"],"content":"实现代码 package cn.lruihao.base; import java.awt.FlowLayout; import java.awt.Font; import java.awt.HeadlessException; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.FileOutputStream; import java.io.InputStream; import java.net.URL; import java.net.URLConnection; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JTextField; public class SingleThreadDown extends JFrame implements ActionListener { private final JPanel panel=new JPanel(); private final JLabel label1=new JLabel(\"网络资源的单线程下载：\"); private final JLabel label2=new JLabel(\"网络资源的网址：\"); JButton StartButton = new JButton(\"单击开始下载\"); JButton resetButton = new JButton(\"清空\"); JButton exitButton = new JButton(\"退出\"); JTextField urlField = new JTextField(20); public SingleThreadDown() { panel.setLayout(new FlowLayout()); //布局管理器 label1.setFont(new Font(\"雅黑\",Font.BOLD,15)); panel.add(label1); panel.add(label2); panel.add(urlField); panel.add(StartButton); panel.add(resetButton); panel.add(exitButton); setContentPane(panel); setSize(400,200); setLocation(400,400); setVisible(true); //面板可视化，也可以在 main 中通过 JFrame 子类对象调用方法设置 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //默认关闭事件 StartButton.addActionListener(this);//添加点击事件，传入 ActionListener 对象，由于子类继承了 ActionListener 接口，所以 this resetButton.addActionListener(this); exitButton.addActionListener(this); } public void download(String address) throws Exception { URL url = new URL(address); URLConnection urlcon = url.openConnection(); urlcon.connect(); InputStream in=urlcon.getInputStream();//获取的字节流对象 String filePath = url.getFile(); int pos=filePath.lastIndexOf(\"/\"); //\"/\"分割的最后一个串的下标 String fileName = filePath.substring(pos+1); FileOutputStream out = new FileOutputStream(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\\"+fileName); byte[] b = new byte[1024]; int len=0; while((len=in.read(b,0,1024))!=-1) { out.write(b,0,len); } out.close(); in.close(); JOptionPane.showMessageDialog(this, \"下载完毕\"); } @Override public void actionPerformed(ActionEvent e) { if(e.getSource()==StartButton) { if(\"\".equals(urlField.getText())){ JOptionPane.showMessageDialog(this, \"请输入资源地址\"); } String url = urlField.getText(); try { download(url); } catch (Exception e1) { JOptionPane.showMessageDialog(this, \"资源地址有误，请检查~\"); e1.printStackTrace(); } }else if(e.getSource()==resetButton) { urlField.setText(\"\"); }else { System.exit(0); } } public static void main(String[] args) { new SingleThreadDown(); } } ","date":"2019-05-08","objectID":"/posts/singlethreaddown/:2:0","tags":["GUI","URLConnection","HTTP","Java"],"title":"java 实现一个单线程的资源下载器","uri":"/posts/singlethreaddown/"},{"categories":["Java"],"content":"运行结果测试 通过https://github.com/Lruihao/Grocery/raw/master/fonts/MMT_last.ttf下载沐目体 ttf 字体文件，稍微等待一下弹出对话框“下载完毕”，经检查下载内容正常。 ","date":"2019-05-08","objectID":"/posts/singlethreaddown/:3:0","tags":["GUI","URLConnection","HTTP","Java"],"title":"java 实现一个单线程的资源下载器","uri":"/posts/singlethreaddown/"},{"categories":["Python"],"content":" Json（JavaScript Object Notation）它是一种轻量级的数据交换格式，具有数据格式简单，读写方便易懂等很多优点。许多主流的编程语言都在用它来进行前后端的数据传输，大大的简化了服务器和客户端的开发工作量。相对于 XML 来说，更加的轻量级，更方便解析，因此许多开发者都遵循 Json 格式来进行数据的传输和交换。今天我们详细介绍一下 Python 在 Json 的编解码方面的知识。 ","date":"2019-05-07","objectID":"/posts/jsoninfo/:0:0","tags":["Python","JSON","他山之石"],"title":"Python 如何操作 Json？","uri":"/posts/jsoninfo/"},{"categories":["Python"],"content":"json 的数据格式 在 json 中，遵循“键值对”的这样一种方式，比如：“{“name”:“tom”}”, 就是一个 json 格式的数据，json 的格式归纳下来，一般有以下几点： 对象通过键值对表现； 键通过双引号包裹，后面跟冒号“:”，然后跟该键的值； 值可以是字符串、数字、数组等数据类型； 对象与对象之间用逗号隔开； “{}”用来表达对象； “[]”用来表达数组； 我们看一个略为复杂一点的例子： 上例则是一个典型的 json 格式的数据，强大的 Python 提供了一个“json”模块，可以方便的将各种零散的数据通过模块的内置函数编码形成一个 json 格式的数据，也可以将一个 json 格式的数据解码形成自己需要的数据，非常好用，下面我们就来介绍一下。 ","date":"2019-05-07","objectID":"/posts/jsoninfo/:1:0","tags":["Python","JSON","他山之石"],"title":"Python 如何操作 Json？","uri":"/posts/jsoninfo/"},{"categories":["Python"],"content":"json.dumps() json 模块里的 dumps 函数是对数据进行编码，形成 json 格式的数据，我们看一下下面的例子： 通过输出的结果很容易看出，通过 dumps 方法使字典转换成为了 json 格式，虽然它们非常相似。其中，在 dumps 里的参数“sort_keys=True”，使得输出 json 后对 key 和 value 进行 0~9、a~ z 的顺序排序，如果不填，则按照无序排列。有时候，通过排序可以方便地比较 json 中的数据，因此，适当的排序是很有必要的。 此外，“Indent”参数表示缩进的意思，它可以使得输出的 Json 看起来更加整齐好看，可读性更强，例如： 下面列举一下 dumps（）的可填参数： skipkey：默认为 False，当 dict 对象里的数据不是 Python 的基本数据类型；（str,unicode,int,long,float,bool,None）时，当 skipkey 为 False，就会报错，如果 skipkey 为 True，则可以跳过这类 key； indent：如果填 0 或者不填，则按照一行进行打印，否则按照 indent 的数值显示前面的空格（正整数形式）； separators：分隔符，默认为“(’,’,’:’)”，它表示 key 之间用“,”隔开，key 和 value 之间用“:”隔开； encoding：编码格式，默认值是 UTF-8； sort_keys：对 key、value 进行排序，默认值是 False，即不排序； ensure_ascii：默认为 True，如果 dict 对象里含有 none-ASCII 的字符，则显示、uXX 的格式，如果为 False，则能正常显示出来； ","date":"2019-05-07","objectID":"/posts/jsoninfo/:2:0","tags":["Python","JSON","他山之石"],"title":"Python 如何操作 Json？","uri":"/posts/jsoninfo/"},{"categories":["Python"],"content":"json.loads() 和 dumps 相反，loads 函数则是将 json 格式的数据解码，转换为 Python 字典，我们看一下下面的例子： 有时候，输出结果遇到中文的时候，会出现编码格式不一样的情况，显示出为 Unicode 的编码格式，使得不易读懂，解决办法是添加参数“encoding”参数，即上面的改写成这样：d1 = json.loads(data1,encoding=‘utf-8’) 即可。 ","date":"2019-05-07","objectID":"/posts/jsoninfo/:3:0","tags":["Python","JSON","他山之石"],"title":"Python 如何操作 Json？","uri":"/posts/jsoninfo/"},{"categories":["Python"],"content":"json.dump() 和 json.load() 相对于上面所讲的 dumps 和 loads 来说，dump 和 load 函数的功能类似，只不过前者是用来处理字符串类型的，而后者是用于处理文件类型的，如下所示： 上例列举出了 json 的四个方法：dumps（）和 dump（）、loads（）和 load（）的简单使用方法，可见，Python 对于 json 的处理相当方便，不像 c++那样（谁用谁知道）。 ","date":"2019-05-07","objectID":"/posts/jsoninfo/:4:0","tags":["Python","JSON","他山之石"],"title":"Python 如何操作 Json？","uri":"/posts/jsoninfo/"},{"categories":["Python"],"content":" 通过 requests 可以向某个地址发送请求，可以用来做一些接口的测试；主要有两个方法： requests.get() requests.post() 最近帮朋友的项目做一个小需求，需要把后台数据定期打包发送到微信群，麻小科技涛哥给了我一个接口，post 访问。 #!/usr/bin/python import requests \"\"\" 通过 requests 可以向某个地址发送请求 requests.post(url,json date) post 方法还有其他参数，如 header 等 \"\"\" # post 发送的数据 postData = { # 'username':'test', # 'password':'123456', # 'salary':2000, } # 接口这里不便公开 r = requests.post('http://demo.maxiaokeji.com/xx/xxxxx/xxxx',data=postData) # print(r.text) response=r.json() print(response) 运行后会在屏幕打印出返回的 json 数据 ","date":"2019-05-07","objectID":"/posts/posttest/:0:0","tags":["Python","HTTP"],"title":"python 发送 post 请求进行简单的接口测试","uri":"/posts/posttest/"},{"categories":["Java"],"content":" 该例中首先生成一个 URL 对象 lrh，指向 RUI 豪小栈，然后再调用 lrh.openStream() 方法生成该 URL 的一个输入流，这是一个字节流，在此基础上进一步通过 InputStreamReader 和 BufferedReader 构造一个带缓冲功能的字符流，并通过这个字符流对象读取该 URL 的 html 内容，进而输出到桌面文件和控制台屏幕。URLConnection 类也可以用来对由 URL 引用的资源进行读写操作，前提是先通过 connect() 方法建立连接，然后再去获取响应头信息或响应内容。 package cn.lruihao.base; import java.io.BufferedReader; import java.io.File; import java.io.FileWriter; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; public class URLReader { public static void main(String[] args) throws Exception{ try { URL lrh=new URL(\"https://www.lruihao.cn\"); File file=new File(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\lrh.html\"); FileWriter fout=new FileWriter(file); BufferedReader in =new BufferedReader(new InputStreamReader(lrh.openStream()));//字节流转化成字符流，再构建缓冲字符流 String inputLine; while((inputLine=in.readLine())!=null) { System.out.println(inputLine); fout.write(inputLine); } in.close(); fout.close(); //获取响应 header 信息 URLConnection conn=lrh.openConnection(); conn.connect(); System.out.println(\"获取到的响应长度：\"+conn.getContentLength()); System.out.println(\"响应类型：\"+conn.getContentType()); //用 BufferedReader 读取 URL 的响应 in =new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; String result=null; while((line=in.readLine())!=null) { result+=line; } System.out.println(result); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2019-05-06","objectID":"/posts/java-urlreader/:0:0","tags":["URLConnection","Java"],"title":"java 通过 URL 和 URLConnection 访问网页资源","uri":"/posts/java-urlreader/"},{"categories":["Java"],"content":" 基本功能： 给定一个密钥，读取文件内容，加密后，输出到另外一个文件。 这里使用文件输入流读取文件内容，然后每个字节和密码进行异或简单加密。加密完成，使用文件输出流写入另一个文件中。解密和加密方法一样。利用的是对同一个数异或两遍其值不变的性质。因此一个程序可以完成加密和解密功能。只需修改文件名即可。 ","date":"2019-05-02","objectID":"/posts/byteio/:0:0","tags":["Java"],"title":"文件加密解密（字节流）","uri":"/posts/byteio/"},{"categories":["Java"],"content":"文件加密解密 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class EncryptFile { public static void main(String[] args) throws IOException { byte pwd=123;//加密/解密密码 FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/EncryptFile.java\");//待加密文件 FileOutputStream fout=new FileOutputStream(\"encrypted.txt\");//已加密文件 System.out.println(\"开始加密。\"); int n=f.available()/5; byte[] b=new byte[n];//以一个字节数组的长度读取和复制 int count=0; while((count=f.read(b,0,n))!=-1) { //写入之前先加密/解密 for(int i=0;i\u003ccount;i++) { b[i]=(byte)(b[i]^pwd);// } fout.write(b,0,count); } System.out.println(\"完成加密\"); f.close(); fout.close(); // f=new FileInputStream(\"encrypted.txt\"); // fout=new FileOutputStream(\"unencrypted.txt\"); // System.out.println(\"开始解密。\"); // n=f.available()/5; // b=new byte[n];//以一个字节数组的长度读取和复制 // count=0; // while((count=f.read(b,0,n))!=-1) { // //写入之前先加密/解密 // for(int i=0;i\u003ccount;i++) { // b[i]=(byte)(b[i]^pwd); // } // fout.write(b,0,count); // } // System.out.println(\"完成解密\"); // f.close(); // fout.close(); } } ","date":"2019-05-02","objectID":"/posts/byteio/:1:0","tags":["Java"],"title":"文件加密解密（字节流）","uri":"/posts/byteio/"},{"categories":["Java"],"content":"文件复制 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileStreamCopy { public static void main(String[] args) throws IOException { int size; FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/FileStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); System.out.println(\"总长度：\"+(size=f.available())); int n=size/10; System.out.print(\"使用单字节方法读取后：\"); for(int i=0;i\u003cn;i++) { fout.write(f.read()); } System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取一个字节数组后：\"); byte b[]=new byte[n]; f.read(b); fout.write(b); System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取余下数据：\"); int count=0; while((count=f.read(b,0,n))!=-1) { //System.out.println(count); fout.write(b,0,count); } System.out.println(\"剩余长度：\"+f.available()); f.close(); fout.flush(); fout.close(); } } package cn.lruihao.base; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class BufferedStreamCopy { public static void main(String[] args) throws IOException { FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/BufferedStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); BufferedInputStream bis=new BufferedInputStream(f); BufferedOutputStream bos=new BufferedOutputStream(fout); System.out.println(\"开始复制。\"); int n=f.available()/5; byte[] b=new byte[n]; int count=0; while((count=bis.read(b,0,n))!=-1) { bos.write(b,0,count); } System.out.println(\"复制完成\"); bis.close(); bos.flush(); bos.close(); f.close(); fout.flush(); fout.close(); } } ","date":"2019-05-02","objectID":"/posts/byteio/:2:0","tags":["Java"],"title":"文件加密解密（字节流）","uri":"/posts/byteio/"},{"categories":["Java"],"content":"实现代码 这里的异常主要是InputMismatchException, 可以直接捕获该异常，我直接捕获了父类异常。 package cn.lruihao.Exception; import java.util.Scanner; /** * @author 李瑞豪 * 借书系统（异常练习） */ public class ExceptionDemo { private final Book[] books = { new Book(\"数据结构\"), new Book(\"Java\"), new Book(\"php\"), new Book(\"c\") }; public static void main(String[] args) { System.out.println(\"欢迎来到借书系统！\"); ExceptionDemo jieshu= new ExceptionDemo(); jieshu.menu(); } public void menu() { System.out.println(\"输入命令：1. 书名查找；\\t2. 序号查找；\"); //初始化并捕获用户输入 Scanner sc = new Scanner(System.in); // 捕获异常 try { int id =sc.nextInt(); if(id==1||id==2) { inquire(id); }else { System.out.println(\"输入错误！请根据提示输入~~\");//输入非 1，2 的数字情况 menu(); } }catch (Exception e) {//输入字符为非数字 e.printStackTrace(); System.out.println(\"输入错误，请输入数字命令~~\"); menu(); }finally{ sc.close(); } } private void inquire(int id) { Scanner sc = new Scanner(System.in); if(id==1) { System.out.println(\"请输入要查找的书名！\"); String name=sc.nextLine(); int num=FindName(name); if(num==0?false:true) {//验证书名是否存在 存在则打印 System.out.println(\"book：\"+name+\"\\t 序号：\"+num); //menu();//回到访问起点 也可以去掉终止程序 }else{ System.out.println(\"图书不存在\"); menu(); } sc.close(); }else if(id == 2) { System.out.println(\"请输入您要查找的序号：\"); int id2=sc.nextInt(); FindNum(id2); sc.close(); } } private void FindNum(int num) { try { if(num\u003e=0\u0026\u0026num\u003cbooks.length) { System.out.println(books[num].getName()); //menu();//回到访问起点 也可以去掉终止程序 }else{ System.out.println(\"图书不存在\"); menu(); } }catch (Exception e) { e.printStackTrace(); System.out.println(\"输入有误！~~\"); } } private int FindName(String name) { int num=0; for(Book i:books) { String name1=i.getName(); if(name1.equals(name)) { return num; } num++; } return 0; } } package cn.lruihao.Exception; public class Book { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public Book(String name) { this.name = name; } } ","date":"2019-05-01","objectID":"/posts/javaexception/:1:0","tags":["Java"],"title":"模拟借书系统（java 异常练习）","uri":"/posts/javaexception/"},{"categories":["Java"],"content":"大致运行效果 ","date":"2019-05-01","objectID":"/posts/javaexception/:2:0","tags":["Java"],"title":"模拟借书系统（java 异常练习）","uri":"/posts/javaexception/"},{"categories":["瞎折腾","Python"],"content":" Python 二维码生成器是 github 上@sylnsfar 开源的一个 python 生成二维码工具。有 python, 网页及 exe 版本，详见 sylnsfar/qrcode，本文主要介绍记录一下 python 版本使用。exe 可以去 项目开源地址 下载，公众号文章后台回复关键词“qrcode”获取链接。 可生成普通二维码、带图片的艺术二维码（黑白与彩色）、动态二维码（黑白与彩色）。 ","date":"2019-04-27","objectID":"/posts/qrcode/:0:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"示例 from MyQR import myqr import os version, level, qr_name = myqr.run( words='https://lruihao.cn', version=1, level='H', picture='2.jpg', colorized=True, contrast=1.0, brightness=1.0, save_name=None, save_dir=os.getcwd() ) # help(myqr) # https://github.com/sylnsfar/qrcode/ ''' Positional parameter words: str # 链接或者文字 Optional parameters version: int, from 1 to 40 # 控制边长 level: str, just one of ('L','M','Q','H') # 控制纠错水平，从左到右依次升高。 picutre: str, a filename of a image # 图片，需在同路径，默认 None colorized: bool # 是否彩色 默认 False constrast: float # 对比度 默认 1.0 brightness: float # 亮度 默认 1.0 save_name: str, the output filename like 'example.png' #控制文件名，默认 None,'qrcode.png' save_dir: str, the output directory # 储存路径 ''' ","date":"2019-04-27","objectID":"/posts/qrcode/:1:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"安装 # 通过 pip pip(3) install myqr(or MyQR) ","date":"2019-04-27","objectID":"/posts/qrcode/:2:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"使用方法 ","date":"2019-04-27","objectID":"/posts/qrcode/:3:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"命令行方式 （提示：如果你尚未安装 MyQR ，以下内容请使用python(3) myqr.py 而非myqr 。） # 概括 myqr Words [-v {1,2,3,...,40}] [-l {L,M,Q,H}] [-n output-filename] [-d output-directory] [-p picture_file] [-c] [-con contrast] [-bri brightness] 普通二维码 介绍了 Words, -v, -l, -n, -d 艺术二维码 介绍了 -p, -c, -con, -bri 动态 GIF 二维码 介绍了动态的生成方法和注意点 普通二维码 #1 Words myqr https://github.com 在命令后输入链接或者句子作为参数，然后在程序的当前目录中产生相应的二维码图片文件，默认命名为 “qrcode.png”。 #2 -v, -l myqr https://github.com -v 10 -l Q 默认边长是取决于你输入的信息的长度和使用的纠错等级； 而默认纠错等级是最高级的 H。 自定义：如果想要控制边长和纠错水平就使用 -v 和 -l 参数。 -v 控制边长，范围是** 1 至 40**，数字越大边长越大； -l 控制纠错水平，范围是** L、M、Q、H**，从左到右依次升高。 #3 -n, -d myqr https://github.com -n github_qr.jpg -d .../paths/ 默认输出文件名是“ qrcode.png “，而默认存储位置是当前目录。 自定义：可以自己定义输出名称和位置。注意同名文件会覆盖旧的。 -n 控制文件名，格式可以是 .jpg， .png ，.bmp ，.gif ； -d 控制位置。 艺术二维码 #1 -p myqr https://github.com -p github.jpg 参数-p 用来将 QR 二维码图像与一张同目录下的图片相结合，产生一张黑白图片。 #2 -c myqr https://github.com -p github.jpg -c 加上参数 -c 可以使产生的图片由黑白变为彩色的。 #3 -con, -bri myqr https://github.com -p github.jpg [-c] -con 1.5 -bri 1.6 参数-con 用以调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为 1.0。 参数 -bri 用来调节图片的亮度，其余用法和取值与 -con 相同。 动态 GIF 二维码 动态二维码与上述的带图片的二维码的生成方法没什么区别，你只要采用 .gif 格式的图片即可生成黑白或者彩色的动态二维码。但注意如果使用了 -n 参数自定义输出的文件名，切记其格式也必须是 .gif 格式。 ","date":"2019-04-27","objectID":"/posts/qrcode/:3:1","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"作为导入文件 # 安装模块后 from MyQR import myqr version, level, qr_name = myqr.run( words, version=1, level='H', picture=None, colorized=False, contrast=1.0, brightness=1.0, save_name=None, save_dir=os.getcwd() ) 以下各个参数已经在上文命令行方式有所介绍 # help(myqr) Positional parameter words: str Optional parameters version: int, from 1 to 40 level: str, just one of ('L','M','Q','H') picutre: str, a filename of a image colorized: bool constrast: float brightness: float save_name: str, the output filename like 'example.png' save_dir: str, the output directory ","date":"2019-04-27","objectID":"/posts/qrcode/:3:2","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"使用提示 请采用正方形或近似正方形的图片 建议在图片尺寸大的时候使用 -v 的值也应该适当变大。 ","date":"2019-04-27","objectID":"/posts/qrcode/:4:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"可用字符 数字 0 到 9 大小写的英文字母 常用英文标点符号和空格 · , . : ; + - * / \\ ~ ! @ # $ % ^ \u0026 ` ' = \u003c \u003e [ ] ( ) ? _ { } | and (space) ","date":"2019-04-27","objectID":"/posts/qrcode/:5:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"依赖库 pillow numpy imageio ","date":"2019-04-27","objectID":"/posts/qrcode/:6:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["瞎折腾","Python"],"content":"运行环境 Linux, Python 3 Windows, Python 3 Mac, Python 3 ","date":"2019-04-27","objectID":"/posts/qrcode/:7:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["随笔"],"content":" 时间过得真快，一下从大一到了大三，马上就要实习毕业等等了。 Success 富士康在学校有一个春招的机会，我和朋友抱着侥幸的心理去试了试。 虽然深知自己还身有很多缺点，但是不面试不知道，一面试都暴露出来了，以下记录一下自己的不足之处： php 和 sql 的经典组合虽然有所接触了解，但是确实什么都会，得花时间学 html/css 等虽然平时折腾博客这些应用的比较多，但是今天竟然紧张地忘记了 margin 和 padding 都不会写了 如上一条，公众表现能力有待加强。正如当今“酒香也怕巷子深”，何况“不香”。 惊喜的事说来就来，本来知道自己这么多缺点，这么菜后，觉得这个实习的 offer 是没戏了，没想到下午技术主管微信发来消息，说录用了。当场懵逼，受宠若惊的感觉！非常谢谢面试官老师！ 无论生活还是学习，希望以后的自己一定要保持一颗谦逊爱学的心，早日实现全栈工程师的梦想，还有早点存钱把大学学费的贷款还掉！ ","date":"2019-04-24","objectID":"/posts/1thintervivew/:0:0","tags":["面试"],"title":"第一次面试经历","uri":"/posts/1thintervivew/"},{"categories":["瞎折腾","Python"],"content":" 以下程序对 该网址 内的手写体图片进行爬取！这个手写体是我在手机上通过《手迹造字》app 书写的，大概 6886 个字符，历时两年多，目前仍在修改中。字体效果查看 ","date":"2019-04-22","objectID":"/posts/mmtimgpy/:0:0","tags":["Python"],"title":"python 爬取网站图片（图片链接相似）","uri":"/posts/mmtimgpy/"},{"categories":["瞎折腾","Python"],"content":"思路设计 通过观察目标网页中字符图片的链接，很容易发现每个字符图片的直链是由两部分组成。 固定链接 图片文件编号 其中固定连接为https://image.xiezixiansheng.com/users/2010/700/unzip/579767/, 图片文件为xxxxx.png@50q，如果去掉@50q，获取到的图片就是透明背景的不然就是白色背景。然后发现编号大多是 5 位数的形式，但是还有一些是 4 位的，甚至还有 2-3 位的数字。仔细看看 127 前的编号都是一些国际符号诸如英文和数字等。比对一下发现正是 ASCII 码对应的命名方式。可想而知中文自然也是通过编码来命名的。一个标准的字库文件至少包含 6763 个汉字，也就是我书写的这个GB2312-80, 范围： 0xA1A1 - 0xFEFE，其中汉字范围： 0xB0A1 - 0xF7FE。两个 16 进制位对应一个字节，一个汉字至少由两个字节组成，这样理解，范围自然是 4 个 16 进制位。所以转换成 10 进制，范围大致在 65278 以下。要了解更加具体一点的范围还需要去查一下汉字编码的分区等。这里暂时不必了解，因为本来就打算暴力下载。 说了这么多，既然图片链接这么简单，所以我是想暴力遍历，搜索图片，判断链接状态码，然后下载图片。 ","date":"2019-04-22","objectID":"/posts/mmtimgpy/:1:0","tags":["Python"],"title":"python 爬取网站图片（图片链接相似）","uri":"/posts/mmtimgpy/"},{"categories":["瞎折腾","Python"],"content":"源码设计 大致分为三个范围吧 英文字符 中文符号 汉字范围 我主要分这几个区间查找 33 ~ 126 8212 ~ 8243 12289 ~ 12305 19968 ~ 40864 65281 ~ 65509 磨刀不误砍柴工，分析观察了这么久，终于可以运行程序了，F5 后就静静等待吧，可以去看看 java，或者打一把王者 hhhhh! import os import requests path=\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\MMT_images\\\\\" #下载路径： 绝对或者相对路径比如。/image/ os.makedirs(path+\"0\\\\\", exist_ok=True) ## 创建文件夹 os.makedirs(path+\"1\\\\\", exist_ok=True) ## 下载图片 def urllib_download(url,num): ## （下载链接，图片编号） from urllib.request import urlretrieve urlretrieve(url,path+num+\".png\") ## 判断状态码 def get_status(url): r = requests.get(url, allow_redirects = False) return r.status_code def main(): BASE_URL = \"https://image.xiezixiansheng.com/users/2010/700/unzip/579767/\" n=33 total=0 print(\"正在爬取第 1 张图片！\") while n \u003c 65510: #分段爬取，不然会超时！！！## 33 ~ 126 ## 8212 ~ 8243 ## 12289 ~ 12305 ## 19968 ~ 40864 ## 65281 ~ 65509 if n == 127: n = 8212 continue elif n == 8244: n = 12289 continue elif n ==12306: n = 19968 continue elif n == 40865: n = 65281 continue ## for n in range(37341,40865): num = str(n) IMAGE_URL = BASE_URL+num+\".png\" ## xxx.png 是透明背景，xxx.png@50q 是白色背景，分别存放在 0，1 文件夹 p 是中小 w 是小图 if(get_status(IMAGE_URL)==200): ## 同时下载透明和白色背景的图片 total+=1 urllib_download(IMAGE_URL,\"0\\\\\"+num) IMAGE_URL += \"@50q\" urllib_download(IMAGE_URL,\"1\\\\\"+num) print(\"Downloaded \"+num+\".png\") print(\"正在爬取第\",total+1,\"张图片！\") n+=1 print(\"\\n 爬取完毕！共爬取\",total,\"张图片！\") print(\"图片存放路径：\"+path) print(\"作者博客：lruihao.cn\") if __name__==\"__main__\": main(); ","date":"2019-04-22","objectID":"/posts/mmtimgpy/:2:0","tags":["Python"],"title":"python 爬取网站图片（图片链接相似）","uri":"/posts/mmtimgpy/"},{"categories":["瞎折腾","Python"],"content":"爬取过程及结果 文件夹左下角数目变化 爬取过程 危险 说实话看着控制台不停地输出提示信息有没有很爽，对于强迫症来说真的是很治愈了！但是爬取第 6042 张图片的时候，我打开了一下目标网页发现无法加载图片了，就想这应该也算是一次 Dos 攻击了吧！打开控制台果然停了，相当于访问了近两万次！唉，还是太暴力了！！还差 800 多张，只好又重新接着写上次的位置爬！不慎造成目标网站服务器压力，实在对不起！ 错误提示 一个半小时左右后终于下载完了，一共是 6886 张；程序是同时下载了透明和白色背景的图片的！分别在 0,1 子文件夹！ 爬取完毕 ","date":"2019-04-22","objectID":"/posts/mmtimgpy/:3:0","tags":["Python"],"title":"python 爬取网站图片（图片链接相似）","uri":"/posts/mmtimgpy/"},{"categories":["瞎折腾","Python"],"content":"其他思路 模拟浏览器载入 html 文件，获取源码，查找到所有\u003cimg\u003e标签内链接，必要时配合正则表达式，然后下载图片。 ","date":"2019-04-22","objectID":"/posts/mmtimgpy/:4:0","tags":["Python"],"title":"python 爬取网站图片（图片链接相似）","uri":"/posts/mmtimgpy/"},{"categories":["瞎折腾","Python"],"content":" 文中涉及的图片涉及个人隐私，仅做举例，请勿传播 查看微信好友男女比例 查看好友地区分布 群性别统计 ","date":"2019-04-20","objectID":"/posts/wxpy1/:0:0","tags":["Python","wxpy","pyecharts","jieba","他山之石"],"title":"python 玩微信：初探 wxpy","uri":"/posts/wxpy1/"},{"categories":["瞎折腾","Python"],"content":"前期准备 wxpy pyecharts（百度 echarts） ","date":"2019-04-20","objectID":"/posts/wxpy1/:1:0","tags":["Python","wxpy","pyecharts","jieba","他山之石"],"title":"python 玩微信：初探 wxpy","uri":"/posts/wxpy1/"},{"categories":["瞎折腾","Python"],"content":"查看微信好友男女比例 from wxpy import * from pyecharts import Pie bot = Bot(cache_path = True) #定义一个微信机器人 friends = bot.friends(update=False) #获取更新好友列表 male = female = other = 0 for i in friends[1:]: #[1:] 自己是第一个，排除掉 sex = i.sex if sex == 1: male += 1 elif sex == 2: female += 1 else: other += 1 total = len(friends[1:]) #计算总数 #下面为分析 attr = [\"男性\",\"女性\",\"其他\"] v1 = [float(male),float(female),float(other)] pie = Pie(\"饼图-圆环图示例\", title_pos='center') pie.add(\"\", attr, v1, radius=[40, 75], label_text_color=None, is_label_show=True, legend_orient='vertical', legend_pos='left') pie.render(\"sex.html\") ","date":"2019-04-20","objectID":"/posts/wxpy1/:2:0","tags":["Python","wxpy","pyecharts","jieba","他山之石"],"title":"python 玩微信：初探 wxpy","uri":"/posts/wxpy1/"},{"categories":["瞎折腾","Python"],"content":"查看好友地区分布 from wxpy import * from pyecharts import Map #因为获取的列表城市都没有带市字，而 pyecharts 需要带个市字 b = '市' def s(x): return x+b #只提取湖南的 bot = Bot(cache_path = True) friends = bot.friends(update=False).search(province = '湖南') citys = [] for f in friends : city = f.city citys.append(city) r = map(s,citys) cityss = list(r) #为城市计数 a = {} for i in cityss: a[i] = cityss.count(i) a.pop('市') #把字典进行有序拆分为 2 个列表 attrs = [] values = [] for value, attr in a.items(): values.append(attr) attrs.append(value) #开始绘图 map = Map(\"湖南地图示例\", width=1200, height=600) map.add(\"\", attrs, values, maptype='湖南', is_visualmap=True, visual_text_color='#000') map.render(\"city.html\") 以上参考简书 陈思煜 ","date":"2019-04-20","objectID":"/posts/wxpy1/:3:0","tags":["Python","wxpy","pyecharts","jieba","他山之石"],"title":"python 玩微信：初探 wxpy","uri":"/posts/wxpy1/"},{"categories":["瞎折腾","Python"],"content":"统计所有群男女数目 统计结果会自动发送到所有群聊 男女人数和不一定等于总数（有些人不显示性别） #encoding=utf-8 from wxpy import * import numpy def removeAll(the_list, val): return [value for value in the_list if value != val] def stats_text(target_group, group_name): print(group_name + \"群共有：\" + str(len(target_group)) + \"人，其中：\") all_stats_text = [] all_dict = {} ## 乱序先整理一份省份 + 地点的列表 for user in target_group.members: trimed_data = user.province.replace(' ', '') + user.city.replace(' ', '') if trimed_data != '': all_stats_text.append(trimed_data) ## 计数 for data in all_stats_text: if all_stats_text.count(data) != 0: all_dict[data] = all_stats_text.count(data) all_stats_text = removeAll(all_stats_text, data) final_dict = {} for i in sorted(all_dict.keys()): final_dict[i] = all_dict[i] return final_dict def stats_sex(target_group): male = 0 female = 0 other = 0 for user in target_group.members: if user.sex == 1: male = male + 1 if user.sex == 2: female = female + 1 else: other = other + 1 print(\"男的有：\" + str(male) + \"人\") print(\"女的有：\" + str(female) + \"人\") msg = \"男的有：\" + str(male) + \"人、n\" + \"女的有：\" + str(female) + \"人、n\" return msg bot = Bot() target_group = bot.groups(update=True, contact_only=False) for curr_group in target_group: ## 小于 10 人的群过滤掉 if len(curr_group) \u003c 10: continue curr_group.update_group(members_details=True) print(curr_group.name + \"一共有：\" + str(len(curr_group)) + \"人、n\") msg = stats_sex(curr_group) curr_group.send(curr_group.name + \"群，一共有：\" + str(len(curr_group)) + \"人、n\" + msg) ","date":"2019-04-20","objectID":"/posts/wxpy1/:4:0","tags":["Python","wxpy","pyecharts","jieba","他山之石"],"title":"python 玩微信：初探 wxpy","uri":"/posts/wxpy1/"},{"categories":["瞎折腾","Python"],"content":" Python 通过 wxpy 登录微信网页版，爬取好友所有头像并拼接成一张大图。然后删除所有子图。（注释相关代码可以不删除） 文中涉及的图片涉及个人隐私，仅做举例，请勿传播 文中编码由 Sunbelife 提供，来自他的同名微信公众号，本博仅用于学习，侵删 ","date":"2019-04-20","objectID":"/posts/wximgpy/:0:0","tags":["wxpy","pillow","Python"],"title":"基本 python 实现的爬取微信好友头像，并拼接成大图","uri":"/posts/wximgpy/"},{"categories":["瞎折腾","Python"],"content":"依赖 wxpy（Pythone 登录微信） pillow（拼接头像） os（文件夹操作） math（数学计算） wxpy: wxpy 在 itchat 的基础上，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展。 PIL： Python Imaging Library，已经是 Python 平台事实上的图像处理标准库了。PIL 功能非常强大，但 API 却非常简单易用。由于 PIL 仅支持到 Python 2.7，加上年久失修，于是一群志愿者在 PIL 的基础上创建了兼容的版本，名字叫 Pillow，支持最新 Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用 Pillow。 ","date":"2019-04-20","objectID":"/posts/wximgpy/:1:0","tags":["wxpy","pillow","Python"],"title":"基本 python 实现的爬取微信好友头像，并拼接成大图","uri":"/posts/wximgpy/"},{"categories":["瞎折腾","Python"],"content":"安装 pip install -U wxpy -i \"https://pypi.doubanio.com/simple/\" pip install pillow ","date":"2019-04-20","objectID":"/posts/wximgpy/:2:0","tags":["wxpy","pillow","Python"],"title":"基本 python 实现的爬取微信好友头像，并拼接成大图","uri":"/posts/wximgpy/"},{"categories":["瞎折腾","Python"],"content":"运行 如果在 Python IDE 运行出错，可能是因为微信好友的 id 是特殊字符，在 IDE 打印出错，注释掉代码 36 行即可。 from wxpy import * import math import PIL.Image as Image import os import sys import shutil # ### 获取文件所在的绝对路径 def get_dir(sys_arg): sys_arg = sys_arg.split(\"/\") dir_str = \"\" count = 0 for cur_dir in sys_arg: if count == 0: count = count + 1 if count == len(sys_arg): break dir_str = dir_str + cur_dir + \"/\" count = count + 1 return dir_str curr_dir = get_dir(sys.argv[0]) bot = Bot() ## 机器人账号自身 myself = bot.self my_friends = bot.friends(update=True) if not os.path.exists(curr_dir + \"group-images/\"): os.mkdir(curr_dir + \"group-images/\") count = 0 for friend in my_friends: print(friend.nick_name) friend.get_avatar(curr_dir + \"group-images/\" + str(count) + \".jpg\") count = count + 1 ## 获取下载的头像文件 ls = os.listdir(curr_dir + 'group-images') ## 去除非 .jpg 文件 for filter_ls in ls: if \".jpg\" in filter_ls: continue else: ls.remove(filter_ls) ## 排序 ls.sort(key=lambda x:int(x[:-4])) ## 头像墙尺寸 image_size = 2560 each_size = math.floor(image_size/math.floor(math.sqrt(len(ls)))) x_lines = math.ceil(math.sqrt(len(ls))) y_lines = math.ceil(math.sqrt(len(ls))) image = Image.new('RGB', (each_size * x_lines, each_size * y_lines)) x = 0 y = 0 for file_names in ls: try: img = Image.open(curr_dir + \"group-images/\" + file_names) print(\"正在处理\" + file_names.split('.jpg')[0] + \"/\" + str(len(ls))) except IOError: continue else: img = img.resize((each_size, each_size)) image.paste(img, (x * each_size, y * each_size)) x += 1 if x == x_lines: x = 0 y += 1 img = image.save(curr_dir + \"all.jpg\") try: shutil.rmtree(curr_dir + \"group-images/\") print(\"收尾，清理临时文件\") except FileNotFoundError: print(\"没什么好删的\") print(\"！！！\\n 生成完毕了，放在了目录\" + curr_dir + \"，去看看吧。\") print(\"工具作者：@Sunbelife（新浪微博）\") print(\"公众号：Sunbelife\") print(\"感谢使用\") print(\"v1.2\") print(\"2019.4.18\") ","date":"2019-04-20","objectID":"/posts/wximgpy/:3:0","tags":["wxpy","pillow","Python"],"title":"基本 python 实现的爬取微信好友头像，并拼接成大图","uri":"/posts/wximgpy/"},{"categories":["瞎折腾","Python"],"content":"群友全家福 修改 11 行群名称 import itchat import math import PIL.Image as Image import os import shutil ## 变量 itchat.auto_login(hotReload=True,enableCmdQR=False) roomslist = itchat.get_chatrooms(update=True)[0:] itchat.dump_login_status() ## 显示所有的群聊信息，默认是返回保存到通讯录中的群聊 myroom=itchat.search_chatrooms(name=u'绥宁一中高 396 班') #群聊名称 gsq=itchat.update_chatroom(myroom[0]['UserName'], detailedMember=True) num = 0 if not os.path.exists(\"./group-images/\"): os.mkdir(\"./group-images/\") for i in gsq['MemberList']: print(i[\"UserName\"]) img = itchat.get_head_img(userName=i[\"UserName\"],chatroomUserName=myroom[0]['UserName']) fileImage = open(\"./group-images/\" + str(num) + \".jpg\",'wb') fileImage.write(img) fileImage.close() num += 1 ls = os.listdir('./group-images') each_size = int(math.sqrt(float(640*640)/len(ls))) lines = int(640/each_size) image = Image.new('RGBA', (640, 640)) x = 0 y = 0 for i in range(0,len(ls)+1): try: img = Image.open(\"./group-images/\" + str(i) + \".jpg\") except IOError: print(\"Error\") else: img = img.resize((each_size, each_size), Image.ANTIALIAS) image.paste(img, (x * each_size, y * each_size)) x += 1 if x == lines: x = 0 y += 1 image.save(\"all.png\") shutil.rmtree(\"./group-images\") 绥宁一中高 396 班 加个列表，加个循环实现自动爬取所有群聊头像并发送 import itchat import math import PIL.Image as Image import os import shutil ## 变量 itchat.auto_login(hotReload=True,enableCmdQR=False) roomslist = itchat.get_chatrooms(update=True)[0:] itchat.dump_login_status() ## 显示所有的群聊信息，默认是返回保存到通讯录中的群聊 for room in roomslist: print(room['UserName']) gsq=itchat.update_chatroom(room['UserName'], detailedMember=True) num = 0 if not os.path.exists(\"./group-images/\"): os.mkdir(\"./group-images/\") for i in gsq['MemberList']: print(i[\"UserName\"]) img = itchat.get_head_img(userName=i[\"UserName\"],chatroomUserName=room['UserName']) fileImage = open(\"./group-images/\" + str(num) + \".jpg\",'wb') fileImage.write(img) fileImage.close() num += 1 ls = os.listdir('./group-images') each_size = int(math.sqrt(float(640*640)/len(ls))) lines = int(640/each_size) image = Image.new('RGB', (640, 640)) x = 0 y = 0 for i in range(0,len(ls)+1): try: img = Image.open(\"./group-images/\" + str(i) + \".jpg\") except IOError: print(\"Error\") else: img = img.resize((each_size, each_size), Image.ANTIALIAS) image.paste(img, (x * each_size, y * each_size)) x += 1 if x == lines: x = 0 y += 1 image.save(\"all.jpg\") itchat.send(\"写了个好玩的… 测试一下\", room['UserName']) itchat.send_image(\"all.jpg\", room['UserName']) shutil.rmtree(\"./group-images\") ","date":"2019-04-20","objectID":"/posts/wximgpy/:4:0","tags":["wxpy","pillow","Python"],"title":"基本 python 实现的爬取微信好友头像，并拼接成大图","uri":"/posts/wximgpy/"},{"categories":["Java"],"content":" 之所以用记事本来写不是为了装 X 或者什么的。反而恰恰是返璞归真，因为在用 java 语言进行程序开发时，首先是以纯文本的方式编写所有的 java 源程序，并保存成以.java为后缀的文件；然后将这些源程序用javac编译成.class后缀名的字节代码文件；字节代码不是被本地处理器执行的代码，而是能够被 java 虚拟机（JVM）执行的代码。最后用 java 运行工具在 JVM 执行 java 应用程序。 由于 JVM 可以运行在不同的操作系统上，因此同一个字节代码文件可以跨平台运行。 javac java ","date":"2019-04-19","objectID":"/posts/hellojava/:0:0","tags":["Java"],"title":"用记事本编写第一个 java 程序","uri":"/posts/hellojava/"},{"categories":["Java"],"content":"编写 java 用记事本编辑 java 文件，并且把后缀改成.java，文件名和类名要一样。 public class HelloWorld{ public static void main(String[] args){ System.out.println(\"Hello World!\"); } } ","date":"2019-04-19","objectID":"/posts/hellojava/:1:0","tags":["Java"],"title":"用记事本编写第一个 java 程序","uri":"/posts/hellojava/"},{"categories":["Java"],"content":"打开 cmd ","date":"2019-04-19","objectID":"/posts/hellojava/:2:0","tags":["Java"],"title":"用记事本编写第一个 java 程序","uri":"/posts/hellojava/"},{"categories":["Java"],"content":"邮箱 import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexDemo { public static void main(String[] args) { // Pattern 类 正则表达式的编译表示。 Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9_!#$%\u0026'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$\"); String[] emails = {\"admin@lruihao.cn\", \"lruihao.cn\"}; for (String email : emails) { //Matcher 通过解释 Pattern 对字符序列执行匹配操作的引擎 Matcher matcher = pattern.matcher(email); System.out.println(email + \"匹配结果：\" + matcher.matches()); } } } admin@lruihao.cn 匹配结果：true lruihao.cn 匹配结果：false ","date":"2019-04-18","objectID":"/posts/java-regex/:1:0","tags":["regex","Java"],"title":"java 正则表达式练习","uri":"/posts/java-regex/"},{"categories":["Java"],"content":"电话 package base; import java.util.Scanner; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexTest { public static void main(String[] args) { Pattern patter=Pattern.compile(\"^[1][3,4,5,7,8][0-9]{9}$\"); Scanner sc=new Scanner(System.in); String telnum=sc.nextLine(); sc.close(); Matcher matcher=patter.matcher(telnum); System.out.println(telnum+\"匹配结果： \"+matcher.matches()); } } /** * 获取当前的 httpSession * @return */ public static HttpSession getSession() { return getRequest().getSession(); } /** * 手机号验证 * @param str * @return 验证通过返回 true */ public static boolean isMobile(final String str) { Pattern p = null; Matcher m = null; boolean b = false; p = Pattern.compile(\"^[1][3,4,5,7,8][0-9]{9}$\"); // 验证手机号 m = p.matcher(str); b = m.matches(); return b; } /** * 电话号码验证 * @param str * @return 验证通过返回 true */ public static boolean isPhone(final String str) { Pattern p1 = null, p2 = null; Matcher m = null; boolean b = false; p1 = Pattern.compile(\"^[0][1-9]{2,3}-[0-9]{5,10}$\"); // 验证带区号的 p2 = Pattern.compile(\"^[1-9]{1}[0-9]{5,8}$\"); // 验证没有区号的 if (str.length() \u003e 9) { m = p1.matcher(str); b = m.matches(); } else { m = p2.matcher(str); b = m.matches(); } return b; } ","date":"2019-04-18","objectID":"/posts/java-regex/:2:0","tags":["regex","Java"],"title":"java 正则表达式练习","uri":"/posts/java-regex/"},{"categories":["Java"],"content":"身份证 /* 身份证正则表达式 16 或 18 */ public static final String IDCARD=\"((11|12|13|14|15|21|22|23|31|32|33|34|35|36|37|41|42|43|44|45|46|50|51|52|53|54|61|62|63|64|65)[0-9]{4})\" + \"(([1|2][0-9]{3}[0|1][0-9][0-3][0-9][0-9]{3}\" + \"[Xx0-9])|([0-9]{2}[0|1][0-9][0-3][0-9][0-9]{3}))\"; ","date":"2019-04-18","objectID":"/posts/java-regex/:3:0","tags":["regex","Java"],"title":"java 正则表达式练习","uri":"/posts/java-regex/"},{"categories":["Java"],"content":"StringBuffer/StringBuilder（掌握） ","date":"2019-04-14","objectID":"/posts/stringbuffer/:1:0","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"StringBuffer 是线程安全的可变字符串。 StringBuilder 是线程不安全的可变字符串。 和 StringBuffer 的功能一样。就是效率高一些，但是不安全。 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:1:1","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"构造方法： StringBuffer sb = new StringBuffer(); StringBuffer sb = new StringBuffer(50); StringBuffer sb = new StringBuffer(“hello”); ","date":"2019-04-14","objectID":"/posts/stringbuffer/:1:2","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"成员方法：（自己补齐方法和意思） 添加功能 public StringBuffer append(String str): 追加字符串 public StringBuffer insert(int offset,String str): 在指定位置插入字符串 删除功能 public StringBuffer deleteCharAt(int index): 删除指定位置字符 public StringBuffer delete(int start,int end): 删除从指定开始到结束的字符，左闭右开 替换功能 public StringBuffer replace(int start,int end,String str): 以字符串替代从指定开始到结束的字符 反转功能 public StringBuffer reverse(): 反转 截取功能 public String substring(int start): 从指定索引到末尾的字符串 public String substring(int start,int end): 从指定索引开始到指定索引结束的字符串 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:1:3","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"案例： String 和 StringBuffer 的相互转换，通过构造即可。 把数组转成指定的字符串格式 把字符串反转 判断一个字符串是否是对称字符串 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:1:4","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"数组高级部分（理解） ","date":"2019-04-14","objectID":"/posts/stringbuffer/:2:0","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"排序 冒泡排序 相邻元素，两两比较，大的往后放。 public static void bubbleSort(int[] arr) { for(int x=0; x\u003carr.length-1; x++) { for(int y=0; y\u003carr.length-1-x; y++) { if(arr[y]\u003earr[y+1]) { int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; } } } } 选择排序 从 0 开始，依次和后面的比较，小的往前放。 public static void selectSort(int[] arr) { for(int x=0; x\u003carr.length-1; x++) { for(int y=x+1; y\u003carr.length; y++) { if(arr[y] \u003c arr[x]) { int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; } } } } public static void selectSort(int[] a) { int min=0; int temp=0; if((a==null)||(a.length==0)) return; for(int i=0;i\u003ca.length-1;i++) { min=i;//无序区的最小数据数组下标 for(int j=i+1;j\u003ca.length;j++) { //在无序区中找到最小数据并保存其数组下标 if(a[j]\u003ca[min]) { min=j; } } //将最小元素放到本次循环的前端 temp=a[i]; a[i]=a[min]; a[min]=temp; } } ","date":"2019-04-14","objectID":"/posts/stringbuffer/:2:1","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"查找 基本查找 数组无序 二分查找 数组有序 public static int getIndex(int[] arr,int value) { int max = arr.length-1; int min = 0; int mid = (max+min)/2; while(arr[mid] != value) { if(arr[mid] \u003e value) { max = mid - 1; }else if(arr[mid] \u003c value) { min = mid + 1; } if(max \u003c min) { return -1; } mid = (max+min)/2; } return mid; } ","date":"2019-04-14","objectID":"/posts/stringbuffer/:2:2","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"Arrays 工具类（掌握） ","date":"2019-04-14","objectID":"/posts/stringbuffer/:3:0","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"Arrays 是针对数组进行操作的工具类，提供了排序和查找等功能 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:3:1","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"成员方法：（自己补齐方法和意思） 把数组转成字符串 public static String toString(): 将任意类型数据转换成字符串 排序 public static void sort()： 二分查找 public static int binarySearch(int[] arr,int key) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:3:2","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"案例： 把字符串中的字符进行排序 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:3:3","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"基本类型包装类（掌握） ","date":"2019-04-14","objectID":"/posts/stringbuffer/:4:0","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"为了让我们对基本类型进行更多的操作，java 针对每种基本类型提供了对应的包装类类型。 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:4:1","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"分别是哪些呢？ byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 特殊： void Void ","date":"2019-04-14","objectID":"/posts/stringbuffer/:4:2","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"Integer 构造方法 Integer i = new Integer(100); Integer i = new Integer(“100”); 成员方法（自己补齐方法和意思） 把字符串转成 int 类型 String-\u003eint: Integer.parseInt() int-\u003eString: String.valueOf() 或 Integer.toString() JDK5 的新特性 自动装箱： int --\u003e Integer //Integer.valueOf() 自动拆箱： Integer --\u003e int //Integer.intValue() 请解释： Integer i = 100; i+=200; System.out.println(i); byte 缓存池面试题 byte,short,char—\u003e小于 127，否则报-6 的错误（查看 JDK) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:4:3","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"Character 构造方法 Character ch = new Character(‘a’); 成员方法（自己补齐方法和意思） 判断字符是否是大写字母 public boolean isUpperCase(char ch) 判断字符是否是小写字母 public boolean isLowerCase(Char ch) 判断字符是否是数字字符 public boolean isDigit(Char ch) 把字符转成大写 public Char toUpperCase(Char ch) 把字符转成小写 public Char toLowerCase(Char ch) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:4:4","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["ACM"],"content":"题目大意： 题目链接 老鼠有 M 磅猫食 , 有 N 个房间 , 每个房间前有一只猫 , 房间里有老鼠最喜欢的食品 J[i] , 若要得到房间的食物 , 必须付出相应的猫食 F[i] , 当然这只老鼠没必要每次都付出所有的 F[i]，若它付出 F[i] 的 a%， 则得到 J[i] 的 a%，求老鼠能吃到的最多的食物。 ","date":"2019-04-12","objectID":"/posts/hdu1009/:1:0","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade（贪心）","uri":"/posts/hdu1009/"},{"categories":["ACM"],"content":"Sample Input 5 3 7 2 4 3 5 2 20 3 25 18 24 15 15 10 -1 -1 ","date":"2019-04-12","objectID":"/posts/hdu1009/:1:1","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade（贪心）","uri":"/posts/hdu1009/"},{"categories":["ACM"],"content":"Sample Output 13.333 31.500 ","date":"2019-04-12","objectID":"/posts/hdu1009/:1:2","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade（贪心）","uri":"/posts/hdu1009/"},{"categories":["ACM"],"content":"分析 老鼠要用最少的猫粮来换取最多的食物 , 也就是 J[i]/F[i] 越大越好 , 所以按照 J[i]/F[i] 进行降序排列 , 然后依次用猫粮来换取食物 , 当所剩下的猫粮不足以完全换取食物 , 能换多少是多少。 #include\u003cstdio.h\u003e #include\u003calgorithm\u003e using namespace std; struct node{ double j; double f; double s; }a[1005]; int cmp(node x,node y){ return x.s\u003ey.s; } int main(){ int m,n,i; while(scanf(\"%d%d\",\u0026m,\u0026n)\u0026\u0026(m!=-1\u0026\u0026n!=-1)){ memset(a,0,sizeof(a)); for(i=0;i\u003cn;i++){ scanf(\"%lf%lf\",\u0026a[i].j,\u0026a[i].f); a[i].s=a[i].j/a[i].f; } sort(a,a+n,cmp); double sum=0; for(i=0;i\u003cn;i++){ if(m\u003e=a[i].f){ sum+=a[i].j; m-=a[i].f; }else{ sum+=a[i].s*m; m=0; } if(m\u003c=0) break; } printf(\"%.3lf\\n\",sum); } return 0; } ","date":"2019-04-12","objectID":"/posts/hdu1009/:2:0","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade（贪心）","uri":"/posts/hdu1009/"},{"categories":["OS"],"content":" 一直都想在自己电脑上搭建一个网站或者把自己的电脑做成服务器，今天终于简单实现了。还有很多知识需要学习，简单记录一下。 ","date":"2019-04-03","objectID":"/posts/ngrok/:0:0","tags":["ngrok","linux","宝塔面板","server","ubuntu"],"title":"本地搭建网站服务器并穿透内网","uri":"/posts/ngrok/"},{"categories":["OS"],"content":"搭建环境 我的电脑是ubuntu+windows双系统的，所以我先在 ubuntu 上面装了一个宝塔面板，方便通过 web 管理电脑，宝塔安装好后安装相关的环境mysql,php,nginx等。我们现在只能通过本地 ip127.0.0.1:8888访问面板。 ","date":"2019-04-03","objectID":"/posts/ngrok/:1:0","tags":["ngrok","linux","宝塔面板","server","ubuntu"],"title":"本地搭建网站服务器并穿透内网","uri":"/posts/ngrok/"},{"categories":["OS"],"content":"ngrok 穿透 去 ngrok 注册登录，购买隧道（有免费的），然后绑定端口，绑定域名，这里我们拿端口8888和域名test.lruihao.cn做实验，也就是宝塔面板的端口，这样我们就可以透过域名远程访问本地服务器，这样是不是开始有云服务器的感觉了。然后宝塔面板设置也绑定好域名test.lruihao.cn,dns 服务商那里做好相应的解析。 然后在 ngrok 那里下载 sunny 客户端文件，我们是 ubuntu 选择linux-64bits版本。解压后在 ubuntu 打开终端进入 sunny 文件目录，权限给到 755，运行命令./sunny clientid xxxxxxx 后面的你的隧道订单的 id。 现在就可以通过互联网访问我的 ubuntu 服务器了。 ","date":"2019-04-03","objectID":"/posts/ngrok/:2:0","tags":["ngrok","linux","宝塔面板","server","ubuntu"],"title":"本地搭建网站服务器并穿透内网","uri":"/posts/ngrok/"},{"categories":["OS"],"content":"搭建网站 前面两步搞定，搭建网站就没问题了。 我们只要把网站的端口按第二步的在 ngrok 设置好就可以穿透了。 ","date":"2019-04-03","objectID":"/posts/ngrok/:3:0","tags":["ngrok","linux","宝塔面板","server","ubuntu"],"title":"本地搭建网站服务器并穿透内网","uri":"/posts/ngrok/"},{"categories":["OS"],"content":"注意 访问本地网站的必要条件是你的电脑得是开机状态而且有网络。 ","date":"2019-04-03","objectID":"/posts/ngrok/:4:0","tags":["ngrok","linux","宝塔面板","server","ubuntu"],"title":"本地搭建网站服务器并穿透内网","uri":"/posts/ngrok/"},{"categories":["Memo"],"content":" 原文链接 “卓越班”到了大三突然掀起一股毕业慌，一部分人投身于考研的热潮中，一部分人选择了培训机构学习技术。而我出于种种原因既不考研也不培训，选择自学 java 和 web 相关的知识，也希望因此能在以后谋得一份心仪的工作。 如果文章中有出现纰漏、错误之处，还请看到的小伙伴多多指教，先行谢过 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:0:0","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"HTML ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:0","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"1. Doctype 作用，HTML5 为什么只需要写 \u003c!DOCTYPE HTML\u003e doctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。\u003c!DOCTYPE\u003e声明必须是 HTML 文档的第一行，位于 html 标签之前 HTML5 不基于 SGML，所以不需要引用 DTD。在 HTML5 中\u003c!DOCTYPE\u003e只有一种 SGML: 标准通用标记语言，是现时常用的超文本格式的最高层次标准 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:1","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"2. 行内元素有哪些，块级元素有哪些，空 (void) 元素有那些 行内元素：a span i img input select b 等 块级元素：div ul ol li h1~h6 p table 等 空元素：br hr link 等 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:2","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"3. 简述一下你对 HTML 语义化的理解 简单来说，就是合适的标签做合适的事情，这样具有以下好处： 有助于构架良好的 HTML 结构，有利于搜索引擎的建立索引、抓取，利于 SEO 有利于不同设备的解析 有利于构建清晰的机构，有利于团队的开发、维护 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:3","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"4. 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解 Trident 内核：IE Gecko 内核：NETSCAPE6 及以上版本，火狐 Presto 内核：Opera7 及以上。[Opera 内核原为：Presto，现为：Blink;] Webkit 内核：Safari，Chrome 等。[Chrome 的：Blink（WebKit 的分支）] 浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。 渲染引擎主要负责取得网页的内容、整理讯息、计算网页的显示方式等，JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:4","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"5. html5 有哪些新特性 语义化标签：header footer nav section article aside 等 增强型表单：date（从一个日期选择器选择一个日期） email（包含 e-mail 地址的输入域） number（数值的输入域） range（一定范围内数字值的输入域） search（用于搜索域） tel（定义输入电话号码字段） 等 视频和音频：audio video Canvas 绘图 SVG 绘图 地理定位：Geolocation 拖放 API：drag web worker：是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能 web storage: localStorage sessionStorage WebSocket: HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:5","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"6. 描述一下 cookie，sessionStorage 和 localStorage 的区别 特性 Cookie localStorage sessionStorage 生命周期 可设置失效时间，没有设置的话，默认是关闭浏览器后失效 除非被手动清除，否则将会永久保存 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 存放数据大小 4KB 左右 可以保存 5MB 的信息 可以保存 5MB 的信息 http 请求 每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:6","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"7. 如何实现浏览器内多个标签页之间的通信 使用 localStorage: localStorage.setItem(key,value)、localStorage.getItem(key) websocket 协议 webworker 多个标签页之间的通信 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:7","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"8. HTML5 的离线存储怎么使用，解释一下工作原理 HTML5 的离线存储 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:8","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"9. src 与 href 的区别 区别：src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系 \u003clink href=\"style.css\" rel=\"stylesheet\" /\u003e浏览器加载到这里的时候，html 的渲染和解析不会暂停，css 文件的加载是同时进行的 \u003cscript src=\"script.js\"\u003e\u003c/script\u003e当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个 js 文件 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:9","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"10. 表单提交中 Get 和 Post 方式的区别 Get 一般用于从服务器上获取数据，Post 向服务器传送数据 Get 传输的数据是拼接在 Url 之后的，对用户是可见的；Post 的传输数据对用户是不可见的 Get 传送的数据量较小，不能大于 2KB。Post 传送的数据量较大，一般被默认为不受限制 Get 安全性非常低，Post 安全性较高 在 FORM 提交的时候，如果不指定 Method，则默认为 Get 请求 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:10","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"CSS ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:0","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"1. css 盒子模型，box-sizing 属性的理解 css 的盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。但盒子的大小由 content+padding+border 这几部分决定 box-sizing 是一个 CSS3 属性，与盒子模型有着密切联系。即决定元素的宽高如何计算，box-sizing 有三个属性： box-sizing: content-box|border-box|inherit: content-box 使得元素的宽高即为内容区的宽高（默认模式） border-box: 计算方式 content + padding + border = 本身元素大小，即缩小了 content 大小 inherit 指定 box-sizing 属性的值，应该从父元素继承 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:1","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方式： 为父元素设置高度 为父元素添加overflow:hidden 伪元素 .fix::after { content: ''; display: block; clear: both; } 使用伪元素的好处：不增加冗余的 DOM 节点，符合语义化 overflow:hidden 可以触发 BFC 机制。BFC：块级格式化上下文，创建了 BFC 的元素就是一个独立的盒子，它规定了内部如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素，计算 BFC 的高度时，浮动元素也参与计算 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:2","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"3. 如何让一个不定宽高的盒子水平垂直居中 定位的方式 .father { position: relative; } .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; } css3 属性 .father { position: relative; } .son { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex 布局 .father { display: flex; justify-content: center; align-items: center; } ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:3","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"4. px 和 em 和 rem 的区别 px: 像素，相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em的值并不是固定的，会继承父级元素的字体大小，代表倍数 rem的值并不是固定的，始终是基于根元素 \u003chtml\u003e 的，也代表倍数 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:4","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"5. position 的值有哪些 static： 默认值。没有定位，元素出现在正常的流中 relative（相对定位）：生成相对定位的元素，相对于其正常（原先本身）位置进行定位 absolute（绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位 fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:5","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"6. display:none 与 visibility：hidden 的区别 区别 display:none visibility：hidden 的 是否占据空间 不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中） 该元素空间依旧存在 是否渲染 会触发 reflow（回流），进行渲染 只会触发 repaint（重绘），因为没有发现位置变化，不进行渲染 是否是继承属性 不是继承属性，元素及其子元素都会消失 是继承属性，若子元素使用了 visibility:visible，则不继承，这个子孙元素又会显现出 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:6","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"7. CSS 中 link 和@import 的区别 link 属于 XHTML 标签，@import 完全是 CSS 提供的一种方式，只能加载 CSS 加载顺序的差别，当一个页面被加载的时候，link 引用的 CSS 会同时被加载，而@import 引用的 CSS 会等到页面全部被下载完再被加载 兼容性的差别。由于@import 是 CSS2.1 提出的所以老的浏览器不支持，而 link 标签无此问题 当使用 javascript 控制 dom 去改变样式的时候，只能使用 link 标签，因为@import 不是 dom 可以控制的 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:7","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"8. 什么是响应式设计，响应式设计的基本原理是什么 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:8","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"9. 为什么要初始化 CSS 样式 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异 初始化样式会对 SEO 有一定的影响 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:9","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"10. CSS3 有哪些新特性 实现圆角border-radius，阴影box-shadow，边框图片border-image 对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient 实现旋转transform:rotate(90deg), 缩放scale(0.85,0.90),translate(0px,-30px)定位，倾斜skew(-9deg,0deg); 增加了更多的 CSS 选择器、多背景、rgba() 唯一引入的伪元素是::selection； 实现媒体查询@media，多栏布局flex 过渡transition 动画animation ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:10","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"11. ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用 单冒号 (:) 用于 CSS3 伪类，双冒号 (::) 用于 CSS3 伪元素。（伪元素由双冒号和伪元素名称组成）, 双冒号是在当前规范中引入的，用于区分伪类和伪元素 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:11","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"12. CSS 优化、提高性能的方法有哪些 移除空的 css 规则（Remove empty rules） 正确使用 display 的属性 不滥用浮动、web 字体 不声明过多的 font-size 不在选择符中使用 ID 标识符 遵守盒模型规则 尽量减少页面重排、重绘 抽象提取公共样式，减少代码量 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:12","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"13. 重绘和回流 重绘和回流 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:13","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"14. flex 布局 flex 布局教程–阮一峰 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:14","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["Memo"],"content":"15. css 预处理器 提供了一种 css 的书写方式，常见的就是 SAAS 文档 和 LESS 文档 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:15","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["ACM"],"content":" 我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 设公鸡，母鸡，小鸡数目分别为 x,y,z(x\u003c=20,y\u003c=33,z\u003c=100) ","date":"2019-03-30","objectID":"/posts/bqbj/:0:0","tags":["ACM"],"title":"百钱百鸡（枚举法）","uri":"/posts/bqbj/"},{"categories":["ACM"],"content":"约束条件 x+y+z=100 5x+3y+z/3=100 ","date":"2019-03-30","objectID":"/posts/bqbj/:1:0","tags":["ACM"],"title":"百钱百鸡（枚举法）","uri":"/posts/bqbj/"},{"categories":["ACM"],"content":"算法分析 若依次枚举 x,y,x, 则至少尝试 21*34*100=71400 次，显然效率太低。 在 x,y 的数目确定后，z 的数目也就确定下来了 100-x-y，无须再进行枚举，此时约束条件只有一个 5x+3y+z/3=100. 只需枚举 x,y，共 21*34=714 次。 ","date":"2019-03-30","objectID":"/posts/bqbj/:2:0","tags":["ACM"],"title":"百钱百鸡（枚举法）","uri":"/posts/bqbj/"},{"categories":["ACM"],"content":"算法设计 #include\u003cstdio.h\u003e int main(){ int x,y,z; for(x=0;x\u003c=20;x++) //21*34=714 for(y=0;y\u003c=33;y++){ z=100-y-x; if(z%3==0 \u0026\u0026 (5*x+3*y+z/3)==100){//限定 z 能被 3 整除，进一步提高效率 printf(\"cock number:%d\\t\",x); printf(\"hen number:%d\\t\",y); printf(\"chick number:%d\\n\",z); } } return 0; } 运行解 cock number:0 hen number:25 chick number:75 cock number:4 hen number:18 chick number:78 cock number:8 hen number:11 chick number:81 cock number:12 hen number:4 chick number:84 ","date":"2019-03-30","objectID":"/posts/bqbj/:3:0","tags":["ACM"],"title":"百钱百鸡（枚举法）","uri":"/posts/bqbj/"},{"categories":["ACM"],"content":" 大数乘法 c 版(基础写法) #include\u003cstdio.h\u003e #include\u003cstring.h\u003e #define N 202 int main() { int a[N] = {0}, b[N] = {0}, c[404] = {0}, la, lb, i, j,k, d = 0, n1, n2;//202位数相乘，最长404位数 int get(int *p); void change(int *a, int *b, int n); la = get(a); lb = get(b); n1 = la \u003e lb ? la : lb;//较长的数长 n2 = la \u003c lb ? la : lb;//较短的数长 if (la \u003c lb) change(a, b, lb); //模拟乘法运算过程（进位等考虑） for (i = 0; i \u003c n2; i++) { for (j = 0; j \u003c n1; j++) { c[j + i] += (b[i] * a[j] + d)%10; d = (b[i] * a[j] + d) / 10; if (c[j+i]\u003e9){ d++; c[j+i]%=10; } if (a[j+1]==0\u0026\u0026d!=0){ k=j+i+1; c[k]=d; } } d=0; } k=k\u003e(j+i-2)?k:j+i-2; for (i = k; i \u003e= 0; i--)//将倒序装入的结果打印 printf(\"%d\", c[i]); return 0; } //输入字符串作为数字，并返回数字去除前导0后的长度 int get(int *p) { char x[N]; int l, i, ex = 0; scanf(\"%s\", x); l = strlen(x); while (x[ex] == '0') ex++; for (i = ex; i \u003c l; i++) //提取字符串数字到int数组，倒序排列 *(p + l - i - 1) = x[i] - '0'; return l - ex; } void change(int *a, int *b, int n) { int i, t; for (i = 0; i \u003c n; i++) { t = a[i]; a[i] = b[i]; b[i] = t; } } 程序运行结果 1234567890123456789 98765432109876543210 121932631124517831023715309991126352690 ","date":"2019-03-28","objectID":"/posts/dacheng/:0:0","tags":["数学","大数运算","ACM","C"],"title":"大数乘法","uri":"/posts/dacheng/"},{"categories":["Grocery"],"content":" 记录自己在配置 vps 及博客 SSL 证书时遇到的问题。 ","date":"2019-03-28","objectID":"/posts/http2https/:0:0","tags":["SSL","redirect","CDN","JavaScript","server"],"title":"vps 配置 ssl 及 https 重定向","uri":"/posts/http2https/"},{"categories":["Grocery"],"content":"强制重定向 https 有一种情况相信很多人都遇到过，就是虽然我们配置了 ssl 证书，但是 https 和 http 地址都是各自都可以单独访问。我们应该也见过类似于 github 的代码托管网站有强制 https 的开关。如果是这种情况我们还可以通过 js 进行 301 定向。 \u003cscript\u003e var targetProtocol = \"https:\"; var host = \"lruihao.cn\"; if (window.location.host == host \u0026\u0026 window.location.protocol != targetProtocol){ window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); } \u003c/script\u003e ","date":"2019-03-28","objectID":"/posts/http2https/:1:0","tags":["SSL","redirect","CDN","JavaScript","server"],"title":"vps 配置 ssl 及 https 重定向","uri":"/posts/http2https/"},{"categories":["Grocery"],"content":"腾讯云 CDN 配置 这个博客后来是转到了腾讯云的 cos 桶存储。当时在桶内静态网站设置的时候，设置强制 https 发现会出错。而且还接入了 CDN，所以今天在 CDN 设置那里也看到了 https 的设置，打开强制 https 就 OK 了。这天在三丰云撸了一个免费的主机，搭了一个 WordPress（想试试 wp 的感觉），然后 vps 的 SSL 问题现在也很简单了，第一步，到腾讯云申请免费证书；第二步，配置 CDN，按步骤来，其中接入方式选择自有源站；第三步，强制 https（可选）。 ","date":"2019-03-28","objectID":"/posts/http2https/:2:0","tags":["SSL","redirect","CDN","JavaScript","server"],"title":"vps 配置 ssl 及 https 重定向","uri":"/posts/http2https/"},{"categories":["Memo"],"content":"基于 hexo-theme-next 6.0+的 Pisces 模板做的 DIY 扩展性设计","date":"2019-03-21","objectID":"/posts/hexo-theme-next/","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":" 危险 如无必要，不再更新！（2019.09.13） 今晚我做出了一个慎重的决定，由于博主时间精力有限，需要更多的时间来工作和学习。所以我将放弃对 next 的主题的自定义修改，next 主题官方已经更新到了 7.0+的版本，喜欢 next 主题风格的朋友可以在 github 更新。 我这也算是上古版本了，版本差距实在过大，所以我也将放弃博客使用主题的更新。 以下仍为当前博客使用主题，lib 资源已打包 github。 next 基于 hexo-theme-next 6.0+ 的 Pisces 模板做的 DIY 扩展性设计（部分兼容 next 其他几种模板）。主要是一些 custom style 还有一些第三方的 js。修改的地方太多也有点小乱就不提 PR 了。 modified 官方 Demo =\u003e https://theme-next.org 记录一下折腾过程，以后备份恢复博客也好方便自己。本文之前的美化修改请见 hexo 标签。 主题中若有遗漏第三方插件或应用的 key 及 id 值等请修改为自己对应的值 主要的几个自定义文件 _config.swig #主题配置文件 相关账户信息自己注册替换 \\layout\\custom\\head.swig #在头部自定义加入标签 \\layout\\custom\\google_adsense.swig #谷歌广告模块，内有注释暂时弃用 \\layout\\_layout.swig #主布局 \\layout\\_macro\\post.swig #文章布局 \\layout\\_macro\\post-copyright.swig #文章版权 \\layout\\_macro\\siderbar.swig #侧栏模板 \\layout\\_third-party\\copy-code.swig #复制按钮 \\layout\\_partials\\comments.swig #评论主模板 \\layout\\_partials\\footer.swig #底部模板#该模块在 layout.swig 引入，用于在 body 自定义标签 \\layout\\_partials\\footer_custom.swig #footer 自定义文件 \\layout\\_third-party\\custom.swig #该模块在 layout.swig 引入用于在 body 自定义标签 \\source\\css\\_custom\\customs.styl #主要用户自定义样式表 \\source\\fonts\\ #引入了一些我的手写体及外部字体 \\scripts\\qcloudcdn.js #腾讯云 cos 桶刷新缓存的脚本，不需要可删掉 [^1] ^1 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:0:0","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"初步安装 安装整个改过的主题，然后下载相应的 lib 资源解压放入 source 文件夹 cd hexo git clone https://github.com/Lruihao/hexo-theme-next themes/next 主题配置文件_config.yml, 选择主题 theme: next lib 下载 http://github.com/Lruihao/hexo-theme-next/releases/tag/v6.9.1 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:1:0","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"更新内容 更多自定义详见源码 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:0","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"links 模板 自定义友链模板，打开hexo\\themes\\next\\layout\\新建links.swig文件，写下以下内容后保存。 {% extends '_layout.swig' %} {% import '_macro/sidebar.swig' as sidebar_template %} {% block title %}{# #}{% set page_title_suffix = ' | ' + title %}{# #}{% if page.type === \"categories\" and not page.title %}{# #}{{ __('title.category') + page_title_suffix }}{# #}{% elif page.type === \"tags\" and not page.title %}{# #}{{ __('title.tag') + page_title_suffix }}{# #}{% elif page.type === \"photos\" and not page.title %}{# #}{{ __('title.photos') + page_title_suffix }}{# #}{% else %}{# #}{{ page.title + page_title_suffix }}{# #}{% endif %}{# #}{% endblock %} {% block page_class %}page-post-detail{% endblock %} {% block content %} \u003cdiv id=\"posts\" class=\"posts-expand\"\u003e {##################} {#### PAGE BLOCK ###} {##################} \u003cdiv class=\"post-block page\"\u003e {% include '_partials/page-header.swig' %} {#################} {#### PAGE BODY ###} {#################} \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003cdiv class=\"post-body{% if theme.han %} han-init-context{% endif %}{% if page.direction \u0026\u0026 page.direction.toLowerCase() === 'rtl' %} rtl{% endif %}\"\u003e \u003cdiv class=\"links-list\"\u003e {% for svg,link in site.data.links %} \u003cdiv class=\"card-box\" title=\"{{ link.info }}\"\u003e \u003ca href=\"{{ link.site }}\" target=\"_blank\"\u003e {% if link.avatar %} \u003cimg class=\"card-avatar\" data-original=\"{{ link.avatar }}\" alt=\"{{ link.nickname }}\"/\u003e {% else %} \u003csvg class=\"card-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{svg+1}}\"\u003e\u003c/use\u003e \u003c/svg\u003e {% endif %} \u003cspan title=\"{{ link.nickname }}\"\u003e@{{ link.nickname }}\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e {% endfor %} \u003c/div\u003e {{ page.content }} \u003c/div\u003e \u003cstyle\u003e /* @Author: lruihao.cn */ .links-list { margin-top: 1rem; display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; } .card-box { width: 150px; height: 200px; font-size: 1rem; text-align: center; background: rgba(255,255,255,0.3); box-sizing: border-box; box-shadow: 3px 3px 5px #aaa; border-radius: 5px; transition-duration: 0.3s; margin-bottom: 1rem; display: flex; flex-direction: column; } .card-box:hover { background: #fff; transform: scale(1.03); box-shadow: 0 0 3px #aaa; } .card-box a { border:none; } .card-avatar { width: 100%!important; height: 150px!important; border-radius: 5px; margin: 0; padding: 0; } .card-box span{ display: block; position: relative; bottom: 1rem; align-self: flex-end; color: #2bbc8a; font-weight: bold; max-width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; margin-top: 15px; } .card-box span:hover { color: #d480aa; } \u003c/style\u003e {#####################} {#### END PAGE BODY ###} {#####################} \u003c/div\u003e {% include '_partials/breadcrumb.swig' %} {######################} {#### END PAGE BLOCK ###} {######################} \u003c/div\u003e {% endblock %} {% block sidebar %} {{ sidebar_template.render(false) }} {% endblock %} {% block script_extra %} {% include '_scripts/pages/post-details.swig' %} {% endblock %} 若未使用懒加载请将模板中的data-original属性改为src 若懒加载无法加载预览图请手动添加src=\"/images/loading.gif\" 若 fancybox 显示 alt 内容请更换 fancybox2 或者将 alt 属值删除 \u003cimg class=\"card-avatar\" data-original=\"{{ link.avatar }}\" alt=\"{{ link.nickname }}\"/\u003e 然后hexo n page links新建一个页面文章配置写下如下内容： --- title: 友情链接 layout: links --- 然后在links页面文件夹下面新建文件夹_data，再在里面新建links.yml，内容如下 - nickname: 博採眾長 avatar: http://lruihao.cn/images/avatar.png site: http://lruihao.cn info: 一个菜鸟的博客 - nickname: #友链名称 avatar: #友链头像 site: #友链地址 info: #友链说明 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:1","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"备案信息自定义 ## ------------------------------------------------------------- ## footer_custom Settings ## ------------------------------------------------------------- beian: enable: true gov: 湘公网安备 43030402000254 号 recordcode: 43030402000254 icp: 湘 ICP 备 18020535 号 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:2","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"文字抖动特效 \u003cdiv class=\"shaky\"\u003e（づ●'◡'●) づ ❥内容区\u003c/div\u003e （づ●'◡'●) づ ❥内容区 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:3","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"左下角微信公众号 \\source\\css\\_custom\\customs.styl ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:4","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"相关文章收纳 加入 H5 标签，实现可收纳功能，点击查看详情。 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:5","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"Chat Services 共 chatra,tidio,daovoice 三个选项，三选一 ## Chatra Support ## See: https://chatra.io ## Dashboard: https://app.chatra.io/settings/general chatra: enable: false async: true id: ## visit Dashboard to get your ChatraID #embed: ## unfinished experimental feature for developers, See: https://chatra.io/help/api/#injectto ## Tidio Support ## See: https://www.tidiochat.com ## Dashboard: https://www.tidiochat.com/panel/dashboard tidio: enable: false key: ## Public Key, get it from Dashboard, See: https://www.tidiochat.com/panel/settings/developer #在线客服 daovoice: true daovoice_app_id: xxxx ## http://www.daovoice.io/ ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:6","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"pdf 和 Mermaid 解析模块 pdf 传送门 pdf: enable: false ## Default height height: 500px pdfobject: cdn: //cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js ## Mermaid tag mermaid: enable: false ## Available themes: default | dark | forest | neutral theme: forest cdn: //cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:7","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"模仿 csdn 转发样式 ... \u003ca class=\"post-title-link\" href=\"{{ url_for(post.path) }}\" itemprop=\"url\"\u003e + {% if post.repost %} + \u003cspan class=\"repost\"\u003e转\u003c/span\u003e + {% endif %} {{ post.title | default(__('post.untitled'))}} \u003c/a\u003e {% else -%} + {% if post.repost %} + \u003cspan class=\"repost\"\u003e转\u003c/span\u003e + {% endif %} {{- post.title -}} ... .repost { color: #5acc79; border: 1px solid #e7f4df; border-radius: 20px; padding: 2px 5px; font-size: 15px; font-weight: 500; } --- title: xxxx repost: true --- 预览 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:8","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"热度页面 打开hexo\\themes\\next\\layout新建 top.swig 文件，写下如下内容保存： {% extends '_layout.swig' %} {% import '_macro/sidebar.swig' as sidebar_template %} {% block title %}{# #}{% set page_title_suffix = ' | ' + title %}{# #}{% if page.type === \"categories\" and not page.title %}{# #}{{ __('title.category') + page_title_suffix }}{# #}{% elif page.type === \"tags\" and not page.title %}{# #}{{ __('title.tag') + page_title_suffix }}{# #}{% elif page.type === \"photos\" and not page.title %}{# #}{{ __('title.photos') + page_title_suffix }}{# #}{% else %}{# #}{{ page.title + page_title_suffix }}{# #}{% endif %}{# #}{% endblock %} {% block page_class %}page-post-detail{% endblock %} {% block content %} \u003cdiv id=\"posts\" class=\"posts-expand\"\u003e {##################} {#### PAGE BLOCK ###} {##################} \u003cdiv class=\"post-block page\"\u003e {% include '_partials/page-header.swig' %} {#################} {#### PAGE BODY ###} {#################} \u003cdiv class=\"post-body{% if theme.han %} han-init-context{% endif %}{% if page.direction \u0026\u0026 page.direction.toLowerCase() === 'rtl' %} rtl{% endif %}\"\u003e {{ page.content }} \u003cdiv id=\"top\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e #top{ display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; width: 100%; min-height: calc({{ page.limit }} * 20px); } #top div{ width: 400px; height: 40px; max-width: 400px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } #top a{ color: #555; text-decoration: none; outline: 0; border-bottom: 1px solid #999; word-wrap: break-word; } \u003c/style\u003e \u003cscript src=\"https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js\"\u003e\u003c/script\u003e \u003cscript\u003eAV.initialize(\"{{ theme.valine.appid }}\", \"{{ theme.valine.appkey }}\");\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e setTimeout(function(){ var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit({{ page.limit }}); //设置篇数 query.find().then(function (todo) { for (var i=0;i\u003c{{ page.limit }};i++){ var result=todo[i].attributes; time=result.time; title=result.title; category=result.categories url=result.url; var content=\"\u003cdiv\u003e\"+\"【文章热度：\"+time+\"℃】\"+\"\u003ca href='\"+\"{{ config.url }}\"+\"\"+url+\"'\u003e\"+title+\"\u003c/a\u003e\"+\"\u003c/div\u003e\"; document.getElementById(\"top\").innerHTML+=content; } }, function (error) { console.log(\"error\"); }); },1000) \u003c/script\u003e {#####################} {#### END PAGE BODY ###} {#####################} \u003c/div\u003e {% include '_partials/breadcrumb.swig' %} {######################} {#### END PAGE BLOCK ###} {######################} \u003c/div\u003e {% endblock %} {% block sidebar %} {{ sidebar_template.render(false) }} {% endblock %} {% block script_extra %} {% include '_scripts/pages/post-details.swig' %} {% endblock %} 其中第 36 行改成你自己的 leancloud 的 appid 和 appkey, 比如我的是在主题配置文件里面的 valine 配置下，所以我就写成theme.valine.appid。和我一样就不需要修改，其他自行配置。 然后hexo n page top新建一个页面文章配置写下如下内容，limit 表示显示篇数： --- title: 热度 layout: top limit: 20 --- ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:9","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":"复制按钮样式 本来只想简单美化一下变成 night 样式的，后来写完发现 3dbtn 也挺喜欢的。 codeblock: ## Manual define the border radius in codeblock ## Leave it empty for the default 1 border_radius: 5 ## Add copy button on codeblock copy_button: enable: true ## Show text copy result show_result: true ## Style: 'light,night,flat,3dbtn' is currently available, leave it empty or light is default theme style: night ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:10","tags":["hexo"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Java"],"content":" 摘要：Java 基本的对象初始化过程，子类的初始化，以及涉及到父类和子类的转化时可能引起混乱的情况。 ","date":"2019-03-21","objectID":"/posts/substatus/:0:0","tags":["Java"],"title":"Java 父类子类的对象初始化过程","uri":"/posts/substatus/"},{"categories":["Java"],"content":"基本初始化过程 对于一个简单类的初始化过程是： static 修饰的模块（static 变量和 static 块） =\u003e 按照代码顺序依次执行。 ↓ 实例变量 及非 static 模块 =\u003e 按照代码顺序依次执行。 ↓ 构造函数 =\u003e 执行对应的构造函数。 ","date":"2019-03-21","objectID":"/posts/substatus/:1:0","tags":["Java"],"title":"Java 父类子类的对象初始化过程","uri":"/posts/substatus/"},{"categories":["Java"],"content":"子类的初始化过程 父类 static 修饰的模块 ↓ 子类 static 修饰模块 ↓ 父类实例变量和非 static 块 ↓ 父类对应构造函数。当子类对应构造函数中没有显示调用时调用的是父类默认的构造函数。 ↓ 子类实例变量和非 static 块 ↓ 子类构造函数 package code0507; public class Demo { public static void main(String[] args) { Sub sub = new Sub(); System.out.println(sub); } } class Super { int a = 6; public Super() { test(); //被子类同名函数覆盖，优先访问子类 test } int b=9; public void test() { System.out.println(a); } } class Sub extends Super { int a = 8; public Sub() { test(); } public void test() { System.out.println(a); } } 运行结果 0 8 ","date":"2019-03-21","objectID":"/posts/substatus/:2:0","tags":["Java"],"title":"Java 父类子类的对象初始化过程","uri":"/posts/substatus/"},{"categories":["OS"],"content":" 双系统默认启动项是 Ubuntu，而日常使用最多的还是 Windows，所以说很不方便，一不小心就开机到 Ubuntu 去了。今天来设置一下。 ","date":"2019-03-21","objectID":"/posts/windefault/:0:0","tags":["linux","windows","ubuntu"],"title":"ubuntu + windows 双系统默认启动项设置","uri":"/posts/windefault/"},{"categories":["OS"],"content":"修改/etc/default/grub文件 同时按住键盘上的“Ctrl Alt T”三个键（即快捷键“Ctrl+Alt+T”），打开终端窗口。在终端内输入 sudo gedit /etc/default/grub 按 Enter 键确认，提示输入用户密码，输入的用户密码是看不见的，不要管它，输入完成确认即可打开 grub 文件。 把 grub 文件中的 GRUB_DEFAULT=0 中的 0 改为 saved, 把 GRUB_TIMEOUT=10 中的 10 改为 5。（这里的 5 表示开机时等待选择操作系统是时间是 5 秒） 在文件末尾添加 GRUB_SAVEDEFAULT=true后保存文件并退出。 ","date":"2019-03-21","objectID":"/posts/windefault/:1:0","tags":["linux","windows","ubuntu"],"title":"ubuntu + windows 双系统默认启动项设置","uri":"/posts/windefault/"},{"categories":["OS"],"content":"更新启动配置文件 在终端输入 sudo update-grub 按 Enter 键确认 ","date":"2019-03-21","objectID":"/posts/windefault/:2:0","tags":["linux","windows","ubuntu"],"title":"ubuntu + windows 双系统默认启动项设置","uri":"/posts/windefault/"},{"categories":["OS"],"content":"重启 sudo reboot或者点击重启，重启到启动菜单时，选择你要更改为默认启动项的系统，按 Enter 键确认启动即可，下次启动时刚刚选择的系统即为默认启动系统，直到你手动选择启动其他的系统为止。以后可以轻松的来回切换默认系统了。 ","date":"2019-03-21","objectID":"/posts/windefault/:3:0","tags":["linux","windows","ubuntu"],"title":"ubuntu + windows 双系统默认启动项设置","uri":"/posts/windefault/"},{"categories":["瞎折腾","PHP"],"content":" 宅音乐播放器，HTML5 网页播放器，集成后台管理及 API 调用，目前正在开发中，敬请关注~ 原项目 由 IT 技术宅 开源，使用 thinkPHP 开发后台。 fork 地址 是我个人学习模仿的库，也是相当于备份源码。 注： 插件修改于明月浩空免费版，仅用于学习交流，无商业价值，如发现商业传播，将禁止软件的免费使用。 ","date":"2019-03-19","objectID":"/posts/player/:0:0","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"技术栈 后端：thinkphp 5.1 前端：layui 数据库：mysql ","date":"2019-03-19","objectID":"/posts/player/:1:0","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"演示站 已兼容移动端，测试账号仅供测试请勿修改密码！ test test123 https://player.ilt.me/ https://player.lruihao.cn/ ","date":"2019-03-19","objectID":"/posts/player/:2:0","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"安装 ","date":"2019-03-19","objectID":"/posts/player/:3:0","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"视频安装教程 https://www.bilibili.com/video/av46476706 ","date":"2019-03-19","objectID":"/posts/player/:3:1","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"依赖 composer php 5.6+ mysql 5.5+ ","date":"2019-03-19","objectID":"/posts/player/:3:2","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"步骤 安装 php 依赖包 composer install 配置数据库，配置链接数据库名以及用户名密码 /config/database.php 创建数据库 字符编码：utf8 -- UTF-8 Unicode 导入数据库脚本，脚本位置 extend/database ","date":"2019-03-19","objectID":"/posts/player/:3:3","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"伪静态配置 nginx location / { index index.htm index.html index.php; #访问路径的文件不存在则重写 URL 转交给 ThinkPHP 处理 if (!-e $request_filename) { rewrite ^/(.*)$ /index.php?s=$1 last; break; } } apache 项目自带 apache 静态化无需配置 ","date":"2019-03-19","objectID":"/posts/player/:3:4","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"启动项目 添加 public 为 web 根目录 若为 apache 服务器则默认伪静态，nginx 可自行配置伪静态 ","date":"2019-03-19","objectID":"/posts/player/:3:5","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"预览 ","date":"2019-03-19","objectID":"/posts/player/:4:0","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"首页 ","date":"2019-03-19","objectID":"/posts/player/:4:1","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"登陆页面 ","date":"2019-03-19","objectID":"/posts/player/:4:2","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"后台首页 ","date":"2019-03-19","objectID":"/posts/player/:4:3","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"后台播放器管理页面 ","date":"2019-03-19","objectID":"/posts/player/:4:4","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["瞎折腾","PHP"],"content":"后台歌单管理页面 ","date":"2019-03-19","objectID":"/posts/player/:4:5","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["OS"],"content":"极速方便的一键配置与管理，免除繁琐的命令行操作，通过 Web 面板一键即可操作实现。可选择安装 lamp 或者 lnmp 环境，可创建及管理网站，可创建及管理数据库，可创建及管理 FTP 等等。宝塔官网介绍 ","date":"2019-03-18","objectID":"/posts/bt/:0:0","tags":["linux","server","宝塔面板"],"title":"宝塔面板安装","uri":"/posts/bt/"},{"categories":["OS"],"content":"系统要求 操作系统：全新系统（支持 CentOS、Ubuntu、Debian、Fedora、Deepin)， 确保是干净的操作系统，没有安装过其它环境带的 Apache/Nginx/php/MySQL 宝塔 Linux6.0 版本是基于 centos7 开发的，强烈建议使用 centos7.x 系统 内存要求：内存要求最低 512MB，推荐 768MB 以上，纯面板约占系统 60MB 内存. ","date":"2019-03-18","objectID":"/posts/bt/:1:0","tags":["linux","server","宝塔面板"],"title":"宝塔面板安装","uri":"/posts/bt/"},{"categories":["OS"],"content":"安装方法 官方号称 2 分钟装好面板，一键管理服务器。 使用 SSH 连接工具，如宝塔远程桌面助手连接到您的 Linux 服务器后，挂载磁盘，根据系统执行相应命令开始安装（大约 2 分钟完成面板安装）： yum install -y wget \u0026\u0026 wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 sh install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 sudo bash install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 bash install.sh wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 bash install.sh ","date":"2019-03-18","objectID":"/posts/bt/:2:0","tags":["linux","server","宝塔面板"],"title":"宝塔面板安装","uri":"/posts/bt/"},{"categories":["OS"],"content":"搭建 ftp 和云盘服务器 可以很傻瓜式的搭建自己的云盘，和平时用的比较多的 ftp 服务器。搭建静态网站也可以用 ftp 来上传文件。 ","date":"2019-03-18","objectID":"/posts/bt/:3:0","tags":["linux","server","宝塔面板"],"title":"宝塔面板安装","uri":"/posts/bt/"},{"categories":["Memo"],"content":" 下面一些 web 开发的一些总结，还有一些常用到的代码，脚本等！ ","date":"2019-03-18","objectID":"/posts/webbiji/:0:0","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"front-end ","date":"2019-03-18","objectID":"/posts/webbiji/:1:0","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"html HTML+CSS oblique 和 intalic 的区别 这两个都是font-style属性的值，这两个值都能实现倾斜的效果，但是有区别的。 intalic: 这个是字体的倾斜，相当于斜体，字体必须有倾斜属性。 oblique: 这个准确地说是让文字倾斜。相当于斜字，字体不一定要有倾斜属性。 title 显示换行 使用\u0026#10;或使用\u0026#13; \u003ca href=\"#\" title=\"第一行\u0026#10; 第二行\u0026#10; 第三行\"\u003e使用`\u0026#10;`\u003c/a\u003e \u003ca href=\"#\" title=\"第一排\u0026#13; 第二排\u0026#13; 第三排\"\u003e使用`\u0026#13;`\u003c/a\u003e 图片类型选择 图片类型选择 ","date":"2019-03-18","objectID":"/posts/webbiji/:1:1","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"css flexbox Flex 布局将成为未来布局的首选方案，比如说常见的 bootstrap4 的版本就用 flex 替代了 float 来进行排版。 我在网上看到几个很好的教程，图文并茂，一目了然。 A Complete Guide to Flexbox Flex 布局教程：语法篇 实在懒癌发作，笔记本上手抄了笔记我就不写学习总结了，还有网友 Demo 也写了。 ","date":"2019-03-18","objectID":"/posts/webbiji/:1:2","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"javascript keydown 和 keypress keydown：按下键盘键 keypress：紧接着keydown事件触发（只有按下字符键时触发） 如果用户按下了一个字符键不放，就会重复触发keydown和keypress事件，直到用户松开该键为止。 如果用户按下了一个非字符键不放，就会重复触发keydown事件，直到用户松开该键为止。 详解键盘事件 (keydown，keypress，keyup) textContent、innerText 和 innerHTML 的区别 设置标签中的文本内容，应该使用textContent或innerText（更老）属性，区别在于浏览器支援程度 innerHTML能够获得元素内的所有标签内容，也可以设置标签使之生效。（注意防止 XSS 注入） 如果某个属性在浏览器中不支持，那么这个属性的类型是undefined，判断这个属性的类型是不是undefined，就知道浏览器是否支持。 \u003cscript\u003e // 设置任意的标签中间的任意文本内容 function setInnerText(element, text) { //判断浏览器是否支持这个属性 if (typeof element.textContent == \"undefined\") {//不支持 element.innerText = text; } else {//支持这个属性 element.textContent = text; } }; \u003c/script\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:1:3","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"图床方案 自行搭建 比如使用开源图床 ImgURL 搭建的img.lruihao.cn（需要服务器） 使用上传工具加第三方免费空间，比如PicGo + 腾讯云 COS（无需服务器） 使用各大图床 诸如 sm.ms，腾讯云 COS，阿里云 OSS，七牛云，又拍云，Github，微博图床，ImgURL 图床等等 ","date":"2019-03-18","objectID":"/posts/webbiji/:1:4","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"font-awesome 现在使用 5 的版本，可以使用webfont+css或svg+js \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css\"\u003e 其他的图标 js \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003csvg class=\"card-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{n+1}}\"\u003e\u003c/use\u003e \u003c!--n 为一个数字--\u003e \u003c/svg\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:1:5","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"响应式（自适应） \u003clink rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css\"\u003e \u003cscript src=\"https://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\"\u003e .col-xs- 超小屏幕 手机 \u003c768px .col-sm- 小屏幕 平板 \u003e=768px .col-md- 中等屏幕 \u003e=992px .col-lg- 大屏幕 \u003e1200px css3 写法 @media （宽度具体调整） /* 手机等小屏幕手持设备 */ @media screen and (min-width: 320px) and (max-width: 480px) { /*手机端 css 样式表*/ } /* 平板之类的宽度 1024 以下设备 */ @media only screen and (min-width: 321px) and (max-width: 1024px) { /*电脑端 css 样式表*/ } link 引入不同 css \u003c!--手机端--\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"style_phone.css\" media=\"screen and (max-width: 960px)\"/\u003e \u003c!--电脑端--\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"style_PC.css\" media=\"screen and (min-width: 960px)\"/\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:1:6","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"jquery \u003cscript src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"http://cdn.bootcss.com/jquery/1.11.0/jquery.min.js\"\u003e\u003c/script\u003e //还有其他的源 ... ","date":"2019-03-18","objectID":"/posts/webbiji/:1:7","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"QQ 推广链接 QQ 推广 QQ 群 \u003ca target=\"_blank\" href=\"https://wpa.qq.com/msgrd?v=3\u0026uin=1074627678\u0026site=qq\u0026menu=yes\"\u003e\u003cimg border=\"0\" src=\"http://wpa.qq.com/pa?p=2:1074627678:51\" alt=\"点击这里给我发消息\" title=\"点击这里给我发消息\"/\u003e\u003c/a\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:1:8","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"Google fonts https://fonts.google.com/ 一般选用国内源镜像替代（待补充 ...） + https://fonts.loli.net + //fonts.lug.ustc.edu.cn ","date":"2019-03-18","objectID":"/posts/webbiji/:1:9","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"fancybox github 介绍 fancybox 源 \u003clink href=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css\" rel=\"stylesheet\"\u003e \u003cscript src=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js\"\u003e\u003c/script\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:1:10","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Memo"],"content":"back-end 更多学习内容见 学习课件 练习作业 源码+Demo ","date":"2019-03-18","objectID":"/posts/webbiji/:2:0","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Java"],"content":" 泛型方法，它在修饰符后，返回值类型前增加了类型参数 (\u003c\u003e) 类型通配符一般使用问号?代替具体的类型实参，注意不是类型形参。 ","date":"2019-03-16","objectID":"/posts/fanxing/:0:0","tags":["泛型","Java"],"title":"java 泛型 test","uri":"/posts/fanxing/"},{"categories":["Java"],"content":"代码 package code0507; public class WildCardTest { public static void main(String[] args) { Box\u003cString\u003ename=new Box\u003cString\u003e(\"hello\"); Box\u003cInteger\u003eage=new Box\u003cInteger\u003e(12); Box\u003cDouble\u003enumber=new Box\u003cDouble\u003e(210.50); Box\u003cInteger\u003epoint=new Box\u003cInteger\u003e(); getData(name); getData(age); getData(number); point.printpoint(520, 1314); point.printpoint(\"me\", \"too\"); } public static void getData(Box\u003c?\u003edata){//类型通配符 System.out.println(\"data:\"+data.getData()); } } class Box\u003cT\u003e{ private T data; public Box() {}//构造方法重载 public Box(T data) { setData(data); } public T getData() { return data; } public void setData(T data) { this.data = data; } //定义泛型方法 public\u003cT1,T2\u003evoid printpoint(T1 x,T2 y){ T1 m=x; T2 n=y; System.out.println(\"This point is:\"+m+\",\"+n); } } ","date":"2019-03-16","objectID":"/posts/fanxing/:1:0","tags":["泛型","Java"],"title":"java 泛型 test","uri":"/posts/fanxing/"},{"categories":["Java"],"content":"运行结果 data:hello data:12 data:210.5 This point is:520,1314 This point is:me,too ","date":"2019-03-16","objectID":"/posts/fanxing/:2:0","tags":["泛型","Java"],"title":"java 泛型 test","uri":"/posts/fanxing/"},{"categories":["Memo"],"content":"基本使用 A: 选择一个工作空间 D:\\develop\\eclipse-SDK-3.7.2-win64\\workspace B: 如何写一个 HelloWorld 案例（代码以项目为基本单位） a: 创建项目（工程） *File -- New -- Java Project *在左边空白处，直接右键 -- New -- Java Project 键入项目名称后直接 Finish。 b: 所有的 java 文件必须写到 src 下面才有效 c: 创建一个包 cn.lruihao d: 在包下创建一个类 HelloWorld 同时让它帮我们写好了 main 方法。 e: 在 main 方法中写内容即可 f: 编译程序 自动编译，在保存的那一刻帮你做好了 g: 运行程序 选择要运行的文件或者在要运行的文件内容中 右键 -- Run as - Java Application 即可 h: 内容显示 在 Console 控制台显示内容 ","date":"2019-03-15","objectID":"/posts/eclipseuse/:1:0","tags":["eclipse","Java"],"title":"eclipse 的基本使用","uri":"/posts/eclipseuse/"},{"categories":["Memo"],"content":"Eclipse 的基本设置 A: 程序的编译和运行的环境配置（如果你的 Eclipse 启动没有问题，就不要配置了） B: 去掉默认注释（可以不用改） C: 行号的显示和隐藏 显示：在代码区域的最左边的空白区域，右键 -- Show Line Numbers 即可。 隐藏：把上面的动作再做一次。 D: 字体大小及颜色 a:Java 代码区域的字体大小和颜色： window -- Preferences -- General -- Appearance -- Colors And Fonts -- Java 修改 -- Java Edit Text Font b: 控制台 window -- Preferences -- General -- Appearance -- Colors And Fonts -- Debug -- Console font c: 其他文件 window -- Preferences -- General -- Appearance -- Colors And Fonts -- Basic -- Text Font E: 窗体给弄乱了，怎么办 window -- Reset Perspective F: 控制台找不到了 Window--Show View—Console ","date":"2019-03-15","objectID":"/posts/eclipseuse/:2:0","tags":["eclipse","Java"],"title":"eclipse 的基本使用","uri":"/posts/eclipseuse/"},{"categories":["Memo"],"content":"快捷键的使用 A: 内容辅助键 Alt+/ 起提示作用 main+alt+/,syso+alt+/, 给出其他提示 B: 快捷键 格式化 ctrl+shift+f 导入包 ctrl+shift+o 注释 ctrl+/ ctrl+shift+/,ctrl+shift+\\ 代码上下移动 选中代码 alt+上/下箭头 查看源码 选中类名 (F3 或者 Ctrl+鼠标点击） ","date":"2019-03-15","objectID":"/posts/eclipseuse/:3:0","tags":["eclipse","Java"],"title":"eclipse 的基本使用","uri":"/posts/eclipseuse/"},{"categories":["Memo"],"content":"Eclipse 中如何提高开发效率 A: 自动生成构造方法 a: 无参构造方法 在代码区域右键--source--Generate Constructors from Superclass b: 带参构造方法 在代码区域右键--source--Generate Constructors using fields.. -- finish B: 自动生成 get/set 方法 在代码区域右键--source--Generate Getters and Setters... ","date":"2019-03-15","objectID":"/posts/eclipseuse/:4:0","tags":["eclipse","Java"],"title":"eclipse 的基本使用","uri":"/posts/eclipseuse/"},{"categories":["Java"],"content":" java 中匿名类用的最多的地方就是可视化界面设计中，特别是将事件监听器注册到某个组件上的时候。 ","date":"2019-03-15","objectID":"/posts/qframe/:0:0","tags":["GUI","Java"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["Java"],"content":"代码 package cn.lruihao; import java.awt.event.*; import javax.swing.*; public class QFrame extends JFrame { public QFrame() { JButton jbtnew=new JButton(\"New\");//新建按钮 JPanel panel=new JPanel();//面板容器 panel.add(jbtnew);//添加组件 add(panel); jbtnew.addActionListener(new ActionListener() { //新建一匿名类，并将该对应的事件监听器注册到“新建”按钮 就 jbtnew 上 @Override public void actionPerformed(ActionEvent e) { JOptionPane.showMessageDialog(null, \"单击了新建按钮\"); System.out.println(\"lruihao.cn\"); } }); } public static void main(String[] args) { JFrame frame=new QFrame(); frame.setTitle(\"QFrame\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); frame.pack(); frame.setVisible(true); } } 创建一个可视化界面，界面中有一个按钮，单击按钮显示“单击了新建按钮”。 ","date":"2019-03-15","objectID":"/posts/qframe/:1:0","tags":["GUI","Java"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["Java"],"content":"结果 ","date":"2019-03-15","objectID":"/posts/qframe/:2:0","tags":["GUI","Java"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["Java"],"content":"参考 JOptionPane 的使用 ","date":"2019-03-15","objectID":"/posts/qframe/:3:0","tags":["GUI","Java"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["JavaScript"],"content":" 模仿知乎的卡片式链接，idea 来自 [兰州小红鸡] ","date":"2019-03-15","objectID":"/posts/linkcard/:0:0","tags":["JavaScript","hexo"],"title":"模仿知乎卡片式链接","uri":"/posts/linkcard/"},{"categories":["JavaScript"],"content":"源码 2021/10/2 1:29 更新 这是一种后加载，创建linkcard.js放到source/js/src/，然后在next\\layout\\_macro\\post.swig中引用 function cardLink() { let $cardLinks = document.querySelectorAll('.card-link'); if ($cardLinks.length === 0) { return; } //插入样式 let $linkStyle = document.createElement('style'); $linkStyle.innerHTML = '.card-link,.card-link:hover{text-decoration:none;border:none!important;color:inherit!important}.card-link{position:relative;display:block;margin:1em auto;width:390px;box-sizing:border-box;border-radius:12px;max-width:100%;overflow:hidden;color:inherit;text-decoration:none}.ztext{word-break:break-word;line-height:1.6}.card-link-backdrop{position:absolute;top:0;left:0;right:0;bottom:0;background-image:url(/images/card-link-bg.jpg);background-repeat:no-repeat;-webkit-filter:blur(20px);filter:blur(20px);background-size:cover;background-position:center}.card-link,.card-link:hover{text-decoration:none;border:none!important;color:inherit!important}.card-link-content{position:relative;display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:inherit;background-color:rgba(246,246,246,0.88)}.card-link-text{overflow:hidden}.card-link-title{display:-webkit-box;-webkit-line-clamp:2;overflow:hidden;text-overflow:ellipsis;max-height:calc(16px * 1.25 * 2);font-size:16px;font-weight:500;line-height:1.25;color:#1a1a1a}.card-link-meta{display:flex;margin-top:4px;font-size:14px;line-height:20px;color:#999;white-space:nowrap}.card-link-url{display: inline-flex;align-items: center;}.card-link-imageCell{margin-left:8px;border-radius:6px}.card-link-image{display:block;width:60px;height:60px;border-radius:inherit}'; document.querySelector('body').appendChild($linkStyle); //渲染 DOM for (let $cardLink of $cardLinks) { $cardLink.innerHTML = `\u003cspan class='card-link-backdrop'\u003e\u003c/span\u003e\u003cspan class='card-link-content'\u003e\u003cspan class='card-link-text'\u003e\u003cspan class='card-link-title'\u003e${$cardLink.innerText}\u003c/span\u003e\u003cspan class='card-link-meta'\u003e\u003cspan class='card-link-url'\u003e\u003csvg class='Zi Zi--InsertLink' fill='currentColor' viewBox='0 0 24 24' width='17' height='17'\u003e\u003cpath d='M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z' fill-rule='evenodd'\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/span\u003e${$cardLink.href}\u003c/span\u003e\u003c/span\u003e\u003cspan class='card-link-imageCell'\u003e\u003cimg class='card-link-image' alt='card-link icon' src='/images/linkicon.png'\u003e\u003c/span\u003e\u003c/span\u003e`; } } window.onload = () =\u003e { cardLink(); }; ","date":"2019-03-15","objectID":"/posts/linkcard/:1:0","tags":["JavaScript","hexo"],"title":"模仿知乎卡片式链接","uri":"/posts/linkcard/"},{"categories":["JavaScript"],"content":"使用 \u003c!--知乎卡片链接--\u003e \u003cscript type=\"text/javascript\" src=\"/js/src/card-link.js\"\u003e\u003c/script\u003e html 链接写法，a 标签加上class=\"card-link\" \u003ca href=\"https://github.com/Lruihao/lruihao.github.io\" target=\"_blank\" class=\"card-link\"\u003eLruihao 博客\u003c/a\u003e Lruihao 博客 https://github.com/Lruihao/lruihao.github.io ","date":"2019-03-15","objectID":"/posts/linkcard/:2:0","tags":["JavaScript","hexo"],"title":"模仿知乎卡片式链接","uri":"/posts/linkcard/"},{"categories":["OS"],"content":" 我的 Ubuntu 和 Windows 双系统是 Ubuntu 是第一启动项，所以总是开机忘记点下键，一进 Ubuntu 系统时间就不对了（总是少了 8 小时），回到 Windows 时间也是错的。知道是错的调整一下还好。忘记调了有时候真的会误事。比如说 git 版本控制提交会遇到问题种种等。 ","date":"2019-03-15","objectID":"/posts/ubuntutime/:0:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu 双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["OS"],"content":"原因 在安装 Ubuntu 和 Windows 双系统的情况下，Ubuntu 的时间总会和 Windows 的时间相差 8 小时，原因在于 widows 认为 BIOS 时间是本地时间，Ubuntu 认为 BIOS 时间是 UTC 时间，即协调世界时，(Universal Time Coordinated) 英文缩写，是由国际无线电咨询委员会规定和推荐，并由国际时间局 (BIH) 负责保持的以秒为基础的时间标度。UTC 相当于本初子午线（即经度 0 度）上的平均太阳时，过去曾用格林威治平均时 (GMT) 来表示。北京时间比 UTC 时间早 8 小时，以 1999 年 1 月 1 日 00:00 UTC 为例，UTC 时间是零点，北京时间为 1999 年 1 月 1 日早上 8 点整。)，所以我们在时间上面相隔了 8 个小时。这个时候 bios 的时间和系统的时间当然是不一致，一个代表 utc 时间，一个代表 cst（＋ 8 时区），即我们常用的时间。 ","date":"2019-03-15","objectID":"/posts/ubuntutime/:1:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu 双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["OS"],"content":"方法一 在 Windows 下 进行如下修改：（博主 win10,win7 自测） 以管理员身份运行 CMD（win+x 后选择 Windows Powershell（管理员） Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 重启看看时间发现 ok 了。 ","date":"2019-03-15","objectID":"/posts/ubuntutime/:2:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu 双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["OS"],"content":"方法二 老版 Ubuntu（Ubuntu10 左右）： 修改 /etc/default/rcS 文件 编辑 /etc/default/rcS 将 UTC=yes改成 UTC=no 。 新版 Ubuntu（Ubuntu16.04）： 新版本的 Ubuntu 使用 systemd 启动之后，时间也改成了由 timedatectl 来管理，此方法就不适用了。 $sudo timedatectl set-local-rtc 1 先在 ubuntu 下更新一下时间，确保时间无误： $sudo apt-get install ntpdate $sudo ntpdate time.windows.com 然后将时间更新到硬件上： $sudo hwclock --localtime --systohc 重新进入 windows10，发现时间恢复正常了！ ","date":"2019-03-15","objectID":"/posts/ubuntutime/:3:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu 双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["JavaScript"],"content":" 以前在 QQ 里面聊天的时候发现，有些链接是卡片式的链接，像知乎里那些一样，就好奇为啥我的域名没有生成卡片。 查了一下百度知道了大概就是 qq 没有抓取到你的网站的 xml。并在其他教程中得到了一个强制提交抓取的 url https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url= 于是就有了脚本刷新的想法。简陋的写了一下。 ","date":"2019-03-08","objectID":"/posts/qqxml/:0:0","tags":["JavaScript"],"title":"QQ 强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["JavaScript"],"content":"批量式刷新 //设置刷新前缀 url=首页地址（最好使用 https） var base_src = 'https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url=https://lruihao.cn'; //用户地址 //var custom_src = \"https://lruihao.cn\"; //初始化工作地址 var new_src = ''; function createArrayAndOpenWindow() { //alert(\"number function\"); //定义数组存储后缀 var numberArray = new Array(4); //存储后缀 numberArray[0] = '/about/'; numberArray[1] = '/categories/'; numberArray[2] = '/tags/'; numberArray[3] = '/archives/'; //numberArray[4] = \"/guestbook/\"; //遍历 for (var i = 0; i \u003c numberArray.length; i++) { new_src = base_src + numberArray[i]; //打开该地址 open_new(); //清空后缀 new_src = ''; } } //负责打开窗口，并关闭 function open_new() { var new_window = window.open(new_src, '', 'width=400,height=200'); setTimeout(function () { //开启后 200ms（单页）关闭，速度自行把握数组越大时间越多 new_window.close(); }, 2000); } window.onload = function () { createArrayAndOpenWindow(); //设置定时函数，疯狂刷新直到 xml 出现内容 var timer = setInterval('createArrayAndOpenWindow()', 2000); }; ","date":"2019-03-08","objectID":"/posts/qqxml/:1:0","tags":["JavaScript"],"title":"QQ 强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["JavaScript"],"content":"单链接刷新 \u003cdiv style=\"text-align: center;\"\u003e \u003cinput type=\"text\" id=\"input\" value=\"\" /\u003e \u003cinput type=\"button\" value=\"疯狂刷新\" onclick=\"yanzheng()\" /\u003e \u003c/div\u003e //设置刷新前缀 url=首页地址（最好使用 https）https://lruihao.cn var base_src = 'https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url='; //用户地址 var custom_src = ''; //初始化工作地址 var new_src = ''; //负责打开窗口，并关闭 function open_new() { var new_window = window.open(new_src, '', 'width=400,height=200'); setTimeout(function () { //开启后 200ms 关闭 new_window.close(); }, 200); } // 获取验证用户输入 function yanzheng() { var Input = document.getElementById('input'); var oValue = Input.value; custom_src = oValue; new_src = base_src + custom_src; if (oValue == 0) { alert('请输入地址'); } else { var timer = setInterval('open_new()', 200); } } ","date":"2019-03-08","objectID":"/posts/qqxml/:2:0","tags":["JavaScript"],"title":"QQ 强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["JavaScript"],"content":"demo 线上 demo 仅做参考请自行下载 效果 ","date":"2019-03-08","objectID":"/posts/qqxml/:3:0","tags":["JavaScript"],"title":"QQ 强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["OS"],"content":"外存的组织方式 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"连续组织方式 连续组织方式的优点 顺序访问容易 顺序访问速度快 连续组织方式的缺点 分配连续的存储空间 必须知道文件长度 删除与插入数据不灵活 动态增长的文件分配空间问题 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"链接组织方式 隐式链接 显式链接 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"FAT 技术 FAT12 早期的 FAT12 文件系统 以簇为单位的 FAT12 文件系统 FAT16 FAT32 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"NTFS 的文件组织方式 NTFS 新特征 磁盘组织 文件的组织 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:4","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"索引组织方式 单级索引组织方式 多级索引组织方式 增量式索引组织方式 增量式索引组织方式的基本思想 UNIX System V 的组织方式 直接地址 一次间接地址 多次间接地址 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:5","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"文件存储空间的管理 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"空闲表法和空闲链表法 空闲表法 空闲表 存储空间的分配与回收 空闲链表法 空闲盘块链 空闲盘区链 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"位示图法 位示图 盘块的分配（步骤） 顺序扫描示图 转换盘块号 修改位示图 盘块的回收（步骤） 盘块号转换成行列号 修改位示图 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"成组链接法 空闲盘块的组织 空闲盘块的分配与回收 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"提高磁盘 I/O 速度的途径 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"磁盘高速缓存 数据交付方式 数据交付 指针交付 置换算法 周期性地写回磁盘 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"提高磁盘 I/O 速度的其他方法 提前读 延迟写 优化物理块的分布 虚拟盘 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"廉价磁盘冗余阵列 (RAID) 并行交叉存取 RAID 的分级 RAID 0 级 RAID 1 级 RAID 2 级 RAID 3 级 RAID 4 级 RAID 5 级 RAID 6 级和 RAID 7 级 RAID 的优点 可靠性高 磁盘 I/O 速度高 性价比高 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"提高磁盘可靠性的技术 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"第一级容错技术 SFT-Ⅰ 双份目录和双份文件分配表 热修复重定向和写后读校验 热修复重定向 写后读校验方式 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"第二级容错技术 SFT-Ⅱ 磁盘镜像 磁盘双工 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"基于集群技术的容错功能 双机热备份模式 双机互为备份模式 公用磁盘模式 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"后备系统 磁带机 硬盘 移动磁盘 固定硬盘驱动器 光盘驱动器 CD-ROM 和 DVD-ROM 刻录机 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:4","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"数据一致性控制 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"事务 事务的定义 事务记录 恢复算法 undo \u003cTi\u003e redo \u003cTi\u003e ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"检查点 检查点的作用 新的恢复算法 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"并发控制 利用互斥锁实现“顺序性” 利用互斥锁和共享锁实现顺序性 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["OS"],"content":"重复数据的数据一致性问题 重复文件的一致性 链接数一致性检查 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:4","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["JavaScript"],"content":" 请点击验证码处：↑ ","date":"2019-03-04","objectID":"/posts/js-vcode/:0:0","tags":["JavaScript"],"title":"JS 验证码","uri":"/posts/js-vcode/"},{"categories":["JavaScript"],"content":" 验证码 JS 来源互联网 \u003cscript type=\"text/javascript\"\u003e //设置一个全局的变量，便于保存验证码 var code; function createCode(){ //首先默认 code 为空字符串 code = ''; //设置长度，这里看需求，我这里设置了 4 var codeLength = 4; var codeV = document.getElementById('code'); //设置随机字符 var random = new Array(0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R', 'S','T','U','V','W','X','Y','Z'); //循环 codeLength 我设置的 4 就是循环 4 次 for(var i = 0; i \u003c codeLength; i++){ //设置随机数范围，这设置为 0 ~ 36 var index = Math.floor(Math.random()*36); //字符串拼接 将每次随机的字符 进行拼接 code += random[index]; } //将拼接好的字符串赋值给展示的 Value codeV.value = code; } //下面就是判断是否== 的代码，无需解释，也可以结合 ajax 在后台做判断 function validate(){ var Input = document.getElementById('input'); var oValue = Input.value.toUpperCase(); if(oValue ==0){ alert('请输入验证码'); }else if(oValue != code){ Input.value = ''; alert('验证码不正确，请重新输入'); createCode(); }else{ Input.value = ''; alert('验证码正确！');//window.open('http://lruihao.cn','_self'); } } //设置此处的原因是每次进入界面展示一个随机的验证码，不设置则为空 window.onload = function (){ createCode(); } \u003c/script\u003e ","date":"2019-03-04","objectID":"/posts/js-vcode/:1:0","tags":["JavaScript"],"title":"JS 验证码","uri":"/posts/js-vcode/"},{"categories":["随笔"],"content":" 这不是英国作家哈代的《The Return of Native》, 而是我们这辈的父母所经历的常态。 逢近年关，邻居家的王婶又在等她的儿子了。 她的儿子大抵有五年未曾回家了。记得去年，他同王婶说好了回家过年，王婶便从腊月二十直直地等到腊月三十，准备好一桌的年夜饭，最后却只是她一个人随便地扒拉了几口。 我尚且还记得那日，王婶与我母亲一同去河边处理鸡鸭，我也随了去。母亲同王婶说：“源子怎地还不回来？”王婶道：“许是买的车票晚了些，他早前和我说回家过年的，想来还在回来的路上。” 到晚上，万家灯火渐起，都说热热闹闹团圆饭，王婶家却格外冷清。王婶嫁过来时，家中便只有王叔一人，早些年，王叔随人去炸山取石，人也不幸被石头砸死，家中便只有王婶和她儿子二人。王源也知家中境况，自大学毕业后在外工作，至今，除了前年我暑假时回来过一次，其中便从未回来过。 人倒是挺奋进，这些年，王婶家从小木屋变成了三层小洋房，家里也添置了许多家具和电器。王婶倒像一个门卫，守着这栋房子，看着这个家。 不过别家事总归别家事。 王婶是个十分随和的人，也常常和村里人打趣逗乐，常见她笑眼眯眯。一年到头，也唯有这“头”让她难展笑颜。 “王婶子，源哥还没回来吗？” “快了，快了……” 王婶又坐在门口，纳着新鞋，常常一纳就是一天。 我们常听到一个词——衣锦还乡，其实，于父母而言，他们所看重的从来都只是还乡。而所谓衣锦，不过是死要面子者拿来的托辞。衣锦若无，无便无罢，衣锦若有，有便有罢。 衣锦随意，还乡就好。 戊戌年腊月廿七于家中。 ","date":"2019-02-01","objectID":"/posts/renative/:0:0","tags":["随笔","他山之石"],"title":"还乡","uri":"/posts/renative/"},{"categories":["Java"],"content":" 引用 继承的好处： 提高了代码的复用性 提高了代码的维护性 让类与类之间产生了关系，是多态的前提 继承的弊端：类的耦合性很强 设计原则：低耦合，高内聚。 耦合：类与类的关系。 内聚：自己完成事情的能力。 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:0","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"java 中的继承特点 Java 只支持单继承，不支持多继承。Java 支持多层继承（继承体系） class A { } class B extends A { } /* class C extends A,B { } */ class C extends B { } class ExtendsDemo { public static void main(String[] args) { } } ","date":"2019-01-24","objectID":"/posts/jicheng/:0:1","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"java 中的继承注意事项 子类只能继承父类所有非私有的成员（成员方法和成员变量） 子类不能继承父类的构造方法，但是可以通过 super 关键字去访问父类构造方法。 不要为了部分功能而去继承 那么，我们什么时候考虑使用继承呢？ 继承中类之间体现的是：”is a”的关系。 如果两个类满足这个关系：xxx is a yyy，那么他们就可以使用继承。 Student,Person 对 Dog,Animal 对 Dog,Pig 错 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:2","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"继承 继承间的构造方法关系：创建子类对象，会先去访问父类的构造方法。对父类的数据进行初始化。 package jicheng; class Fu{ public int num = 10; public Fu(){ System.out.println(\"父类\"); } } class Zi extends Fu{ public int num = 20; public Zi(){ System.out.println(\"子类\"); } public void show(){ int num = 30; System.out.println(num);//30 System.out.println(this.num);//20 System.out.println(super.num);//10 } } public class test { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } 程序运行结果 父类 子类 30 20 10 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:3","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"代码块 代码块的执行顺序： 静态代码块 –\u003e 构造代码块 –\u003e 构造方法 代码的执行特点：静态代码块只执行一次，构造代码块每次调用构造方法都执行。 package jicheng; class Fu { static { System.out.println(\"父类静态代码块\"); } { System.out.println(\"父类构造代码块\"); } public Fu() { System.out.println(\"父类构造方法\"); } } class Zi extends Fu { static { System.out.println(\"子类静态代码块\"); } { System.out.println(\"子类构造代码块\"); } public Zi() { System.out.println(\"子类构造方法\"); } } public class test { public static void main(String[] args) { Zi z = new Zi(); Zi z2 = new Zi(); } } 程序运行结果： 父类静态代码块 子类静态代码块 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:4","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"继承间的成员关系 成员方法 不同名称： 非常简单，一看就知道调用谁 相同名称： 先在子类找，再在父类找 … 找不到就报错。 成员变量： 名字不同： 非常的简单，一看就知道使用的是谁。 名字相同： 就近原则。 使用变量的时候，会先找局部范围。 如果想直接使用成员变量，加关键字：this 即可。 如果想直接使用父类的成员变量，加关键字：super 即可。 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:5","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"注意事项 子类中所有的构造方法默认都会访问父类中空参数的构造方法。为什么呢？因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:6","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Memo"],"content":" 本以为 coding pages 与腾讯云合作后会更好，没想到正是这种初期 bug 不断，速度也是非常慢。比 gitee, 甚至 github 都要慢很多了。所以决定放弃 coding 了，本想挂到云服务器上，但是这个云服务器只续费了半年，可能不会再续费，前几天看到用腾讯云的 cos 桶 xml 制作动态相册的文章，知道了对象存储这个玩意，腾讯云 COS 提供免费 50G 的存储空间，还有 CDN 加速服务，我觉得是个不错的选择，部署后发现速度还挺好。 适用于 hexo, hugo 等静态博客的部署。 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Memo"],"content":"创建存储桶 打开腾讯云控制台–云产品–存储–对象存储，然后创建存储桶。 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:1:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Memo"],"content":"开启静态网站设置 在基础配置打开静态网站（关掉强制 https) ","date":"2019-01-22","objectID":"/posts/cos-hexo/:2:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Memo"],"content":"绑定域名 SSL 设置 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:3:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Memo"],"content":"域名解析，添加记录 去 dns 服务商添加域名解析记录 CNAME 指向上面的域名 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:4:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Memo"],"content":"hexo 设置 安装插件 npm install hexo-deployer-cos --save 站点配置文件 deploy: type: cos bucket: yourBucketName #cos 桶名称 appId: yourAppId #cos 桶名称后数字 secretId: yourSecretId #云 API 密钥 secretKey: yourSecretKey #云 API 密钥 region: yourRegion #所属地域 发布还是一样的 hexo clean hexo g -d 结果类似于 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:5:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Memo"],"content":"CDN 刷新 每次更新博客内容完后，都要登陆腾讯云 CDN–缓存刷新，手动刷新一下 CDN。 用脚本在每次更新后刷新 安装 npm install qcloud-cdn-node-sdk --save 创建qcloudcdn.js放入script文件夹 const qcloudSDK = require('qcloud-cdn-node-sdk'); qcloudSDK.config({ secretId: '你的 ID', secretKey: '你的密钥' }); qcloudSDK.request( 'RefreshCdnDir', { 'dirs.1': 'http://博客地址' }, (res) =\u003e { console.log(res); } ); ","date":"2019-01-22","objectID":"/posts/cos-hexo/:6:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Memo"],"content":"自动 CDN 刷新配置 （推荐） 进入腾讯云，找到 函数计算 -\u003e CDN 缓存刷新函数 -\u003e 创建 CDN 缓存刷新函数 修改 index.js 内容后重新部署 'use strict'; const CosSdk = require('cos-nodejs-sdk-v5'); const CdnSdk = require('./common/CdnSdk'); const CdnRefreshTask = require('./common/CdnRefreshTask'); const { getParams, getObjectUrl, logger, getLogSummary } = require('./common/utils'); exports.main_handler = async (event, context, callback) =\u003e { /** * parse param from event and process.env */ const { objects, cdnHosts, secretId, secretKey, token } = getParams(event); logger({ title: 'param is parsed success, param as follow: ', data: { objects, cdnHosts, event } }); /** * init cos instance */ if (!secretId || !secretKey || !token) { throw new Error(`secretId, secretKey or token is missing`); } const cdnSdkInstance = new CdnSdk({ secretId, secretKey, token }); const cosInstance = new CosSdk({ SecretId: secretId, SecretKey: secretKey, XCosSecurityToken: token }); const taskList = objects.map(({ bucket, region, key }) =\u003e { /* 变更内容-START */ const purgeUrls = []; cdnHosts.forEach((host) =\u003e { const tempUrl = getObjectUrl({ cosInstance, bucket, region, key, origin: `${/^(http\\:\\/\\/|https\\:\\/\\/)/.test(host) ? '' : 'https://'}${host}` }); purgeUrls.push(tempUrl); // 如果以 /index.html 结尾，则增加目录首页/。 // 例如 https://www.xxxx.com/index.html, 则增加 https://www.xxxx.com/。 if (tempUrl.lastIndexOf('/index.html') == tempUrl.length - 11) { purgeUrls.push(tempUrl.substr(0, tempUrl.length - 10)); } }); return new CdnRefreshTask({ cdnSdkInstance, urls: purgeUrls }); /* 变更内容-END */ }); const taskResults = []; for (const task of taskList) { const results = await task.runPurgeTasks(); taskResults.push(...results); } logger({ title: 'cdn refresh full logs:', data: taskResults }); const { status, messages } = getLogSummary(taskResults); logger({ messages: messages.map((item) =\u003e item.replace(/\\,\\ /g, '\\n')) }); if (status === 'fail') { throw messages.join('; '); } else { return messages.join('; '); } }; ","date":"2019-01-22","objectID":"/posts/cos-hexo/:7:0","tags":["hexo","hugo","腾讯云 cos 桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Java"],"content":"主要方法 static type[] copyof(type[] original,int length) static int binarysearch(type[] a,type key) static boolean equals(type[] a,type[] b) static void fill(type[] a,type val) static void fill(type[] a,int fromindex,int toindex,type val) static void sort(type[] a) ","date":"2019-01-18","objectID":"/posts/java-arrays/:0:1","tags":["Java","Collator","Comparator"],"title":"Arrays 类及基本使用","uri":"/posts/java-arrays/"},{"categories":["Java"],"content":"实例代码 package Arrays; import java.text.Collator; import java.util.Arrays; import java.util.Comparator; public class ArraysDemo { public static void main(String agrs[]) { Integer arr[]=new Integer[9]; for(int i=0;i\u003c9;i++) arr[i]=(int)(Math.random()*100); //显示，排序数组 System.out.print(\"原内容：\"); display(arr); Arrays.sort(arr); System.out.print(\"排序后：\"); display(arr); //将值-1 分配给数组 arr 中下标从 0 到 3-1 的位置 Arrays.fill(arr, 0,3,-1); System.out.print(\"fill() 后：\"); display(arr); //搜索 23 System.out.print(\"值 23 的位置：\"); int index =Arrays.binarySearch(arr, 23);//二分查找 System.out.print(index);//如果查找不到，index 为负 System.out.print(\"\\n 插入 0 在 3 号位置：\"); Arrays.fill(arr,3,4,0); display(arr); System.out.print(\"值 0 的位置：\"); index =Arrays.binarySearch(arr, 0); System.out.print(index); Integer arr2[]=new Integer[8]; arr2=Arrays.copyOf(arr, arr2.length); //复制 8 个 System.out.print(\"\\n 复制后的数组：\"); display(arr2); if(Arrays.equals(arr, arr2)) System.out.println(\"两数组相同！\"); else System.out.println(\"两数组不相同！\"); System.out.println(\"----------------------------------------\"); String[] str = {\"计算机\",\"黄桑\",\"通信\",\"李瑞豪\"}; Arrays.sort(str); for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); System.out.println(\"\"); //Collator 类是用来执行分语言环境的字符串比较，这里用的 CHINA Comparator com=Collator.getInstance(java.util.Locale.CHINA);//获取 Comparator 对象，参数表示按中文排序 //根据指定的 \"比较器\" 产生的顺序对 \"指定对象数组\" 进行排序 Arrays.sort(str,com);//sort(T[] a,Comparator\u003c?super T\u003ec) for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); } static void display(Integer arr[]) { for(int i=0;i\u003carr.length;i++) System.out.print(arr[i]+\" \"); System.out.println(\"\"); } } ","date":"2019-01-18","objectID":"/posts/java-arrays/:0:2","tags":["Java","Collator","Comparator"],"title":"Arrays 类及基本使用","uri":"/posts/java-arrays/"},{"categories":["Java"],"content":"程序运行结果 原内容：41 0 44 96 49 96 30 6 87 排序后：0 6 30 41 44 49 87 96 96 fill() 后：-1 -1 -1 41 44 49 87 96 96 值 23 的位置：-4 插入 0 在 3 号位置：-1 -1 -1 0 44 49 87 96 96 值 0 的位置：3 复制后的数组：-1 -1 -1 0 44 49 87 96 两数组不相同！ ---------------------------------------- 李瑞豪 计算机 通信 黄桑 黄桑 计算机 李瑞豪 通信 ","date":"2019-01-18","objectID":"/posts/java-arrays/:0:3","tags":["Java","Collator","Comparator"],"title":"Arrays 类及基本使用","uri":"/posts/java-arrays/"},{"categories":["Memo"],"content":" 首先在主题配置文件添加以下关键字 recent_posts: enable: true search: true post: false sidebar: false icon: history title: 近期文章 layout: block ","date":"2019-01-16","objectID":"/posts/recent-posts/:0:0","tags":["hexo"],"title":"在搜索、文章底部、侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["Memo"],"content":"侧栏 在 next/layout/_macro/sidebar.swig 中的 if theme.links 对应的 endif 后面。 {% if theme.recent_posts.enable and theme.recent_posts.sidebar %} \u003cdiv class=\"links-of-blogroll motion-element {{ \"links-of-blogroll-\" + theme.recent_posts.layout }}\"\u003e \u003cdiv class=\"links-of-blogroll-title\"\u003e \u003ci class=\"fa fa-history fa-{{ theme.recent_posts.icon | lower }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul class=\"links-of-blogroll-list\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '3') %} \u003cli\u003e \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} ","date":"2019-01-16","objectID":"/posts/recent-posts/:1:0","tags":["hexo"],"title":"在搜索、文章底部、侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["Memo"],"content":"搜索结果处添加 找到路径H:\\hexo\\themes\\hexo-theme-next\\layout\\_partials\\search下localsearch.swig文件 把\u003cdiv id=\"local-search-result\"\u003e\u003c/div\u003e修改成以下内容（这里显示 15 篇） \u003cdiv id=\"local-search-result\"\u003e {% if theme.recent_posts.enable and theme.recent_posts.search %} \u003cdiv style=\"text-align: center;padding: 3px 0 0;\"\u003e \u003cdiv style=\"margin-top: 20px;font-size: 18px;font-weight: 600;border-bottom: 1px solid #ccc;\"\u003e \u003ci class=\"fa fa-{{ theme.recent_posts.icon }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul style=\"margin: 0;padding: 0;list-style: none;\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '15') %} \u003cli\u003e \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} \u003c/div\u003e ","date":"2019-01-16","objectID":"/posts/recent-posts/:2:0","tags":["hexo"],"title":"在搜索、文章底部、侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["Memo"],"content":"文章尾部添加 把代码加在H:\\hexo\\themes\\hexo-theme-next\\layout\\_macro\\post.swig里的相应位置（我加在 tags 后） {% if not is_index and theme.recent_posts.enable and theme.recent_posts.post %} \u003cdiv style=\"text-align: center;padding: 10px 0 0;\"\u003e \u003cdiv style=\"margin: 60px 0px 10px;font-size: 18px;border-bottom: 1px solid #eee;\"\u003e \u003ci class=\"fa fa-{{ theme.recent_posts.icon }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul style=\"margin: 0;padding: 0;list-style: none;font-size: 11px;\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '5') %} \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e\u0026emsp; {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} ","date":"2019-01-16","objectID":"/posts/recent-posts/:3:0","tags":["hexo"],"title":"在搜索、文章底部、侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["Memo"],"content":"其他 可尝试将-date改为-update ","date":"2019-01-16","objectID":"/posts/recent-posts/:4:0","tags":["hexo"],"title":"在搜索、文章底部、侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["Java"],"content":" 大一刚学 c 的时候以前写过 c 语言版 的。 Math: 针对数学进行运算的类 特点：没有构造方法，因为它的成员都是静态的 产生随机数： public static double random(): 产生随机数，范围 [0.0,1.0) 产生 1-100 之间的随机数 int number = (int)(Math.random()*100)+1; 猜数字小游戏案例 class MathDemo { public static void main(String[] args) { //获取随机数 //double d = Math.random(); //System.out.println(d); /* for(int x=0; x\u003c10; x++) { //System.out.println(Math.random()); System.out.println(Math.random()*100); } */ //我们如何获取 1-100 之间的随机数呢？ for(int x=0; x\u003c100; x++) { int number = (int)(Math.random()*100)+1; System.out.println(number); } } } ","date":"2019-01-15","objectID":"/posts/mathclass/:0:0","tags":["Java"],"title":"java 猜数字小游戏（Math 类）","uri":"/posts/mathclass/"},{"categories":["Java"],"content":"小游戏 该游戏可以由程序随机产生或由用户输入四个 0 到 9 之间的数字，且不重复。玩游戏者通过游戏提示输入八次来匹配上面所输入的数字。A 表示位置正确且数字正确，B 表示数字正确而位置不正确。 算法： 可以直接算出 A 类的数目，但是 B 类的数目直接算出或许会很麻烦，正好我们可以先算出 C 类数目恰好减去 A 类就是 B 类了。 package caishuzi; import java.util.Scanner; class Num { private int[] a= {0,0,0,0}; public Num() {} public void setx() { /*for(int i=0;i\u003c4;i++) { a[i]=(int)(Math.random()*10); }*/ //为了四个互不相同的随机数 a[0]=(int)Math.random()*10+1; for(int i=1;i\u003c4;i++) { int t=(int)(Math.random()*10); for(int j=0;j\u003ci;j++) { if(t==a[j]) { t=(int)(Math.random()*10); j=0; } } a[i]=t; } } public int[] getx() { return a; } public void show() { System.out.println(); for(int i=0;i\u003c4;i++) System.out.print(a[i]+\" \"); System.out.println(); } } public class caishuzi { public static void main(String agrs[]) { int a[] = {0,0,0,0},b[] = {0,0,0,0}; System.out.println(\"* * * *\\n 请输入 4 个数字！A 表示位置数字都正确，B 表示数字正确位置错误。\"); Scanner sc=new Scanner(System.in); Num n=new Num(); n.setx(); a=n.getx(); /*for(int i=0;i\u003c4;i++) System.out.print(a[i]+\" \"); n.show();*/ for(int k=0;k\u003c10;k++) {//猜测次数 int A=0,B=0,C=0; for(int i=0;i\u003c4;i++) { b[i]=sc.nextInt(); } sc.close(); for(int i=0;i\u003c4;i++){ if (b[i]==a[i])A++; for(int j=0;j\u003c4;j++){ C=b[i]==a[j]?++C:C;//C 表示猜测数内和随机数中 A 类和 B 类数的数目 if (b[i]==a[j])break; } } B=C-A;// 关键算法（感叹数学魅力） if(A==4) { System.out.println(\"恭喜猜对啦！\"); }else { System.out.println(A+\"A\"+B+\"B\"); } } } } ","date":"2019-01-15","objectID":"/posts/mathclass/:0:1","tags":["Java"],"title":"java 猜数字小游戏（Math 类）","uri":"/posts/mathclass/"},{"categories":["Java"],"content":"一次游戏过程 * * * * 请输入 4 个数字！A 表示位置数字都正确，B 表示数字正确位置错误。 0 1 2 3 0A1B 0 1 2 4 0A1B 0 1 2 5 1A1B 6 1 2 5 1A2B 1 6 2 5 3A0B 1 6 7 5 恭喜猜对啦！ ","date":"2019-01-15","objectID":"/posts/mathclass/:0:2","tags":["Java"],"title":"java 猜数字小游戏（Math 类）","uri":"/posts/mathclass/"},{"categories":["Java"],"content":"面向对象思想（理解） 面向对象是基于面向过程的一种编程思想 思想特点： A: 是一种更符合我们思考习惯的思想 B: 把复杂的问题简单化 C: 让我们从执行者变成了指挥者 举例： A: 洗衣服 B: 吃饭 C: 买电脑 举例并代码体现 把大象装进冰箱 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:1","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"类与对象（掌握） 我们学习编程是为了把现实世界的事物用编程语言描述来实现信息化。 现实世界事物是如何表达的呢？ 属性：外在特征 行为：内在行为 我们学习的是 java 语言，它最基本的单位是类。 所以我们要学会用类来体现一个事物。 类：是一组相关的属性和行为的集合 对象：是该类事物的具体个体。 举例： 学生 类 张三 对象 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:2","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"类的组成（掌握） 成员变量 其实就是变量，只不过定义在类中，方法外，并且可以不用初始化。 成员方法 其实就是方法，只不过不需要 static 了 案例： 学生类 class Student { String name; int age; public void study() {} } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:3","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"类的使用（掌握） 创建对象 格式：类名 对象名 = new 类名 (); 使用成员 成员变量：对象名。变量名； 成员方法：对象名。方法名 (…); ","date":"2019-01-15","objectID":"/posts/duixiang/:0:4","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"成员变量和局部变量的区别（理解） 在类中的位置不同 A: 成员变量 类中，方法外 B: 局部变量 方法的形式参数，或者方法体中 在内存中的位置不同 A: 成员变量 在堆中 B: 局部变量 在栈中 生命周期不同 A: 成员变量 随着对象的存在而存在，随着对象的消失而消失 B: 局部变量 随着方法的调用而存在，随着方法的调用完毕而消失 初始化值不同 A: 成员变量 有默认初始化值 B: 局部变量 没有默认值，必须先声明，赋值，最后才能使用 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:5","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"形式参数问题（理解） 基本类型 基本类型作为形式参数，需要的是该基本类型的值。 引用类型 引用类型作为形式参数，需要的是该引用类型的地址值。（对象） ","date":"2019-01-15","objectID":"/posts/duixiang/:0:6","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"匿名对象（理解） 匿名对象：没有名字的对象。是对象的简化书写方式。 使用场景 A: 调用方法，仅仅只调用一次 B: 作为实际参数传递 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:7","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"封装（掌握） 隐藏实现细节，提供公共的访问方式 好处： A: 隐藏实现细节，提供公共的访问方式 B: 提高了代码的复用性 C: 提高了代码的安全性 使用原则 A: 把成员变量隐藏 B: 给出该成员变量对应的公共访问方式 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:8","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"private 关键字（掌握） 是一个权限修饰符 可以修饰类的成员（成员变量和成员方法） 仅仅在本类中可以访问，对外提供对应的 GetXXX()，SetXXX() 等方法 标准代码： class Student { private String name; private int age; public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } public void study() {} } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:9","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"this 关键字（掌握） this：代表本类的对象 应用场景： 解决了局部变量隐藏成员变量的问题。 其他用法和 super 一起讲。 标准代码： class Student { private String name; private int age; public void setName(String name) {//局部变量 this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(\"姓名是：\"+name+\", 年龄是：\"+age); } public void study() { System.out.println(\"学生爱学习\"); } public void eat() { System.out.println(\"学生要吃饭\"); } public void sleep() { System.out.println(\"学生想睡觉\"); } } class StudentTest { public static void main(String[] args) { Student s = new Student(); s.setName(\"林青霞\"); s.setAge(28); s.show(); s.study(); s.eat(); s.sleep(); System.out.println(\"姓名是：\"+s.getName()); System.out.println(\"年龄是：\"+s.getAge()); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:10","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"构造方法（掌握） 作用：对对象的数据进行初始化。 特点： A: 方法名和类名相同 B: 没有返回值类型 C: 没有返回值 注意事项 A: 如果我们没写构造方法，系统将默认给出无参构造方法 B: 如果我们写了构造方法，系统将不再给出默认无参构造方法 建议：我们自己手动给出无参构造方法 给成员变量赋值： A: 无参+setXxx() B: 带参 一个标准的代码： class Student { private String name; private int age; public Student() {} public Student(String name,int age) {//构造方法 this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(\"姓名是：\"+name+\", 年龄是：\"+age); } } class StudentTest { public static void main(String[] args) { //无参+setXxx() Student s = new Student(); s.setName(\"林青霞\"); s.setAge(28); s.show(); //带参 Student ss = new Student(\"张曼玉\",20); ss.show(); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:11","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"对象的初始化过程（理解） Student s = new Student(); 做了哪些事情 A: 加载 Student.class 文件进内存 B: 在栈中为 s 开辟空间 C: 在堆中为学生对象开辟空间 D: 为学生对象的成员变量赋默认值 E: 为学生对象的成员变量赋显示值 F: 通过构造方法给成员变量赋值 G: 对象构造完毕，把地址赋值给 s 变量 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:12","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"static 关键字（掌握） 是一个状态修饰符。静态的意思 它可以修饰成员变量和成员方法 特点： A: 随着类的加载而加载 B: 优先于对象存在 C: 被所有对象共享 这也是判断我们是不是该使用静态的条件 举例：饮水机（可共享 static) 和水杯例子。 D: 可以通过类名调用 静态修饰的内容，可以通过类名调用，也可以通过对象名调用 方法访问特点 A: 普通成员方法 可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法 B: 静态成员方法 只能访问静态成员变量，静态成员方法 简记：静态只能访问静态 注意： 静态中是不能有 this 的。 先进内存的不能访问后进内存的。反之可以。 /* 班级编号应该是被班级每个人都共享的，所以定义一个就应该可以了。 而姓名和年龄，每个人应该是不一样的，所以，每个对象，都应该定义自己的。 在 java 中，用什么来表示成员变量是被共享的呢？static */ class Student { //姓名 String name; //年龄 int age; //班级编号 //String classNumber; static String classNumber; public Student(String name,int age) { this.name = name; this.age = age; } public Student(String name,int age,String classNumber) { this.name = name; this.age = age; this.classNumber = classNumber; } public void show() { System.out.println(name+\"---\"+age+\"---\"+classNumber); } } class StudentDemo { public static void main(String[] args) { //创建学生对象 Student s1 = new Student(\"林青霞\",28,\"20150306\"); s1.show(); /* Student s2 = new Student(\"马云\",35,\"20150306\"); s2.show(); Student s3 = new Student(\"马化腾\",33,\"20150306\"); s3.show(); */ Student s2 = new Student(\"马云\",35); s2.show(); Student s3 = new Student(\"马化腾\",33); s3.show(); } } /* static: 静态关键字。 作用： 可以修饰成员变量和成员方法 特点： A: 随着类的加载而加载 B: 优先于对象存在 C: 被类的所有对象共享 这也是我们判断是否使用静态关键字的条件 饮水机：可以被静态修饰 水杯：不可以被静态修饰 D: 可以通过类名调用 我们的调用既可以是对象，还可以是类名 */ class Student { public void show() { System.out.println(\"show\"); } public static void show2() { System.out.println(\"show2\"); } } class StudentDemo2 { public static void main(String[] args) { Student s = new Student(); s.show(); s.show2(); Student.show2(); //Student.show();\u0026ensp; } } /* static 的注意事项： A: 在静态方法中是没有 this 关键字的 因为静态是随着类的加载而加载，优先于对象而存在。而 this 是随着对象的创建而存在。 先进内存的， 不能访问后进内存的；而后进内存的，可以访问先进内存的。 B: 静态只能访问静态。 非静态的成员方法： 可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法 静态的成员方法： 只能访问静态的成员变量，静态的成员方法 */ /* class Student { private String name; public static void setName(String name) {//\u0026ensp; 静态方法不能用 this this.name = name; } public void show() { System.out.println(name); } }*/ class Demo { int x = 10; static int y = 20; public void show() { System.out.println(x); System.out.println(y); } public static void show2() { //System.out.println(x);\u0026ensp; System.out.println(y);//√ } public void show3() { show(); show2(); } public static void show4() { //show(); 只能访问静态的成员方法 show2(); } } class StudentDemo3 { public static void main(String[] args) { //Student.setName(\"林青霞\"); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:13","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"静态成员变量和普通成员变量的区别（理解） 所属不同 静态属于类的，称为类变量 非静态属于对象的，称为对象变量，实例变量 内存空间不同 静态在方法区的静态区 非静态在堆内存 生命周期不同 静态随着类的加载而加载，随着类的消失而消失 非静态随着对象的创建而存在，随着对象的消失而消失 调用不同 静态可以通过类名调用，也可以通过对象名调用。建议通过类名调用 非静态只能通过对象名调用 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:14","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"main 方法是静态的（理解） public static void main(String[] args) public: 访问权限修饰符，表示最大的访问权限，被 jvm 调用，所有权限要够大。 static: 被 jvm 调用，不用创建对象，直接类名访问 void: 被 jvm 调用，不需要给 jvm 返回值 main: 一个通用的名称，虽然不是关键字，但是被 jvm 识别 String[] args: 早期出现是为了接收键盘录入数据的。 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:15","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"实例 /*求和*/ class Demo { private int x; private int y; public Demo() {} public Demo(int x,int y) { this.x = x; this.y = y; } public void setX(int x) { this.x = x; } public int getX() { return x; } public void setY(int y) { this.y = y; } public int getY() { return y; } //成员变量已经有 x,y 了。这里就没有必要在定义了 /* public int sum(int x,int y) { return x + y; } */ public int sum() { return x + y; } } class Test { public static void main(String[] args) { Demo d = new Demo(); d.setX(10); d.setY(20); int result = d.sum(); System.out.println(result); } } /*求和*/ class Demo { public int sum(int x,int y) { return x + y; } } class Test2 { public static void main(String[] args) { Demo d = new Demo(); int result = d.sum(10,20); System.out.println(result); } } /* 定义一个员工类，自己分析出几个成员， 然后给出成员变量，构造方法，getXxx()/setXxx() 方法， 以及一个显示所有成员信息的方法。并测试。 Employee： 成员变量：员工编号，姓名，职位 构造方法：无参，带参 成员方法：getXxx()/setXxx() 方法，show() */ class Employee { private String eid; private String name; private String job; public Employee() {} public Employee(String eid,String name,String job) { this.eid = eid; this.name = name; this.job = job; } public void setEid(String eid) { this.eid = eid; } public String getEid() { return eid; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setJob(String job) { this.job = job; } public String getJob() { return job; } public void show() { System.out.println(\"员工编号是：\"+eid+\", 姓名是：\"+name+\", 职位是：\"+job); } } class EmployeeDemo { public static void main(String[] args) { //无参 Employee e = new Employee(); e.setEid(\"itcast007\"); e.setName(\"周星驰\"); e.setJob(\"高级工程师\"); e.show(); //带参 Employee e2 = new Employee(\"itcast003\",\"刘德华\",\"挖掘机工程师\"); e2.show(); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:16","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"java 类中的成员变量和方法访问权限 关键词 同一个类 同一个包 不同包中的子类 不同包中的非子类 private √ default √ √ protected √ √ √ public √ √ √ √ ","date":"2019-01-15","objectID":"/posts/duixiang/:0:17","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":" 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3 次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。 ","date":"2019-01-14","objectID":"/posts/java-range/:0:0","tags":["水仙花数","Java"],"title":"java 水仙花数（循环）","uri":"/posts/java-range/"},{"categories":["Java"],"content":"定义 水仙花数只是自幂数的一种，严格来说 3 位数的 3 次幂数才称为水仙花数。 附：其他位数的自幂数名字 一位自幂数：独身数 两位自幂数：没有 三位自幂数：水仙花数 四位自幂数：四叶玫瑰数 五位自幂数：五角星数 六位自幂数：六合数 七位自幂数：北斗七星数 八位自幂数：八仙数 九位自幂数：九九重阳数 十位自幂数：十全十美数 package xunhuan; import java.util.Scanner; public class shuixianhua { public static void main(String[] agrs) { System.out.print(\"指定最大位数 N:\"); Scanner input = new Scanner(System.in); int N = input.nextInt(); input.close(); for (int i = 3; i \u003c= N; i++) { int a[] = new int[i]; int num = (int) Math.pow(10, i - 1) + 1; System.out.print(i + \"位的水仙花数有：\\t\"); while (num \u003c= Math.pow(10, i)) { int sum = 0; for (int j = 0; j \u003c i; j++) a[j] = (int) (num / Math.pow(10, j) % 10);//取各个位的数 for (int j = 0; j \u003c i; j++) sum = sum + (int) Math.pow(a[j], i); if (num == sum) System.out.print(num + \"\\t\"); num++; } System.out.print(\"\\n\"); } } } 由于 int 精度限制，最多算到 9 位，而且使用常规算法，算到 8，9 位的时候就特别慢了。 指定最大位数 N:10 3 位的水仙花数有： 153 370 371 407 4 位的水仙花数有： 1634 8208 9474 5 位的水仙花数有： 54748 92727 93084 6 位的水仙花数有： 548834 7 位的水仙花数有： 1741725 4210818 9800817 9926315 8 位的水仙花数有： 24678050 24678051 88593477 9 位的水仙花数有： 146511208 ","date":"2019-01-14","objectID":"/posts/java-range/:0:1","tags":["水仙花数","Java"],"title":"java 水仙花数（循环）","uri":"/posts/java-range/"},{"categories":["Java"],"content":"记忆格式： (1) 导包： import java.util.Scanner; 注意：位置在 class 的上面。 (2) 创建键盘录入对象： Scanner sc = new Scanner(System.in); (3) 获取数据 int i = sc.nextInt(); (4) 练习： A: 求两个数据的和 B: 获取两个数据中较大的值 C: 获取三个数据中较大的值 D: 比较两个数是否相等 ","date":"2019-01-14","objectID":"/posts/java-input/:0:1","tags":["Java"],"title":"java 录入数据","uri":"/posts/java-input/"},{"categories":["Java"],"content":"实例 package helloworld; import java.util.Scanner; public class helloworld { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int i=sc.nextInt(),j=sc.nextInt(),k=sc.nextInt(); sc.close(); System.out.println(i+\"+\"+j+\"=\"+(i+j)); System.out.println(\"MAXij=\"+Max(i,j)); System.out.println(\"MAXijk=\"+Max(i,j,k)); } //Max() 方法重载 static int Max(int i,int j) { return i\u003ej?i:j; } static int Max(int i,int j,int k) { if(i==j) System.out.println(\"i 和 j 相等\"); else if(i==k) System.out.println(\"i 和 k 相等\"); else if(j==k) System.out.println(\"j 和 k 相等\"); return (i=i\u003ej?i:j)\u003ek?i:k; } } 结果 5 5 6 5+5=10 MAXij=5 i 和 j 相等 MAXijk=6 ","date":"2019-01-14","objectID":"/posts/java-input/:0:2","tags":["Java"],"title":"java 录入数据","uri":"/posts/java-input/"},{"categories":["Java"],"content":"标识符： 给类，接口，方法或者变量起名字的符号 ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:1","tags":["Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"组成规则： A: 英文字母大小写 B: 数字 C:_和$ ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:2","tags":["Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"注意事项： A: 不能以数字开头 B: 不能是 Java 中的关键字 C: 区分大小写 Student,student 这是两个名称 ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:3","tags":["Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"常见命名方式： A: 包 其实就是文件夹，用于解决相同类名问题 全部小写 单级：com 多级：cn.itcast B: 类或者接口 一个单词：首字母大写 Student,Person,Teacher 多个单词：每个单词的首字母大写 HelloWorld,MyName,NameDemo C: 方法或者变量 一个单词：全部小写 name,age,show() 多个单词：从第二个单词开始，每个单词首字母大写 myName,showAllStudentNames() D: 常量 一个单词：全部大写 AGE 多个单词：每个单词都大写，用_连接 STUDENT_MAX_AGE ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:4","tags":["Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Study"],"content":"常见情况 ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"由 and 或 both and 连接的并列主语，谓语动词一般用复数 English and chinese are two quite different languages. Both brother and sister tire of city life. ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:1","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"一但主语前被 no,every,each 所修饰时，谓语动词用单数 No desk and (no) chair is seen in the hall. All work and no play makes Jack a dull boy. They each have been to the Forbidden city. each 位于主语后，所以谓语动词用复数 ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:2","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"当主语表示同一事物的两个部分，同一个人的两个身份（第二个名词前无冠词），谓语动词用单数 比如 the（a）horse and cart a watch and chain a knife and fork a cup and soucer the butter and bread The horse and cart has fallen down the cliff（悬崖）. Butter and bread is his favourate. The poet（诗人） and writer has been sentenced（判决） to death. The poet and the writer have been sentenced（判决） to death. ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:3","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"两数相加或相乘，单复皆可，相减或相除，只能用单数，量词做主语，用单数 等于： be,equal,be equal to,make 相加： and,plus 相减： minus 相乘： multily,time 相除： divided by One and one make(makes) two. ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:4","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"就近原则 not only…but also there/here be or,nor,either…or,neither…nor,not…but There is a desk and two chairs in the room. Are you or your sister fond of classical music? An apple or two lies on the desk.（数量词后用单数） One or two apples lie on the desk. Not he but you have come. ","date":"2019-01-12","objectID":"/posts/subject-verb/:2:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"就远原则 两单体两结构三 with 四除外 like,including rather than,as well as with,together with,along with except,besides,but,in addition to The couple in addition to their child are mean. Lauren,rather than anyone else was chose his partener. A library together with 3000 books was destroyed in the fire. ","date":"2019-01-12","objectID":"/posts/subject-verb/:3:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"时间，金钱，距离，温度，天气，重量等不可数名词，to do,doing, 从句做主语时，谓 v 用单数 To go to bed early and rise early is a good habit. What he says and behaives doesn’t concern me. ","date":"2019-01-12","objectID":"/posts/subject-verb/:4:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"分数，百分数，the rest(+of+n) 做主语，用单数 谓语动词由 of 后面的名词决定，一般用单数。 分数用法： 通常分子读基数，分母读序数，分子超过 1 时，分母加 s。即 基+序 (s)+of+n+谓 Most students are in favaour of the contract（契约） but the rest disagree. be favaour of: be for,approve of,support,agree with About two thirds of the earth’s surface is covered by water. ","date":"2019-01-12","objectID":"/posts/subject-verb/:5:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"一些短语 one of+n 或 the only one of+n, 一般用单数（定从根据中心词在 of 前后） a number of+n（用复数） \u0026 the number of+n（用单数） one in 或 one out of+n （用单数） a large quantity of \u0026 large quantity of + 可、不可数 n a large amount of \u0026 large amounts of + 不可数 n He is one of the students who were awarded the other day. He is the only one of the students who was awarded the other day. One of his family was a traitor（卖国贼，叛徒） during the world war two. A number of teenagers are addicted to the Internet. The number of students who are addicted to the Internet is up to（接近于） 15. Large amounts of power are foused on him alone.==a large amount of power is foused on him alone. ","date":"2019-01-12","objectID":"/posts/subject-verb/:6:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"不定代词做主语，谓语动词用单数 all 修饰人，谓语动词用复数，修饰物，谓语动词用单数 All are present besides the professor. All that glitters（发光体） is not gold. not 与 all/both 等连用表部分否定 ","date":"2019-01-12","objectID":"/posts/subject-verb/:7:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"the +adj 表一类人做主语时，谓语动词用复数 The injured are taken good care of in hospital. The agreeable is not always the useful.（不表人） ","date":"2019-01-12","objectID":"/posts/subject-verb/:8:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"成双成对的词做主语，用复数 trousers（裤子）,chopsticks,scissors（剪刀）,glasses Pants are what I want. The pair of glasses seems expensive.（谓语动词与表示计量单位的名词形式一致） Three set of fashionable socks are shown in today’s evening proper（恰当地）. 一系列： a piece/pair/set/suit/series of ","date":"2019-01-12","objectID":"/posts/subject-verb/:9:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"以 s 结尾特殊专用名词，用单数 表学科，疾病，山脉，河流，书名，歌名，格言等 maths,physicsa（物理）,politics（政治）,classics,economics,Aids,SARs,diabetes（糖尿病）,arthritis（关节炎）,bronchitis（支气管炎）,Himalayas,Arabian Night Arabian Night sounds beautiful. ","date":"2019-01-12","objectID":"/posts/subject-verb/:10:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"many a +单 n+单谓： “许多” more than one +单 n+单谓： “不止一个” Many a man thinks life is meaningless without a purpose/an aim. More than one student has put forward the suggestion. More students than one are against the proposal. More than 20% students were absent at the meeting yesterday.（不止） ","date":"2019-01-12","objectID":"/posts/subject-verb/:11:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"police,people,cattle 做主语，用复数 It is reported that police are trying their best to capture the murder. ","date":"2019-01-12","objectID":"/posts/subject-verb/:12:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"the Olympics \u0026 the Olympic games The Olympices is hold every four years. == The Olympic games are hold every four year. ","date":"2019-01-12","objectID":"/posts/subject-verb/:13:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"集体名词做主语，表整体用单数，表成员用复数 family,class,group,team,army,public,crew,population The innovation experiment（革新实验） class consists of 24 students and enjoy chinese. Population in China is 1.4 billion or so(about) 20% (Population) have no access to clean water. ","date":"2019-01-12","objectID":"/posts/subject-verb/:14:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"单复同形，sheep,deer,means,Chinese 等谓语动词依据情况而定 Many deer live on the African grassland. ","date":"2019-01-12","objectID":"/posts/subject-verb/:15:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"地点状语位于句首 Among the crow stand his parents. On the wall hangs an alarm clock. ","date":"2019-01-12","objectID":"/posts/subject-verb/:16:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":"“of”: of 表所属时，中心词在 of 之前，谓语动词由中心词决定，特例除外。 ","date":"2019-01-12","objectID":"/posts/subject-verb/:17:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Study"],"content":" 形式倒装，句子本不是本来的语序。 ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:0","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["Study"],"content":"may 位于句首，标祝愿 例句 May you succeed. May you have a happy holiday. Long live chairman Mao.（毛主席万古长青） ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:1","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["Study"],"content":"whatever 直接做成分或放在名词之前，however 放在 adv,adj 之前或 many,much 等词之前 例句 Whatever the weather is,he sticks out（坚持） walking outside. Go to stamp sales and buy whatever you can offord. Whatever reasons you have,you should carry out your promise. However many difficulties(n.) you meet with,you should try to overcome them. Whatever difficulties(n.) you meet with,you should try to overcome them. However difficult(adj.) the problem is,we must work it out today. ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:2","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["Study"],"content":"the + 比较级，the + 比较级 --\u003e“越 … 越 …” 例句 The hander you study,the greater progress you will make. The more you listen to English,the easier it becomes. The older you grow,the more challenges you will meet. ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:3","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["Study"],"content":"感叹句 例句 What an interesting talk they had! How interesting the talk was! ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:4","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["Study"],"content":" 完全倒装： 把整个谓语动词放到主语前。 ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:0","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["Study"],"content":"表方位或时间的副词 (adv)、表地点的介词短语位于句首时 例句 Here comes the bus. In the lecture hall of a university sits a professor. Out rushed the children. Now comes your turn. Up jumped the cat and caught the mouse. Down came the rain and up went the umbrellas. Among the people stood his friend,Jim. (To be) South of the river lies a small factory. 但主语为表示人称的代词时无需倒装 Here are you. Away it flew. ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:1","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["Study"],"content":"表语（词/短语）位于句首时，adj/doing/done 例句 Written on the blackboard are the name of these who were late. Gone are the days when we worked together. Standing at the tree is a shy girl with two big eges. Present(adj) at the conference were all leaders of this city. Lying on the grassland is the boy who was injured in the fire. ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:2","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["Study"],"content":"存在句 there be 中，其中 be -\u003eexist/arise/follow/enter/appear/live 等表状态 vi 例句 There come shows for help from the river. There seems something wrong with machine. There remains nothing to be done. There happened an event last week. ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:3","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["Study"],"content":" 虽然我英语四级没过，词汇量也不很多，甚至下降了很多，但是对于英语的语法我还是很喜欢的，马上快四级了又，复习整理一下以前的语法笔记。以下内容纯手打！！ 先从倒装句开始吧！分为三大类，部分倒装，完全倒装和形式倒装。先复习第一种。 部分倒装： 把谓语动词的一部分（助动词，be 动词，情态动词）提到主语前面。 ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:0","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"xx 也如此，xx 也一样 表示前面的内容也适用于后者，用\"so/nor/neither + 动词 + 主语\"句型。表“xx 也如此，xx 也一样”。可用,、;、and隔开（注意情形）。 例句 They love having lots of friends, so dothe disabled.（这里the + 形容词表一类人） I have had a new idea; so hasmy friends. Lily can’t ride bicycle, nor/neither canlucy. The injured look disappointed（沮丧的）, so didsenior citizens.（老人） （否定前缀词 ≠ 否定） If you aren’t for the plan; nor/neither willI. , 或 ; 前的句子若为从句，先将主句补充出，其后再根据主句改。 这里主句应为： I will not be for the plan.(be for 同意） It is burning（燃烧） hot today, so it is（那确实） and/; so was (it)yesterday.（这里只用用 and 或；) Everyone is here and looks upset, so it is with Mary = it is the same withMary. 这个句型同样适用于前面的六个例子，但是前面是并列句必须用这个句型。 The truth is that no one is perfect.When all potential（潜在的） for ugliness in removed, so is all of the potential for beauty. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:1","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"否定副词或含有否定的介词短位于句首 例句 Neither does Mr.Green know the matter（事件） nor does he care about it. neither……nor…… 既不也不 either……or……要么要么，不是就是 Not only did we lose our way but also (we) came close to losing our lives.(come close to 接近，差一点就） Not until I began to work hard did I realize how much time I had wasted. 从句不倒装，原句为： I didn’t realize how much time I had wasted until I began to work hard. No sooner had they arrived at the tomb than they fell ill.（一……就……) In no case will we give up half-way. Hardly does Jim think it possible to finish the task before/when dark. hardly…before/when 一……就…… 这里取\"几乎不\"释义应该更合适。 Not a (single) mistake has Mary made so far.（玛丽到目前为止一个错误也没犯。) not a (single) + 单数名词 表示“一个也没有”%} In no time（立刻马上） Jone worked out the figure（体积）. （无否定不倒装） ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:2","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"only + 状语位于句首 例句 Only in this way are you able to do it well. 倒装前： You are able to do it well only in this way. Only when they returned home did they understand what had happened. Only on such a trip will you gain a better appreciation（理解） of Eurepean literature. Only the teacher got the news that our school could have a 4-day holiday.（同位语从句，only+主语所以不倒装） ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:3","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"So/Such…that… 句型位于句首 So + adj + a/an + 单数名词 = Such + a/an + adj + 单数名词 如此 ... 以至于 ... so 侧重于 adj/adv such 侧重于 n. 比如，so many/much/few/little 例句 So crowded was the art gallery（展览会） that I couldn’t move about (it). Such good weather was it that we all went out last week. Such a lovely girl is kate that everyone likes her. So loudly did he speak that even people next room could hear him. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:4","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"as 引导让步狀语从句 as 引导让步状语从句（虽然，即使，尽管，无论），把从句中的表语，动词，副词提至句首 (as 后不用再倒装了），当表语是名词时，提至句首时一律用零冠词（其中 as 可用 though 替代，倒装后省略 but,though,however,even,though,although 等） 例句 Child as he is,he knows a lot. Poor as King was,he tried his best to help others. Try as he may,he has never made his boss satisfied. Search as you would,you could find no body in the room. Much as I want to buy the car,I can’t afford（支付） it. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:5","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"把虚拟语气从句中的 were,had,should 提至句首，并省略 if 例句 Had you followwed my advice,you couldn’t have made such a silly mistake. Were you not a boy,you could wear a dress. Should he invite me,I might take part in this party. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:6","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"表肯定含义的时间频率词位于句首 always,often,many a time(many times 多次）,every + 时间，now and then（时不时的） 例句 Many a time has he offered me some good suggestions. Now and then does my class teacher warn us not yo use cellphones in the classroom. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:7","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Study"],"content":"疑问句用部分倒装 普通的疑问句： How do you do that? 除了： What is wrong? = What is the matter? … ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:8","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Memo"],"content":" 2021/10/2 更新 博客已迁移至 Hugo, 插件演示不适用，已删除。 让文章写的好看又简洁又好用的插件！hexo 完整的标签列表，next 插件列表 ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:0","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"hexo 插件 hexo-lazyload-image npm install hexo-lazyload-image --save First add configuration in _config.yml from your hexo project. lazyload: enable: true onlypost: false loadingImg: # eg ./images/loading.gif hexo-ruby-marks 不支持ruby新标签的浏览器将显示rp中的内容。 \u003cruby\u003e博採眾長\u003crp\u003e（\u003c/rp\u003e \u003crt\u003elruihao.cn\u003c/rt\u003e\u003crp\u003e）\u003c/rp\u003e\u003c/ruby\u003e 博採眾長（ lruihao.cn） 插件使用 npm i hexo-ruby-marks {% ruby _**base**_|_**top text**_ %} hexo-pwa npm install --save hexo-pwa You can configure this plugin in _config.yml.（配置完即可使用不许单独设置manifest.json文件及配置，插件生成） pwa: manifest: path: /manifest.json body: name: hexo short_name: hexo icons: - src: /images/android-chrome-192x192.png sizes: 192x192 type: image/png - src: /images/android-chrome-512x512.png sizes: 512x512 type: image/png start_url: /index.html theme_color: '#ffffff' background_color: '#ffffff' display: standalone serviceWorker: path: /sw.js preload: urls: - / posts: 5 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /.*\\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\\// strategy: networkFirst priority: 5 hexo-tag-dplayer hexo-tag-dplayer npm install hexo-tag-dplayer --save {% dplayer key=value ... %} key can be dplayer options: 'autoplay', 'loop', 'screenshot', 'hotkey', 'mutex', 'dmunlimited' : bool options, use \"yes\" \"y\" \"true\" \"1\" \"on\" or just without value to enable 'preload', 'theme', 'lang', 'logo', 'url', 'pic', 'thumbnails', 'vidtype', 'suburl', 'subtype', 'subbottom', 'subcolor', 'subcolor', 'id', 'api', 'token', 'addition', 'dmuser' : string arguments 'volume', 'maximum' : number arguments container options: 'width', 'height' : string, used in container element style other: 'code' : value of this key will be append to script tag {% dplayer \"url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4\" \"addition=https://dplayer.daoapp.io/bilibili?aid=4157142\" \"api=https://api.prprpr.me/dplayer/\" \"pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg\" \"id=9E2E3368B56CDBB4\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %} hexo-tag-aplayer more npm install --save hexo-tag-aplayer {% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %} 标签参数 title : 曲目标题 author: 曲目作者 url: 音乐文件 URL 地址 picture_url: （可选） 音乐对应的图片地址 narrow: （可选）播放器袖珍风格 autoplay: （可选） 自动播放，移动端浏览器暂时不支持此功能 width:xxx: （可选） 播放器宽度 （默认：100%) lrc:xxx: （可选）歌词文件 URL 地址 当开启 Hexo 的 文章资源文件夹 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用： {% aplayer \"Caffeine\" \"Jeff Williams\" \"caffeine.mp3\" \"picture.jpg\" \"lrc:caffeine.txt\" %} {% aplayer \"你离开了南京，从此没人和我说话\" \"李志\" \"https://cdn-1256932288.cos.ap-chengdu.myqcloud.com/files/nanjing.mp3\" \"https://p2.music.126.net/UuSe-Vc6rS7JtRJSQgDU2g==/2323268069553116.jpg?param=300x300\" %} hexo-pdf pdf 传送门 hexo-filter-flowchart（流程图） 语法 npm install --save hexo-filter-flowchart ```%flow #去掉%号 st=\u003estart: Start|past:\u003ehttps://lruihao.cn[blank] e=\u003eend: End:\u003ehttps://www.lruihao.cn[blank] op1=\u003eoperation: My Operation|past op2=\u003eoperation: Stuff|current sub1=\u003esubroutine: My Subroutine|invalid cond=\u003econdition: Yes or No?|approved:\u003e/hexo/nextplugin.html c2=\u003econdition: Good idea|rejected io=\u003einputoutput: catch something...|request st-\u003eop1(right)-\u003econd cond(yes, right)-\u003ec2 cond(no)-\u003esub1(left)-\u003eop1 c2(yes)-\u003eio-\u003ee c2(no)-\u003eop2-\u003ee ``` hexo-spoiler npm install hexo-spoiler --save If hexo can’t detect this plugin automatically, you need to modify the plugins section of [path_to_your_site]/_config.yml manually, like: plugins: - hexo-spoiler {% spoiler [text] %} It will pixelate your text, and click to reveal. Click again to hide your text again. But you need to add \u003cbr\u003e manually if you want line breaks after/before it. When you writes: {% spoiler text %} {% spoiler ~~text~~ %} {% spoiler *text* %} {% spoiler **text** %}\u003cbr\u003e {% spoiler **hello welcome to 博採眾長！** %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:1","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"宅音乐侧栏播放器插件 体验 源码 目前在 next 中可能引起部分 css 冲突，建议在 next 中使用在单个页面中。 依赖于 jQuery，一行 js 可以引入播放器插件。 ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:2","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"caniuse 使用 {% caniuse feature @ periods %} \u003c!-- Tag Alias --\u003e {% can feature @ periods %} feature : Search for the feature you want on https://caniuse.com, then click on the hash sign to the left of the search result heading and you will get the unique name of this feature. periods : Select the browser versions to display. Supported values: past_1, past_2, past_3, past_4, past_5, current, future_3, future_2, future_1. If this value is empty, the default value 'current' will be used. 栗子 Caniuse without periods {% caniuse fetch %} Caniuse with current period {% can sharedarraybuffer @ current %} Caniuse with future periods {% caniuse loading-lazy-attr @ future_3,future_2,future_1 %} Caniuse with past periods {% caniuse link-rel-modulepreload @ past_1,past_2,past_3,past_4,past_5 %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:3","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"Include Raw This tag include any raw content into your posts. Path is relative to your site source directory. {% include_raw '_data/path/to/file.html' %} Let’s create include-raw.html file in _data directory under site root directory with following content: Any \u003cstrong\u003eraw content\u003c/strong\u003e may be included with this tag. Then in any post we can use this content with include_raw tag: {% include_raw '_data/path/to/include-raw.html' %} Any raw content may be included with this tag. ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:4","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"button more info {% button url, text, icon [class], [title] %} \u003c!-- Tag Alias --\u003e {% btn url, text, icon [class], [title] %} url : Absolute or relative path to URL. text : Button text. Required if no icon specified. icon : FontAwesome icon name (without 'fa-' at the begining). Required if no text specified. [class] : FontAwesome class(es): fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5x Optional parameter. [title] : Tooltip at mouseover. Optional parameter. {% btn #, Text \u0026 Large Icon \u0026 Title, home fa-fw fa-lg, Title %} ``` ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:5","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"Mermaid more info example {% mermaid gitGraph: %} options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit checkout master commit merge newbranch {% endmermaid %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:6","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"video Usage {% video url %} Examples {% video https://example.com/sample.mp4 %} {% video /path/to/your/video.mp4 %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:7","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"tab 选项卡 “tab\"为选项卡的名称，可以自定义，数字是几表示从第几个选项卡开始。非必须，若数值为-1 则隐藏选项卡内容。 查看更多 {% tabs Unique name, [index] %} \u003c!-- tab [Tab caption] [@icon] --\u003e Any content (support inline tags too). \u003c!-- endtab --\u003e {% endtabs %} Unique name : Unique name of tabs block tag without comma. Will be used in #id's as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique! [index] : Index number of active tab. If not specified, first tab (1) will be selected. If index is -1, no tab will be selected. It's will be something like spoiler. Optional parameter. [Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. Optional parameter. [@icon] : FontAwesome icon name (without 'fa-' at the begining). Can be specified with or without space; e.g. 'Tab caption @icon' similar to 'Tab caption@icon'. Optional parameter. {% tabs tab,2 %} \u003c!-- tab --\u003e this is tab1 \u003c!-- endtab --\u003e \u003c!-- tab --\u003e this is tab2 \u003c!-- endtab --\u003e \u003c!-- tab --\u003e this is tab3 \u003c!-- endtab --\u003e {% endtabs %} 数值为-1 {% tabs 选项，-1 %} \u003c!-- tab --\u003e **选项 1** \u003c!-- endtab --\u003e \u003c!-- tab --\u003e **选项 2** \u003c!-- endtab --\u003e \u003c!-- tab --\u003e **选项 3** \u003c!-- endtab --\u003e {% endtabs %} 名字写在选项里面 {% tabs Fourth unique name %} \u003c!-- tab Solution 1 --\u003e **This is Tab 1.** \u003c!-- endtab --\u003e \u003c!-- tab Solution 2 --\u003e **This is Tab 2.** \u003c!-- endtab --\u003e \u003c!-- tab Solution 3 --\u003e **This is Tab 3.** \u003c!-- endtab --\u003e {% endtabs %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:8","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"note 便签 主题配置文件搜索 note, 可设置风格和图标是否显示。 # Note tag (bs-callout). note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 15 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 写法 {% note default %} default 类型还有以下几种 {% endnote %} {% note primary %} primary 内容 {% endnote %} {% note success %} success 内容 {% endnote %} {% note info %} info 内容 {% endnote %} {% note warning %} warning 内容 {% endnote %} {% note danger %} danger 内容 {% endnote %} {% note %} 不填 内容 {% endnote %} {% note danger no-icon %} danger no-icon 内容 {% endnote %} ### 引用（文本居中） {% cq %} there are test words {% endcq %} ### [Font Awesome 图标](https://www.runoob.com/font-awesome/fontawesome-tutorial.html) \u003e Font Awesome 是一套绝佳的图标字体库和 CSS 框架。 \u003e Font Awesome 字体为您提供可缩放矢量图标，它可以被定制大小、颜色、阴影以及任何可以用 CSS 的样式。 \u003e 要使用 Font Awesome 图标，请在 HTML 页面的 部分中添加以下行： #### 1、国内推荐 CDN ``` #### 2、海外推荐 CDN \u003clink rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"\u003e next 已经引用了，可以直接用，比如： \u003ci class=\"fa fa-car\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car\" style=\"font-size:48px;\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car\" style=\"font-size:60px;color:red;\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-lg\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-2x\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-3x\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-4x\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-5x\"\u003e\u003c/i\u003e 动态图标 \u003ci class=\"fa fa-spinner fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-circle-o-notch fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-refresh fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-cog fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-spinner fa-pulse\"\u003e\u003c/i\u003e ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:9","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"代码块等 [language] [title] [url] [link text] code snippet - printf(\"Hello World!\"); + printf(\"Hello_World!\"); iframe 在文章中插入 iframe。 {% iframe url [width] [height] %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:10","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"Todo list 已完成 未完成 \u003cul\u003e \u003cli\u003e\u003ci class=\"fa fa-check-square\"\u003e\u003c/i\u003e 已完成\u003c/li\u003e \u003cli\u003e\u003ci class=\"fa fa-square\"\u003e\u003c/i\u003e 未完成\u003c/li\u003e \u003c/ul\u003e \u003c!--或者--\u003e - \u003ci class=\"fa fa-check-square\"\u003e\u003c/i\u003e 已完成 - \u003ci class=\"fa fa-square\"\u003e\u003c/i\u003e 未完成 ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:11","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"Label 主题配置文件中打开 # Label tag. label: true @前面的是 label 的名字，后面的是要显示的文字 {% label default@default %} primary success info warning danger ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:12","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["Memo"],"content":"其他 包括小色块、左侧色条、右侧色条、上方色条、数字色块（需要自定义样式） ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:13","tags":["hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["OS"],"content":" 前面我有文章提到怎么提交本地文件到 github,coding 等远程仓库。每次可以分为三个步骤 git add * （添加需要提交的文件，这里全选） git commit -m “提交信息” git push 但是这样感觉很麻烦每次都要重复输入提交命令和提示信息。 这个时候可以用到 windows 批处理 bat 文件 (linux 的话可以用 shell 脚本）。用完发现好用到不行！ ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:0","tags":["bat"],"title":"通过 bat 批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["OS"],"content":"新建文本文档 @echo off title Commit git add . set /p m=Message: git commit -m \"%m%\" git push 然后另存为commit.bat文件，只要后缀是bat就行了。 ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:1","tags":["bat"],"title":"通过 bat 批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["OS"],"content":"使用 把文件放到你原本需要提交代码的本地文件夹。双击运行，输入提交信息回车即可。 ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:2","tags":["bat"],"title":"通过 bat 批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["OS"],"content":"hexo 博客新姿势 hexo 提交也很麻烦，当然也要批处理一下呀 hexo clean\u0026\u0026hexo g -d ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:3","tags":["bat"],"title":"通过 bat 批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["OS"],"content":"其他 死机脚本 (友情提醒千万不要在真机实验，请在虚拟机运行) start cmd ifconfig 另外也说一下 linux 死机命令。fork 炸弹。 死机无非是耗尽系统资源 _(){ _ | _ \u0026 }; _ 这个\u0026指后台运行的意思。 统计文件名 dir \\\\?\\%1 /a:-d /b /o /p /w \u003eFilelist.txt 将需要统计的文件夹拖到 bat 文件上。 ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:4","tags":["bat"],"title":"通过 bat 批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["Grocery"],"content":"介绍 使用 fusion app 对网页进行的封装。 功能： 浏览本博客，主页 私人网盘 2048 等小游戏 在线客服，QQ 等 pc 与移动浏览器标识切换 留言，打赏，博主日志等 分享功能，分享到 QQ，微信，浏览器打开等 app 内添加书签，自动记录历史记录，刷新等 配合博客的PWA + quicklink功能可实现离线浏览 ","date":"2018-11-12","objectID":"/posts/fas-app/:0:1","tags":["lua","fusion"],"title":"博採眾長 app","uri":"/posts/fas-app/"},{"categories":["Grocery"],"content":"下载 app 内也可以更新，不过就我自己用，懒得更新。 百度云，密码：479l github 下载 PWA 应用 地址栏输入：Chrome://flags 搜索并启用以下项目：Desktop PWAs（桌面 PWAs)、App Banners（应用横幅）、Experimental App Banners（实验性应用横幅） 重启浏览器使修改的设置生效 点击地址栏最右边按钮 安装“博採眾長” ","date":"2018-11-12","objectID":"/posts/fas-app/:0:2","tags":["lua","fusion"],"title":"博採眾長 app","uri":"/posts/fas-app/"},{"categories":["Grocery"],"content":"部分源码 看到这些中文的函数总觉得怪怪的哈哈哈 😂 语言：lua 检测更新 --检查测当前是否最新版本 local dl=ProgressDialog.show(activity,nil,'更新检测中…') dl.show() local tt=Ticker() tt.start() packinfo=this.getPackageManager().getPackageInfo(this.getPackageName(),((32552732/2/2-8183)/10000-6-231)/9) version=tostring(packinfo.versionName) versioncode=tostring(packinfo.versionCode) url=\"https://share.weiyun.com/43fa66d8fc95db27141530ed2d006be2\"; function 过滤 (content) 版本名=content:match(\"【版本名】(.-)【版本名】\") 版本=content:match(\"【版本】(.-)【版本】\") 内容=content:match(\"【内容】(.-)【内容】\") 链接=content:match(\"【链接】(.-)【链接】\") if（版本名==nil) then 版本名=\"获取失败\" end if（版本==nil) then 版本=\"0\" end if（内容==nil) then 内容=\"获取失败\" end if（链接==nil) then 弹出消息 (\"服务器参数配置错误，请过段时间再次尝试\") end if（版本 \u003e versioncode) then dl.dismiss() tt.stop() 对话框 () . 设置标题 (\"检测到更新\") . 设置消息 (\"版本：\"..version..\"→\".. 版本名。.\"\\n 更新内容：\".. 内容） . 设置积极按钮 (\"下载更新\",function() 下载文件（链接） 弹出消息 (\"下载更新中…\") end) . 设置消极按钮 (\"取消更新\") . 显示 () else dl.dismiss() tt.stop() 弹出消息 (\"当前已是最新版本！\") end Http.get(url,nil,\"UTF-8\",nil,function(code,content,cookie,header) if(code==200 and content)then content=content:match(\"\\\"html_content\\\":(.-),\"):gsub(\"\\\\u003C/?.-%\u003e\",\"\"):gsub(\"\\\\\\\\\",\"\u0026revs;\"):gsub(\"\\\\n\",\"\\n\"):gsub(\"\u0026nbsp;\",\" \"):gsub(\"\u0026lt;\",\"\u003c\"):gsub(\"\u0026gt;\",\"\u003e\"):gsub(\"\u0026quot;\",\"\\\"\"):gsub(\"\u0026apos;\",\"'\"):gsub(\"\u0026revs;\",\"\\\\\"):gsub(\"\u0026amp;\",\"\u0026\"); 过滤 (content) else dl.dismiss() tt.stop() 弹出消息 (\"本地网络或服务器异常 \"..code) end end) 方向锁定 --flag 在程序启动事件声明的全局变量 if flag==1 then activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR); SetHSP=\"H\" else SetHSP=nil end if SetHSP==nil then --竖屏锁定 activity.setRequestedOrientation(1); flag=1 else flag=0 end 程序启动事件 弹出消息 (\"©2018 李瑞豪\") --自动，由物理感应器决定 import \"android.content.pm.ActivityInfo\" flag=1 --程序退出时执行对话框 function onKeyDown(key,event) if(key==4)then if(webView.canGoBack())then webView.goBack() else appinfo=this.getPackageManager().getApplicationInfo(this.getPackageName(),0) applabel=this.getPackageManager().getApplicationLabel(appinfo) 退出确认=对话框 () . 设置消息 (\"您确定要退出 \"..applabel..\" 吗？\") 退出按钮={ [1]=function() 退出确认 . 设置积极按钮 (\"确认\",function() 退出程序 () end ) . 设置中立按钮 (\"清除缓存\",function() 对话框 () . 设置消息 (\"清除缓存后再次运行程序将变得缓慢、n 您确定要清除 \"..applabel..\" 的缓存吗？\") . 设置积极按钮 (\"确定\",function() os.execute(\"pm clear \"..this.packageName) 退出程序 () end) . 设置消极按钮 (\"取消\",function() end) . 显示 () end ) . 设置消极按钮 (\"取消\") end } math.randomseed(tonumber(tostring(os.time()):reverse():sub(1, 6))) 退出按钮 [math.random(1,1)]() 退出确认。show() end return true end end --历史记录 lstads=\"/data/data/\"..activity.getPackageName()..\"/lst.lua\" lstwebads=\"/data/data/\"..activity.getPackageName()..\"/lstweb.lua\" --2. 序列化 function slz(obj) local lua = \"\" local t = type(obj) if t == \"number\" then lua = lua .. obj elseif t == \"boolean\" then lua = lua .. tostring(obj) elseif t == \"string\" then lua = lua .. string.format(\"%q\", obj) elseif t == \"table\" then lua = lua .. \"{\\n\" for k, v in pairs(obj) do lua = lua .. \"[\" .. slz(k) .. \"]=\" .. slz(v) .. \",\\n\" end local metatable = getmetatable(obj) if metatable ~= nil and type(metatable.__index) == \"table\" then for k, v in pairs(metatable.__index) do lua = lua .. \"[\" .. slz(k) .. \"]=\" .. slz(v) .. \",\\n\" end end lua = lua .. \"}\" elseif t == \"nil\" then return nil else error(\"can not serialize a \" .. t .. \" type.\") end return lua end function rslz(lua) local t = type(lua) if t == \"nil\" or lua == \"\" then return {} elseif t == \"number\" or t == \"string\" or t == \"boolean\" then lua = tostring(lua) else error(\"can not unserialize a \" .. t .. \" type.\") end lua = \"return \" .. lua local func = loadstring(lua) if func == nil then return nil end return func() end --3. 历史记录框布局 function hstshow() hstlayout={ LinearLayout, orientation=\"1\", gravity=\"center\", layout_width=\"wrap_content\", layout_height=\"wrap_content\", { TextView, text=\"\", gravity=\"center\", layout_width=\"wrap_content\", textSize=\"0sp\", background=\"#000000\", layout_height=\"15dp\",}, { TextView, text=\"历史记录\", gravity=\"center\", layout_width=\"wrap_content\", textSize=\"30sp\", textStyle=\"bold\", layout_height=\"50dp\",}, { ListView, id=\"hlst\", items=","date":"2018-11-12","objectID":"/posts/fas-app/:0:3","tags":["lua","fusion"],"title":"博採眾長 app","uri":"/posts/fas-app/"},{"categories":["Grocery"],"content":"安装 cd ~ curl https://getcaddy.com | bash -s personal http.filemanager ","date":"2018-11-11","objectID":"/posts/caddy-file/:1:0","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["Grocery"],"content":"编写配置文件 vim Caddyfile 内容如下： :80 { filemanager / /sdcard timeouts none gzip } 这里的 8080 端口号可以随意指定，如果在手机 termux 等搭建，由于手机权限比较低，所以一般设置 1024 以上的端口。80端口可以直接通过 ip 访问。如118.24.217.167 如果用域名，先在域名服务商解析 ip, 再配置文件如下 https://pan.lruihao.cn { filemanager / /sdcard timeouts none tls admin@lruihao.cn gzip } 指定邮箱是为了申请 ssl, 实现 https. ","date":"2018-11-11","objectID":"/posts/caddy-file/:2:0","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["Grocery"],"content":"demo 启动 caddy caddy 账号密码默认admin ","date":"2018-11-11","objectID":"/posts/caddy-file/:3:0","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["Grocery"],"content":"设置定时器启动 caddy（好像没用，我不会） 为了断开 xshell 后 caddy 还在运行。 vim run.sh 编辑以下内容 #!/bin/bash caddy 加权 chmod +x run.sh 设置任务 参考 crontab -e 加入 * * * * * /root/run.sh service crond start ","date":"2018-11-11","objectID":"/posts/caddy-file/:4:0","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["Grocery"],"content":"？？？ 最后误打误撞开启了 caddy 昨晚双十一要抢裤子，加上湘潭天气太 tm 冷了，就上床了，接着用 termux 远程连接服务器继续搞。结果连接的时候命令输错了-_-! 本来是ssh root@118.24.217.167再输入密码就可以了。这次搞错了多写了个-T, 然后运行caddy,ctrl+c 再断开，意外地发现 filemanager 竟然可以访问了。 ssh -T root@118.24.217.167 caddy Ctrl+c ","date":"2018-11-11","objectID":"/posts/caddy-file/:5:0","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["Memo"],"content":" 最新的 next 主题已经更新了支持 PDF 功能，写法也和链接写法一样，可是我没有更新，我按 github 上那个 readme 试了一下好像不可以，所以用了另外一种插件的方法。 ","date":"2018-11-09","objectID":"/posts/next-pdf/:0:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["Memo"],"content":"iframe(推荐) \u003ciframe src=\"/posts/next-pdf/1.pdf\" style=\"width: 100%;height: 800px;\"\u003e\u003c/iframe\u003e ","date":"2018-11-09","objectID":"/posts/next-pdf/:1:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["Memo"],"content":"模板自带 今天（2019.4.3）又看了一下，改了写法，写法和插件一样，我在我的模板里也更新了。（插件模板二选一即可,个人更喜欢插件） 但是如果安装插件后，也是优先模板的 pdf 脚本解析 pdf,所以在我的模板中把模板的 pdf 脚本先注释了。要启用去掉注释即可。 /* 'use strict'; function pdf(args) { return `\u003cdiv class=\"pdf\" target=\"${args[0]}\" height=\"${args[1] || ''}\"\u003e\u003c/div\u003e`; } hexo.extend.tag.register('pdf', pdf, {ends: false}); */ ","date":"2018-11-09","objectID":"/posts/next-pdf/:2:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["Memo"],"content":"pdf 插件(推荐) ","date":"2018-11-09","objectID":"/posts/next-pdf/:3:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["Memo"],"content":"安装 npm install --save hexo-pdf ","date":"2018-11-09","objectID":"/posts/next-pdf/:3:1","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["Memo"],"content":"使用 {% pdf url %} 比如本文 {% pdf /posts/next-pdf/1.pdf %} ","date":"2018-11-09","objectID":"/posts/next-pdf/:3:2","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["JavaScript"],"content":"前端开发经常遇到需要判断用户的浏览设备，是 pc 端还是移动端，移动端使用的是什么手机系统？android、ios、ipad、windows phone 等等，有时候还需要知道用户浏览页面是在微信中打开还是在移动端浏览器中打开，等等一系列判断做一些相应的处理。 ","date":"2018-11-03","objectID":"/posts/js-device/:0:0","tags":["JavaScript","他山之石"],"title":"js 判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"首先判断 pc 端还是移动端 function IsPC() { var userAgentInfo = navigator.userAgent; var Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; var flag = true; for (var v = 0; v \u003c Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u003e 0) { flag = false; break; } } return flag; } ","date":"2018-11-03","objectID":"/posts/js-device/:0:1","tags":["JavaScript","他山之石"],"title":"js 判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"判断用户移动端使用的系统平台 var u = navigator.userAgent; if (u.indexOf('Android') \u003e -1 || u.indexOf('Linux') \u003e -1) { //安卓手机 } else if (u.indexOf('iPhone') \u003e -1) { //苹果手机 } else if (u.indexOf('Windows Phone') \u003e -1) { //winphone 手机 } ","date":"2018-11-03","objectID":"/posts/js-device/:0:2","tags":["JavaScript","他山之石"],"title":"js 判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"判断用户是否在微信中打开 function isWeiXin(){ var ua = navigator.userAgent.toLowerCase(); if(ua.indexOf('micromessenger') != -1) { return true; } else { return false; } } ","date":"2018-11-03","objectID":"/posts/js-device/:0:3","tags":["JavaScript","他山之石"],"title":"js 判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"实际运用 根据 pc 或者移动端控制飘花数目，降低 cpu 消耗，减少卡顿。demo \u003cscript\u003e function sakuraInit() { $(document).snowfall('clear'); var userAgentInfo = navigator.userAgent; var Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; var flag = true; for (var v = 0; v \u003c Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u003e 0) { flag = false; break; } } if (flag) { $(document).snowfall({image:\"images/1.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/2.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/3.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/4.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); } else { $(document).snowfall({image:\"images/1.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/2.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/3.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/4.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); } } window.onload = sakuraInit(); \u003c/script\u003e ","date":"2018-11-03","objectID":"/posts/js-device/:0:4","tags":["JavaScript","他山之石"],"title":"js 判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["Memo","Git"],"content":"备份 hexo 博客 //如果 themes/next（主题文件）下面有。git，请删除这个。git 文件夹。 cd hexo git init //初始化本地仓库 git add source themes scaffolds _config.yml package.json package-lock.json //将必要的文件依次添加 git commit -m \"blog hexo\" git branch hexo //新建 hexo 分支 git checkout hexo //切换到 hexo 分支上 git remote add origin git@github.com:username/username.github.io.git //将本地与 Github 项目对接 git push origin hexo //push 到 Github 项目的 hexo 分支上 ","date":"2018-11-03","objectID":"/posts/blog-backup/:1:0","tags":["Git","Node.js","hexo"],"title":"hexo 博客源码备份","uri":"/posts/blog-backup/"},{"categories":["Memo","Git"],"content":"在其他终端克隆和更新 hexo 博客 nodejs,git,hexo 已经安装好，即搭建完成 ","date":"2018-11-03","objectID":"/posts/blog-backup/:2:0","tags":["Git","Node.js","hexo"],"title":"hexo 博客源码备份","uri":"/posts/blog-backup/"},{"categories":["Memo","Git"],"content":"克隆 hexo 博客备份 git clone -b hexo git@github.com:username/username.github.io.git //将 Github 中 hexo 分支 clone 到本地 cd user.github.io npm install //注意，这里一定要切换到刚刚 clone 的文件夹内执行，安装必要的所需组件，不用再 init 这样我们的备份文件就会原封不动的拷贝到本地。 ","date":"2018-11-03","objectID":"/posts/blog-backup/:2:1","tags":["Git","Node.js","hexo"],"title":"hexo 博客源码备份","uri":"/posts/blog-backup/"},{"categories":["Memo","Git"],"content":"写新文章并备份和部署（备用操作） 其实源码拷下来了，这步不做我们也知道怎么做了，完全没必要按照教程死搬硬套。灵活一点就行了。 //进入 username.github.io 文件夹，应是 hexo 分支 git pull origin hexo //本地和远端的融合 hexo new post \"new post name\" //写新文章 git add source git commit -m \"xxx\" git push origin hexo //备份 hexo d -g //部署 参考 ","date":"2018-11-03","objectID":"/posts/blog-backup/:2:2","tags":["Git","Node.js","hexo"],"title":"hexo 博客源码备份","uri":"/posts/blog-backup/"},{"categories":["随笔"],"content":" 备案 经过时间长达 20 多天的备案之旅今天终于结束了，也闭馆了 20 多天，也按相关要求把 ICP 备案号和公安备案号加载了网站和博客底部。只是今天去岳塘分局签网络安全告知书的时候不小心把身份证落在那个办公室了。亏我走之前一秒还在提醒自己，唉！不过那个办公室的大姐姐挺好的，前面跟我说好星期一来，我还今天上午提前给她打了电话，她还下楼给我开办公楼楼道的门禁，还有我身份证落在那里她说先帮我收着，有时间再去拿！总之，这个姐姐的服务态度五星好评！手动@岳塘分局 B204 的姐姐。 备案完成也算放下一块提着的石头，可以睡个好觉了！ZzZzzzz ","date":"2018-10-29","objectID":"/posts/beian/:0:0","tags":["随笔","网站备案"],"title":"网站备案之旅","uri":"/posts/beian/"},{"categories":["OS"],"content":"今天上机学了几个小命令 read echo if 然后自己写了一个小脚本觉得还挺有趣的 #!/bin/bash #liruihao #menu.sh #sudo apt curl install nyancat sl figlet toilet cowsay echo \"-------------菜-单--------------\" echo \"------------1-打印二维码--------\" echo \"------------2-彩虹猫------------\" echo \"------------3-小火切------------\" echo \"------------4-打字机------------\" echo \"------------5-小许牛------------\" echo \"----------Ctrl+c 暂停程序--------\" echo \"\" echo \"请输入序号！\" read i if test $i -eq 1 then echo \"请输入网址！\" read s1 echo $s1 |curl -F-=\\\u003c- qrenco.de fi if test $i -eq 2 then nyancat fi if test $i -eq 3 then sl fi if test $i -eq 4 then echo \"请输入字符串！\" read s2 echo \"选择样式：\" echo \"------样式 1-----\" echo \"------样式 2-----\" read j if test $j -eq 1 then figlet $s2 else toilet -f mono12 -F gay $s2 fi fi if test $i -eq 5 then echo \"请输入字符串！\" read s3 cowsay $s3 fi echo \"任意建继续！\" read x clear ./menu.sh ","date":"2018-10-29","objectID":"/posts/shell/:0:0","tags":["shell","linux"],"title":"shell 脚本初体验","uri":"/posts/shell/"},{"categories":["OS"],"content":"搭建 Apache web 服务 安装 Apache 超文本传输协议 (HTTP) 服务器的主程序 [root@VM_0_6_centos /]# yum install -y httpd 注意安装目录，可通过 cd 命令切换。 启动 HTTP 服务 [root@VM_0_6_centos /]# systemctl start httpd.service 如果启动失败，可通过 systemctl status httpd.service 查看错误原因。 启动成功，证明 http 服务已经可以使用，发现还需要把本地文件传到服务器。 默认根目录/var/www/html/ ","date":"2018-10-29","objectID":"/posts/web-server-yun/:0:1","tags":["server","linux","他山之石"],"title":"云服务器 CentOS 系统搭建 web 服务","uri":"/posts/web-server-yun/"},{"categories":["OS"],"content":"使用 SSH 连接服务器 尝试了两种方式：PuTTY 和 Xshell（推荐） Xshell 方式 官网下载安装 Xshell 打开，输入 ip 账号密码连接主机。 使用 lrzsz 方式上传下载文件 步骤 1：在服务器安装 lrzsz [root@VM_0_6_centos /]# yum -y install lrzsz 步骤 2：输入命令rz打开上传窗口（可以选择多个文件。) 使用sz文件名命令可打开从服务器下载文件的保存窗口。 ","date":"2018-10-29","objectID":"/posts/web-server-yun/:0:2","tags":["server","linux","他山之石"],"title":"云服务器 CentOS 系统搭建 web 服务","uri":"/posts/web-server-yun/"},{"categories":["OS"],"content":"修改 HTTP 配置 1.VIM 编辑器打开配置文件 [root@VM_0_6_centos /]# vim /etc/httpd/conf/httpd.conf 按I键进入编辑模式 找到并修改以下内容 ServerAdmin 管理员邮箱，用于浏览器请求报错时展示 DocumentRoot 访问根目录（默认：/var/www/html），如项目存放在其他地方，可修改为项目存放位置 \u003cDirectory \"/var/www/html\"\u003e 同 DocumentRoot 配置 ServerName 服务器 IP 或 域名 按下 ESC 键输入:wq保存退出 重启服务service httpd restart 打开浏览器，输入地址访问 如：我的项目索引 html 路径为 love/index.html，输入 http://IP 地址或域名/love/index.html 访问不成功，先检查网络，再查看 http 服务是否开启，最后检查配置； 访问成功，配置完成。 ","date":"2018-10-29","objectID":"/posts/web-server-yun/:0:3","tags":["server","linux","他山之石"],"title":"云服务器 CentOS 系统搭建 web 服务","uri":"/posts/web-server-yun/"},{"categories":["JavaScript"],"content":"获取链接（转） 传送门 在 WEB 开发中，时常会用到 javascript 来获取当前页面的 url 网址信息，在这里是我的一些获取 url 信息的小总结。 下面我们举例一个 URL，然后获得它的各个组成部分：http://i.cnblogs.com/EditPosts.aspx?opt=1 window.location.href（设置或获取整个 URL 为字符串） var test = window.location.href; alert(test); 返回：http://i.cnblogs.com/EditPosts.aspx?opt=1 window.location.protocol（设置或获取 URL 的协议部分） var test = window.location.protocol; alert(test); 返回：http: window.location.host（设置或获取 URL 的主机部分） var test = window.location.host; alert(test); 返回：i.cnblogs.com window.location.port（设置或获取与 URL 关联的端口号码） var test = window.location.port; alert(test); 返回：空字符（如果采用默认的 80 端口 (update: 即使添加了：80)，那么返回值并不是默认的 80 而是空字符） window.location.pathname（设置或获取与 URL 的路径部分（就是文件地址）) var test = window.location.pathname; alert(test); 返回：/EditPosts.aspx window.location.search（设置或获取 href 属性中跟在问号后面的部分） var test = window.location.search; alert(test); 返回：?opt=1 PS：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用 javascript 来获得相信应的参数值。 window.location.hash（设置或获取 href 属性中在井号“#”后面的分段） var test = window.location.hash; alert(test); 返回：空字符（因为 url 中没有） js 获取 url 中的参数值 正则法 function getQueryString(name) { var reg = new RegExp('(^|\u0026)' + name + '=([^\u0026]*)(\u0026|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) { return unescape(r[2]); } return null; } // 这样调用： alert(GetQueryString(\"参数名 1\")); alert(GetQueryString(\"参数名 2\")); alert(GetQueryString(\"参数名 3\")); split 拆分法 function GetRequest() { var url = location.search; //获取 url 中\"?\"符后的字串 var theRequest = new Object(); if (url.indexOf(\"?\") != -1) { var str = url.substr(1); strs = str.split(\"\u0026\"); for(var i = 0; i \u003c strs.length; i ++) { theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]); } } return theRequest; } var Request = new Object(); Request = GetRequest();\u003cbr\u003e// var id=Request[\"id\"]; // var 参数 1, 参数 2, 参数 3, 参数 N; // 参数 1 = Request['参数 1']; // 参数 2 = Request['参数 2']; // 参数 3 = Request['参数 3']; // 参数 N = Request['参数 N']; 指定取 比如说一个 url：http://i.cnblogs.com/?j=js, 我们想得到参数 j 的值，可以通过以下函数调用。 function GetQueryString(name) { var reg = new RegExp(\"(^|\u0026)\" + name + \"=([^\u0026]*)(\u0026|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); //获取 url 中\"?\"符后的字符串并正则匹配 var context = \"\"; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == \"\" || context == \"undefined\" ? \"\" : context; } alert(GetQueryString(\"j\")); ","date":"2018-10-28","objectID":"/posts/href-301/:0:1","tags":["redirect","JavaScript","他山之石"],"title":"使用 js 准确获取当前页面 url 网址信息及 301 重定向实战","uri":"/posts/href-301/"},{"categories":["JavaScript"],"content":"301 重定向（实践） 由于之前把 blog 和网站主页分开在两个仓库所以要想在 blog 中 menu 里跳转到站外链接就要做一些处理。以前一直百度不到。 其实想法早就有了，只要在 blog 首页或者网站首页检测到https://lruihao.cn/home这个链接，或者检测到 home 字段就自动跳转。想法很简单。可是对 js 真的一点都不了解，以前百度也找不到实际的效果案例。所以还是自己写吧！附上蹩脚代码。 var path = window.location.href; //alert(path); if (path=='https://lruihao.cn/home/') { window.location.replace(\"https://www.lruihao.cn\"); } 或者 var path = window.location.pathname; //alert(path); if (path=='/home/') { window.location.replace(\"https://www.lruihao.cn\"); } http 强制重定向 https \u003cscript\u003e var targetProtocol = \"https:\"; var host = \"lruihao.cn\"; //域名判断，因为 localhost 仅支持 http if (window.location.host == host \u0026\u0026 window.location.protocol != targetProtocol){ window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); } \u003c/script\u003e ","date":"2018-10-28","objectID":"/posts/href-301/:0:2","tags":["redirect","JavaScript","他山之石"],"title":"使用 js 准确获取当前页面 url 网址信息及 301 重定向实战","uri":"/posts/href-301/"},{"categories":["Grocery"],"content":" 我用的 win10 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:0","tags":["server","windows"],"title":"windows 上搭建 web 服务器","uri":"/posts/web-server-win/"},{"categories":["Grocery"],"content":"打开控制面板 选择并进入“程序”，双击“启用或关闭 Windows 服务”，在弹出的窗口中选择“Internet Information Services”下面所有地选项，点击确定后，开始更新服务。 打开控制面板 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:1","tags":["server","windows"],"title":"windows 上搭建 web 服务器","uri":"/posts/web-server-win/"},{"categories":["Grocery"],"content":"查看 更新完成后，打开浏览器，输入http://localhost或者127.0.0.1回车，如果此时出现 IIS7 欢迎界面，说明 Web 服务器已经搭建成功。 查看 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:2","tags":["server","windows"],"title":"windows 上搭建 web 服务器","uri":"/posts/web-server-win/"},{"categories":["Grocery"],"content":"网站设置 当 web 服务器搭建成功后，我们下一步所要做的就是把我们开发的网站安装到 Web 服务器的目录中。一般情况下，当 Web 服务器安装完成后，会创建路径%系统根目录%inetpub/wwwroot，将我们开发的网站 COPY 到该路径下。即可实现本地访问该网站。 也可以更改根目录，搜索 IIS，点击网站，Default Web Site，基本设置修改物理路径（默认站点名称不要改） 我这里改到了 hexo 的 public 相当于 hexo 部署在本地服务器58.45.227.225 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:3","tags":["server","windows"],"title":"windows 上搭建 web 服务器","uri":"/posts/web-server-win/"},{"categories":["Grocery"],"content":"设置防火墙 让局域网当其它计算机也能访问本地网站资源。具体方法：打开控制面板，选择“系统和安全”，点击“允许程序通过 Windows 防火墙”，在弹出的对话框中勾选“万维网服务 HTTP”右侧的两个复选框，最后点击确定退出。 在局域网中其它计算机上，打开浏览器就可以通过你电脑的 ip 地址访问了（手机也可以） 本地 ip 可以通过 cmd 用 ipconfig 查看 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:4","tags":["server","windows"],"title":"windows 上搭建 web 服务器","uri":"/posts/web-server-win/"},{"categories":["Git"],"content":"config git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" 第一次使用 git 的时候需要设置提交者信息。 注意： 如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 ","date":"2018-10-26","objectID":"/posts/gituse/:0:1","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Git"],"content":"生成 ssh 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： ssh-keygen -t rsa -C \"youremail@example.com\" 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 C:\\Users\\用户名、或者~/ 下生成 .ssh文件夹，进去，打开 id_rsa.pub，复制里面的 key。去 github、coding 等平台配置 SSH 公钥（根据自己情况） ","date":"2018-10-26","objectID":"/posts/gituse/:0:2","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Git"],"content":"创建本地代码库 在本地创建一个文件夹，作为你上传代码的本地仓库，在这个文件夹内点击右键，选择 Git Bash Here，首先要初始化本地仓库： git init 接下来进行远程代码库克隆（事先在 coding 等中建立一个项目，就是你需要链接的仓库） git clone https://github.com/Lruihao/Lruihao.github.io.git 克隆时会出现输入账号密码的环节正确输入即可。 ","date":"2018-10-26","objectID":"/posts/gituse/:0:3","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Git"],"content":"代码推送（重点） git status git add * git commit -m \"代码备注随便写\" git push origin master Gearn Git Branching ","date":"2018-10-26","objectID":"/posts/gituse/:0:4","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Memo"],"content":" 前面有一篇文章写到一些，在 Android 上搭建 hexo 博客 本文当初摘要自 国光个人博客 如若作者博客 IP 被墙，可前往国光第三方博客诸如 csdn 等。备用 ","date":"2018-10-23","objectID":"/posts/termux1/:0:0","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"初始化 下载并初始化 termux 安装 vim 安装编辑器 vim pkg install vim 解决中文乱码问题 在 home 目录下，新建 .vimrc 文件 vim .vimrc 添加内容如下： set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 set enc=utf8 set fencs=utf8,gbk,gb2312,gb18030 然后 source 下变量： source .vimrc 修改启动问候语 vim $PREFIX/etc/motd 按 i 然后编辑，比如 www.lruihao.cn 李瑞豪 Esc 然后：wq 退出 管理员权限 手机已经 root, 安装 tsu, 这是一个 su 的 termux 版本，用来在 termux 上替代 su: pkg install tsu 然后终端下面输入： tsu 即可切换 root 用户，这个时候会弹出 root 授权提示。在管理员身份下，输入 exit 可回到普通用户身份。 ","date":"2018-10-23","objectID":"/posts/termux1/:0:1","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"美化 Termux-ohmyzsh 作用 ： 美化之外，主要使用了 zsh 来替代 bash 作为默认 shell。使用一键安装脚本来安装，一步到位，顺便启动了外置存储，可以直接访问 SD 卡下的目录，创建软文件夹。 使用 sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" 设置色彩样式： 运行 chcolor 更换色彩样式，或者： ~/.termux/colors.sh 设置字体 运行 chfont 更换字体，或者： ~/.termux/fonts.sh 需要软件包： curl ","date":"2018-10-23","objectID":"/posts/termux1/:0:2","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"访问外置存储 执行过上面的 zsh 一键配置脚本后，并且授予文件访问权限的话，会在家目录生成 storage 目录，并且生成若干目录，软连接都指向外置存储卡的相应目录 可以让从外置储存复制文件进 system 分区 创建 QQ 文件夹软连接 ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ 创建 blog2 文件夹软连接备份文件 ln -s /data/data/com.termux/files/home/storage/shared/blog2 blog2 ","date":"2018-10-23","objectID":"/posts/termux1/:0:3","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"安装 hexo 安装准备 pkg install nodejs pkg install git npm install hexo-cli -g npm install hexo-deployer-git --save pkg install openssh 初始化 hexo hexo init blog cd blog hexo g hexo s 浏览器输入127.0.0.1:4000查看效果 链接 github,coding,gitee 等远程仓库 ssh-keygen -t rsa -C \"your_email@example.com\" #这将按照你提供的邮箱地址，创建一对密钥（个人喜欢一路回车） 找到~/.ssh/id_rsa.pub这个文件复制里面的内容，到对应的平台生成 SSH 公钥 设置用户信息 git config --global user.name \"lruihao\" git config --global user.email \"1074627678@qq.com\" 测试链接 ssh -T git@github.com #github ssh -T git@coding.net #coding ssh -T git@gitee.com #gitee 注意#注释部分不要的 站点配置文件 打开站点配置文件填写代码库 例如我的 deploy: - type: git repository: github: git@github.com:Lruihao/Lruihao.github.io.git,master coding: git@git.coding.net:liruihao/liruihao.git,master #message: \"日常更新\" 部署 hexo clean hexo g -d 没出错就可以正常通过相应域名访问了。 https://lruihao.github.io https://liruihao.coding.me https://lruihao.gitee.io //手机 hexo 效果展示 ","date":"2018-10-23","objectID":"/posts/termux1/:0:4","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"ssh 连接电脑或者服务器 ssh root@118.24.217.167 会提示输入密码，linux 下输入密码是看不到的，大家都知道，小心点别输入错误。 之后就可以手机操作服务器了。 ","date":"2018-10-23","objectID":"/posts/termux1/:0:5","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"解决 npm 安装报错（未验证） vim $PREFIX/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js 把里面的 length 改成 4，我默认的是 1。 ","date":"2018-10-23","objectID":"/posts/termux1/:0:6","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"nyancat 彩虹猫 彩虹貓（英语：Nyan Cat）是在 2011 年 4 月上传在 Youtube 的视频，并且迅速爆红于网络，並在 2011 年 YouTube 浏览量最高的视频中排名第五。 pkg install nyancat nyancat 还有更多姿势这里就不写了，只写一下日常用到的，就这样 OK 睡觉！ ","date":"2018-10-23","objectID":"/posts/termux1/:0:7","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Memo"],"content":"termux 更多常用有趣命令（适用于 linux） vim $PREFIX/etc/motd chcolor chfont ~/.termux/colors.sh ~/.termux/fonts.sh echo \"https://www.lruihao.cn\" |curl -F-=\\\u003c- qrenco.de pkg install nyancat nyancat pkg install sl sl pkg install figlet figlet hello pkg install toilet toilet hello toilet -f mono12 -F gay \"hello\" pkg cowsay cowsay \"hello\" pkg install cmatrix cmatrix pkg install w3m w3m www.lruihao.cn cmatrix 常用命令如下： cmatrix-a : 异步滚动（默认） cmatrix-b : 随机粗体 cmatrix-B : 全部粗体 cmatrix-o : 使用旧风格滚动 cmatrix-x :X window 模式 cmatrix-V : 显示版本信息 cmatrix-u : 刷新频率，0-9，也就是滚动的快慢 cmatrix-C : 显示的颜色，支持 green（默认）,red,blue,white,yellow,cyan, magenta and black 例如：使用红色 cmatrix -b -C red 使用蓝色 cmatrix -b -C blue 等等 ........ 主义：在运行状态下，使用 0-9 数字，可以改变运行速度快慢。 开启你的装逼之路把，骚年！ ","date":"2018-10-23","objectID":"/posts/termux1/:0:8","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Grocery"],"content":"html 网页引用中文字体，文件过大，加载缓慢的解决办法","date":"2018-10-17","objectID":"/posts/web-font/","tags":["Node.js","字体压缩"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["Grocery"],"content":"安装 nodeJs 这个不多说，都有。 ","date":"2018-10-17","objectID":"/posts/web-font/:0:1","tags":["Node.js","字体压缩"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["Grocery"],"content":"安装字蛛 输入命令 npm install font-spider -g ","date":"2018-10-17","objectID":"/posts/web-font/:0:2","tags":["Node.js","字体压缩"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["Grocery"],"content":"运行 安装成功之后就开始压缩了 我的 css \u003cstyle type=\"text/css\"\u003e @font-face { font-family: MMT; src: url(\"font/MMT_579767_SOAJ0_0.ttf\"); } \u003c/style\u003e 生成新的字体库，命令行输入 font-spider C:\\Users\\李瑞豪、Desktop\\love\\index.html 官网 ","date":"2018-10-17","objectID":"/posts/web-font/:0:3","tags":["Node.js","字体压缩"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["OS"],"content":" 在 Linux 上编译 c 语言文件。 ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:0","tags":["linux","C"],"title":"linux 编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["OS"],"content":"打开 vim 编辑器 （没有就用 vi, 或者先安装 vimsudo apt-get install vim) $ vim ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:1","tags":["linux","C"],"title":"linux 编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["OS"],"content":"编辑文件 打开文件编辑器之后编辑文件 首先按Esc再:进入末行命令 再保存为 hello.c 文件后退出 : w hello.c : q 打开目录看看生成的文件 $ ls ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:2","tags":["linux","C"],"title":"linux 编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["OS"],"content":"编译生成可执行文件并执行 $ gcc hello.c -o hello $ ./hello 若权限不够则加可执行权限chmod +x hello ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:3","tags":["linux","C"],"title":"linux 编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["Projects"],"content":"预览 {{ message || '「沐目之，湘也」\\n 从下笔到停笔，从开始到结束，沐目体见证了我们稚嫩到成熟。\\n故事的开头往往极具温柔，但结局常常不尽人意。\\n那些忘不掉的人和事，岁月都已替我轻描淡写。' }} From playlist, Powered By mmt-netease 点击展开更多 《富士山下》 《爱情转移》 前尘硬化像石头 阳光在身上流转 随缘地抛下便逃走 等所有业障被原谅 我绝不罕有 爱情不停站 往街里绕过一周 想开往地老天荒 我便化乌有 需要多勇敢 你还嫌不够 你不要失望 我把这陈年风褛 荡气回肠是为了 送赠你解咒 最美的平凡 ","date":"2018-10-12","objectID":"/projects/font-mmt/:1:0","tags":["沐目体"],"title":"沐目体","uri":"/projects/font-mmt/"},{"categories":["Projects"],"content":"下载 警告 沐目体 仅用于个人非商用！ ","date":"2018-10-12","objectID":"/projects/font-mmt/:2:0","tags":["沐目体"],"title":"沐目体","uri":"/projects/font-mmt/"},{"categories":["Grocery"],"content":"概念 流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。 未使用流水线 使用流水线 流水线周期为执行时间最长的一段。 ","date":"2018-10-09","objectID":"/posts/liushuixian/:1:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"流水线计算公式 首先使用理论公式，没有答案用实践公式。 ","date":"2018-10-09","objectID":"/posts/liushuixian/:2:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"流水线吞吐率计算 流水线吞吐率是指单位时间内处理的任务的数量。 基本公式 最大吞吐率 ","date":"2018-10-09","objectID":"/posts/liushuixian/:3:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"流水线加速比 完成一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。 公式： S=不使用流水线执行时间/使用流水线执行时间 流水线加速比越高越好，说明使用流水线的效果。 ","date":"2018-10-09","objectID":"/posts/liushuixian/:4:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"流水线的效率 ","date":"2018-10-09","objectID":"/posts/liushuixian/:5:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"例题 ","date":"2018-10-09","objectID":"/posts/liushuixian/:6:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"其他 ","date":"2018-10-09","objectID":"/posts/liushuixian/:7:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"主机 ","date":"2018-10-09","objectID":"/posts/liushuixian/:7:1","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"CISC 和 RISC 类型 指令 寻址方式 实现方式 其他 CISC（复杂指令集） 数量多，使用频率差别大，可变长格式 支持多种 微程序控制技术（微码） 研制周期长 RISC（精简指令集） 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有 Load/Store 操作内存 支持方式少 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 优化编码，有效支持高级语言 ","date":"2018-10-09","objectID":"/posts/liushuixian/:7:2","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"数据的表示 数据的表示可分为：原码，反码和补码。（二进制） 原码： 符号位 0 为正，1 为负。 反码： 符号位 0 为正，1 为负。 正数： 反码同原码。 负数： 符号位除外其他位按位取反。 补码： 正数： 同原码。 负数： 符号位除外其他位按位取反再+1。 移码： 补码符号位取反。 ","date":"2018-10-08","objectID":"/posts/data/:0:1","tags":["计算机数据","计算机组成与体系结构"],"title":"计算机数据","uri":"/posts/data/"},{"categories":["Grocery"],"content":"数据表示范围 原码： -(z^n-1 - 1) ~ 2^n-1 - 1 反码： -(z^n-1 - 1) ~ 2^n-1 - 1 补码： -z^n-1 ~ 2^n-1 - 1 （补码正 0 和负 0 相同，少占一数位，就多一个范围） 例： 8 位二进制，除去符号位还有 7 位，7 个 1 为最大数，相当于 8 个 1 减 1，也就是 2^7-1, 所以范围就算出来了。 ","date":"2018-10-08","objectID":"/posts/data/:0:2","tags":["计算机数据","计算机组成与体系结构"],"title":"计算机数据","uri":"/posts/data/"},{"categories":["Grocery"],"content":"浮点数运算 对阶（小阶对大阶）+ 尾数计算（科学计数法）+ 结果规格化（科学技术法） ","date":"2018-10-08","objectID":"/posts/data/:0:3","tags":["计算机数据","计算机组成与体系结构"],"title":"计算机数据","uri":"/posts/data/"},{"categories":["JavaScript"],"content":" 这几天看到别人的博客有开关灯效果，就想给自己的博客也加一个，其实以前就在想了。经过谷歌百度后这样实现了。css+js 如何给 Web 页面增加夜间模式功能？其实所谓的夜间模式就是在页面上增加一个透明的遮罩层，但是遮罩层会挡住页面元素， 解决方法是 添加 DIV，给 DIV 的 outline 属性一个很大的 outline-width 值，用 outline 的边框作为遮罩，这样既能正常点击页面元素，又能达到夜间模式的效果。 ","date":"2018-09-27","objectID":"/posts/night/:0:0","tags":["JavaScript"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"css 部分 \u003cstyle\u003e .cover{ position:fixed; top: 0px; left: 0px; outline:5000px solid rgba(0, 0, 0, 0);//初始亮度 z-index: 99999; } \u003c/style\u003e ","date":"2018-09-27","objectID":"/posts/night/:0:1","tags":["JavaScript"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"js 部分 \u003cscript\u003e var brightness; //显示遮罩 function cover(brightness) { if (typeof(div) == 'undefined') { div = document.createElement('div'); div.setAttribute('style', 'position:fixed;top:0;left:0;outline:5000px solid;z-index:99999;'); document.body.appendChild(div); } else { div.style.display = ''; } div.style.outlineColor = 'rgba(0,0,0,' + brightness + ')'; } //事件监听 window.addEventListener('keydown', function(e) { if (e.altKey \u0026\u0026 e.keyCode == 90) { cover(brightness = 0.3); } if (e.altKey \u0026\u0026 e.keyCode == 88) { cover(brightness = 0); } if (e.altKey \u0026\u0026 e.keyCode == 38) { if (brightness - 0.05 \u003e 0.05) cover(brightness -= 0.05); } if (e.altKey \u0026\u0026 e.keyCode == 40) { if (brightness + 0.05 \u003c 0.95) cover(brightness += 0.05); } }, false); \u003c/script\u003e ","date":"2018-09-27","objectID":"/posts/night/:0:2","tags":["JavaScript"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"html 部分 \u003cdiv class=\"cover\"\u003e\u003c/div\u003e ","date":"2018-09-27","objectID":"/posts/night/:0:3","tags":["JavaScript"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"使用 Alt+Z: 打开夜间模式 Alt+X: 关闭 Alt+↑: 增加亮度 Alt+↓: 降低亮度 ","date":"2018-09-27","objectID":"/posts/night/:0:4","tags":["JavaScript"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":" 从暑假到现在有好几个小伙伴问我博客的标题怎么变来变去的，不想再和每个人都说一遍了，耽误时间，索性写一下。 ","date":"2018-09-26","objectID":"/posts/crash-cheat/:0:0","tags":["JavaScript","hexo"],"title":"网页离开时改变标题“崩溃欺骗”","uri":"/posts/crash-cheat/"},{"categories":["JavaScript"],"content":"创建一个 js 文件 我们先创建一个 js 文件，我们用记事本就好了，然后改个文件名，不妨就叫crash-cheat.js吧，你们可以随意！ 然后把文件放到 source 文件夹的 js 文件夹的 src 里面。（我用的 next 主题，放这里统一存放，其他主题随意） 崩溃欺骗 (Jquery 版） var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', 'https://i.loli.net/2018/08/24/5b7fcb00ed9bf.png'); document.title = '怎么回事╭(°A°`)╮'; clearTimeout(titleTime); } else { $(\"[rel='icon']\").attr('href', 'https://i.loli.net/2018/09/25/5baa4f21661e7.png'); document.title = '小老弟 (ฅ\u003eω\u003c*ฅ)'; titleTime = setTimeout(function () { document.title = OriginTitle; $(\"[rel='icon']\").attr('href', '/images/favicon-32x32-next.png'); }, 2000); } }); 崩溃欺骗 (JS 版） var oldTitle = document.title; var titleTime; //標題恢復計時器 document.addEventListener('visibilitychange', function () { if (document.hidden) { document.querySelector(\"[rel='icon']\").setAttribute('href', '/images/icons/favicon-32.png'); document.title = '網站崩潰了！'; clearTimeout(titleTime); } else { document.title = '其實並沒有！'; document.querySelector(\"[rel='icon']\").setAttribute('href', '/images/icons/crash.png'); titleTime = setTimeout(function () { document.title = oldTitle; }, 1000); } }); ","date":"2018-09-26","objectID":"/posts/crash-cheat/:1:0","tags":["JavaScript","hexo"],"title":"网页离开时改变标题“崩溃欺骗”","uri":"/posts/crash-cheat/"},{"categories":["JavaScript"],"content":"使用 在hexo\\themes\\hexo-theme-next\\layout文件路径找到layout.swig文件，其他有些主题用的是.ejs后缀，一样的。 然后打开文件，在\u003cbody\u003e\u003c/body\u003e之间加入调用刚刚的 js。 \u003cscript type=\"text/javascript\" src=\"/js/src/crash-cheat.js\"\u003e\u003c/script\u003e 重新部署博客就可以了。 ","date":"2018-09-26","objectID":"/posts/crash-cheat/:2:0","tags":["JavaScript","hexo"],"title":"网页离开时改变标题“崩溃欺骗”","uri":"/posts/crash-cheat/"},{"categories":["Git","OS"],"content":"下载 git wget https://github.com/git/git/archive/v2.14.1.zip ","date":"2018-09-22","objectID":"/posts/linux-git/:0:1","tags":["Git","linux"],"title":"linux/centos 下的安装 git","uri":"/posts/linux-git/"},{"categories":["Git","OS"],"content":"安装依赖 sudo yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker ","date":"2018-09-22","objectID":"/posts/linux-git/:0:2","tags":["Git","linux"],"title":"linux/centos 下的安装 git","uri":"/posts/linux-git/"},{"categories":["Git","OS"],"content":"解压 git unzip v2.14.1.zip 注： unzip 命令用不了，具体步骤如下： #yum list | grep zip/unzip #yum install zip #yum install unzip 基本完成，如果在编译的时候出现错误：gcc : error trying to exec 'cc1plus': execvp : No sunch file or directory 可以用gcc -v/g++ -v 来查看 gcc 版本，会发现没有安装。安装如下： #yum list | grep gcc #yum install gcc-c++ #yum install unzip ","date":"2018-09-22","objectID":"/posts/linux-git/:0:3","tags":["Git","linux"],"title":"linux/centos 下的安装 git","uri":"/posts/linux-git/"},{"categories":["Git","OS"],"content":"将 git 安装到/usr/local 上 先进入 git 文件夹 编译 安装 cd git-2.14.1 make prefix=/usr/local all make prefix=/usr/local install ","date":"2018-09-22","objectID":"/posts/linux-git/:0:4","tags":["Git","linux"],"title":"linux/centos 下的安装 git","uri":"/posts/linux-git/"},{"categories":["Git","OS"],"content":"验证是否安装完成 git --version … ","date":"2018-09-22","objectID":"/posts/linux-git/:0:5","tags":["Git","linux"],"title":"linux/centos 下的安装 git","uri":"/posts/linux-git/"},{"categories":["随笔"],"content":" 手机便签里保存的一段话，也记不得在哪看到的了。 每一个优秀的人，都有一段沉默的时光，是那一段时光，不抱怨不诉苦，最后渡过了这段感动自己的日子。 什么都还没有，所以没有卖弄的资格。如果有了什么，就没有卖弄的必要。 人生的每一笔经历，都在书写你的简历。多做你本以为微不足道的事情，回头看的时候，都有着无法细数的刻度。 自己拼出来的东西，和别人送到嘴边的东西，意义和珍惜的程度都大为不同。 我从不担心我努力了不优秀，只担心优秀的人都比我更努力。 决定你高度的是你对自己的要求。 以前的我，常常担心、常常犹豫，可现在我发现，人生的每一个阶段，都需要我们有一种能力同一时间完成很多重要的事情。 学习的时候，我们要谈谈恋爱。工作的时候，我们要担心家庭。所以，这是一种平衡的能力。 相信我，你做得到。因为，那么那么多学长学姐都走过来了，所以不用怕不用怕，你从来都不是一个人。 不要抱怨，抱怨永远只能显示你没本事。因为如果你有本事，就可以改变现状，而不只是忍受。 既然改变不了，又不够走开，那么就沉默地接受现实。 隐忍，是我们抵抗世界的力量，当你拥有，你才有资格自由。 我们做的每一个决定，都是由自己来买单。 而当你可以把自己不喜欢的东西都做好的时候，相信你一定可以把自己喜欢的东西做的更好！ 努力和效果之间，永远有这样一段距离。成功和失败的唯一区别是，你能不能坚持挺过这段无法估计的距离。 你可以试试？ 坚持做一件事情，坚持下去。不管它是什么。 选择本身，就是放弃另一种跋涉的可能。尝试倾听自己内心的声音，而不是外在的掌声。 尝试选择适合自己的，而不是别人眼里最好的。 尝试决定我们的决定，不是因为选项表面的光鲜亮丽。 所以，每当我们每做一个选择的时候，总记得兑现心中的对自己的承诺。 不要想得到一切，对生活对自己都慷慨一些。 ","date":"2018-09-21","objectID":"/posts/mood/:0:0","tags":["随笔"],"title":"每一个优秀的人，都有一段沉默的时光","uri":"/posts/mood/"},{"categories":["Memo"],"content":"Vim 速查表-帮你提高 N 倍效率 ","date":"2018-08-31","objectID":"/posts/vim/:0:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"进入 vim 命令 描述 vim filename 打开或新建文件，并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第 n 行首 vim + filename 打开文件，并将光标置于最后一行首 vim +/pattern filename 打开文件，并将光标置于第一个与 pattern 匹配的串处 vim -r filename 在上次正用 vim 编辑时发生系统崩溃，恢复 filename vim filename….filename 打开多个文件，依次编辑 ","date":"2018-08-31","objectID":"/posts/vim/:1:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"vim 配置 命令 描述 all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位 (Ctrl+I) 和行尾标志（$) number 显示行号 report 显示由面向行的命令修改过的数目 terse 显示简短的警告信息 warn 在转到别的文件时若没保存当前文件则显示 NO write 信息 nomagic 允许在搜索模式中，使用前面不带“\\”的特殊字符 nowrapscan 禁止 vi 在搜索到达文件两端时，又从另一端开始 mesg 允许 vi 显示其他用户用 write 写到自己终端上的信息 :set number / set nonumber 显示/不显示行号 :set ruler /set noruler 显示/不显示标尺 :set hlsearch 高亮显示查找到的单词 :set nohlsearch 关闭高亮显示 :syntax on 语法高亮 :set nu 显示行号 :set tabstop=8 设置 tab 大小，8 为最常用最普遍的设置 :set softtabstop=8 4:4 个空格，8: 正常的制表符，12: 一个制表符 4 个空格，16: 两个制表符 :set autoindent 自动缩进 :set cindent C 语言格式里面的自动缩进 ","date":"2018-08-31","objectID":"/posts/vim/:2:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"移动光标 命令 描述 k nk 上 向上移动 n 行 j nj 下 向下移动 n 行 h nh 左 向左移动 n 行 l nl 右 向右移动 n 行 Space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w/W 光标右移一个字至字首 b/B 光标左移一个字至字首 e 或 E 光标右移一个字至字尾 ) 光标移至句尾 ( 光标移至句首 } 光标移至段落开头 { 光标移至段落结尾 n$ 光标移至第 n 行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 （注意是数字零）光标移至当前行首 ^ 移动光标到行首第一个非空字符上去 $ 光标移至当前行尾 gg 移到第一行 G 移到最后一行 f 移动光标到当前行的字符 a 上 F 相反 % 移动到与制匹配的括号上去（），{}，[]，\u003c\u003e等 nG 移动到第 n 行上 G 到最后一行 ","date":"2018-08-31","objectID":"/posts/vim/:3:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"屏幕滚动 命令 描述 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl ＋ b 向文件首翻一屏 nz 将第 n 行滚至屏幕顶部，不指定 n 时将当前行滚至屏幕顶部 ","date":"2018-08-31","objectID":"/posts/vim/:4:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"插入文本类 命令 描述 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符，直至按 ESC 键 s 从当前光标位置处开始，以输入的文本替代指定数目的字符 S 删除指定数目的行，并以所输入文本代替之 ncw/nCW 修改指定数目的字 nCC 修改指定数目的行 ","date":"2018-08-31","objectID":"/posts/vim/:5:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"删除命令 命令 描述 x/X 删除一个字符，x 删除光标后的，而 X 删除光标前的 dw 删除一个单词（删除光标位置到下一个单词开始的位置） dnw 删除 n 个单词 dne 也可，只是删除到单词尾 do 删至行首 d$ 删至行尾 dd 删除一行 ndd 删除当前行及其后 n-1 行 dnl 向右删除 n 个字母 dnh 向左删除 n 个字母 dnj 向下删除 n 行，当前行+其上 n 行 dnk 向上删除 n 行，当期行+其下 n 行 cnw[word] 将 n 个 word 改变为 word C$ 改变到行尾 cc 改变整行 shift+j 删除行尾的换行符，下一行接上来了 ","date":"2018-08-31","objectID":"/posts/vim/:6:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"复制粘贴 命令 描述 p 粘贴用 x 或 d 删除的文本 ynw 复制 n 个单词 yy 复制一行 ynl 复制 n 个字符 y$ 复制当前光标至行尾处 nyy 拷贝 n 行 ","date":"2018-08-31","objectID":"/posts/vim/:7:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"撤销 命令 描述 u 撤销前一次的操作 shif+u(U) 撤销对该行的所有操作 ","date":"2018-08-31","objectID":"/posts/vim/:8:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"搜索及替换 命令 描述 /pattern 从光标开始处向文件尾搜索 pattern ?pattern 从光标开始处向文件首搜索 pattern n 在同一方向重复上一次搜索命令 N 在反方向上重复上一次搜索命令 cw newword 替换为 newword n 继续查找 . 执行替换 :s/p1/p2/g 将当前行中所有 p1 均用 p2 替代，g 表示执行 用 c 表示需要确认 :n1,n2 s/p1/p2/g 将第 n1 至 n2 行中所有 p1 均用 p2 替代 :g/p1/s//p2/g 将文件中所有 p1 均用 p2 替换 :1,$ s/string1/string2/g 在全文中将 string1 替换为 string2 ","date":"2018-08-31","objectID":"/posts/vim/:9:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"书签 命令 描述 m[a-z] 在文中做标记，标记号可为 a-z 的 26 个字母 `a 移动到标记 a 处 ","date":"2018-08-31","objectID":"/posts/vim/:10:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"visual 模式 命令 描述 v 进入 visual 模式 V 进入行的 visual 模式 ctrl+v 进如块操作模式用 o 和 O 改变选择的边的大小 在所有行插入相同的内容如 include\u003c 将光标移到开始插入的位置，按 CTRL+V 进入 VISUAL 模式，选择好模块后按 I（shift+i)，后插入要插入的文本，按 [ESC] 完成 ","date":"2018-08-31","objectID":"/posts/vim/:11:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"行方式命令 命令 描述 :n1,n2 co n3 将 n1 行到 n2 行之间的内容拷贝到第 n3 行下 :n1,n2 m n3 将 n1 行到 n2 行之间的内容移至到第 n3 行下 :n1,n2 d 将 n1 行到 n2 行之间的内容删除 :n1,n2 w!command 将文件中 n1 行至 n2 行的内容作为 command 的输入并执行之 若不指定 n1，n2，则表示将整个文件内容作为 command 的输入 ","date":"2018-08-31","objectID":"/posts/vim/:12:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"宏 命令 描述 q[a-z] 开始记录但前开始的操作为宏，名称可为【a-z】，然后用 q 终止录制宏 reg 显示当前定义的所有的宏，用@[a-z] 来在当前光标处执行宏 [a-z] ","date":"2018-08-31","objectID":"/posts/vim/:13:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"窗口操作 命令 描述 :split 分割一个窗口 :split file.c 为另一个文件 file.c 分隔窗口 :nsplit file.c 为另一个文件 file.c 分隔窗口，并指定其行数 ctrl ＋ w 在窗口中切换 :close 关闭当前窗口 ","date":"2018-08-31","objectID":"/posts/vim/:14:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":"文件及其他 命令 描述 :q 退出 vi :q! 不保存文件并退出 vi :e filename 打开文件 filename 进行编辑 :e! 放弃修改文件内容，重新载入该文件编辑 :w 保存当前文件 :wq 存盘退出 :ZZ 保存当前文档并退出 VIM :!command 执行 shell 命令 command :r!command 将命令 command 的输出结果放到当前行 :n1,n2 write temp.c :read file.c 将文件 file.c 的内容插入到当前光标所在的下面 ","date":"2018-08-31","objectID":"/posts/vim/:15:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":" 警告 2018/11/1 说明 next 主题好像更新了，现在自带的可以用了，如果可以用了，以下教程可以忽略！！！ 最近有几个小伙伴问我博客的字数统计怎么实现的，怎么网上的教程不管用啊？一开始我搭建博客的时候也遇到了类似的问题，按照 github 上 wordcount 的 readme 操作后，并没有什么用，我打开 post 相关配置文件并没有发现发现 wordcount 这个关键词，next 本身似乎也并没有在主题配置文件提供选项（或许是个人原因），所以只好自己动手加一个了。为了不重复回答问题，先做个原创记录。转载请注明出处。在此抛转引玉，如果有更好的方法请在留言区提出，我会及时更改。同时也希望小伙伴多发扬折腾精神，多专研，少提问，毕竟还是 RTFSC 大法好！(Read the fucking source code) ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:0:0","tags":["hexo","字数统计"],"title":"hexo next 主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["Memo"],"content":"安装 wordcount github 如果没有安装 hexo-wordcount 插件，先安装该插件： npm i --save hexo-wordcount # Node 版本 7.6.0 之前，请安装 2.x 版本 (Node.js v7.6.0 and previous) npm install hexo-wordcount@2 --save ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:1:0","tags":["hexo","字数统计"],"title":"hexo next 主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["Memo"],"content":"post 添加 打开hexo\\themes\\hexo-theme-next\\layout\\_macro路径下的 post.swig 文件，既然没有字数统计那么我们就加一个，简单暴力地直接在阅读数后面加上一条就好了，在文件类搜索关键词busuanzi, 我用的是不蒜子，如果用的了 leancloud 的搜 leancloud 就好了，其他类似。找到这段代码后 {% if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %} \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e \u003cspan class=\"post-meta-item-icon\" {% if not theme.post_meta.item_text %} title=\"{{ __('post.views') }}\" {% endif %}\u003e \u003ci class=\"fa fa-{{ theme.busuanzi_count.post_views_icon }}\"\u003e\u003c/i\u003e {% if theme.post_meta.item_text %} {{__('post.views') + __('symbol.colon') }} {% endif %} \u003cspan class=\"busuanzi-value\" id=\"busuanzi_value_page_pv\" \u003e\u003c/span\u003e \u003c/span\u003e {% endif %} 在endif上面，即本文代码块那个空行处添加以下代码 \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e \u003cspan title=\"{{ __('post.wordcount') }}\"\u003e\u003cspan class=\"post-meta-item-icon\"\u003e\u003ci class=\"fa fa-file-word-o\"\u003e\u003c/i\u003e\u003c/span\u003e字数： {{ wordcount(post.content) }}\u003c/span\u003e ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:2:0","tags":["hexo","字数统计"],"title":"hexo next 主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["Memo"],"content":"全站添加 打开hexo\\themes\\hexo-theme-next\\layout\\_partials路径下 footer.swig 文件，在你喜欢的位置添加以下代码 \u003cdiv class=\"theme-info\"\u003e \u003cdiv class=\"powered-by\"\u003e\u003c/div\u003e \u003cspan class=\"post-count\"\u003e全站共 {{ totalcount(site) }} 字\u003c/span\u003e \u003c/div\u003e ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:3:0","tags":["hexo","字数统计"],"title":"hexo next 主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["Memo"],"content":"搭建这个博客以来，隔一段时间就出现一次部署失败的错误，每次都差不多，莫名其妙地出现的。前几次不知道怎么瞎搞就好了。 现在做一下记录，防止以后出错用。 错误如下 Connection reset by 13.229.188.59 port 22 fatal: sha1 file '\u003cstdout\u003e' write error: Broken pipe fatal: The remote end hung up unexpectedly FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error: Connection reset by 13.229.188.59 port 22 fatal: sha1 file '\u003cstdout\u003e' write error: Broken pipe fatal: The remote end hung up unexpectedly at ChildProcess.\u003canonymous\u003e (H:\\Hexo\\node_modules\\hexo-util\\lib\\spawn.js:37:17) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at ChildProcess.cp.emit (H:\\Hexo\\node_modules\\cross-spawn\\lib\\enoent.js:40:29) at maybeClose (internal/child_process.js:850:16) at Socket.\u003canonymous\u003e (internal/child_process.js:323:11) at emitOne (events.js:96:13) at Socket.emit (events.js:188:7) at Pipe._handle.close [as _onclose] (net.js:492:12) ... 确保 ssh 正常，hexo-deploy-git 插件正常的情况下删除。deploy_git 文件夹就好了。 最后吐槽一下，这个鬼错误，搞我一晚上醉了。我又打算重装了的。/吐血 ","date":"2018-08-21","objectID":"/posts/hexo-d-error/:0:0","tags":["hexo"],"title":"hexo d 出错","uri":"/posts/hexo-d-error/"},{"categories":["Memo"],"content":" 本文适合我这种纯小白。 目前为止，全网也就只有一个博主写到过这样动态显示 subtitle 的文章。传送门（关键词：js, 后加载） 但是嘞，该博写的不怎么详细，17 年底写的。当然更大的可能是 next 更新了一些文件结构，所以不适合现在使用了。以前我按原博的流程配置了一下没成功就搁在那里了，今天突然心血来潮。翻了翻原博主博客的源码，再与自己的对比了一下，发现了一些端倪。稍作调整后如下： ","date":"2018-08-20","objectID":"/posts/dongtaisub/:0:0","tags":["hexo","JavaScript"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["Memo"],"content":"修改站点配置文件，主要修改 subtitle subtitle: 不怕万人阻挡，只怕自己投降。W 你如何回忆，决定你是一个怎样的人！W 这是一个句子。W 这是另一个句子。W 这些句子你们不要搞一样的不然怎么叫个性签名-_-！。 句子与句子之间以 W 分割，后续需要根据该标志位去拆分句子组。 小伙伴们博主这里只是提供一个思路，不要和我用一模一样的啊，不然撞了多尴尬呀 ","date":"2018-08-20","objectID":"/posts/dongtaisub/:1:0","tags":["hexo","JavaScript"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["Memo"],"content":"修改 header\\index.swig 修改 themes\\next\\layout_partials\\header 下面的 index.swig 文件 在最开头添加如下代码： （这里用的原博的 js) \u003cscript\u003e function GetRandomNum(Min,Max) { var Range = Max - Min; var Rand = Math.random(); return(Min + Math.round(Rand * Range)); } function setSidebarMarginTop (headerOffset) { return $('#sidebar').css({ 'margin-top': headerOffset }); } function getHeaderOffset () { return $('.header-inner').height() + CONFIG.sidebar.offset; } window.onload=function(){ var subtitle = \"{{config.subtitle}}\"; var mytitle = subtitle.split(\"W\"); var max = mytitle.length-1; var index = GetRandomNum(0,max); var text = mytitle[index]; $(\"#helloTitle\").html(text); var headOffset = getHeaderOffset(); setSidebarMarginTop(headOffset); //动态 subtitle 设置 } \u003c/script\u003e ","date":"2018-08-20","objectID":"/posts/dongtaisub/:2:0","tags":["hexo","JavaScript"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["Memo"],"content":"修改 brand.swig 找到 {% if subtitle %} {% if theme.seo %} ... {% else %} ... {% endif %} {% endif %} 把这一段，把原来的修改成以下代码即可 ps: title和subtitle的字体还有颜色也可以在这个文件修改，即使用style标签，按个人爱好修改也可不要。 {% if subtitle %} {% if theme.seo %} \u003cp class=\"site-subtitle\" id=\"helloTitle\" itemprop=\"description\"\u003e\u003c/p\u003e {% else %} \u003cp id=\"helloTitle\" class=\"site-subtitle\"\u003e\u003c/p\u003e {% endif %} {% endif %} 之后部署后每次刷新就可以看到不同的 subtitle 了，开心 😀 ","date":"2018-08-20","objectID":"/posts/dongtaisub/:3:0","tags":["hexo","JavaScript"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["Memo"],"content":"今日诗词 今日诗词 \u003cspan id=\"jinrishici-sentence\"\u003e正在加载今日诗词 ....\u003c/span\u003e \u003cscript src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"\u003e\u003c/script\u003e 正在加载今日诗词 .... ","date":"2018-08-20","objectID":"/posts/dongtaisub/:4:0","tags":["hexo","JavaScript"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["Memo"],"content":"api 调用 直接 js 调用 api 简单快速 2021/9/30 更新 一言 api-参数详见 已经挂了 \u003cdiv\u003e \u003cscript type=\"text/javascript\" src=\"https://api.imjad.cn/hitokoto/?cat=\u0026charset=utf-8\u0026length=\u0026encode=js\u0026fun=sync\u0026source=\"\u003e\u003c/script\u003e \u003cdiv id=\"hitokoto\"\u003e \u003cscript\u003e hitokoto(); \u003c/script\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2018-08-20","objectID":"/posts/dongtaisub/:5:0","tags":["hexo","JavaScript"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["Git"],"content":"在 git 没有运行完成之前强制关闭，下次提交的时候会产以下生错误，或者类似的。 fatal: Unable to create '/xxx/xx/.git/index.lock': File exists. If no other git process is currently running, this probably means a git process crashed in this repository earlier. Make sure no other git process is running and remove the file manually to continue. 原因是在你进行某些比较费时的 git 操作时自动生成，操作结束后自动删除，相当于一个锁定文件，目的在于防止对一个目录同时进行多个操作。 有时强制关闭进行中的 git 操作，这个文件没有被自动删除，之后你就无法进行其他操作，必须手动删除，进入。git 文件中删除，打开显示隐藏文件。如果没有看见。git 文件夹，可以直接用命令 rm -f ./.git/index.lock。之后就可以正常使用。 ","date":"2018-08-14","objectID":"/posts/git-index-lock/:0:0","tags":["Git"],"title":"git index.lock","uri":"/posts/git-index-lock/"},{"categories":["Memo"],"content":" 暑假刚开始的时候放假回家没带电脑，只能玩手机，想折腾一下博客都没有条件，在一个发现一个 app, 卧槽 😱，termux 真的强大！（初始化需要科学上网）安卓手机上的 linux 简直了，在手机就可以搭了一个 hexo 博客，只要在 github 上实现分支管理就可以多终端同步更新了。恕我学疏才浅，还只想到这些！一开始想回校后，折腾一下 hexo-admin 实现类似动态博客一样的多终端管理（手动滑稽），现在发现 termux 这样子的操作也不错嘛，挺装哔 hhhhhh**部署后的效果** ","date":"2018-08-11","objectID":"/posts/termux/:0:0","tags":["Node.js","hexo","termux"],"title":"在 Android 上搭建 hexo 博客","uri":"/posts/termux/"},{"categories":["Memo"],"content":"准备 Termux 文件管理器（RE,MT 文件管理器等高级一点的） ","date":"2018-08-11","objectID":"/posts/termux/:1:0","tags":["Node.js","hexo","termux"],"title":"在 Android 上搭建 hexo 博客","uri":"/posts/termux/"},{"categories":["Memo"],"content":"开始 打开 Termux，输入$pkg install nodejs安装 Nodejs，在输入pkg install git安装 Git。 过程会出现一个提示，输入 y 回车确认即可。 按照 Hexo 官网提示安装 Hexo。 npm install hexo-cli -g hexo init blog cd blog 注意 ssh 配置先安装：pkg install openssh 然后按照基本操作配置 Hexo，GitHub 或者 gitee,coding 等连上，部署测试一次。 安装部署插件npm install hexo-deployer-git --save，部署hexo d -g 没有问题的话进行下一步。 ","date":"2018-08-11","objectID":"/posts/termux/:2:0","tags":["Node.js","hexo","termux"],"title":"在 Android 上搭建 hexo 博客","uri":"/posts/termux/"},{"categories":["Memo"],"content":"编辑 写文章的话创建 md 文件命令和电脑上一样，文件管理器打开/data/data/com.termux/files/home/i/source/_posts/ 编辑文章 md 文件。这种方式需要 Root。 没有 Root 的话可以使用 Vim，网上很多教程。但是这种方式相对来说更麻烦。 ","date":"2018-08-11","objectID":"/posts/termux/:3:0","tags":["Node.js","hexo","termux"],"title":"在 Android 上搭建 hexo 博客","uri":"/posts/termux/"},{"categories":["Memo"],"content":"参考 termux 高级终端安装使用配置教程 使用 Termux 在手机上运行 linux 黑科技 hexo 搭建过程 超详细教程 ","date":"2018-08-11","objectID":"/posts/termux/:4:0","tags":["Node.js","hexo","termux"],"title":"在 Android 上搭建 hexo 博客","uri":"/posts/termux/"},{"categories":["Memo"],"content":"效果图（未连接 github，coding 等） 效果图 1 效果图 2 效果图 3 效果图 4 ","date":"2018-08-11","objectID":"/posts/termux/:5:0","tags":["Node.js","hexo","termux"],"title":"在 Android 上搭建 hexo 博客","uri":"/posts/termux/"},{"categories":["ACM"],"content":"链接：https://www.nowcoder.com/acm/contest/157/A 来源：牛客网 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:0","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"题目描述 xb 有 m 种石子，每种无限个，Ta 想从这些石子中取出 n 个，并按顺序排列起来，为了好看，相邻的石子不能相同。xb 想知道有多少种排列的方法。 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:1","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"输入描述： 第一行有两个正整数 n，m。 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:2","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"输出描述： 第一行一个整数，表示在 m 种石子中取出 n 个的排列方案数模 1000000007 后的值。 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:3","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"示例 1 输入 1 1 输出 1 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:4","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"示例 2 输入 2 3 输出 6 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:5","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"示例 3 输入 3 3 输出 12 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:6","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"备注： 对于 100%的测试数据： 1 ≤ n, m ≤ 1000 数据量较大，注意使用更快的输入输出方式。 水题。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long n,m,ans; scanf(\"%lld%lld\",\u0026n,\u0026m); ans=m; for(int i=1;i\u003cn;i++) ans=(ans*(m-1))%1000000007; printf(\"%lld\\n\",ans); return 0; } ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:7","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"题目链接 Dreamoon wants to climb up a stair of n steps. He can climb 1 or 2 steps at each move. Dreamoon wants the number of moves to be a multiple of an integer m. What is the minimal number of moves making him climb to the top of the stairs that satisfies his condition? ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:0","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Input The single line contains two space separated integers n, m (0 \u003c n ≤ 10000, 1 \u003c m ≤ 10). ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:1","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Output Print a single integer — the minimal number of moves being a multiple of m. If there is no way he can climb satisfying condition print - 1 instead. ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:2","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Examples input 10 2 output 6 input 3 5 output -1 ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:3","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Note For the first sample, Dreamoon could climb in 6 moves with following sequence of steps: {2, 2, 2, 2, 1, 1}. For the second sample, there are only three valid sequence of steps {2, 1}, {1, 2}, {1, 1, 1} with 2, 2, and 3 steps respectively. All these numbers are not multiples of 5. 有一个 n 级台阶，每次可以走一级或两级，问最少的步数是多少，且步数必须是 m 的倍数。 找一下数学公式就好了。 具体看代码。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int x,n,m; cin\u003e\u003en\u003e\u003em; if(n\u003cm){ cout\u003c\u003c-1\u003c\u003cendl; return 0; } if(n==m){ cout\u003c\u003cn\u003c\u003cendl; return 0; } if(n%2==0){ x=n/2%m; if(x==0) cout\u003c\u003cn/2\u003c\u003cendl; else cout\u003c\u003cn/2+m-x\u003c\u003cendl; }else if(n%2!=0){ x=(n/2+1)%m; if(x==0) cout\u003c\u003cn/2+1\u003c\u003cendl; else cout\u003c\u003c(n/2+1)+m-x\u003c\u003cendl; } return 0; } ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:4","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"题目链接 ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:0","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi（组合数学）","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"题目大意 就是给定两个字符串，第一个字符串由\"+\",\"-“组成，第二个字符串由”+\",\"-\",\"?“组成，“+”代表加 1，”-“代表减一，“?“代表可取正也可取负，问第二个字符串的位置和第一个字符串相等的概率是多少。 我一开始的想法是把（+1，-1）^n 看成和二项式定理一样的展开始式，只不过把乘法改为加法，然后得到公式 c(n,0)(n+(-1)0)+c(n,1)(n-1+(-1)1)+c(n,i)(n-i+(-1)i)+...+c(n,n)(n-n+(-1)n) 化简一下可知通项为c(n,i)(n-2*i) 然后我对第一个串求出位置 sum, 第二个串先求出已知位置 sum1，然后记录下？的个数，然后遍历找出展开式中某一项 n-2i+sum1==sum，这样 x 的系数就是可能出现位置相等的所有情况，用 (n-2i)/系数和就是概率了啊，可是为什么不对呢，本地调试，数据没问题，可是交到 cf 上第二组都过不了，烦亏我还觉得想到一个独辟的方法呢，过不了。 //cf 错误报告，思前恐后不晓得 why,wtf??? 先码着吧 Test: #2, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER Input +-+- +-?? Output -0.000000000000 Answer 0.500000000000 Checker Log wrong answer 1st numbers differ - expected: '0.5000000', found: '-0.0000000', error = '0.5000000' ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:1","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi（组合数学）","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"错误代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int i,j,cnt=0; long long c[11][11],sum=0,sum1=0; for(i = 0; i \u003c 11; i++){//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(j = 1; j \u003c i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; } string a,b; cin\u003e\u003ea\u003e\u003eb; //cout\u003c\u003ca\u003c\u003cendl\u003c\u003cb\u003c\u003cendl; int len=a.length(); for(i=0;i\u003clen;i++) if(a[i]=='+') sum+=1; else sum-=1; for(i=0;i\u003cb.length();i++){ if(b[i]=='+') sum1+=1; else if(b[i]=='-')sum1-=1; if(b[i]=='?') cnt++; } if(sum==sum1\u0026\u0026cnt==0){ printf(\"1.000000000000\\n\"); return 0; } int flag=0; int x=0; for(j=0;j\u003c=cnt;j++) x+=c[cnt][j]; //cout\u003c\u003cx\u003c\u003cendl; for(i=0;i\u003c=cnt;i++) if(cnt-2*i+sum1==sum){ flag=1; long double y=c[cnt][i]*1.0/x; printf(\"%.12llf\\n\",y); } if(!flag)printf(\"0.000000000000\\n\"); return 0; } 想不通，没办法只好换思路。 我先分别记下 a,b 串的’+’,’-’,’?‘个数，然后后我们很容易知道，如要 a,b 位置相等，则加号和减号的数目，两串要相等，且 a 中的加号要比 b 中已知的加号要多，减号也要比 b 中已知的要多，否则打死都不会相等的，仔细比划一下就知道了。然后有 z 个‘?’，相当于有 z 个坑，让我们去填使得 a,b 相等。只能填+或-，设加号差等于 x-p, 所以概率就等于 c(z,x-p)/2^z。 ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:2","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi（组合数学）","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"AC 代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ string a,b; int x,y,z,p,q,c[11][11],i,j; for(i = 0; i \u003c 11; i++){ c[i][0] = 1; c[i][i] = 1; for(j = 1; j \u003c i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; } cin\u003e\u003ea; cin\u003e\u003eb; x=y=z=p=q=0; for(i=0;i\u003ca.length();i++) if(a[i]=='+') x++; else y++; for(i=0;i\u003cb.length();i++){ if(b[i]=='+') p++; else if(b[i]=='-') q++; else z++; } if(x==p\u0026\u0026z==0){ printf(\"1.000000000000\\n\"); return 0; } if(x-p\u003c0||y-q\u003c0) { printf(\"0.000000000000\\n\"); return 0; } x=x-p; printf(\"%0.12f\",c[z][x]*1.0/(2\u003c\u003c(z-1))); return 0; } 几分钟写完后面的代码，心中一万头草泥马在奔腾。 ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:3","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi（组合数学）","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"题意： 给出 a,b,c,x1,x2,y1,y2，求满足 ax+by+c=0，且 x∈[x1,x2],y∈[y1,y2] 的整数解个数。 ","date":"2018-08-10","objectID":"/posts/euclid/:0:1","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106（扩展欧几里得）","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"分析： 对于解二元一次不定方程，容易想到利用扩展欧几里得求出一组可行解后找到通解，下面来介绍一下欧几里得以及扩展欧几里得。 欧几里得： 又名辗转相除法，是用来计算两个数的最大公约数，其中就是利用 gcd(a,b)=gcd(b,a mod b) 来求解。下证 gcd(a,b)=gcd(b,a mod b) 的正确性： 设 a,b 的一个公约数为 d 设 a mod b=r，则 a=kb+r(k 为整数），r=a-kb 因为 d|a,d|b 所以 d|a-kb, 即 d|r，而 r=a mod b 所以 d 为 b,a mod b 的公约数 又因为 d 也为 a,b 的公约数，所以（a,b) 和 (b,a mod b) 的公约数一样，所以最大公约数必然一样，得证。 代码描述： int gcd(int a,int b) { if (b==0) return a; return gcd(b,a%b); } 扩展欧几里得 顾名思义，为上述欧几里得算法的扩展。欧几里得是用来求 a,b 的最大公约数，那么扩展欧几里得不仅能求出 a,b 的最大公约数，还能求出满足 ax+by=gcd(a,b) 的一组可行解。 求解过程中，扩展欧几里得比欧几里得多了一个赋值过程，具体证明如下： 设 ax1+by1=gcd(a,b),bx2+(a mod b)y2=gcd(b,a mod b) 因为由欧几里得算法可知，gcd(a,b)=gcd(b,a mod b) 所以 ax1+by1=bx2+(a mod b)y2 因为a mod b=a-(a div b)*b（div 为整除 所以有ax1+by1=bx2+(a-(a div b)*b)y2 将右边移项，展开得： ax1+by1=ay2+bx2-(a div b)*b*y2 =ay2+b[x2-(a div b)]y2 所以可得： x1=y2 y1=x2-(a div b)*y2 将得到的的 x1,y1 递归操作求解 x2,y2，如此循环往复，将会像欧几里得一样得到 b=0 的情况，此时递归结束，返回 x=1,y=0，回溯得解。 代码描述： 此函数返回的是 a,b 的最大公约数，同时也求解出满足 ax+by=gcd(a,b) 的一组可行的 (x,y) int exgcd(int a,int b,int \u0026x,int \u0026y) { if (b==0) {x=1;y=0;return a;} int t=exgcd(b,a%b,x,y); int x0=x,y0=y; x=y0;y=x0-(a/b)*y0; return t; } 关于求解二元一次不定方程 ax+by=c 首先，如果 c 不是 gcd(a,b) 的倍数，方程显然无解。 扩展欧几里得求解的是 ax+by=gcd(a,b)=1 的可行解，但是题目中并没有说 c 与 a,b 互质之类的条件，所以需要在开始时两边同时除以 gcd(a,b)。 设 d=gcd(a,b) 设 a’=a/d,b’=b/d,c’=c/d, 则下面需要求解 a’x+b’y=c’的整数解，而 gcd(a’,b’)=1， 则我们只需求 a’x+b’y=1 的可行解 直接使用扩展欧几里得，得到 (x’,y’), 则最终解为x'*c',y'*c'设为 (x0,y0)。 现在得到了一组可行解，但是如何得到通解呢？ 将 (x0,y0) 代入 ax+by=c，则有 a*(x0)+b*(y0)=c 通过拆添项，可有： a*(x0+1*b)+b*(y0-1*a)=c a*(x0+2*b)+b*(y0-2*a)=c a*(x0+3*b)+b*(y0-3*a)=c …… a*(x0+k*b)+b*(y0-k*a)=c (k∈Z) 至此，我们得到了通解的方程 x=x0+k*b y=y0-k*a (k∈Z) 这样，所有满足 ax+by=c 的可行解都可求出。 ","date":"2018-08-10","objectID":"/posts/euclid/:0:2","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106（扩展欧几里得）","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"具体实现 有了主体算法，下面要谈到具体实现了。 先处理一下无解的情况： 当 a=0 并且 b=0，而 c≠0 时，显然无解； 当 a=0,b=0，而 c=0 时，[x1,x2],[y1,y2] 都为可行解，根据乘法原理，可行解的个数为(x2-x1+1)*(y2-y1+1); 当 a=0 b≠0 时： 此时即为求解 by=c，则 y=c/b， 如果 c/b 不是整数或 c/b 不在 [y1,y2] 的范围内，无解 否则 [x1,x2] 内全部整数都为可行解。 当 b=0,a≠0 时，同上。 若 c 不是 gcd(a,b) 的个数，方程显然无解。 处理完了一些繁琐的细节后，下面是具体的求解过程： 扩展欧几里得求解的是 ax+by=c，而本题是 ax+by+c=0，需将 c 移项。 对于本道题，首先要注意的是，对于负数的模运算在此算法中无法得到正确解，所以要处理一下 a,b,c 的正负情况。 如果 a 为负数，只需将 a 取相反数后，再处理一下 x∈[x1,x2] 的范围。当 a 取了相反数，相当于把 x 也取反，则需要把 x 的范围由 [x1,x2] 转变成 [-x2,-x1], 类似于把数轴反了过来。b 同理。 利用扩展欧几里得解二元一次不定方程，得到一组可行解 (x0,y0)。 因为题目中对 x,y 有条件约束，而有 x=x0+kb,y=y0-kb，我们可以求出满足 x∈[x1,x2],y∈[y1,y2] 的 k 的取值范围， 即为求解 x1\u003c=x0+kb\u003c=x2,y1\u003c=y0-kb\u003c=y2 的整数 k 的个数 但是在求解这两个一次函数的过程中，会有除不尽的现象，该如何取整呢？ 举个例子 当出现 2.5\u003c=k\u003c=5.5 时，我们需要的可行的 k 为 3,4,5，所以需要将 2.5 向上取整得到 3，5.5 向下取整得到 5，即为 3\u003c=k\u003c=5； 当出现-5.5\u003c=\u003c=-2.5 时，我们需要的可行的 k 为-5,-4,-3, 所以需要将-5.5 向上取整得到-5,-2.5 向下取整得到-3，即为-5\u003c=k\u003c=-3； 正负数的情况都已经考虑完全了，可以得到取整的结论：上界下取整，下界上取整。 最后，将得到的两个范围取交集，得到 [l,r]，则最终答案为 r-l+1。 这样，本题就可以完美解决了。 // BY Rinyo #include\u003ccstdio\u003e #include\u003ccmath\u003e long long a,b,c,x1,x2,yy1,y2,x0,yy0; inline long long cmin(const long long \u0026x,const long long \u0026y) {return x\u003cy?x:y;} inline long long cmax(const long long \u0026x,const long long \u0026y) {return x\u003ey?x:y;} long long gcd(long long a,long long b) { if (b==0) return a; return gcd(b,a % b); } void exgcd(long long a,long long b) { if (b==0){x0=1;yy0=0;return;} exgcd(b,a%b); long long t=x0;x0=yy0;yy0=t-a/b*yy0; return; } int main() { scanf(\"%I64d%I64d%I64d%I64d%I64d%I64d%I64d\",\u0026a,\u0026b,\u0026c,\u0026x1,\u0026x2,\u0026yy1,\u0026y2); c=-c; if (c\u003c0) {a=-a;b=-b;c=-c;} if (a\u003c0) {a=-a;long long t=x1;x1=-x2;x2=-t;} if (b\u003c0) {b=-b;long long t=yy1;yy1=-y2;y2=-t;} if (a==0 \u0026\u0026 b==0) { if (c==0) { printf(\"%I64d\",(x2-x1+1)*(y2-yy1+1)); return 0; } printf(\"0\");return 0; } else if (a==0) { if (c %b ==0) if (c/b\u003c=y2 \u0026\u0026 c/b\u003e=yy1) {printf(\"%I64d\",x2-x1+1);return 0;} printf(\"0\");return 0; } else if (b==0) { if (c%a==0) if (c/a\u003c=x2 \u0026\u0026 c/a\u003e=x1) {printf(\"%I64d\",y2-yy1+1);return 0;} printf(\"0\");return 0; } long long d=gcd(a,b); if (c%d!=0){printf(\"0\");return 0;} a=a/d;b=b/d;c=c/d; exgcd(a,b); x0=x0*c;yy0=yy0*c; double tx2=x2,tx1=x1,tx0=x0,ta=a,tb=b,tc=c,ty1=yy1,ty2=y2,ty0=yy0; long long down1=floor(((tx2-tx0)/tb)),down2=floor(((ty0-ty1)/ta)); long long r=cmin(down1,down2); long long up1=ceil(((tx1-tx0)/tb)),up2=ceil(((ty0-ty2)/ta)); long long l=cmax(up1,up2); if (r\u003cl) printf(\"0\"); else printf(\"%I64d\",r-l+1); return 0; } 扩展欧几里得模板 #include\u003ciostream\u003e using namespace std; int exgcd(int a,int b,int \u0026x,int \u0026y) { if(b==0) { x=1; y=0; return a; } int gcd=exgcd(b,a%b,x,y); int x2=x,y2=y; x=y2; y=x2-(a/b)*y2; return gcd; } int main() { int x,y,a,b; cout\u003c\u003c\"请输入 a 和 b:\"\u003c\u003cendl; cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003c\"a 和 b 的最大公约数：\"\u003c\u003cendl; cout\u003c\u003cexgcd(a,b,x,y)\u003c\u003cendl; cout\u003c\u003c\"ax+by=gcd(a,b) 的一组解是：\"\u003c\u003cendl; cout\u003c\u003cx\u003c\u003c\" \"\u003c\u003cy\u003c\u003cendl; return 0; } ","date":"2018-08-10","objectID":"/posts/euclid/:0:3","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106（扩展欧几里得）","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"题目链接 ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:1","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282（快速幂+对数运算）","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"题目大意： 给定两个数 n,k 求 n^k 的前三位和最后三位。 ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:2","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282（快速幂+对数运算）","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"分析 求后三位的话：直接快速幂，对 1000 取模就好了。 求前三位，对于给定的一个数 n, 它可以写成 n=10^a, 其中这个 a 为浮点数，则t=n^k=(10^a)^k=10^a*k=(10^x)*(10^y);其中 x,y 分别是a*k的整数部分和小数部分，对于 t=n^k 这个数，它的位数由 (10^x) 决定，它的位数上的值则有 (10^y) 决定，因此我们要求 t 的前三位，只需要将 10^y 求出，在乘以 100，就得到了它的前三位。 分析完，我们再整体看，设 n^k=10^z; 那么z=k*log10(n) fmod(z,1)可以求出 x 的小数部分。 //再一次吐槽 lightoj 的头文件，让我不能用万能头\u003cbits/stdc++.h\u003e #include\u003cstdio.h\u003e #include\u003cmath.h\u003e typedef long long LL; int quickpow (int m, int n, int k) { int b = 1; while (n \u003e 0) { if (n \u0026 1) b = (b * m) % k; n \u003e\u003e= 1; m = (m * m) % k; } return b%k; } int main () { int t, flag = 1; scanf (\"%d\", \u0026t); while (t--) { LL n, k; scanf (\"%lld %lld\", \u0026n, \u0026k); int first = pow (10.0, 2.0 + fmod (k*log10(n*1.0), 1)); int last = quickpow (n%1000, k, 1000); printf (\"Case %d: %d %03d\\n\", flag++, first, last); } return 0; } ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:3","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282（快速幂+对数运算）","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"注： C 库函数 - fmod() C 库函数 double fmod(double x, double y) 返回 x 除以 y 的余数。 x – 代表分子的浮点值。 y – 代表分母的浮点值。 该函数返回 x/y 的余数。 下面的实例演示了 fmod() 函数的用法。 #include \u003cstdio.h\u003e #include \u003cmath.h\u003e int main () { float a, b; int c; a = 9.2; b = 3.7; c = 2; printf(\"%f / %d 的余数是 %lf\\n\", a, c, fmod(a,c)); printf(\"%f / %f 的余数是 %lf\\n\", a, b, fmod(a,b)); return(0); } 结果： 9.200000 / 2 的余数是 1.200000 9.200000 / 3.700000 的余数是 1.800000 ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:4","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282（快速幂+对数运算）","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"A. The Rank 题目大意： 给出 n 个学生的成绩，Thomas Smith 的成绩是第一行，然后要按总成绩进行排序，总分相同的按编号从小到大排； 开始看还以为要写 sort 的 cmp 函数进行多条件排序，敲完才发现其实只要按总分就可以了，因为托马斯的 id 是一，必然会排在前面。 #include\u003cbits/stdc++.h\u003e using namespace std; int a[4],sum[1005]; int main(){ int n,s,f1; cin\u003e\u003en; for(int j=1;j\u003c=n;j++){ s=0; for(int i=0;i\u003c4;i++){ cin\u003e\u003ea[i]; s+=a[i]; } sum[j]=s; if(j==1) f1=s; } sort(sum+1,sum+n+1,greater\u003cint\u003e()); for(int i=1;i\u003c=n;i++) if(sum[i]==f1){ cout\u003c\u003ci\u003c\u003cendl; break; } return 0; } ","date":"2018-08-09","objectID":"/posts/cfcontest1017/:0:1","tags":["ACM","Codeforces","组合数学","C++"],"title":"Codeforces Round 502(Div.1 + Div.2)","uri":"/posts/cfcontest1017/"},{"categories":["ACM"],"content":"B. The Bits 题目大意： 先给出二进制数的长度，然后输入两个二进制数 a,b，问交换 a 中的某些位数的数，使得 a|b（按位或）的结果不同，求有多少种不同的或值。 a,b 上下对应的情况：a/b 个数 1/0 m 0/0 n 1/1 x 0/1 y 用组合数学的思想来想： 只要看 b 为 0 的位就行了，如果 0/0,a 只能换 1 的位置，为了避免重复，所以这里总数为n*x, 再考虑 1/0 的情况，只能和 0 的位置换，这是后可以把 0/0 没算的都算上，所以总数m*(n+y) 所以最后总数为sum=n*x+m*(n+y) #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long n,m,x,y,t; n=m=x=y=0; char a[100005],b[100005]; cin\u003e\u003et; cin\u003e\u003ea\u003e\u003eb; for(int i=0;i\u003ct;i++){ int p=a[i]-'0'; int q=b[i]-'0'; if(p==0\u0026\u0026q==0) n++; if(p==1\u0026\u0026q==0) m++; if(p==1\u0026\u0026q==1) x++; if(p==0\u0026\u0026q==1) y++; } long long sum=n*x+m*(y+n); cout\u003c\u003csum\u003c\u003cendl; return 0; } ","date":"2018-08-09","objectID":"/posts/cfcontest1017/:0:2","tags":["ACM","Codeforces","组合数学","C++"],"title":"Codeforces Round 502(Div.1 + Div.2)","uri":"/posts/cfcontest1017/"},{"categories":["ACM"],"content":"欧拉函数是求小于 x 并且和 x互质 的数的个数 通式：φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn) 其中 p1, p2……pn 为 x 的所有质因数，x 是不为 0 的整数 φ(1)=1（唯一和 1 互质的数就是 1 本身）【注意：每种质因数只一个。比如 12=223】 ","date":"2018-08-08","objectID":"/posts/euler/:0:1","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"定理： 若 n 是素数 p 的 k 次幂，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)，因为除了 p 的倍数外，其他数都跟 n 互质 欧拉函数是积性函数——若 m,n 互质，φ(mn)=φ(m)φ(n) ","date":"2018-08-08","objectID":"/posts/euler/:0:2","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"特殊性质： 当 n 为奇数时，φ(2n)=φ(n) p 是素数，φ(p) = p - 1，φ(p) 称为 p 的欧拉值 若 a 为素数，b mod a=0,φ(a*b)=φ(b)*a ","date":"2018-08-08","objectID":"/posts/euler/:0:3","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"模板 //直接法 int Euler(int n){ int res = n,i; //由于任何一个合数都至少有一个不大于根号 n 的素因子，所以只要遍历到根号 n 即可 for(i=2;i * i \u003c= n;i++) if(n%i == 0){ //第一次找到的必为素因子 n /=i ; res = res - res/i; //x(1-1/p1) while(n % i ==0) n/=i; //将该素因子的倍数也全部筛掉 } if (n \u003e 1) res = res - res/n; return res; } 以上转载注明 //素数筛选法，先素数筛选，再求欧拉 /* 特性 : 1. 若 a 为质数，phi[a]=a-1; 2. 若 a 为质数，b mod a=0,phi[a*b]=phi[b]*a 3. 若 a,b 互质，phi[a*b]=phi[a]*phi[b](当 a 为质数时，if b mod a!=0 ,phi[a*b]=phi[a]*phi[b]) */ int m[n],phi[n],p[n],nump; //m[i] 标记 i 是否为素数，0 为素数，1 不为素数；p 是存放素数的数组；nump 是当前素数个数；phi[i] 为欧拉函数 int make() { phi[1]=1; for (int i=2;i\u003c=n;i++) { if (!m[i])//i 为素数，m[] 初始化为 0 { p[++nump]=i;//将 i 加入素数数组 p 中 phi[i]=i-1;//因为 i 是素数，由特性得知 } for (int j=1;j\u003c=nump\u0026\u0026p[j]*i\u003cn;j++) //用当前已的到的素数数组 p 筛，筛去 p[j]*i { m[p[j]*i]=1;//可以确定 i*p[j] 不是素数 if (i%p[j]==0) //看 p[j] 是否是 i 的约数，因为素数 p[j], 等于判断 i 和 p[j] 是否互质 { phi[p[j]*i]=phi[i]*p[j]; //特性 2 break; } else phi[p[j]*i]=phi[i]*(p[j]-1); //互质，特性 3,p[j]-1 就是 phi[p[j]] } } } 附素数打表 int p[N]={1,1,0}; void prime(){ for(int i=2;i\u003cN;i++) if(!p[i]){ for(int j=2*i;j\u003c=N;j+=i)//筛掉 i 的倍数 p[j]=1; } } ","date":"2018-08-08","objectID":"/posts/euler/:0:4","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"例题 Bi-shoe and Phi-shoe LightOJ - 1370 题意： 给一些数 Ai（第 i 个数），Ai 这些数代表的是某个数欧拉函数的值，我们要求出数 Ni 的欧拉函数值不小于 Ai。而我们要求的就是这些 Ni 这些数字的和 sum，而且我们想要 sum 最小，求出 sum 最小多少。 解题思路： 要求和最小，我们可以让每个数都尽量小，那么我们最后得到的肯定就是一个最小值。 给定一个数的欧拉函数值 ψ(N)，我们怎么样才能求得最小的 N? 我们知道，一个素数 P 的欧拉函数值 ψ(P)=P-1。所以如果我们知道 ψ(N)，那么最小的 N 就是最接近 ψ(N)，并且大于 ψ(N) 的素数。我们把所有素数打表之后再判断就可以了。 这个 lightoj 有毒，什么头文件都不支持，卡了我好久。 #include\u003cstdio.h\u003e #define N 1000005 #define ll long long int m[N]={1,1,0}; int p[100000],cnt=0; int max(int x,int y){ return x\u003ey?x:y; } void prime(){ for(int i=2;i\u003cN;i++) if(!m[i]){ for(int j=2*i;j\u003c=N;j+=i) m[j]=1; p[cnt++]=i; } } int binary_search(int x){//二分查找 int l=0,r=cnt; while(l\u003c=r){ int mid=(l+r)/2; if(p[mid]\u003ex) r=mid-1; else l=mid+1; } for(int i=max(r,0);;i++) if(p[i]\u003ex) return p[i]; } int main(){ prime(); int T,n,cas=1,temp; scanf(\"%d\",\u0026T); while(T--){ scanf(\"%d\",\u0026n); ll sum=0; for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026temp); sum+=binary_search(temp); } printf(\"Case %d: %lld Xukha\\n\",cas++,sum); } return 0; } ","date":"2018-08-08","objectID":"/posts/euler/:0:5","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"题目链接](http://poj.org/problem?id=1797) 大意： 要从城市 1 到城市 N 运送货物，有 M 条道路，每条道路都有它的最大载重量，问从城市 1 到城市 N 运送最多的重量是多少。 其实题意很简单，就是找一条 1–\u003eN 的路径，在不超过每条路径的最大载重量的情况下，使得运送的货物最多。一条路径上的最大载重量为这个路径上权值最小的边； //dijkstra #include\u003ciostream\u003e #include\u003ccstdio\u003e #define min(a,b) (a\u003cb?a:b) using namespace std; int n,m,v[1010],maps[1010][1010],d[1010];//此时 d 表示 1 到每一个点的能通过的最大的重量 int dijkstra(){ int i,j,k; for(i=1;i\u003c=n;i++){ v[i]=0; d[i]=maps[1][i];//这个时候 d 不代表最短路径，而是从 1 到 n 的最大承载量 } for(i=1;i\u003c=n;i++){//n 个点 int f=-1; for(j=1;j\u003c=n;j++) if(!v[j]\u0026\u0026d[j]\u003ef){ f=d[j]; k=j; } v[k]=1; for(j=1;j\u003c=n;j++) if(!v[j]\u0026\u0026d[j]\u003cmin(d[k],maps[k][j]))//更新说明见图解 d[j]=min(d[k],maps[k][j]); } return d[n]; } int main(){ int ans=1; int a,b,w; int T; scanf(\"%d\",\u0026T); while(T--){ for(int i=0;i\u003c=n;i++) for(int j=0;j\u003c=n;j++) maps[i][j]=0; scanf(\"%d%d\",\u0026n,\u0026m); for(int i=1;i\u003c=m;i++){ scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026w); maps[a][b]=maps[b][a]=w; } printf(\"Scenario #%d:\\n%d\\n\\n\",ans++,dijkstra()); } return 0; } ","date":"2018-08-06","objectID":"/posts/poj1797/:0:0","tags":["ACM","POJ","最短路","C++"],"title":"Heavy Transportation-poj1797(dijkstra 或最大生成树）","uri":"/posts/poj1797/"},{"categories":["JavaScript"],"content":"看到知乎，百度的页面 F12 检查后都会有一些有趣的招聘信息。于是乎我也想给我的博客加一个。 我主要用到的工具： console.log() Notepad++ 在线图片转文字工具 ","date":"2018-08-04","objectID":"/posts/console-log/:0:0","tags":["hexo","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"用法 用 js 在\u003cbody\u003e\u003c/body\u003e使用 console.log() 就行了，hexo 的主题文件在_layout.swig里，所以我们打开该文件，在该位置，添加 js 就行了； ","date":"2018-08-04","objectID":"/posts/console-log/:1:0","tags":["hexo","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"图案 我用的我自己的一张照片（电脑上照片就那么几张。)，然后用 在线图片转文字工具 转字符， 选择文件，设置大小，然后生成， 生成后，复制 TXT 文件（下面那个框，上面的是 HTML 代码） 粘贴到 Notepad++ 里面，然后按图操作； Ctrl+H 替换 最后就变成一个字符串了。 ","date":"2018-08-04","objectID":"/posts/console-log/:2:0","tags":["hexo","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"效果图 线上 demo, 按 F12 找到 console ","date":"2018-08-04","objectID":"/posts/console-log/:3:0","tags":["hexo","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"我的 txt \\n` @@#``@@@@@@@@@@@@@@@@@@##,` \\n` @@#`;@@@@@@@@@@@@@@@@@@@':' \\n` @@#`@@@@@@@@@@@@@@@@@@@#+#;` \\n` @@#`@@@@@@@@@@@@@@@@@@###@'. \\n` @@+.@@@@@@@@@@@@@@@@@@@@@##, \\n` @@#,@@@@@@@@@@@@@@@@@@@@@@#, \\n` #@#:@@@@@@@@@@@@@@@@@@@@@@@, \\n` #@#'@@@@@@@@@@@@@@@@@@@@@@@. \\n` +@#;@@@@@@@@@@@@@@@@@@@@@@# \\n` `;: ;@#'@@@@@@@@@@@@@@@@@@+'+@' \\n` `,,;';'+';'@@+:@@@@@@@@@@@@##@#',.:#; \\n,, `` ``..,:;@@#'@@@@@@@@#####@@@@#:`:. \\n` `````:++@@@@@@@@@@@@@###@@@@#+,.. \\n ``````.#@@@@@@@@@@@@@@#@@@#++#'`` \\n` ```.,,:,.`:@@@@@@@@@@@@@###@@@##'.` \\n``..`````..,::;+@@@@@@@@@@@@#+`::+##'`. \\n` ````.```,@@@@@@@@@@@##;``.,';` ` \\n``.;@@@@@@@@@@@@@@@@@@@@@@###;``..`````` \\n#@@@@@@@@@@@@@@@@@@@@@@@@##@#;``,``,.`` \\n@@@@@@@@@@@@@@@@@@@.`````..``.. +` `:` \\n@+''++#####@@#`.@@@``````` ` `,``` `` \\n';;;;'+##+'+.`;+@@@,..```` `` :,. \\n;::,,:;+#++``,,#@@@'..``````` ,`.`` \\n;,,,,...'#.,,..#@@@#,,.`````` .```` \\n:,,,,....`,::;''+#@#;,..`````````.`` \\n:,,,.....'##++''';:+':,.`..,,...` \\n:,,,...#####+'+#@@@'.';+:. ` `` \\n;,,.`'####'#,`.`+@@@+'``` `.` \\n;,.`#@@@#+:'+++##+@##@,,,,` \\n',.#@@###'''';:,.```,+#. \\n+,#@@@####;,,..``````````````` `.:,::\\n+@@@@###+;,,..`````````````````` `.,\\n#@@@##+',,,........`````````````` \\n@@@@#+:,,,,`........`````````` \\n@@@#+:,,,,.`````.....`````````` `` \\n@@##':,......`````....``` ````` ```\\n@@@#':,....,..``````..```` ``` ```\\n@@@#',....,,,..``````````` ``` ..\\n@@@#,.....,,,,.`` ```````` `````` \\n@@@+....,,,,,..````````````` `````````` \\n@@@:....,,,,.LiRuihao```````` ```````````` \\n#@@,....,,,,.Always Be Yourself !````````````\\n,##,,...,::,.````````````..`````` `......``\\n,'#,,..,,:::.`````````........`````` `.,,..\\n\\n 你好！\\n 欢迎进入什么都不会的李瑞豪的个人网站！\\nhttps://lruihao.cn\\nhttps://www.lruihao.cn\\nhttps://lruihao.github.io\\nhttps://liruihao.coding.me\\n\\n\\n\\n 其他个人网站，个人博客也是可以的。 ","date":"2018-08-04","objectID":"/posts/console-log/:4:0","tags":["hexo","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["ACM"],"content":"题目链接 题目大意： 说的是，一只奶牛位于 N 号节点，输入 N 个节点和 T 对双向的边，求出由 N 到 1 的最短的距离，其实就是问的单源最短路问题。 两个点可能有多条路，选择最短的。 #include\u003cstdio.h\u003e #include\u003cstring.h\u003e #include\u003calgorithm\u003e using namespace std; const int INF=99999999; //设为无穷大 int maps[1005][1005],v[1005],d[1005]; //v 表示是否已经过遍历 d 表示从源到点当前最短路 int n; void Dijkstra(int s,int t) { int i,j,k,mini; for(i=1;i\u003c=n;i++) d[i]=INF; //除源点设为 0 距离外 其他先设为无穷大 d[s]=0; for(i=1;i\u003c=n;i++) //n 点循环 n 次 , 找出 n 个 k, 找 n 个点 { mini=INF; k=-1; for(j=1;j\u003c=n;j++) //在所有未标记点中 选 d 值最小的点 if(!v[j] \u0026\u0026 d[j]\u003cmini) mini=d[k=j]; v[k]=1; //标记节点 if(k==t) { printf(\"%d\\n\",d[t]); return; } for(j=1;j\u003c=n;j++) if(!v[j] \u0026\u0026 (d[k]+maps[k][j])\u003cd[j]) //表示从 k 出发的点，对于所有边，更新相连点 d[j]=d[k]+maps[k][j]; } } int main() { int T,i,j,x,y,D; while(scanf(\"%d %d\",\u0026T,\u0026n)!=EOF) { memset(v,0,sizeof(v)); //清除标记 for(i=1;i\u003c=n;i++) for(j=1;j\u003c=n;j++) maps[i][j]=INF; for(i=1;i\u003c=T;i++){ scanf(\"%d%d%d\",\u0026x,\u0026y,\u0026D); if(maps[x][y]\u003eD) //可能有多条路，只记录最短的 maps[x][y]=D,maps[y][x]=D; } Dijkstra(1,n); } return 0; } ","date":"2018-08-03","objectID":"/posts/poj2387/:0:0","tags":["ACM","最短路","C++","C"],"title":"Til the Cows Come Home-poj2387(dijkstra 判断重边）","uri":"/posts/poj2387/"},{"categories":["ACM"],"content":"Dijkstra 算法 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:1:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"1. 定义概览 Dijkstra（迪杰斯特拉）算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra 算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。 问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径） ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:1:1","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"2. 算法描述 1) 算法思想： 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组，第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S 中的顶点的距离就是从 v 到此顶点的最短路径长度，U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。 2) 算法步骤： a. 初始时，S 只包含源点，即 S ＝{v}，v 的距离为 0。U 包含除 v 外的其他顶点，即：U={其余顶点}，若 v 与 U 中顶点 u 有边，则\u003cu,v\u003e正常有权值，若 u 不是 v 的出边邻接点，则\u003cu,v\u003e权值为 ∞。 b. 从 U 中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离就是 v 到 k 的最短路径长度）。 c. 以 k 为新考虑的中间点，修改 U 中各顶点的距离；若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值的顶点 k 的距离加上边上的权。 d. 重复步骤 b 和 c 直到所有顶点都包含在 S 中。 执行动画过程如下图 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:1:2","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"spfa 算法 spfa 是一种求单源最短路的算法 算法中需要用到的主要变量 int n; //表示 n 个点，从 1 到 n 标号 int s,t; //s 为源点，t 为终点 int d[N]; //d[i] 表示源点 s 到点 i 的最短路 int p[N]; //记录路径（或者说记录前驱） queue q; //一个队列，用 STL 实现，当然可有手打队列，无所谓 bool vis[N]; //vis[i]=1 表示点 i 在队列中 vis[i]=0 表示不在队列中 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:2:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"几乎所有的最短路算法其步骤都可以分为两步 初始化 松弛操作 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:3:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"初始化： d 数组全部赋值为 INF（无穷大）；p 数组全部赋值为 s（即源点），或者赋值为-1，表示还没有知道前驱，然后 d[s]=0; 表示源点不用求最短路径，或者说最短路就是 0。将源点入队； （另外记住在整个算法中有顶点入队了要记得标记 vis 数组，有顶点出队了记得消除那个标记） ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:3:1","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"队列+松弛操作 读取队头顶点 u，并将队头顶点 u 出队（记得消除标记）；将与点 u 相连的所有点 v 进行松弛操作，如果能更新估计值（即令 d[v] 变小），那么就更新，另外，如果点 v 没有在队列中，那么要将点 v 入队（记得标记），如果已经在队列中了，那么就不用入队 以此循环，直到队空为止就完成了单源最短路的求解 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:3:2","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"SPFA 可以处理负权边 定理：只要最短路径存在，上述 SPFA 算法必定能求出最小值。 证明： 每次将点放入队尾，都是经过松弛操作达到的。换言之，每次的优化将会有某个点 v 的最短路径估计值 d[v] 变小。所以算法的执行会使 d 越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着 d 值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。（证毕） 期望的时间复杂度 O(ke)， 其中 k 为所有顶点进队的平均次数，可以证明 k 一般小于等于 2。 判断有无负环： 如果某个点进入队列的次数超过 N 次则存在负环（SPFA 无法处理带负环的图） 代码 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:4:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"题目链接 密码：l9sn 终于不爆零了，但是还是 wa 了无数次，有时候代码感觉都差不多 ","date":"2018-08-02","objectID":"/posts/nowcodersummer-5th/:0:0","tags":["Nowcoder","ACM","C++"],"title":"牛客暑假多校第五场","uri":"/posts/nowcodersummer-5th/"},{"categories":["ACM"],"content":"G-max /* //wa #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,c;//好像不会爆 int 吧，头晕 cin\u003e\u003ec\u003e\u003en; int t=n/c; if(t\u003c1) cout\u003c\u003c\"-1\\n\";// else if(t==1) cout\u003c\u003cc*c\u003c\u003cendl; else cout\u003c\u003c(t*c)*((t-1)*c)\u003c\u003cendl; return 0; }*/ //AC #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long n,c; cin\u003e\u003ec\u003e\u003en; long long t=n/c; if(t\u003c1) cout\u003c\u003c-1\u003c\u003cendl; else if(t==1) cout\u003c\u003cc*c\u003c\u003cendl; else cout\u003c\u003c(t*c)*((t-1)*c)\u003c\u003cendl; return 0; } ","date":"2018-08-02","objectID":"/posts/nowcodersummer-5th/:1:0","tags":["Nowcoder","ACM","C++"],"title":"牛客暑假多校第五场","uri":"/posts/nowcodersummer-5th/"},{"categories":["ACM"],"content":"J-plan /*枚举所有情况 全买双人 n%2 0 or 1//剩 1 个人的时候，可以多开一间房或者退一间 2 人房开一间 3 人房 全买 3 人 n%3 0 or 1 or 2 再比较大小 */ #include\u003cbits/stdc++.h\u003e #define INF 1\u003c\u003c20 using namespace std; typedef long long ll; ll min(ll a,ll b){ return a\u003cb?a:b; } int main(){ ll n,p2,p3,sum,sum1; while(cin\u003e\u003en\u003e\u003ep2\u003e\u003ep3){ if(n%2==0) sum=p2*(n/2); else sum=p2*(n/2)+min(min(p2,p3),p3-p2);//退二买三； if(n%3==0) sum1=p3*(n/3); else if(n%3==1) sum1=p3*(n/3)+min(min(p2,p3),2*p2-p3);//退 3 买 2*2 else if(n%3==2) sum1=p3*(n/3)+min(p3,p2);//退 3 买 3*2 cout\u003c\u003cmin(sum1,sum)\u003c\u003cendl; } return 0; } ","date":"2018-08-02","objectID":"/posts/nowcodersummer-5th/:2:0","tags":["Nowcoder","ACM","C++"],"title":"牛客暑假多校第五场","uri":"/posts/nowcodersummer-5th/"},{"categories":["ACM"],"content":"题目链接 思路参考 1,思路参考 2（没看懂） 先占坑，有时间再理理思路。 同一棵树中 d=1, 即 x 和 y 是同类，则需满足 r[x]==r[y] d=2,x 应该吃了 y, 也就是 (r[x]+1)%3 == r[y] 不同树合并且更新关系 (x 树做主根) ’ 如果 x 和 y 为关系 r1, y 和 z 为关系 r2， 那么 x 和 z 的关系就是（r1+r2）%3 如果 d==1 则 x 和 y 是同类 ，那么 y 对 x 的关系是 0, 如果 d==2 , 则 x 吃了 y, 那么 y 对 x 的关系是 1, x 对 y 的关系是 2。综上所述 , 无论 d 为 1 或者是为 2, y 对 x 的关系都是 d-1。 fy 对 y 的关系为 3-r[y] （有点互补的感觉，注意这里是不同类喔） y 对 x 的关系为 d-1, x 对 fx 的关系为 r[x] 所以 fy 对 fx 的关系是（3-r[y] + d-1 + r[x]）%3。可以借助向量图理解 fy-\u003ey-\u003ex-\u003efx #include\u003ccstdio\u003e const int maxn = 50000+10; int p[maxn]; //存父节点 int r[maxn];//存与父节点的关系 0 同一类，1 被父节点吃，2 吃父节点 void set(int n) //初始化 { for(int x = 1; x \u003c= n; x++) { p[x] = x; //开始自己是自己的父亲节点 r[x] = 0;//开始自己就是自己的父亲，每一个点均独立 } } int find(int x) //找父亲节点 { if(x == p[x]) return x; int t = p[x]; p[x] = find(p[x]); r[x] = (r[x]+r[t])%3; //回溯由子节点与父节点的关系和父节点与根节点的关系找子节点与根节点的关系 return p[x]; } void Union(int x, int y, int d) { int fx = find(x); int fy = find(y); p[fy] = fx; //合并树 注意：被 x 吃，所以以 x 的根为父 r[fy] = (r[x]-r[y]+3+(d-1))%3; //对应更新与父节点的关系 } int main() { int n, m; scanf(\"%d%d\", \u0026n, \u0026m); set(n); int ans = 0; int d, x, y; while(m--) { scanf(\"%d%d%d\", \u0026d, \u0026x, \u0026y); if(x \u003e n || y \u003e n || (d == 2 \u0026\u0026 x == y)) ans++; //如果节点编号大于最大编号，或者自己吃自己，说谎 else if(find(x) == find(y)) //如果原来有关系，也就是在同一棵树中，那么直接判断是否说谎 { if(d == 1 \u0026\u0026 r[x] != r[y]) ans++; //如果 x 和 y 不属于同一类 if(d == 2 \u0026\u0026 (r[x]+1)%3 != r[y]) ans++; // 如果 x 没有吃 y （注意要对应 Uinon(x, y) 的情况，否则一路 WA 到死啊！！！) } else Union(x, y, d); //如果开始没有关系，则建立关系 } printf(\"%d\\n\", ans); return 0; } ","date":"2018-08-02","objectID":"/posts/poj1182/:0:0","tags":["ACM","并查集","POJ","C++","C"],"title":"食物链-poj1182（带权并查集经典模板）","uri":"/posts/poj1182/"},{"categories":["ACM"],"content":"题目链接：小希的迷宫 ","date":"2018-08-01","objectID":"/posts/hdu1272/:1:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272（并查集 or 树性质）","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"并查集： 无回路 单连通 并查集做，首先想到的是判断两个点是否连通，不连通就合并，已连通的话说明会形成回路，则可以判定 No，交了一发错了。 想了一下没有考虑到多个连通域的情况，该题必须只有一个连通域 ","date":"2018-08-01","objectID":"/posts/hdu1272/:2:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272（并查集 or 树性质）","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"树的性质： 既然单连通无回路，则这肯定是一棵树；那么 edge=v-1; 最后注意空树的情况，至于自环我这里 No 也过了，没有去验证自环 Yes 的情况了 //并查集 #include\u003cbits/stdc++.h\u003e using namespace std; int pre[100001]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int a,int b){ int x=find(a),y=find(b); if(x!=y) pre[y]=x; } int main(){ int a,b,flag,i,sum; while(1) { flag = 0; while(~scanf(\"%d%d\",\u0026a,\u0026b) \u0026\u0026 a!=0 \u0026\u0026 b!=0){ if(a==-1 \u0026\u0026 b==-1) return 0; if(pre[a]==0)pre[a]=a; if(pre[b]==0)pre[b]=b; if(find(a)==find(b))flag = 1; else if(flag!=1) join(a,b); } for(sum = 0,i=1;i\u003c100001;i++){ if(pre[i]==i)sum++; pre[i] = 0; } if(sum\u003e1 || flag == 1) printf(\"No\\n\"); else printf(\"Yes\\n\"); } } //1 2 3 4 0 0 No 没有连通 //0 0 Yes //1 1 0 0 No（该代码） //树性质 #include \u003cstdio.h\u003e bool s[100001]; int main() { int a,b,i,len,num,v; for(i=0;i\u003c100001;++i) s[i]=false; len=0,num=0,v=0; while(1) { scanf(\"%d%d\",\u0026a,\u0026b); if(a==-1\u0026\u0026b==-1) break; if(a==0\u0026\u0026b==0) { if(v==0) { printf(\"Yes\\n\"); continue; } if(num==len-1) //划重点！！ printf(\"Yes\\n\"); else printf(\"No\\n\"); num=len=v=0; for(i=0;i\u003c100001;++i) s[i]=false; continue; } v=1; if(s[a]==false) len++;//点数 if(s[b]==false) len++; s[a]=s[b]=true; num++;//边数 } return 0; ","date":"2018-08-01","objectID":"/posts/hdu1272/:3:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272（并查集 or 树性质）","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"题目链接：How Many Answers Are Wrong 思路参考：本题直接参考,图文解释 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long LL; int pre[200010],ranks[200010]; int find(int root){ if(pre[root] != root) { int f = pre[root]; pre[root] = find(pre[root]);//递归路径压缩 ranks[root] += ranks[f]; /*精髓假如一开始没关系，那么用 rank 数组来表示 a，b 各自到各自祖先的距离。 那么在把 a 的祖先给 b 的祖先当父亲之后，那么 b 到祖先的距离也就是 rank[b] 就要再加上 b 原本的祖先到 a 的祖先的距离，更新一下， 其中 find 函数（找根节点的函数）里 rank[x]+=rank[pre[x]]（这里 pre 数组存的是对应数的父节点）*/ } return pre[root]; } int main(){ int n,m; while(~scanf(\"%d%d\",\u0026n,\u0026m)){ int ans=0; for(int i=1; i\u003c=n; i++) pre[i]=i; memset(ranks,0,sizeof(ranks)); while(m--){ int a,b,c; scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026c); a--;//[a,b]~~(a--,b] int fa=find(a); int fb=find(b); if(fa!=fb){ pre[fb]=fa;//注意合并顺序，反过来下面的也要改 ranks[fb]=ranks[a]-ranks[b]+c;//更新距离 } else { if(ranks[b]-ranks[a]!=c) ans++; } } printf(\"%d\\n\",ans); } return 0; } ","date":"2018-08-01","objectID":"/posts/hdu3038/:0:0","tags":["并查集","ACM","HDU","C++"],"title":"How Many Answers Are Wrong-hdu3038（带权并查集）","uri":"/posts/hdu3038/"},{"categories":["ACM"],"content":"题目链接：Bear and Finding Criminals 大致题意就是小熊警察住在某个城市，他要抓各个城市的罪犯，现在用一个 BCD 可以知道那个城市里一定有罪犯。 一定能确定该城市有小偷的几种情况： 警察所住城市有罪犯，则一定能检测到 警察所住城市的左边和右边位置若都不为 0，则说明两座城市都有罪犯（只有一边为 1 是不能确定到底哪个城市有罪犯的） 警察所在城市的一边检测到有罪犯，但在另一边已经没有城市了，则说明该城市一定有罪犯 #include\u003cbits/stdc++.h\u003e using namespace std; int t[107]; int main() { int n, a; while(cin\u003e\u003en\u003e\u003ea){ int sum = 0; for(int i =1; i \u003c= n; i++) cin \u003e\u003e t[i]; if(t[a]) sum++;//小熊所在城市有罪犯 for(int i = 1; i \u003c= n; i++){ if(a-i \u003e 0\u0026\u0026a+i \u003c= n) { if(t[a-i] == 1\u0026\u0026t[a+i] == 1) sum+=2; } else if(a-i \u003c= 0\u0026\u0026a+i \u003c= n){//警察在第一个点 if(t[a+i]) sum++; } else if(a-i \u003e 0\u0026\u0026a+i \u003e n){ if(t[a-i]) sum++; } } cout \u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-31","objectID":"/posts/codeforces680b/:0:0","tags":["Codeforces","ACM","C++"],"title":"Bear and Finding Criminals-Codeforces680B","uri":"/posts/codeforces680b/"},{"categories":["ACM"],"content":"题目链接：Bear and Five Cards 大致题意就是小熊有 5 张卡片，每张卡片有对应的分数，他可以选择丢弃 2 张相同的或者 3 张相同的卡片，没有相同的就无法丢弃，问小熊剩下的分数最少是多少。 没有想得那么复杂，由于分数最大才 100，所以直接暴力就好了。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a[5],b[107],i,j,sum=0,sum1=0; for(i=0;i\u003c5;i++){ cin\u003e\u003ea[i]; sum+=a[i]; } sort(a,a+5); memset(b,0,sizeof(b)); for(i=0;i\u003c5;i++) b[a[i]]++; for(i=0;i\u003c107;i++){ if(b[i]==2) sum1=max(2*i,sum1); if(b[i]\u003e=3) {sum1=max(3*i,sum1);/*cout\u003c\u003c3*i\u003c\u003c\" \"\u003c\u003csum1\u003c\u003cendl;*/} } cout\u003c\u003csum-sum1\u003c\u003cendl; return 0; } ","date":"2018-07-31","objectID":"/posts/codeforces680a/:0:0","tags":["Codeforces","ACM","C++"],"title":"Bear and Five Cards-Codeforces680A","uri":"/posts/codeforces680a/"},{"categories":["ACM"],"content":"并查集求连通域数目，初始化 sum=n； 题目链接： how many tables #include\u003cbits/stdc++.h\u003e using namespace std; int pre[1005]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } int main(){ int n,m,t,sum,root1,root2; cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em; sum=n; for(int i=1;i\u003c=n;i++) pre[i]=i; for(int i=0;i\u003cm;i++){ cin\u003e\u003eroot1\u003e\u003eroot2; int xx=find(root1); int yy=find(root2); if(xx!=yy){ pre[xx]=yy; sum--; } } cout\u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-31","objectID":"/posts/how-tables/:0:0","tags":["并查集","HDU","C++","ACM"],"title":"how many tables-HDU-1213（并查集求连通域数目）","uri":"/posts/how-tables/"},{"categories":["ACM"],"content":"题目链接：The-suspects ","date":"2018-07-31","objectID":"/posts/poj-1611/:1:0","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611（并查集）","uri":"/posts/poj-1611/"},{"categories":["ACM"],"content":"翻译： 警察抓贩毒集团。有不同类型的犯罪集团，人员可能重复，集团内的人会相互接触。现在警察在其中一人（0 号）身上搜出毒品，认为与这个人直接接触或通过其他人有间接接触的人都是嫌疑犯。问包括 0 号犯人共有多少嫌疑犯？ ","date":"2018-07-31","objectID":"/posts/poj-1611/:2:0","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611（并查集）","uri":"/posts/poj-1611/"},{"categories":["ACM"],"content":"Input 多样例输入。 每个测试用例以两个整数 n 和 m 开头，其中 n 为人数，m 为犯罪集团数。你可以假定 0 \u003c n \u003c= 30000 和 0 \u003c= m \u003c= 500。在所有的情况下，每个人都有自己独特的整数编号 0 到 n−1, 且 0 号是公认的嫌疑犯。 接下来 m 行输入，每个犯罪集团一行。每一行从一个整数 k 开始，它本身表示集团内成员的数量。按照成员的数量，在这个组中有 k 个整数表示人员。一行中的所有整数都被至少一个空格隔开。 n = 0 且 m = 0 时输入结束。 ","date":"2018-07-31","objectID":"/posts/poj-1611/:2:1","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611（并查集）","uri":"/posts/poj-1611/"},{"categories":["ACM"],"content":"Output 对于每个样例，输出嫌疑犯人数。 ","date":"2018-07-31","objectID":"/posts/poj-1611/:2:2","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611（并查集）","uri":"/posts/poj-1611/"},{"categories":["ACM"],"content":"Sample Input 100 4 2 1 2 5 10 13 11 12 14 2 0 1 2 99 2 200 2 1 5 5 1 2 3 4 5 1 0 0 0 ","date":"2018-07-31","objectID":"/posts/poj-1611/:2:3","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611（并查集）","uri":"/posts/poj-1611/"},{"categories":["ACM"],"content":"Sample Output 4 1 这题也很好理解，AC 代码如下： #include\u003ccstdio\u003e int pre[30010],x[30010]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy) pre[fy]=fx; } int main(){ int n,m,i,k,sum; while(scanf(\"%d%d\",\u0026n,\u0026m),n||m){ sum=0; for(i=0;i\u003cn;i++) pre[i]=i; while(m--){ scanf(\"%d\",\u0026k); for(i=0;i\u003ck;i++) scanf(\"%d\",\u0026x[i]); for(i=1;i\u003ck;i++) join(x[i-1],x[i]); } for(i=0;i\u003cn;i++) if(find(0)==find(i)) sum++;//再次查找并压缩路径，注不用 pre[i] printf(\"%d\\n\",sum); } return 0; } ","date":"2018-07-31","objectID":"/posts/poj-1611/:2:4","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611（并查集）","uri":"/posts/poj-1611/"},{"categories":["ACM"],"content":"题目链接：wireless network ","date":"2018-07-31","objectID":"/posts/poj-2236/:1:0","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"翻译： 南亚发生了一次地震。ACM (Asia Cooperated Medical 亚洲联合医疗队） 已经为膝上型电脑搭建了一个无线网络，但受到了一次不可预知的余震攻击，因此网络中的所有电脑都被破坏了。电脑被逐台修复，网络逐步恢复了工作。由于受到硬件的约束，每台电脑只能与距离它不超过 d 米的其它电脑直接通信。但每台电脑可被看作其它两台电脑的通信中转点，也就是说，如果电脑 A 和电脑 B 可以直接通信，或存在一台电脑 C 既可与 A 也可与 B 通信，那么电脑 A 和电脑 B 之间就能够通信。 在处理网络修复的过程中，工作人员们在任何一个时刻，可以执行两种操作：维修一台电脑，或测试两台电脑是否能够通信。请您找出全部的测试操作。 ","date":"2018-07-31","objectID":"/posts/poj-2236/:2:0","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"输入 第一行包含了两个整数 N 和 d (1 \u003c= N \u003c= 1001, 0 \u003c= d \u003c= 20000)。此处 N 是电脑的数目，编号从 1 到 N；同时，D 是两台电脑之间能够直接通信的最大距离。接下来的 N 行，每行包含两个整数 xi, yi (0 \u003c= xi, yi \u003c= 10000)，表示 N 台电脑的坐标。从第 (N+1) 行到输入结束，是逐一执行的操作，每行包含一个操作，格式是以下两者之一： “O p” (1 \u003c= p \u003c= N)，表示维护电脑 p 。 “S p q” (1 \u003c= p, q \u003c= N)，表示测试电脑 p 和 q 是否能够通信。 输入不超过 300000 行。 ","date":"2018-07-31","objectID":"/posts/poj-2236/:2:1","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"输出 对于每个测试操作，如果两台电脑能够通信，则打印 “SUCCESS”；否则，打印 “FAIL”。 ","date":"2018-07-31","objectID":"/posts/poj-2236/:2:2","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"示例输入 4 1 0 1 0 2 0 3 0 4 O 1 O 2 O 4 S 1 4 O 3 S 1 4 ","date":"2018-07-31","objectID":"/posts/poj-2236/:2:3","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"示例输出 FAIL SUCCESS ","date":"2018-07-31","objectID":"/posts/poj-2236/:2:4","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"AC 代码： #include \"iostream\" #include \"cstring\" using namespace std; int pre[1005]; int x[1005],y[1005],use[1005]; int findd(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int x,int y){ int fx=findd(x),fy=findd(y); if(fx!=fy) pre[fx]=fy; } int dis(int i,int num,int d){ d=d*d; int xx=x[i]-x[num]; int yy=y[i]-y[num]; if((xx*xx+yy*yy)\u003c=d) return 1; return 0; } int main(){ int n,d; char s; memset(use,0,sizeof(use)); cin\u003e\u003en\u003e\u003ed; for(int i=0;i\u003c=n;i++) pre[i]=i; for(int i=1;i\u003c=n;i++) cin\u003e\u003ex[i]\u003e\u003ey[i]; while(cin\u003e\u003es){ if(s=='O'){ int num; cin\u003e\u003enum; use[num]=1; findd(num);//路径压缩 for(int i=1;i\u003c=n;i++) if(i!=num\u0026\u0026use[i]==1\u0026\u0026dis(i,num,d))//修好了，且可以被合并（自己除外） join(i,num); } else if(s=='S'){ int q,p; cin\u003e\u003eq\u003e\u003ep; if(findd(q)==findd(p)) cout\u003c\u003c\"SUCCESS\"\u003c\u003cendl; else cout\u003c\u003c\"FAIL\"\u003c\u003cendl; } } return 0; } ","date":"2018-07-31","objectID":"/posts/poj-2236/:2:5","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"Codeforces Round #500 (Div. 2) 题目链接：Piles With Stones 大致题意就是有 n 堆石头，第一天每堆有一定数目的石头，第二天石头可能被小朋友移动或者带走，求满足题意的两天的石碓； 所以第二天的石头总数不会大于第一天的，所以是 sum1-sum2\u003e=0 即可。 //又只打了一道题，扣了 80 多分。 #include\u003cbits/stdc++.h\u003e using namespace std; int x[55],y[55],n,s1=0,s2=0; int main(){ scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026x[i]); s1+=x[i]; } for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026y[i]); s2+=y[i]; } if((s1-s2)\u003e=0) printf(\"Yes\\n\"); else printf(\"No\\n\"); return 0; } ","date":"2018-07-31","objectID":"/posts/piles-with-stones/:0:0","tags":["ACM","Codeforces","C++"],"title":"Piles-with-stones","uri":"/posts/piles-with-stones/"},{"categories":["ACM"],"content":"并查集入门推荐：超有爱的并查集~ 题目链接：畅通工程 题意分析： 首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。 #include\u003ciostream\u003e #include\u003ccstdio\u003e using namespace std; int pre[1010]; int findd(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } int main(){ int n,m,i,sum,r1,r2,star,end1; while(scanf(\"%d\",\u0026n)\u0026\u0026n){ sum=n-1; for(i=1;i\u003c=n;i++) pre[i]=i; scanf(\"%d\",\u0026m); while(m--){ scanf(\"%d%d\",\u0026star,\u0026end1); r1=findd(star); r2=findd(end1); if(r1!=r2){ pre[r1]=r2; sum--; } } printf(\"%d\\n\",sum); } return 0; } 基础回顾： find() 函数找根结点的两种写法如下： 第一种递归： int find(int x) { return x == pre[x] ? x : find(pre[x]); } 第二种： int find(int x) { int root, temp; root = x; while(root != pre[root]) root = pre[root]; while(x != root) { temp = pre[x]; pre[temp] = root; x = temp; } return root; } 合并函数 void join(int x,int y){ int fx=find(x); int fy=find(y); if(fx!=fy) pre[fx]=fy; } ","date":"2018-07-31","objectID":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/:0:0","tags":["ACM","并查集","HDU","C++","C"],"title":"畅通工程-HDU-1232（并查集经典模板）","uri":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/"},{"categories":["ACM"],"content":"两题水过，暴力，找规律。 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:0:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛 23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"托米的赌球 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:1:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛 23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"托米的划分 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:2:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛 23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"a #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int c[13],d[13]={100,50,20,10,5,2,1,50,20,10,5,2,1}; int i,t; cin\u003e\u003et; int a,b; while(t--){ memset(c,0,sizeof(c)); cin\u003e\u003ea\u003e\u003eb; for(i=0;i\u003c7;i++){ int x=0; if(a\u003ec[i]){ x=a/d[i]; c[i]+=x; a-=x*d[i]; } for(i=7;i\u003c13;i++){ int x=0; if(b\u003ec[i]){ x=b/d[i]; c[i]+=x; b-=x*d[i]; } cout\u003c\u003cc[0]; for(i=1;i\u003c13;i++) cout\u003c\u003c\" \"\u003c\u003cc[i]; cout\u003c\u003cendl; } return 0; } ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:3:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛 23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"b f(n)=f(n-1)+n-1; #include\u003cbits/stdc++.h\u003e using namespace std; long long sum; int main(){ int n; int t; cin\u003e\u003et; while(t--){ sum=1; cin\u003e\u003en; if(n==1) sum=0; for(int i=3;i\u003c=n;i++) sum+=i-1; cout\u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:4:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛 23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["Grocery"],"content":"在线算法 在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。 在计算机科学中，一个在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。相对的，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，选择排序在排序前就需要知道所有待排序元素，然而插入排序就不必。 因为在线算法并不知道整个的输入，所以它被迫做出的选择最后可能会被证明不是最优的，对在线算法的研究主要集中在当前环境下怎么做出选择。对相同问题的在线算法和离线算法的对比分析形成了以上观点。如果想从其他角度了解在线算法可以看一下流算法（关注精确呈现过去的输入所使用的内存的量），动态算法（关注维护一个在线输入的结果所需要的时间复杂度）和在线机器学习。 一个很好的展示在线算法概念的例子是 加拿大旅行者问题，这个问题的目标是在一个有权图中以最小的代价到达一个目标节点，但这个有权图中有些边是不可靠的可能已经被剔除。然而一个旅行者只有到某个边的一个端点时才能确定该边是否已经被移除了。最坏情况下，该问题会变得简单了，即所有的不确定的边都被移除该问题将会变成通常的最短路径问题。 ","date":"2018-07-26","objectID":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/:1:0","tags":["在线离线算法"],"title":"在线离线算法","uri":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"categories":["Grocery"],"content":"离线算法 离线算法 ( off line algorithms)，是指基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。 设计策略 在执行算法前输入已知的基本假设 前提 具有问题完全信息 算法设计策略都是基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果，通常将这类具有问题完全信息前提下设计出的算法称为离线算法 ( off line algorithms) ","date":"2018-07-26","objectID":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/:2:0","tags":["在线离线算法"],"title":"在线离线算法","uri":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"categories":["ACM"],"content":"非常可乐 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是 seeyou 却不这么认为。因为每次当 seeyou 买了可乐以后，阿牛就要求和 seeyou 一起分享这一瓶可乐，而且一定要喝的和 seeyou 一样多。但 seeyou 的手中只有两个杯子，它们的容量分别是 N 毫升和 M 毫升 可乐的体积为 S （S\u003c101）毫升　（正好装满一瓶） ，它们三个之间可以相互倒可乐 （都是没有刻度的，且 S==N+M，101 ＞ S ＞ 0，N ＞ 0，M ＞ 0) 。聪明的 ACMER 你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出\"NO\"。 ","date":"2018-07-24","objectID":"/posts/hdu-1495/:0:0","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs 模拟倒水 or 数论）","uri":"/posts/hdu-1495/"},{"categories":["ACM"],"content":"Input 三个整数 : S 可乐的体积 , N 和 M 是两个杯子的容量，以\"0 0 0\"结束。 ","date":"2018-07-24","objectID":"/posts/hdu-1495/:0:1","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs 模拟倒水 or 数论）","uri":"/posts/hdu-1495/"},{"categories":["ACM"],"content":"Output 如果能平分的话请输出最少要倒的次数，否则输出\"NO\"。 ","date":"2018-07-24","objectID":"/posts/hdu-1495/:0:2","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs 模拟倒水 or 数论）","uri":"/posts/hdu-1495/"},{"categories":["ACM"],"content":"Sample Input 7 4 3 4 1 3 0 0 0 ","date":"2018-07-24","objectID":"/posts/hdu-1495/:0:3","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs 模拟倒水 or 数论）","uri":"/posts/hdu-1495/"},{"categories":["ACM"],"content":"Sample Output NO 3 模拟一下倒水的过程，一共有三种倒法，a 向 bc，b 向 ac，c 向 ab。（相当于一共六个方向）搜索并记录搜索过的过程就好了。 #include\u003cbits/stdc++.h\u003e using namespace std; int a,b,c; int used[111][111][111]; struct node { int x,y,z; int step; }m,n; int bfs() { queue\u003cnode\u003eq; m.x = a; m.y = 0; m.z = 0; m.step = 0; used[a][0][0] = 1; q.push(m); while (!q.empty()) { int trans; //倒水量 m = q.front(); q.pop(); //成功分好的三种情况 if ((m.x == 0 \u0026\u0026 m.y == m.z) || (m.y == 0 \u0026\u0026 m.x == m.z) || (m.z == 0 \u0026\u0026 m.x == m.y)) return m.step; //下面开始 6 个搜索（由一个杯子向另外两个倒水） if (m.x) { //第一 trans = min(m.x , b - m.y);//自己模拟一下倒水过程就知道了 n.x = m.x - trans; n.y = m.y + trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } //第二 trans = min(m.x , c - m.z); n.x = m.x - trans; n.y = m.y; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } } if (m.y) { //第三 trans = min(m.y , a - m.x); n.x = m.x + trans; n.y = m.y - trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } //第四 trans = min(m.y , c - m.z); n.x = m.x; n.y = m.y - trans; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } } if (m.z) { //第五 trans = min(m.z , a - m.x); n.x = m.x + trans; n.y = m.y; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } //第六 trans = min(m.z , b - m.y); n.x = m.x; n.y = m.y + trans; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } } } return 0; } int main() { while (~scanf (\"%d %d %d\",\u0026a,\u0026b,\u0026c) \u0026\u0026 (a || b || c)) { if (a\u00261) //先简单的剪枝一下，奇数肯定不能平分 printf (\"NO\\n\"); else { memset (used,0,sizeof (used)); int ans = bfs(); if (ans) printf (\"%d\\n\",ans); else printf (\"NO\\n\"); } } return 0; } 然后杭电上讨论板子上提供一种数论题解，但是数据存在一点问题，只不过有些数据好像不对；比如： 10 6 5 的结果应该是 1 而不是 9， 也提示我们多维思考同一个问题！ 数论推导 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int s,n,m; while(cin\u003e\u003es\u003e\u003en\u003e\u003em,s+n+m){ s/=__gcd(n,m); if(s\u00261)//奇数 cout\u003c\u003c\"NO\\n\"; else cout\u003c\u003cs-1\u003c\u003cendl; } return 0; } ","date":"2018-07-24","objectID":"/posts/hdu-1495/:0:4","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs 模拟倒水 or 数论）","uri":"/posts/hdu-1495/"},{"categories":["ACM"],"content":"Find a way 圣诞节要到了，坤神和瑞瑞这对基佬想一起去召唤师大峡谷开开车。百度地图一下，发现周围的召唤师大峡谷还不少，这对基佬纠结着，该去哪一个。坤神：我要去左边的这个（因为离自己比较近 哈哈~）。瑞瑞：我要去右边的这个（因为离自己比较近 嘿嘿~） …….. 这对基佬闹矛盾了，开车有危险了！ 为了不让他们去召唤师大峡谷坑人，riot 决定让他们去 X 召唤师大峡谷，保证他俩所走的路程和最短。每走一个点需要花费 11 分钟，输出他们一共花费多少时间（最短时间噢） ","date":"2018-07-23","objectID":"/posts/hdu-2612/:0:1","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双 bfs）","uri":"/posts/hdu-2612/"},{"categories":["ACM"],"content":"Input 多组测试数据 每组数据，开始一行 n，m (2\u003c=n,m\u003c=200) 接下来是个 n x m 的矩阵 ‘Y’ 表示坤神所在的初始位置 ‘M’ 表示瑞瑞所在的初始位置 ‘#’ 该点禁止通行 ‘.’ 该点可通行 ‘@’ 召唤师大峡谷 ","date":"2018-07-23","objectID":"/posts/hdu-2612/:0:2","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双 bfs）","uri":"/posts/hdu-2612/"},{"categories":["ACM"],"content":"Output 每组测试数据，输出坤神和瑞瑞到达同一个召唤师大峡谷所花费的最短时间。 ","date":"2018-07-23","objectID":"/posts/hdu-2612/:0:3","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双 bfs）","uri":"/posts/hdu-2612/"},{"categories":["ACM"],"content":"Sample Input 4 4 Y.#@ .... .#.. @..M 4 4 Y.#@ .... .#.. @#.M 5 5 Y..@. .#... @..M. `#...#` ","date":"2018-07-23","objectID":"/posts/hdu-2612/:0:4","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双 bfs）","uri":"/posts/hdu-2612/"},{"categories":["ACM"],"content":"Sample Output 66 88 66 ","date":"2018-07-23","objectID":"/posts/hdu-2612/:0:5","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双 bfs）","uri":"/posts/hdu-2612/"},{"categories":["ACM"],"content":"Hint 对于第一组样例，坤神和瑞瑞去矩阵（4,1） 这个召唤师大峡谷，耗费的时间为 3 _ 11 + 3 _ 11 = 66， 去矩阵（1,4）这个召唤师大峡谷，耗费的时间为 5 _ 11 + 3 _ 11 = 88 。所以，最终答案：66。思路参考 写代码总是好粗心！！ #include \u003cbits/stdc++.h\u003e #define inf 0x3f3f3f3f //acm 中“无穷大”的一般定义 using namespace std; const int M=202; char mp[M][M]; //地图 int a[M][M],b[M][M]; bool vis[M][M]; //标记数组 int n,m; int ans; struct node { int x,y,step; }; void init() //初始化函数 { ans=inf; for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) { a[i][j]=inf; b[i][j]=inf; } } void bfs(int x,int y,bool flag){ int dir[4][2]={-1,0,1,0,0,1,0,-1}; node u,v; queue\u003cnode\u003e q; //初始化队列第一个元素 u.x=x; u.y=y; u.step=0; vis[x][y]=true; q.push(u); while(!q.empty()){ u=q.front(); q.pop(); if(mp[u.x][u.y]=='@'){ if(!flag) a[u.x][u.y]=u.step; else b[u.x][u.y]=u.step; } for(int i=0;i\u003c4;i++){ int tx=u.x+dir[i][0]; int ty=u.y+dir[i][1]; if(tx\u003e=0\u0026\u0026ty\u003e=0\u0026\u0026tx\u003cn\u0026\u0026ty\u003cm\u0026\u0026!vis[tx][ty]\u0026\u0026mp[tx][ty]!='#'){//注意@和 M，Y 也是可以走的。 v.x=tx; //每次写搜索都忘记 vis!!!! v.y=ty; vis[tx][ty]=true; //我总是忘记。 v.step=u.step+1; q.push(v); } } } } int main() { while(~scanf(\"%d%d\",\u0026n,\u0026m)) { init(); for(int i=0; i\u003cn; i++) scanf(\"%s\",mp[i]); for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) { if(mp[i][j]=='Y') { memset(vis,false,sizeof(vis)); bfs(i,j,false); } if(mp[i][j]=='M') { memset(vis,false,sizeof(vis)); //记得再次初始化标记数组 bfs(i,j,true); } } for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) if(mp[i][j]=='@') ans=min(ans,a[i][j]+b[i][j]); printf(\"%d\\n\",ans*11); } return 0; } ","date":"2018-07-23","objectID":"/posts/hdu-2612/:0:6","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双 bfs）","uri":"/posts/hdu-2612/"},{"categories":["ACM"],"content":"Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X\",“1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:0","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"Input Line 1: Two space-separated integers: N and K ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:1","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"Output Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:2","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"Sample Input 5 17 ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:3","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"Sample Output 4 ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:4","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"Hint The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:5","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"题意： 农场主的牛不见了，主人和牛在一条直线上，且牛没有新的目标，它不会走动，主人的位置是你 n，牛的位置是 k，主人可以有三种走路的方法，右左（距离+-1），闪现（距离+x,x 为当前位置），每走一步，一分钟，问几分钟主人能找到牛。bfs 搜索方向即为三个“方向”。搜索所有走法； #include\"iostream\" #include\u003cqueue\u003e #include\"string.h\" using namespace std; int n,k; bool sign[200007]; struct node{ int x,step; }; bool check(int a) { if(!sign[a]\u0026\u0026a\u003e=0\u0026\u0026a\u003c110000) return true; return false; } void bfs() { node u,v; queue\u003cnode\u003e q; v.x=n;//初始化起点 v.step=0; q.push(v); sign[v.x]=true; while(!q.empty()){ u=q.front(); q.pop(); if(u.x==k){ cout\u003c\u003cu.step\u003c\u003cendl; return ; } //三种前进方向，左右和闪现 v=u; v.x++; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } v=u; v.x--; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } v=u; v.x=2*v.x; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } } } int main() { cin\u003e\u003en\u003e\u003ek; memset(sign,0,sizeof(sign)); bfs(); return 0; } ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:6","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"英文原题链接 ","date":"2018-07-22","objectID":"/posts/poj-2251/:0:0","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维 bfs 最短路）","uri":"/posts/poj-2251/"},{"categories":["ACM"],"content":"Description - 题目描述 你被困在一个三维的空间中，现在要寻找最短路径逃生！ 空间由立方体单位构成 你每次向上下前后左右移动一个单位需要一分钟 你不能对角线移动并且四周封闭 是否存在逃出生天的可能性？如果存在，则需要多少时间？ ","date":"2018-07-22","objectID":"/posts/poj-2251/:0:1","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维 bfs 最短路）","uri":"/posts/poj-2251/"},{"categories":["ACM"],"content":"Input - 输入 输入第一行是一个数表示空间的数量。 每个空间的描述的第一行为 L，R 和 C（皆不超过 30）。 L 表示空间的高度。R 和 C 分别表示每层空间的行与列的大小。 随后 L 层地牢，每层 R 行，每行 C 个字符。 每个字符表示空间的一个单元。’#‘表示不可通过单元，’.‘表示空白单元。你的起始位置在’S’，出口为’E’。 每层空间后都有一个空行。L，R 和 C 均为 0 时输入结束。 ","date":"2018-07-22","objectID":"/posts/poj-2251/:0:2","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维 bfs 最短路）","uri":"/posts/poj-2251/"},{"categories":["ACM"],"content":"Output - 输出 每个空间对应一行输出。 如果可以逃生，则输出如下 Escaped in x minute(s). x 为最短脱离时间。 如果无法逃生，则输出如下 Trapped! ","date":"2018-07-22","objectID":"/posts/poj-2251/:0:3","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维 bfs 最短路）","uri":"/posts/poj-2251/"},{"categories":["ACM"],"content":"Sample Input - 输入样例 3 4 5 S.... .###. .##.. ###.# ##### ##.## ##... ##### #.### ####E 1 3 3 S## #E# ### 0 0 0 ","date":"2018-07-22","objectID":"/posts/poj-2251/:0:4","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维 bfs 最短路）","uri":"/posts/poj-2251/"},{"categories":["ACM"],"content":"Sample Output - 输出样例 Escaped in 11 minute(s). Trapped! 类似二维四个方向的 bfs 最短路，改成上下东西南北就行了，三维 bfs 最短路 #include \u003ciostream\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cqueue\u003e #include \u003calgorithm\u003e using namespace std; char map[35][35][35]; int vis[35][35][35]; int k,n,m,sx,sy,sz,ex,ey,ez; int to[6][3] = {{0,0,1},{0,0,-1},{0,1,0},{0,-1,0},{1,0,0},{-1,0,0}};//上下东西南北 struct node { int x,y,z,step; }; int check(int x,int y,int z)//检查是否可走 { if(x\u003c0 || y\u003c0 || z\u003c0 || x\u003e=k || y\u003e=n || z\u003e=m)//越界判断 return 1; else if(map[x][y][z] == '#') return 1; else if(vis[x][y][z]) return 1; return 0; } int bfs() { int i; node a,next; queue\u003cnode\u003e Q; a.x = sx,a.y = sy,a.z = sz; a.step = 0; vis[sx][sy][sz] = 1; Q.push(a); while(!Q.empty()) { a = Q.front(); Q.pop(); if(a.x == ex \u0026\u0026 a.y == ey \u0026\u0026 a.z == ez) return a.step; for(i = 0; i\u003c6; i++) { next = a; next.x = a.x+to[i][0]; next.y = a.y+to[i][1]; next.z = a.z+to[i][2]; if(check(next.x,next.y,next.z)) continue; vis[next.x][next.y][next.z] = 1; next.step = a.step+1; Q.push(next); } } return 0; } int main() { int i,j,r; while(scanf(\"%d%d%d\",\u0026k,\u0026n,\u0026m),n+m+k) { for(i = 0; i\u003ck; i++) { for(j = 0; j\u003cn; j++) { scanf(\"%s\",map[i][j]); for(r = 0; r\u003cm; r++) { if(map[i][j][r] == 'S') { sx = i,sy = j,sz = r; } else if(map[i][j][r] == 'E') { ex = i,ey = j,ez = r; } } } } memset(vis,0,sizeof(vis)); int ans; ans = bfs(); if(ans) printf(\"Escaped in %d minute(s).\\n\",ans); else printf(\"Trapped!\\n\"); } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-2251/:0:5","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维 bfs 最短路）","uri":"/posts/poj-2251/"},{"categories":["ACM"],"content":"Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 63659 Accepted: 30423 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:0","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 k 个棋子的所有可行的摆放方案 C。 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:1","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"Input 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个 n * n 的矩阵内描述棋盘，以及摆放棋子的数目。 n \u003c= 8 , k \u003c= n 当为-1 -1 时表示输入结束。 随后的 n 行描述了棋盘的形状：每行有 n 个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:2","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"Output 对于每一组数据，给出一行输出，输出摆放的方案数目 C （数据保证 C\u003c2^31）。 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:3","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"Sample Input 2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:4","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"Sample Output 2 1 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:5","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"Source 蔡错@pku ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:6","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"思路 下子方案数就相当于遍历图的不同遍历数，用 dfs 变形。 理解以下数据还有样例应该差不多了 3 2 #.. .#. ..# 3 3 2 #.. .## ..# 4 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:7","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"AC 代码 #include\u003ciostream\u003e #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003calgorithm\u003e using namespace std; char mp[8][8]; int v[8]; int n,k,w,r;//状态计数器 r void dfs(int x)//逐行深搜，x 为当前搜索行 { if(w==k)//下子数 w { r++;return; } if(x==n)return; for(int i=0;i\u003cn;i++) { if(v[i]!=1\u0026\u0026mp[x][i]=='#') { v[i]=1; w++; dfs(x+1); w--; v[i]=0; } } dfs(x+1);//搜索下一行 } int main() { while(cin\u003e\u003en\u003e\u003ek) { if(n==-1\u0026\u0026k==-1) return 0; memset(mp,0,sizeof(mp)); memset(v,0,sizeof(v)); for(int i=0;i\u003cn;i++) cin\u003e\u003emp[i]; w=0;r=0; dfs(0); cout\u003c\u003cr\u003c\u003cendl; } } 传送门 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:8","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"Find The Multiple Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 40713 Accepted: 17088 Special Judge ","date":"2018-07-22","objectID":"/posts/poj-1426/:1:0","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426/"},{"categories":["ACM"],"content":"Description Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits. ","date":"2018-07-22","objectID":"/posts/poj-1426/:1:1","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426/"},{"categories":["ACM"],"content":"Input The input file may contain multiple test cases. Each line contains a value of n (1 \u003c= n \u003c= 200). A line containing a zero terminates the input. ","date":"2018-07-22","objectID":"/posts/poj-1426/:1:2","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426/"},{"categories":["ACM"],"content":"Output For each value of n in the input print a line containing the corresponding value of m. The decimal representation of m must not contain more than 100 digits. If there are multiple solutions for a given value of n, any one of them is acceptable. ","date":"2018-07-22","objectID":"/posts/poj-1426/:1:3","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426/"},{"categories":["ACM"],"content":"Sample Input 2 6 19 0 ","date":"2018-07-22","objectID":"/posts/poj-1426/:1:4","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426/"},{"categories":["ACM"],"content":"Sample Output 10 100100100100100100 111111111111111111 给定一个正整数 n，请编写一个程序来寻找 n 的一个非零的倍数 m，这个 m 应当在十进制表示时每一位上只包含 0 或者 1。你可以假定 n 不大于 200 且 m 不多于 100 位。 提示：本题采用 Special Judge，你无需输出所有符合条件的 m，你只需要输出任一符合条件的 m 即可。 #include\"iostream\" using namespace std; typedef unsigned long long ll; int n; bool sign; void dfs(ll x,int count) { if(sign) return ; if(x%n==0){ sign=true; cout\u003c\u003cx\u003c\u003cendl; return ; } if(count==19)//m 最多 200 位 return ; dfs(x*10,count+1); dfs(x*10+1,count+1); //每两位数后两位有两种情况，10 或 11，深搜所有情况，找到一种就返回，找不到找另外一颗子树 } int main() { while(cin\u003e\u003en\u0026\u0026n) { sign=false; dfs(1,0); } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-1426/:1:5","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426/"},{"categories":["ACM"],"content":"Codeforces Round 498 (Div. 3) A. Adjacent Replacements（水）","date":"2018-07-22","objectID":"/posts/adjacent-replacements/","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"A. Adjacent Replacements 第一次打 cf 就做出一道这样的找规律的题，打到自闭。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,a[1001]; cin\u003e\u003en; int i; int flag=0; for(i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; if(!(a[i]\u00261)) a[i]--; if(!flag) {cout\u003c\u003ca[i];flag=1;} else cout\u003c\u003c\" \"\u003c\u003ca[i]; } return 0; } ","date":"2018-07-22","objectID":"/posts/adjacent-replacements/:0:0","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"迷宫问题 Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 32323 Accepted: 18471 ","date":"2018-07-22","objectID":"/posts/poj-3984/:0:1","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题 (bfs 路径）","uri":"/posts/poj-3984/"},{"categories":["ACM"],"content":"Description 定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 ","date":"2018-07-22","objectID":"/posts/poj-3984/:0:2","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题 (bfs 路径）","uri":"/posts/poj-3984/"},{"categories":["ACM"],"content":"Input 一个 5 × 5 的二维数组，表示一个迷宫。数据保证有唯一解。 ","date":"2018-07-22","objectID":"/posts/poj-3984/:0:3","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题 (bfs 路径）","uri":"/posts/poj-3984/"},{"categories":["ACM"],"content":"Output 左上角到右下角的最短路径，格式如样例所示。 ","date":"2018-07-22","objectID":"/posts/poj-3984/:0:4","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题 (bfs 路径）","uri":"/posts/poj-3984/"},{"categories":["ACM"],"content":"Sample Input 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 ","date":"2018-07-22","objectID":"/posts/poj-3984/:0:5","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题 (bfs 路径）","uri":"/posts/poj-3984/"},{"categories":["ACM"],"content":"Sample Output (0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (2, 3) (2, 4) (3, 4) (4, 4) 对于新手来说，主要是 bfs 路径的问题有点难度，搞得晕晕的。 #include\u003ciostream\u003e #include\u003ccstring\u003e using namespace std; int map[5][5]; int visited[5][5]; int dx[4]={0, 1, 0, -1}; int dy[4]={ 1, 0,-1, 0}; int head,tail; struct node{ int xx,yy; int fa;//父节点 }pre[25],way[25]; void BFS(int x,int y) { int x1,y1; head=0,tail=1; visited[x][y]=1; pre[0].xx=x,pre[0].yy=y; while(tail\u003ehead)//栈空 { x=pre[head].xx; y=pre[head].yy; if(x==4\u0026\u0026y==4)//结束标志 return ; for(int i=0;i\u003c4;i++) { x1=x+dx[i];y1=y+dy[i]; if(x1\u003e=0\u0026\u0026x1\u003c=4\u0026\u0026y1\u003e=0\u0026\u0026y1\u003c=4) if(map[x1][y1]==0\u0026\u0026!visited[x1][y1]) { pre[tail].xx=x1; pre[tail].yy=y1; pre[tail].fa=head; visited[x1][y1]=1; tail+=1;//入栈 } } head++;//相当于出栈 } } int main() { int i,j; ios::sync_with_stdio(false); memset(map,0,sizeof(map)); memset(visited,0,sizeof(visited)); for(i=0;i\u003c5;i++) for(j=0;j\u003c5;j++) cin\u003e\u003emap[i][j]; BFS(0,0); i=0; while(head)//逆序进行赋值输出就是通路 { way[i].xx=pre[head].xx; way[i].yy=pre[head].yy; head=pre[head].fa; i++; } //画一下队列 way[i].xx=0;way[i].yy=0; while(i!=-1) { cout\u003c\u003c\"(\"\u003c\u003cway[i].xx\u003c\u003c\", \"\u003c\u003cway[i].yy\u003c\u003c\")\"\u003c\u003cendl; i--; } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-3984/:0:6","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题 (bfs 路径）","uri":"/posts/poj-3984/"},{"categories":["ACM"],"content":"链接：https://www.nowcoder.com/acm/contest/133/A 来源：牛客网 ","date":"2018-07-22","objectID":"/posts/wannafly-20/:0:0","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 20-染色","uri":"/posts/wannafly-20/"},{"categories":["ACM"],"content":"题目描述 现在有一棵被 Samsara-Karma 染了 k 种颜色的树，每种颜色有着不同的价值，Applese 觉得 Samsara-Karma 染的太难看了，于是打算把整棵树重新染成同一种颜色，但是，由于一些奥妙重重的原因，每一次染色 Applese 可以选择两个有边相连的点，将其中一个染成另一个的颜色。而进行一次这样的操作需要付出两种颜色价值和的代价， 现在，Applese 的钱要用来买书 (game)，所以他想要最小化代价 ","date":"2018-07-22","objectID":"/posts/wannafly-20/:0:1","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 20-染色","uri":"/posts/wannafly-20/"},{"categories":["ACM"],"content":"输入描述： 输入包括若干行第一行包括一个数 n，表示这棵树有 n 个节点第二行包括 n 个数，第 i 个数表示第 i 个节点的颜色 coli 注意：一个颜色的标号即价值接下来的 n - 1 行，每行包括两个数 u, v，表示 u 节点与 v 节点之间有一条无向边 n ≤ 100000, 1 ≤ coli ≤ 1e9，数据保证是一棵树 ","date":"2018-07-22","objectID":"/posts/wannafly-20/:0:2","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 20-染色","uri":"/posts/wannafly-20/"},{"categories":["ACM"],"content":"输出描述： 输出包括一行第一行包括一个数，表示最小代价 ","date":"2018-07-22","objectID":"/posts/wannafly-20/:0:3","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 20-染色","uri":"/posts/wannafly-20/"},{"categories":["ACM"],"content":"示例 1 输入 4 2 3 4 3 1 2 2 3 3 4 输出 12 蒟蒻暴力枚举-_-! #include \u003cbits/stdc++.h\u003e using namespace std; const int MAXN=1e5+10; int a[MAXN]; map\u003cint, int \u003ema; set\u003cint\u003ese; int x[MAXN],y[MAXN]; int main() { int n; scanf(\"%d\",\u0026n); for (int i = 1; i \u003c=n ; ++i) { scanf(\"%d\",\u0026a[i]); se.insert(a[i]); } for (int i = 1; i \u003cn ; ++i) { scanf(\"%d%d\",\u0026x[i],\u0026y[i]); } long long ans=1e14,sum=0; set\u003cint\u003e::iterator it; for (it=se.begin(); it !=se.end() ; ++it) { sum=0; for (int j = 1; j \u003c=n ; ++j) { if((*it)!=a[j]) sum+=((*it)+a[j]); } ans=min(sum,ans); } printf(\"%lld\\n\",ans); return 0; } 最后想说这都过了什么鬼，不会数据这么弱吧？？！? 我只枚举了最小的价值颜色的情况，唉，不管了不管了。 #include\u003cbits/stdc++.h\u003e using namespace std; int a[1000000],n,m,k=1,t,ans=0; int main() { scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;++i) scanf(\"%d\",\u0026a[i]); sort(a+1,a+n+1); for(int i=2;i\u003c=n;++i) if(a[i]!=a[1]) ans+=a[i]+a[1]; printf(\"%d\",ans); return 0; } ","date":"2018-07-22","objectID":"/posts/wannafly-20/:0:4","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 20-染色","uri":"/posts/wannafly-20/"},{"categories":["ACM"],"content":"Oil Deposits 翻译 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 41406 Accepted Submission(s): 23977 Problem Description The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. Input The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 \u003c= m \u003c= 100 and 1 \u003c= n \u003c= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ’ * ‘, representing the absence of oil, or ‘@’, representing an oil pocket. Output For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input 1 1 * 3 5 *@*@* **@** *@*@* 1 8 @@****@* 5 5 ****@ *@@*@ *@**@ @@@*@ @@**@ 0 0 Sample Output 0 1 2 Source Mid-Central USA 1997 Recommend Eddy | We have carefully selected several similar problems for you: 1016 1010 1312 1242 1240 思路 dfs 模板题吧，八个方向搜索；（像 i，j 这样的计数器还是写在局部比较好，我尽然被定义域的问题搞了一晚上醉了醉了。） #include\u003cbits/stdc++.h\u003e using namespace std; int n,m,s; char maze[107][107]; int vx[8]={-1,1,0,0,-1,-1,1,1}; int vy[8]={0,0,-1,1,-1,1,1,-1}; void dfs(int x,int y){ maze[x][y]='*'; for(int i=0;i\u003c8;i++){ int tx=x+vx[i]; int ty=y+vy[i]; if(tx\u003e=0\u0026\u0026tx\u003cm\u0026\u0026ty\u003e=0\u0026\u0026ty\u003cn\u0026\u0026maze[tx][ty]=='@') dfs(tx,ty); } } int main(){ int i,j; while(cin\u003e\u003em\u003e\u003en\u0026\u0026m){ s=0; for(i=0;i\u003cm;i++) cin\u003e\u003emaze[i]; for(i=0;i\u003cm;i++){//相当于不连通的情况 for(j=0;j\u003cn;j++){ if(maze[i][j]=='@'){ dfs(i,j); s++; } } } cout\u003c\u003cs\u003c\u003cendl; } return 0; } ","date":"2018-07-22","objectID":"/posts/hdu-1241/:1:0","tags":["DFS","搜索","HDU","ACM","C++"],"title":"hdu-1241-Oil Deposits (dfs)","uri":"/posts/hdu-1241/"},{"categories":["ACM"],"content":"假设有一个 n 行 m 列的迷宫，每个单位要么是空地（用 1 表示）要么是障碍物（用 0 表示）. 如和找到从起点到终点的最短路径？利用 BFS 搜索，逐步计算出每个节点到起点的最短距离， 以及最短路径每个节点的前一个节点。最终将生成一颗以起点为根的 BFS 树。此时 BFS 可以求出任意一点到起点的距离。 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:0","tags":["BFS","搜索","C++"],"title":"BFS 求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"图 1 3 0 21 23 2 0 17 20 22 4 0 14 0 0 5 0 12 15 18 6 8 10 0 19 7 9 11 13 16 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:1:0","tags":["BFS","搜索","C++"],"title":"BFS 求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"输入 6 5 1 1 0 1 1 1 0 1 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:2:0","tags":["BFS","搜索","C++"],"title":"BFS 求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"输出 1 2 4 5 6 8 10 12 14 17 20 21 23 12//最短距离 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:3:0","tags":["BFS","搜索","C++"],"title":"BFS 求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"代码 #include\u003ciostream\u003e #include\u003cqueue\u003e #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003cvector\u003e using namespace std; const int maxn=100+5; int G[maxn][maxn]; //存图的 d=id int path[maxn]; //存每个节点的父节点，即路径 int n,m; //n 行 m 列 int k=1;//记录编号 int end_num; int vx[5] = {-1,1,0,0}; //vx vy 用来计算一个节点周围上下左右 4 个节点 int vy[5] = {0,0,-1,1}; bool vis[maxn][maxn]; //判断某节点是否已经被访问过 struct node { int x; int y; int id; int parent=0; node(int a,int b,int c) { x=a; y=b; id=c; } }; int main() { //freopen(\"in.txt\",\"r\",stdin); memset(G,0,sizeof(G)); memset(vis,0,sizeof(vis)); memset(path,0,sizeof(path)); cin\u003e\u003en\u003e\u003em; for(int i=1; i\u003c=n; i++) for(int j=1; j\u003c=m; j++) { cin\u003e\u003eG[i][j]; } queue\u003cnode\u003e q; node v=node(1,1,1); q.push(v); vis[1][1]=1; while(!q.empty()) { node u=q.front(); q.pop(); path[u.id]=u.parent;//记录每个点的父节点 for(int i=0; i\u003c4; i++) { int tx=u.x+vx[i]; int ty=u.y+vy[i]; if(G[tx][ty]\u0026\u0026!vis[tx][ty])//有路可走且未访问 { vis[tx][ty]=1; //cout\u003c\u003ctx\u003c\u003cty\u003c\u003cendl; node v=node(tx,ty,++k); end_num=k; v.parent=u.id; q.push(v); } } } vector\u003cint\u003e ans; //cout\u003c\u003cend_num\u003c\u003cendl; while(end_num)//从后面开始找父亲节点 { ans.push_back(end_num); end_num=path[end_num]; } int s=0; while(!ans.empty()) { s++; cout\u003c\u003c*(ans.end()-1)\u003c\u003c' ';//ans 最后一个元素是 0 ans.pop_back(); } cout\u003c\u003cendl\u003c\u003cs-1; return 0; } ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:4:0","tags":["BFS","搜索","C++"],"title":"BFS 求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"那天晚上报名了没打，第二天早上打的，也只出了两题。 ","date":"2018-07-22","objectID":"/posts/cf-1009/:0:0","tags":["Codeforces","ACM","C++","C"],"title":"Educational Codeforces Round 47 (Rated for Div. 2)","uri":"/posts/cf-1009/"},{"categories":["ACM"],"content":"A. Game Shopping #include\u003ciostream\u003e using namespace std; int main(){ int n,m,s=0; cin\u003e\u003en\u003e\u003em; int i,j; int c[1000],a[1000]; for(i=0;i\u003cn;i++) cin\u003e\u003ec[i]; for(i=0;i\u003cm;i++) cin\u003e\u003ea[i]; for(i=0,j=0;i\u003cn;){ if(j==m) break; if(c[i]\u003c=a[j]){ s++; j++; i++; } else i++; } if(i==n\u0026\u0026s==0) cout\u003c\u003c\"0\\n\"; else cout\u003c\u003cs\u003c\u003cendl; return 0; } ","date":"2018-07-22","objectID":"/posts/cf-1009/:1:0","tags":["Codeforces","ACM","C++","C"],"title":"Educational Codeforces Round 47 (Rated for Div. 2)","uri":"/posts/cf-1009/"},{"categories":["ACM"],"content":"B. Minimum Ternary String #include \u003cbits/stdc++.h\u003e using namespace std; string s, ans; int main(){ cin \u003e\u003e s; int one = 0; for (int i = 0; i \u003c s.size(); i++){ if (s[i] == '0') ans += \"0\"; if (s[i] == '1') one++; if (s[i] == '2') ans += \"2\"; } bool flag = false; for (int i = 0; i \u003c ans.size(); i++){ if (ans[i] == '2' \u0026\u0026 !flag) flag = true, cout \u003c\u003c string(one, '1'); cout \u003c\u003c ans[i]; } if (!flag) cout \u003c\u003c string(one, '1'); return 0; } /* 100210 11222121 20 2001 020201 2012101 111 000 */ ","date":"2018-07-22","objectID":"/posts/cf-1009/:2:0","tags":["Codeforces","ACM","C++","C"],"title":"Educational Codeforces Round 47 (Rated for Div. 2)","uri":"/posts/cf-1009/"},{"categories":["ACM"],"content":" 2018 年全国多校算法寒假训练营练习比赛（第二场）B(0 1 背包变化 特殊处理一个物品） 链接：https://www.nowcoder.com/acm/contest/74/B 来源：牛客网 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:0","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao 要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"题目描述 Taotao 的电脑带不动绝地求生，所以 taotao 只能去玩 pc 版的荒野行动了， 和绝地求生一样，游戏人物本身可以携带一定重量 m 的物品，装备背包 之后可以多携带 h（h 为 0 代表没有装备背包）重量的东西。玩了几天 taotao 发现了一个 BUG，当装备背包之后，如果可携带重量没有满，就 可以拿一个任意重的东西。（解释看样例）有一天 taotao 空降到了一个 奇怪的岛上，岛上有 n 件装备，每个装备都有重量 Wi 和威力值 Vi, 但 taotao 不认识这些装备，所以他来求助你，挑选威力最大的装备，帮助他吃鸡。 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:1","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao 要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"输入描述： 本题有多组输入（小于 10），当 n=0 时结束输入。第一行输入 n,m,h。n，m，h 为整数，并且 0\u003c=n,m,h\u003c=100，接下来 n 行，每行输入第 i 个物品的物品的重量 Wi 和威力值 Vi。0\u003c=Wi,Vi\u003c=100. ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:2","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao 要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"输出描述： 输出最大威力值，每组输出一行。 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:3","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao 要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"示例 1 输入 3 3 3 2 3 3 2 2 3 0 输出 8 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:4","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao 要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"说明 可携带的总重量为 6，当拿了前两件装备，此时容量为 5/6，还可以再拿第三件物品。 思路：0-1 背包的变形题目，h=0 的时候为背包的模板，h！=0 的时候枚举每一个需要特殊处理的物品再背包 #include \u003cbits/stdc++.h\u003e using namespace std; int v[105]; int w[105]; int n,m,h; int dp[205]; int main() { while(scanf(\"%d\",\u0026n)==1\u0026\u0026n!=0){ int sum=0; scanf(\"%d%d\",\u0026m,\u0026h); for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026w[i],\u0026v[i]); if(h==0){ memset(dp,0,sizeof(dp)); for(int i=1;i\u003c=n;i++) //前 i 个物品 for(int j=m;j\u003e=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); // sum=dp[m]; } else{ m+=h for(int k=1;k\u003c=n;k++) //枚举可以被剩下的物品 { memset(dp,0,sizeof(dp)); for(int i=1;i\u003c=n;i++){ //前 i 个物品 if(i!=k){ for(int j=m;j\u003e=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); } } //留下来一个重量，即初始化威力为那个重量的威力 for(int j=m-1;j\u003e=m-w[k];j--) //枚举背包重量+剩下物品 dp[m]=max(dp[m],dp[j]+v[k]); // printf(\"%d\\n\",dp[m]); sum=max(sum,dp[m]); } } printf(\"%d\\n\",sum); } return 0; } ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:5","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao 要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"百度知道 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1、每行数字左右对称，由 1 开始逐渐变大，然后变小，回到 1。 2、第 n 行的数字个数为 n 个。 3、第 n 行数字和为 2^(n－1)。 4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。 5、将第 2n+1 行第 1 个数，跟第 2n+2 行第 3 个数、第 2n+3 行第 5 个数……连成一线，这些数的和是第 2n 个斐波那契数。将第 2n 行第 2 个数，跟第 2n+1 行第 4 个数、第 2n+2 行第 6 个数……这些数之和是第 2n-1 个斐波那契数。 6、第 n 行的第 1 个数为 1，第二个数为 1×(n-1)，第三个数为 1×(n-1)×（n-2）/2，第四个数为 1×(n-1)×（n-2）/2×（n-3）/3…依此类推。 此数列中各行中的数字正好是二项式 a+b 乘方后，展开始终各项的系数。如： (a+b)^1=a^1+b^1 (a+b)^2=a^2+2ab+b^2 (a+b)^3=a^3+3a^2b+3ab^2+b^3 …… (a+b)^6=a^6+6a^5b+15a^4b^2+20a^3b^3+15a^2b^4+6ab^5+b^6（注意发现规律） …… 二项式展开式： ","date":"2018-07-22","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/:0:0","tags":["数学","杨辉三角"],"title":"杨辉三角","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"},{"categories":["ACM"],"content":"广度优先搜索（BFS） 广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。访问了就入队。 ","date":"2018-07-22","objectID":"/posts/dfs_bfs/:0:1","tags":["ACM","BFS","DFS","搜索","C","C++"],"title":"深搜广搜","uri":"/posts/dfs_bfs/"},{"categories":["ACM"],"content":"深度优先搜索（DFS） 深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。 #include \u003cbits/stdc++.h\u003e #define N 5 using namespace std; int maze[N][N] = {//无权有向图邻接矩阵 { 0, 1, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 0 } }; int visited[N]; void DFS(int start) { cout \u003c\u003c start\u003c\u003c \" \"; visited[start] = 1; for (int i = 0; i \u003c N; i++) { if (!visited[i] \u0026\u0026 maze[start][i] == 1)//没访问过且为邻居节点 DFS(i); } } void BFS(int start){ queue\u003cint\u003e Q;//队列 Q.push(start); visited[start] = 1; while (!Q.empty()) { int front = Q.front();//头 cout \u003c\u003c front \u003c\u003c \" \"; Q.pop(); for (int i = 0; i \u003cN; i++) { if (!visited[i] \u0026\u0026 maze[front][i] == 1) { visited[i] = 1; Q.push(i); } } } } int main() { memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; DFS(i); } cout\u003c\u003cendl; memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; BFS(i); } return 0; } 传送门 ","date":"2018-07-22","objectID":"/posts/dfs_bfs/:0:2","tags":["ACM","BFS","DFS","搜索","C","C++"],"title":"深搜广搜","uri":"/posts/dfs_bfs/"},{"categories":["ACM"],"content":"时间限制：C/C++ 1 秒，其他语言 2 秒 空间限制：C/C++ 262144K，其他语言 524288K 64bit IO Format: %lld 题目描述 有一个长度为 n 的序列 a，已知 a[1]=a[n]=1，且对于 2 \u003c= x \u003c= n，a[x] / a[x-1] 是以下三个数字之一 [ 1，-2，0.5 ], 问有多少种不同的序列满足题意。 两个序列不同当且仅当它们有至少一个位置上的数字不同，序列 a 可以为任何实数。 输入描述： 一个整数 表示 n (1\u003c= n \u003c= 1e3) 输出描述： 一个整数 表示答案模 109+7 示例 1 输入 5 输出 7 解题思路： 整体来看，a[x] = a[x-1] _ [1, -2, 0.5]，那么等于从 n-1 个 [1,-2,0.5] 中选出 n-1 个数值相乘（a[x-1]=a[x-2] _ [1,-2,0.5] 同理化简式子）， 最后答案要是 1，所以-2 就必须有偶数个，同理 0.5 的个数要等于-2. 顺序无关。 那所有的转换中，就只要保证有若干组 (-2,-2,0.5,0.5) 存在 表示偶数个 2 的个数与偶数个 0.5 的个数组合；组合数用二项式系数，杨辉三角来求。 #include \u003cbits/stdc++.h\u003e using namespace std; const int maxn = 1e3 + 5; const int mod = 1e9 + 7; long long c[maxn][maxn]; int main(){ for(int i = 0; i \u003c maxn; i++){//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(int j = 1; j \u003c i; j++) c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; } int n; while(~scanf(\"%d\", \u0026n)){ n--; long long ans = 0; for(int i = 0; i*2 \u003c= n; i += 2){ ans = (ans%mod + (c[n][i]*c[n-i][i])%mod)%mod; } printf(\"%lld\\n\", ans); } return 0; } ","date":"2018-07-18","objectID":"/posts/wannafly-18/:0:0","tags":["组合数学","ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 18-序列","uri":"/posts/wannafly-18/"},{"categories":["ACM"],"content":"弱鸡还是弱鸡啊最简单的背包问题——。——！ ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:0:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":"1) 问题描述： 假设有一个能装入总体积为 T 的背包和 n 件体积分别为 W1，W2，···，Wn 的物品，能否从 n 件物品中挑选若干件恰好装满背包，即使 W1+W2+···+Wn=T，要求找出所有满足上述条件的解。例如：当 T=10，共 6 件物品，物品的体积为{1，2，3，4，5，8}，那么可找到下列 4 组解：（1，2，3，4）、（1，4，5）、（2，3，5）、（2、8）。 ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:1:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":"2) 实现提示： 可利用回溯法的设计思想来解决背包问题。首先，将物品排成一列，然后顺序选取物品装入背包，假设已选取了前 i 件物品之后背包还没有装满，则继续选取第 i+1 件物品，若该件物品“太大”不能装入，则丢弃而继续选取下一件，直至背包装满为止。但如果在剩余的物品中找不到合适的物品以填满背包，则说明“刚刚”装入背包的那件物品“不合适”，应将它取出“丢弃一边”，继续再从“它之后”的物品中选取，如此重复，直至求得满足条件的解，或者无解。由于回溯求解的规则是“后进先出”，因此要用到栈。 使用栈作为该程序的数据结构，利用栈进行语法检查，以深度优先的搜索方式解空间，实现递归过程和函数的调用，在设计时还使用 C 语言的数组及其循环语言来实现程序。 运用回溯法解题，在搜索解空间树时，只要其左儿子节点是一个可行结点，搜索就进入左子树，在右子树中有可能包含最优解是才进入右子树搜索。否则将右子树剪去。 #include \u003cstdio.h\u003e #include \u003cwindows.h\u003e #define size 50 struct stacks { int data[size]; int top; } stack; void backpack(int number,int V,int w[]){ int i,j=1,k=0; int flag=0; do { while (V \u003e 0 \u0026\u0026 k \u003c= number) { if (V \u003e= w[k]) { stack.data[stack.top] = k;//第 k 个物品的体积下标 stack.top++; V -= w[k]; } k++; } if (V == 0) { flag=1; printf(\"第%d 个符合条件的解：\", j); for (i = 0; i \u003c stack.top; i++) { printf(\"%d \", w[stack.data[i]]); } j++; printf(\"\\n\"); } //k 满时回溯 k = stack.data[--stack.top]; stack.data[stack.top] = 0; V += w[k]; k++; } while (!(stack.top == 0 \u0026\u0026 k == number)); if(!flag){ printf(\"背包无解！\\n\"); } } void judge(int number,int V,int w[]){ int i,s = 0; for (i = 0; i \u003c number; i++) s = s + w[i]; if(V \u003e s){ printf(\"背包无解！\\n\"); exit(0); } if(V==s){ printf(\"只有一个符合条件的解：%d\\n\", V); exit(0); } } int main() { int w[size]; int V; int i = 0; int j = 0; int number; printf(\"\\t **简单背包问题**\\n\\n\"); printf(\"\\n 请输入可供选择装入物品的个数：\\n\"); scanf(\"%d\", \u0026number); printf(\"\\n 请输入各件物品的体积：\\n\"); for (i = 0; i \u003c number; i++) scanf(\"%d\", \u0026w[i]); //排序 for(i=0;i\u003cnumber;i++) for(j=i+1;j\u003cnumber;j++) if(w[i]\u003ew[j]){ w[i]=w[i]^w[j]; w[j]=w[i]^w[j]; w[i]=w[i]^w[j]; } printf(\"\\n 请输入背包的总体积：\\n\"); scanf(\"%d\", \u0026V); while(V \u003c 0){ printf(\"输入背包体积错误！重新输入！\\n\"); scanf(\"%d\",\u0026V); } judge(number,V,w); //初始化栈 for (i = 0; i \u003c number; i++) stack.data[i] = 0; stack.top = 0; backpack(number,V,w); return 0; } --这么简单的问题我都费力，太辣鸡了 ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:2:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":" 来自一位大佬的演讲 尊敬的领导、教练，亲爱的参赛选手们： 大家好，我是来自广东工业大学的 tmk。今天很荣幸能够站在这里代表全体参赛选手发言，与大家分享我的经历和感受。 刚开始来到大学的时候，我一心向学，本着“好好学习，天天向上，为校争光，不搞对象”的信念，想在大学一展宏图。因为高中 OI 的挫败，我在刚上大学的时候就选择了 ACM 这条“不归路”。一开始是因为高中的遗憾，到后来就完全是因为信念和兴趣慢慢一直搞到现在。当时的我还不知道踏上 ACM 这条路的苦，而如今的我却也尝到了 ACM 带给我的乐。 在这三年里，有数不清的夜晚，我的舍友们在寝室里开黑，而我和我的队友在机房里开黑；在这三年里，有数不清的周末，我的舍友们在校园里驰骋，而我和我的队友在题库里驰骋；在这三年里，有数不清的假期，我的舍友们在召唤师峡谷里征战，而我和我的队友在中国各省市征战。三年过去了，我的舍友们成为了 offer 收割机，而我和我的队友成为了气球收割机。 为了变强是一个痛苦且漫长的过程，只有耐得住寂寞，才能守得住繁华。我的一位队友为了变强甚至牺牲了自己的头发，仅仅是因为他担心他的头发阻碍了他思维的发散。他变秃了也变强了。 三年的 ACM 让我成长很多，收获很多。我也从一个“好好学习天天向上为校争光不搞对象”的无知青年变成了一个写的了工程查得出异常的准程序员。我觉得三年献身于 ACM 的日子是值得的，和一大堆萌萌的男孩子们在屋子里面一个又一个通宵奋斗的酣畅淋漓的日子是值得的，看着谈恋爱的大家一会儿哀伤一会儿忧愁而我与代码自得其乐矢志不渝的日子是值得的。此外他还给我带来两个最好的小伙伴，是他们的一路陪伴，让我有勇气一直走下去。我和他们走过的地方，比我和女朋友去过的地方还要多。噢，对了，我好像没有女朋友。总而言之，请珍惜你们的队友，他们是你们在大学里为数不多一起奋斗的小伙伴。希望大家像我一样，也爱着 ACM，为自己心爱的努力。 最后预祝各位参赛选手们取得理想的成绩，也预祝本次大赛圆满成功。谢谢大家。 ","date":"2018-06-15","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/:0:0","tags":["ACM","2018 湘潭邀请赛"],"title":"18 湘潭邀请赛参赛队员代表发言","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/"},{"categories":["ACM"],"content":"题目链接（hdu 复赛） 2018 年湘潭邀请赛，在湘大举行，当时一起打的过去的，因为没出市就方便点。第一次参加现场赛，首先反省一下自己，比赛前算法先不说（没有好好搞过），就连普通的题，数学性质的题都很少刷，什么都不会，然后英语不说四六级的东西，很多专业英语词汇都没有好好了解过，主要的原因还是刷题刷少了，英文题刷少了。理所当然，成功拿下一铁，湘潭赛打铁告终。 比赛开始，这次是三个人没人一份纸质题目，拿到题目，看最后一题，k.2018 发现可以做，（事实证明确实是一道水题），我就在做这题，他们看了 a 题，好像是 k 题一顿操作后提交，错了，一直到比赛结束都没做出来，后来回去看别人的题解，发现自己情况没有分析全面，其实是完全可以解出来的，真的做的太少太少了。a 题最后也是没过，还有一个 f 题，sort，我最初的想法是用 stl 里的那个 sort 排序，只要对 sort 的 compare 函数做处理应该可以完成排序，比赛之前我看过，但是不熟悉，zxm 她也看了我就交给她了，最后好像因为爆 long double 的问题也没做出来。 哎，菜还是菜，很多算法都不懂，数据结构也没学好，很有一段时间我都特别头疼算法，不想学，费劲，觉得自己不适合学计算机，更不适合 ACM。有时候又想，不适合好像总是 loser 的借口！总是在后悔和偷懒的矛盾中！ 最后，放上，“参赛奖\"羞辱自己，也是鞭策！ ","date":"2018-06-14","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/:0:0","tags":["ACM","2018 湘潭邀请赛","Summaries"],"title":"18 湘潭邀请赛总结","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/"},{"categories":["ACM"],"content":"Sample Input 2 1 1 1 1 1 2 2 1 1 2 1 1 1 3 1 3 1 2 2 1 3 1 1 ","date":"2018-06-14","objectID":"/posts/f-sorting/:1:0","tags":["2018 湘潭邀请赛","ACM"],"title":"F.sorting","uri":"/posts/f-sorting/"},{"categories":["ACM"],"content":"Sample Output 2 1 1 2 1 2 3 题意：给定 n 个元组 (a1,b1,c1),(a2,b2,c2),…,(an,bn,cn)，将其按 (ai+bi)/(ai+bi+ci) 的值从小到大排序，输出排序后的 n 个元组的原序号； 思路：编写 sort 里的 cmp 函数（形参为元组结构体元素，设为 Tuple x,Tuple y)，若直接算出 (x.a+x.b)(y.a+y.b+y.c) 和 (y.a+y.b)(x.a+x.b+x.c) 再比较大小，这两个结果会爆 unsigned long long； 可以把因式乘积展开成多项式的和，约去两式中相同的项，得到 x.ay.c+x.by.c 和 y.ax.c+y.bx.c，因此只需计算它俩再比较即可，结果不会爆 unsigned long long 后 AC 代码 #include \"bits/stdc++.h\" using namespace std; struct node{ long double a,b,c; int numb; }ss[1005]; bool cmp(const node \u0026a,const node \u0026b){ long double suma,sumb; //suma=a.a*b.c+a.b*b.c; //sumb=b.a*a.c+b.b*a.c; suma=(a.a+a.b)/(a.a+a.b+a.c); sumb=(b.a+b.b)/(b.a+b.b+b.c); if(suma!=sumb)return suma\u003csumb; return a.numb\u003cb.numb; } int main(){ int n; while(cin\u003e\u003en){ for(int i=0;i\u003cn;i++){ cin\u003e\u003ess[i].a\u003e\u003ess[i].b\u003e\u003ess[i].c; ss[i].numb=i+1; } stable_sort(ss,ss+n,cmp); int i; for(i=0;i\u003cn-1;i++) cout\u003c\u003css[i].numb\u003c\u003c\" \"; cout\u003c\u003css[i].numb\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/f-sorting/:2:0","tags":["2018 湘潭邀请赛","ACM"],"title":"F.sorting","uri":"/posts/f-sorting/"},{"categories":["ACM"],"content":"K. 2018 Given a,b,c,d, ﬁnd out the number of pairs of integers (x,y) where a ≤ x ≤ b,c ≤ y ≤ d and x·y is a multiple of 2018. ","date":"2018-06-14","objectID":"/posts/k-2018/:1:0","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. Each test case contains four integers a,b,c,d. ","date":"2018-06-14","objectID":"/posts/k-2018/:1:1","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the result. ","date":"2018-06-14","objectID":"/posts/k-2018/:1:2","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Constraint • 1≤ a ≤ b ≤109,1≤ c ≤ d ≤109 • The number of tests cases does not exceed 104. ","date":"2018-06-14","objectID":"/posts/k-2018/:1:3","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Sample Input 1 2 1 2018 1 2018 1 2018 1 1000000000 1 1000000000 ","date":"2018-06-14","objectID":"/posts/k-2018/:1:4","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Sample Output 3 6051 1485883320325200 题意：给定区间 [a,b]、[c,d]，问有多少对有序数组 (x,y)(x∈[a,b],y∈[c,d]) 使得 xy 是 2018 的倍数 思路：2018=21009（分解质因数），则对 x 分类讨论：1) 仅为 2 的倍数；2）仅为 1009 的倍数；3）即为 2 又为 1009 的倍数；4）既不为 2 又不为 1009 的倍数 等价于如下分类讨论： 若 x 是偶数：1）若 x 是 1009 的倍数，则 y 可为 [c,d] 中任意数； 2）若 x 不是 1009 的倍数，则 y 必定为 [c,d] 中 1009 的倍数 若 x 是奇数：1）若 x 是 1009 的倍数，则 y 必定为 [c,d] 中 2 的倍数； 2）若 x 不是 1009 的倍数，则 y 必定为 [c,d] 中 2018 的倍数 后 AC 代码 #include\u003ccstdio\u003e #include\u003ciostream\u003e typedef unsigned long long ll; using namespace std; int main(){ ll a,b,c,d; while(cin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed){ ll num1_all_1009=b/1009-(a-1)/1009; ll num1_even=b/2-(a-1)/2; ll num1_1009_in_even=b/2018-(a-1)/2018; ll num1_rest_in_even=num1_even-num1_1009_in_even; ll num1_odd=(b-a+1)-num1_even; ll num1_1009_in_odd=num1_all_1009-num1_1009_in_even; ll num1_rest_in_odd=num1_odd-num1_1009_in_odd; ll ans=0; ans+=num1_1009_in_even*(d-c+1); ll num2_all_1009=d/1009-(c-1)/1009; ans+=num1_rest_in_even*num2_all_1009; ll num2_even=d/2-(c-1)/2; ans+=num1_1009_in_odd*num2_even; ll num2_all_2018=d/2018-(c-1)/2018; ans+=num1_rest_in_odd*num2_all_2018; cout\u003c\u003cans\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/k-2018/:1:5","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"B. Higher h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has no papers and he is going to publish some subsequently. If he works on a paper for x hours, the paper will get (a·x) citations, where a is a known constant. It’s clear that x should be a positive integer. There is also a trick – one can cite his own papers published earlier. Given Bobo has n working hours, ﬁnd the maximum h-index of him. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:0","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. Each test case contains two integers n and a. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:1","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the maximum h-index. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:2","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Constraint • 1≤ n ≤109 • 0≤ a ≤ n • The number of test cases does not exceed 104. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:3","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Sample Input 3 0 3 1 1000000000 1000000000 ","date":"2018-06-14","objectID":"/posts/b-higher/:1:4","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Sample Output 1 2 1000000000 ","date":"2018-06-14","objectID":"/posts/b-higher/:1:5","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Note For the ﬁrst sample, Bobo can work 3 papers for 1 hour each. With the trick mentioned, he will get papers with citations 2,1,0. Thus, his h-index is 1. For the second sample, Bobo can work 2 papers for 1 and 2 hours respectively. He will get papers with citations 1+1,2+0. Thus, his h-index is 2. 题意：给定 n 个小时，可以用其中 x(1\u003c=x\u003c=n) 个小时写一篇论文，那么这篇论文的\"既定\"引用数将会是x*a(a 为给定正整数）；此外，已经写好的论文将会被其后写成的论文所引用，也就是说，这篇论文的总引用数将会是\"既定\"引用数+其后论文篇数；问在所有的写论文方案中（例如一种方案就是用 n 个小时写 n 篇论文，每篇论文各花 1 小时（可以得到这 n 篇论文的引用数）)，h 最大为多少 (h 的含义同上题）（每一种方案都对应着一个 h，求这些 h 中的最大者） 思路：最优方案（即对应 h 值最大的方案）是平摊 n 小时写成 n 篇论文（证明未知）；此时 n 篇论文的引用数为 a,a+1,a+2,…,a+n-1，引用数为 a+i 时，引用数大于等于它的论文有 n-i 篇，令 a+i=n-i 得 i=(n-a)/2, 所以 h=a+(n-a)/2; 后 AC 代码 #include\u003ccstdio\u003e int main(){ int n,a; while(scanf(\"%d%d\",\u0026n,\u0026a)!=EOF){ printf(\"%d\\n\",a+(n-a)/2); } return 0; } ","date":"2018-06-14","objectID":"/posts/b-higher/:1:6","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"A. Easy h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has published many papers. Given a0,a1,a2,…,an which means Bobo has published ai papers with itations exactly i, ﬁnd the h-index of Bobo. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:0","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. The ﬁrst line of each test case contains an integer n. The second line contains (n+1) integers a0,a1,…,an. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:1","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the result. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:2","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Constraint • 1≤ n ≤2·105 • 0≤ ai ≤109 • The sum of n does not exceed 250,000. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:3","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Sample Input 1 1 2 2 1 2 3 3 0 0 0 0 ","date":"2018-06-14","objectID":"/posts/a-easy/:1:4","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Sample Output 1 2 0 题意：给定被引用次数为 0~n 的论文分别有几张，找到最大的 h，满足被引用次数大于等于 h 的论文至少有 h 张 思路：在区间 [0,n] 内二分答案；或直接从 n~0 遍历找到第一个满足条件的 h 后 AC 代码 #include \"bits/stdc++.h\" using namespace std; int main(){ int a[200005]; int n; int i; while(cin\u003e\u003en){ for(i=0;i\u003c=n;i++) cin\u003e\u003ea[i]; int sum=a[n]; for(i=n;i\u003e=0;){ if(sum\u003e=i){ cout\u003c\u003ci\u003c\u003cendl; break; } else sum+=a[--i]; } if(i\u003c0) cout\u003c\u003c\"0\"\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/a-easy/:1:5","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"sort 使用#include\u003calgorithm\u003e头文件， sort（开始地址，结束地址，排序方式），其中第三参数可以没有，则默认为升序排序。 或者简单的用 less\u003c参数类型\u003e()表示升序 greater\u003c参数类型\u003e()表示降序 也可以用一个 bool 型函数，比如： bool cmp(int a,int b){ return a\u003eb;//表从大到小，即降序 } 假设自己定义了一个结构体 node typedef struct node { int a; int b; double c; }note; 有一个 node 类型的数组 node arr[100]，想对它进行排序：先按 a 值升序排列，如果 a 值相同，再按 b 值降序排列，如果 b 还相同，就按 c 降序排列。就可以写这样一个比较函数： 以下是代码片段： bool cmp(node x,node y) { if(x.a!=y.a) return x.a\u003cy.a; if(x.b!=y.b) return x.b\u003ey.b; return x.c\u003ey.c; } sort() 函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组，数组类型可以是 int,char 等。 实例：先降序再升序 #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; typedef struct data{ int a; double b; }date; bool cmp(date a,date b){ if(a.b!=b.b) return a.b\u003eb.b; return a.a\u003cb.a; } int main(){ date a[3]={{5,56.5},{4,56.5},{8,85}}; sort(a,a+3,cmp); for(int i=0;i\u003c3;i++) cout\u003c\u003ca[i].a\u003c\u003c\"-\"\u003c\u003ca[i].b\u003c\u003cendl; cout\u003c\u003cendl; return 0; } 传送门 ","date":"2018-06-14","objectID":"/posts/c-sort/:0:0","tags":["C++","sort","STL","ACM"],"title":"sort 排序","uri":"/posts/c-sort/"},{"categories":["ACM"],"content":"1.swap（交换两元素值，在 algorithm 下，用法：swap(a,b);） 交换两元素的值在 C 语言课上作为指针讲解的典例。 int a=1,b=2; swap(a,b); //此时 a=2,b=1 （可以是其他类型） ","date":"2018-06-14","objectID":"/posts/c-with-stl/:1:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"2.sort(,,) sort 排序是不稳定的，stl 中的 stable_sort 才是稳定的 inta[10]={1,6,2,3,5,4,3,8,9,7}; stable_sort(a,a+10,greater\u003cint\u003e()); for(int i=0;i\u003c10;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; ","date":"2018-06-14","objectID":"/posts/c-with-stl/:2:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"3.reverse（翻转序列，在 algorithm 下） //常用在字符串上 int a[5]={1,2,3,4,5}; reverse(a,a+5); //序列现在是 5 4 3 2 1 char s[]=“ericxie”; reverse(s,s+strlen(s)); //序列现在是 “eixcire” //同样适用于 string string s=“qwer”; reverse(s.begin(),s.end()); ","date":"2018-06-14","objectID":"/posts/c-with-stl/:3:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"4.min，max（取大，取小） int a=1,b=2,c; c=min(a,b); //此时 c 等于 1 c=max(a,b); //此时 c 等于 2 string s=“qwer”,d=“asjk”,c; c=min(s,d); //c=“asjk” ","date":"2018-06-14","objectID":"/posts/c-with-stl/:4:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"5.__gcd（最大公约数） 手写 gcd 函数也行，辗转相除，辗转相减； int gcd(int a,int b){ return a%b ? b : gcd(b,a%b); } //直接用 int a=4,b=6; int c=__gcd(a,b); //注意下划线，此时 c 等于 2 ","date":"2018-06-14","objectID":"/posts/c-with-stl/:5:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"6.lower_bound 和 upper_bound（二分查找） lower_bound 意思就是：找到第一个位置，使得：如果在这个位置插入 value 后，原有序序列依旧有序。 upper_bound 是找到最后一个符合数位置后一个位置，使得：如果在这个位置插入 value 后，原有序序列依旧有序。 //数组 int a[8]={1,2,4,4,9,12,12,15}; int pos1 = lower_bound(a,a+8,4)-a; int pos2 = upper_bound(a,a+8,4)-a-1; //在这个样例下 pos1!=pos2;pos1=2;pos2=3; 根据我的理解 lower_bound(a,a+8,value) 得到的是一个地址，拿这个地址减去数组首地址 a[0]，那么刚好就是 value 应该放入的位置。 //vector vector\u003cint\u003e a; 若 a 中目前的元素也是{1,2,4,4,9,12,12,15}; 那么这里用 lower_bound 得到的应该也是一个类似于指针的东西，为什么不叫它指针呢？因为他有了一个名字，叫做迭代器。 vector\u003cint\u003e::iterator it; it = lower_bound(a.begin(),a.end(),4); //这里的 it 就是迭代器，那么* it 就是该下标对应的 value 了。 //set 集合 set\u003cint\u003e a; set\u003cint\u003e::iterator it; it = a.lower_bound(value); ","date":"2018-06-14","objectID":"/posts/c-with-stl/:6:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"7.next_permutation （排列） bool next_permutation( iterator start, iterator end ); 通常用于生成序列的全排列。用之前先保证有序； int a[]={1,2,3}; do{ for(int i=0;i\u003c3;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; cout\u003c\u003cendl; }while(next_permutation(a,a+3)); 结果为： 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 string str=\"STL\"; sort(str.begin(), str.end()); do{ cout \u003c\u003c str \u003c\u003c endl; }while (next_permutation(str.begin(),str.end()))； 结果： LST LTS SLT STL TLS TSL 大数据 c 比 c++效率高 int length; char str[MAX]; gets(str); length = strlen(str); sort(str, str + length); do{ puts(str); }while(next_permutation(str, str+length))； ","date":"2018-06-14","objectID":"/posts/c-with-stl/:7:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"8.unique （去重） 如何把序列 a 中的重复元素去除呢？首先需要对原序列 a 进行排序，保证有序后，调用 unique(a.head , a.tail ) 就可以了。unique 会返回一个类似指针的东西（和 lower_bound 有点像），-a 后表示去重之后序列的长度。 下面是实例。 int a[]={1,3,5,7,9,2,2,2,1,1,1}; sort(a,a+11); int len = unique(a,a+11)-a; for(int i=0;i\u003clen;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; 输出结果为：1 2 3 5 7 9 传送门 ","date":"2018-06-14","objectID":"/posts/c-with-stl/:8:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["Grocery"],"content":"1. \u0026运算 \u0026运算通常用于二进制取位操作，例如一个数 \u0026 1 的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为 0 表示该数为偶数，最末位为 1 表示该数为奇数。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["Grocery"],"content":"2. |运算 |运算通常用于二进制特定位上的无条件赋值，例如一个数 or 1 的结果就是把二进制最末位强行变成 1。如果需要把二进制最末位变成 0，对这个数| 1 之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["Grocery"],"content":"3. ^运算 ^运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：异或 0 都不变，异或 1 则取反。 ^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 a ^ b ^ b = a。^运算可以用于简单的加密，比如你想对你 MM 说 1314520，但怕别人知道，于是双方约定拿你的生日 19880516 作为密钥。1314520^19880516 = 20665500，你就把 20665500 告诉 MM。MM 再次计算 20665500 ^ 19880516 的值，得到 1314520，于是她就明白了你的企图。 还可以用异或来进行快速地交换数据， a=2;b=3;//先转化成二进制 a=a^b; b=a^b; a=a^b; 操作后 a=3;b=2; ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["Grocery"],"content":"4. ~ 运算 ~运算的定义是把内存中的 0 和 1 全部取反。使用~运算时要格外小心，你需要注意整数类型有没有符号。如果~的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000 到$FFFF 依次表示的。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:4:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["Grocery"],"content":"5. «运算 a « b 就表示把 a 转为二进制后左移 b 位（在后面添 b 个 0）。例如 100 的二进制为 1100100，而 110010000 转成十进制是 400，那么 100 «2 = 400。可以看出，a « b 的值实际上就是 a 乘以 2 的 b 次方，因为在二进制数后添一个 0 就相当于该数乘以 2。 通常认为 a « 1 比 a * 2 更快，因为前者是更底层一些的操作。因此程序中乘以 2 的操作请尽量用左移一位来代替。 定义一些常量可能会用到«运算。你可以方便地用 1 «16 – 1 来表示 65535。很多算法和数据结构要求数据规模必须是 2 的幂，此时可以用«来定义 Max_N 等常量。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:5:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["Grocery"],"content":"6. »运算 和«相似，a » b 表示二进制右移 b 位（去掉末 b 位），相当于 a 除以 2 的 b 次方（取整）。我们也经常用» 1 来代替 div 2，比如二分查找、堆的插入操作等等。想办法用»代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以 2 操作来代替慢得出奇的 mod 运算，效率可以提高 60% 传送门 原文：http://www.matrix67.com/blog/archives/263 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:6:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["Memo"],"content":" 2021/10/1 更新 使用 Chrome 等浏览器管理书签是更好更方便的方式，登陆 google 账号，或者导出 html 书签文件都挺方便。 我们在平时学习生活总会遇到很多很多有用的网站，也许我们收藏在了浏览器书签里，可过久了，不做说明，这些链接的价值就被时间淹没了，我们自己都记不起来了，所以这篇文章因此而生。对自己收藏的链接做些简单的说明（第一次编写用了我一个下午）；也相当于我的链接收藏夹，分享一些有趣的网站， ","date":"2018-06-07","objectID":"/posts/links/:0:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["Memo"],"content":"ACM 相关 链接 描述 各大 OJ 题目分类 各种算法分类，对应 OJ 题号超链接 ACM 题目分类 codeforces 俄国 CF 在线编程，一般比赛在晚上 9:30 和 11：00 牛客网 国内求职学习网，有很多程序设计比赛 vjudge 这个不用说了吧 hihocoder 打得少，感觉好多数据结构的题 百练 OpenJudge 的一个小组，很多题目来自 POJ；也是我 ACM 启蒙地 HDUOJ 杭州电子科技大学 OJ POJ 北京大学 OJ 洛谷 lintcode 领扣（国外） leedcode 力扣 codewar 国外 更多 OJ，在线刷题网站 … ","date":"2018-06-07","objectID":"/posts/links/:1:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["Memo"],"content":"编程，学习 链接 描述 visualgo 算法学习，数据结构和算法动态可视化 c,c++学习 很详细的知识讲解 Tomcat 下载 Tomcat 各版本下载，Tomcat 解压即安装；\\bin下可以启动和关闭服务器；可手动在\\webapps里创建 web 应用，也可以配合Eclisp IDE for Java EE Developers等 Java IDE 工具创建 w3school 可在线测试，Web 技术教程，HTML, 浏览器脚本，服务器脚本，xml 教程等 w3cschool 和上面不同哦，是不是和上面的很像哈哈哈！我估计是上一个网站的新版，功能更强大，内容更丰富，还有微信小程序教程等 菜鸟教程 和上面两个差不多，还有一些数据库、安卓的东西，git 学习 python 学习 Python 库安装包下载，python,Django,HTML,ACM 学习 python123 Python123 是专注于为中国高等院校教学 Python 语言的而开发的一款学习工具网站 python 学习 pypi Find, install and publish Python packages with the Python Package Index 优矿 python 在线测试，笔记 阮一峰的网络日志 开发者手册，JavaScript 等等 廖雪峰 git,python,javascript 学习 新晴网 PS 学习，摄影教程等 实验楼 在线做实验，高效学编程 慕课网 在线学习，免费，付费视频 wxpy 一个 python 关于微信的库 So1n python 学习 ","date":"2018-06-07","objectID":"/posts/links/:2:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["Memo"],"content":"云服务及站长工具 链接 描述 腾讯云 dnspod 解析新版入口，腾讯云控制台 dnspod 解析 域名解析，其他：阿里云等 cloudflare 解析 域名解析，https 解析，[介绍](https://oliverqueen.cn/2018/01/25/可能是最全的使用 HEXO 搭建个人博客教程) cloud studio 这是腾讯云和 coding 合作后的一个东西，简单来说就是云端开发环境。试了一下完全可以把 hexo 博客源码挂上面编辑。这也就不用只局限于一台电脑发布博客了。 腾讯云大学开放实验室 可以在线进行一些云服务应用搭建等的实验。与之对应的还有阿里云开放实验室 宝塔面板 宝塔面板是一款使用方便、功能强大且终身免费的服务器管理软件，支持 Linux 与 Windows 系统。一键配置：LAMP/LNMP、网站、数据库、FTP、SSL，通过 Web 端轻松管理服务器。 leancloud 一站式后端云服务 daovoice 网站在线客服 百度网站收录 网站 seo Bing 站长 Bing 网站管理员工具 站长工具 网站信息查询，权重，seo，网站速度查询，ping 等 站长工具大全 各种 seo 优化，工具等 ","date":"2018-06-07","objectID":"/posts/links/:3:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["Memo"],"content":"前端工具 链接 描述 全栈开发者 顾名思义，有很多 web 开发的教程，也可以在线执行代码 JSFuck JSFuck 是一种基于 JavaScript 原子部分的深奥教育编程风格。它只使用六个不同的字符来编写和执行代码。（代码极丑化） BootCDN 稳定、快速、免费的前端开源项目 CDN 加速服务，共收录了 3441 个前端开源项目。比如vue,fancybox等 bootstrap 中文网 简洁、直观、强悍的前端开发框架，让 web 开发更迅速、简单。还有一些基于 bootstrap 开发或扩充的项目的 cdn，BootCDN也是在该网站旗下 Font Awesome 图标库 hexo 指定图标库 iconfont 阿里巴巴矢量图标库 easyicon 图标库 图标下载，格式转换，可外链 semantic-ui.com 图标库 semantic-ui.com 还有很多前端样式对应代码 colorhunt 配色方案推荐，调试 grabient 渐变色 渐变色调色 gradient 渐变色调色 渐变色调色，获取代码 encycolorpedia encycolorpedia 取色器 优酷视频上传 获取视频外链，其他：腾讯视频 sm.ms 非常好用的图床 imgURL 一个开源的图床，很不错，有兴趣的可以自己尝试搭建，比如 img.lruihao.cn 现实君外链 支持多种文件外链，唯一不好的是 http PEXELS 美图 文章配图，无版权美图网，避免配图侵权 unsplash 美图 API 还可以获取 随机图 图标工厂 移动应用图标生成工具，一键生成所有尺寸的应用图标 emoji 在线复制 Simple emoji copy and paste HTML 字符实体 网页特殊符号大全 特效字转换工具集 各种特效字转换工具，彩虹字生成器，RGB 转 16 进制颜色等 压缩图 在线 ps，图片去底，证件照换底等操作很方便的 web 图片处理工具 改图宝 在线改图压缩，加水印，生成二维码，印章制作等 GIF 之家 一个压缩效果很好且免费的 gif 压缩工具 二维码解码器 草料二维码 https://cli.im 联图二维码 第九工厂 死磕艺术二维码 模板码 动态二维码等 ","date":"2018-06-07","objectID":"/posts/links/:4:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["Memo"],"content":"实用工具 链接 描述 Gearn Git Branching 通过游戏闯关的方式学习 git！ PicGo 一个很好的开源的图床管理桌面程序，图床神器支持微博图床、七牛图床、腾讯云 COS、又拍云、GitHub 图床、阿里云 OSS、Imgur 图床等等 Proxyee Down 百度云下载解决方案，满速下载，但不限于百度云的下载，感觉比迅雷还好用！ PanDownload 这是 pandownload 网页版，把需要下载的百度网盘链接baidu改成baiduwp即可加速，也有桌面版。 ubuntu pastebin 代码展示托管，生成分享网址，防止代码直接分享缩进消失 图片转字符工具 Img–\u003eString everyfont 中文字库在线压缩 字蛛 font-spider 中文字库压缩 mdtr2pdf markdown 转 pdf AD’s API 包括动态签名，网易音乐等 在线工具 w3cschool 的在线工具集合 在线工具 开源中国社区 菜鸟工具 菜鸟教程 在线工具，编译，加密，压缩代码等 msdn windows 系统上 office 等软件下载（备用） 老殁科技 Adobe 等各种绿色破解软件 百度接口 百度搜索关键词接口 在线短信 不想泄露个人的电话号码，注册一些一次性网站可以用到 配音阁 文字转换语音/语音合成广告叫卖录音在线配音网络软件_促销宣传片配音-配音阁-配音阁，国内专业的广告配音平台 hacknical 在线个性简历，个人 Github 总结分析 ","date":"2018-06-07","objectID":"/posts/links/:5:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["Memo"],"content":"其他 链接 描述 俄罗斯方块 这是一个开源的游戏，小白的我看来简直牛逼爆了，好逼真，刷新都不会打断游戏进度！！ 网址迷宫 nazo_game 一个程序员的网页游戏，我只玩到 12 关。 无损音乐下载 手写体制作 北京大学计算机科学技术研究所的一个项目59.108.48.27 （我的字体至今还未完成） 大象代理 收费，口碑不错 蒲公英 应用内测发布平台 ","date":"2018-06-07","objectID":"/posts/links/:6:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["Memo"],"content":"博客文章 文章 概括 Web 笔记 记录一下自己 web 相关学习的笔记 Git 常用指令汇总 可能用到按需自查 hexo 插件及 next 内置样式集 让文章写的好看又简洁又好用的插件！hexo 更多请看分类 hexo-theme-next @modified LRH 对 next 主题的 DIY 设计记录日志 一款自己写的字体 - 沐目体 沐目体–release ","date":"2018-06-07","objectID":"/posts/links/:7:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["随笔"],"content":"从此故乡只有冬夏，再无春秋。","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/","tags":["随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["随笔"],"content":" 从此故乡只有冬夏，再无春秋。 时间急促得仿佛还在昨天，还没有清楚地认识到这句话的其中含义时，我早已离开它，远去。 自此，一江绿水东去，桃花竞开，春洒满园；瑟瑟秋风里，稻谷黄时，落木萧萧；故乡的春秋成为回忆尘封在我的脑海深处。 三月，这里和故乡一样雨下得缠绵，却尽带着他乡的味道。在不是滋润自己的那方水土上，哪怕是喜雨之人，亦只有料峭的寒意。雨下到这里才懂得，为何古来才子佳人逢阴雨连绵天总是带着一股莫名的惆怅。原是这般由头！我与他们，并无二般，想起故乡来。 故乡的春是在牛耕上的。太爷说，老牛伏在岸边饮水时节就是春耕了。到那时，耕牛头角披红挂彩，鼻挂铜色大铃，以祈愿今年平安，田地丰收；当耕牛喘着鼻息，缓缓地哞哞叫着走下田，是其在田地里大展身手的机会。故而，二月春耕总是会见到红布条装扮的水牛在田间劳作，彩带飘逸，好生招摇，尤其是农夫哼起那极具故乡气息的耕牛民歌，如高山流水般，伴着清脆的铜铃声隐隐飘去……在春末，三月桃花尽开，漫山望去，粉红红一片，甚是好看。小时看到总以为身处仙山，而后来，陶渊明一篇《桃花源记》就以为自己是那秦时避乱而住在桃花源中的后人。每每与外人谈起家乡的桃花山时，必然是一副神气十足的傲气样子。我想，这也是自己不知不觉中受家人影响，又倾心桃花的缘故吧。 印象中，家里人都爱这漫山遍野的桃花。太爷爱赏花，山上桃花开得极好的时候，便移栽了数株桃花留在了院子里，天好天坏，都能观赏上好一会儿。太婆还在的时候，桃花次第开，她就会拾掇许多桃花下来做成桃花糕，那桃花糕香香糯糯的味道飘散四周，总能把我馋来。后来，太婆故去，奶奶学着太婆开始做起了桃花糕，却总是没有太婆做的如意。但奶奶的桃花酒，受到父辈们的一致好评。每当酒坛从土里挖出，揭开红布，酒气便带着桃花的香甜扑鼻而来。父辈们在太爷种的桃花树下把酒话桑麻，颇有一副桃花坞里桃花庵，桃花庵里桃花仙的样子。现如今记忆远去，酒香却长留下来，记起时，那酒酣甜得喜人。 故乡的秋从九月农收渐起，那时候一家老小在浓浓的秋意里忙忙碌碌，直至十月方才得些许闲暇日子。 稻谷黄时，是秋最盛的时候。父辈们清晨便出发去地里收稻谷。晌午，我兴起与祖母前去送饭。正午的太阳烈得很，父辈们大颗大颗的汗直往下掉，稻谷机嘈杂得很。这才想起太爷教我的诗，“妇姑荷箪食，童稚携壶浆”，就是这样的情景无差。那时候不懂得父辈的辛苦，只知奔入山间，捕捉蚱蜢，蛐蛐等趣物。等傍晚将近，坐在板车谷袋上，兴尽而回，一天就算结束。渐渐长大，再也不敢胡闹，不知是童趣少了还是知了人事愈发迷惘了？ 窗外又下起雨，心里竟也惆怅起来。并非是洗过的衣服久晾未干，而是伴着那股湿意而来，藏在雨里的那点点乡愁。这边的桃花也开得好，往窗外，密密一片，不免想起了太爷书房里的书画：花是春时花，却非故乡花。人是故乡人，却是他乡客。所见时，不过是从戏子变成看客了罢。 ","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/:0:0","tags":["随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["Memo"],"content":"更多关于 hexo ","date":"2018-06-01","objectID":"/posts/hexobuild/:0:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"首先 官方文档 是我们的第一手资料，也是最好的。 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git ","date":"2018-06-01","objectID":"/posts/hexobuild/:1:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"hexo 安装 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 npm install -g hexo-cli ","date":"2018-06-01","objectID":"/posts/hexobuild/:2:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 hexo init \u003cfolder\u003e cd \u003cfolder\u003e npm install 为一个文件夹的名字 新建完成后，指定文件夹的目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes ","date":"2018-06-01","objectID":"/posts/hexobuild/:3:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"安装 hexo 插件 全装上吧，没事。 npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked@0.2 --save npm install hexo-renderer-stylus@0.2 --save npm install hexo-generator-feed@1 --save npm install hexo-generator-sitemap@1 --save ","date":"2018-06-01","objectID":"/posts/hexobuild/:4:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"本地查看效果 执行下面语句，执行完再登录 localhost:4000 查看效果（执行完不要按 Ctrl+C，不然就停止了） hexo g hexo s 其他步骤在这里不赘述，参见 超详细教程 安卓上搭建 hexo 博客 ","date":"2018-06-01","objectID":"/posts/hexobuild/:5:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"部署 hexo g -d 部署后我们可以浏览器搜 username.github.io 查看自己的博客效果，比如我的 lruihao.github.io ","date":"2018-06-01","objectID":"/posts/hexobuild/:6:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"美化 这些美化都写的很详细，我建议你们自己好好看看吧，我也是在这里看到的，如果问我和这里说的是一样的。 hexo 个性化教程 valine 特别鸣谢赵俊 👍 asdfv1929 hexo 官方主题集合，我用的是 aloha 主题，该主题 官方文档，后改用 next 主题 next 主题 hexo 官方插件 说说我的主题遇到的一些问题，由于这个主题用的人少，所以作者优化的不是很好（next 使用最多），当然也可以反过来说，所以自己美化了一点 ","date":"2018-06-01","objectID":"/posts/hexobuild/:7:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"博文置顶 修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 'use strict'; var pagination = require('hexo-pagination'); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top \u0026\u0026 b.top) { // 两篇文章 top 都有定义 if(a.top == b.top) return b.date - a.date; // 若 top 值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照 top 值降序排 } else if(a.top \u0026\u0026 !b.top) { // 以下是只有一篇文章 top 有定义，那么将有 top 的排在前面（这里用异或操作居然不行 233） return -1; } else if(!a.top \u0026\u0026 b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } }); }; ","date":"2018-06-01","objectID":"/posts/hexobuild/:7:1","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"about 页面 about 页面可以用 HTML 写，你想怎么写都行，我用的最简单的方法，直接hexo n page \"about\"后，会生成一个 md 文件，也就是后面说的文章，直接写文章就行了。 ","date":"2018-06-01","objectID":"/posts/hexobuild/:7:2","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"添加搜索，评论，分享 搜索功能真心好用，当文章多起来的时候，标签提供的作用已经很少了，只能简单索引，搜索却能精确查找，这里我用的依旧是最简单的本地站内搜索。 安装hexo-generator-searchdb 在站点的根目录下执行以下命令： npm install hexo-generator-searchdb --save 配置站点配置文件 新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 配置主题配置文件 ## Local search local_search: enable: true algolia 参考文件 让搜索引擎找到你的博客，还是看到邱承佳学长博文有写到 传送门 ","date":"2018-06-01","objectID":"/posts/hexobuild/:7:3","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"添加访客数，阅读量等 评论有多说（多说好像挂了），计数有不蒜，我用的不蒜子，还有其他的。 文章阅读量 以下适合非 next 主题的部分主题，next 主题已经自带，到主题配置文件修改就好了。 打开以下路径在你喜欢的地方添加代码，\\blog\\hexo\\themes\\主题名字、layout\\_partial，找到 article.ejs文件 \u003cdiv align=\"left\"\u003e \u003cspan id=\"busuanzi_container_page_pv\"\u003e 本文总阅读量\u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e \u003c/div\u003e 站点访问量，访客数 打开以下路径在你喜欢的地方添加代码，\\blog\\hexo\\themes\\主题名字、layout\\_partial，找到 footer.ejs文件 \u003cscript src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\" async defer\u003e\u003c/script\u003e \u003cspan id=\"busuanzi_container_page_pv\"\u003e 本站总访问量\u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e次 | \u003c/span\u003e \u003cspan id=\"busuanzi_container_site_uv\"\u003e 本站访客数\u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e人次 \u003c/span\u003e 2018.10.08 更新 不蒜子官网说七牛强制过期域名dn-lbstatics.qbox.me, 所以 js 文件位置发生改变，改为busuanzi.ibruce.info ","date":"2018-06-01","objectID":"/posts/hexobuild/:7:4","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":"写文章 hexo 文章用轻量型标签语言 Markdown 编写 markdown 入门 繁体原始文件 繁体原始文件 github ","date":"2018-06-01","objectID":"/posts/hexobuild/:8:0","tags":["Node.js","hexo"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":" 如果实在搞得头晕直接去 简书 写文章，再把简书生成的 md 文章复制过来就好了（简书是个不错的 Markdown 在线编辑器），还可以去 马克飞象，专为印象笔记打造的 Markdown 编辑器，typora 也是不错的，突然发现 csdn 也支持 Markdown 编译器了 ","date":"2018-05-31","objectID":"/posts/hexowrite/:0:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"1. 首先 刚刚搭博客，很多都不懂，就连插入图片的路径问题都把我整的要命。（我用的 Sublime Text 3 编译器） 下面讲讲： ","date":"2018-05-31","objectID":"/posts/hexowrite/:1:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"1.1 设置站点配置_config.yml post_asset_folder: true ","date":"2018-05-31","objectID":"/posts/hexowrite/:1:1","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"1.2 安装插件 npm install https://github.com/CodeFalling/hexo-asset-image -- save ","date":"2018-05-31","objectID":"/posts/hexowrite/:1:2","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"1.3 下次再运行 hexo n “xxxx\"来生成 md 博文时，下路径 /source/_posts 文件夹内除了 xxxx.md 文件还有一个同名的文件夹，在 xxxx.md 中想引入图片时，先把图片复制到 xxxx 这个文件夹中，然后只需要在 xxxx.md 中按照 markdown 的格式引入图片。 ","date":"2018-05-31","objectID":"/posts/hexowrite/:1:3","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"2. 添加图片 首先大家可以查看 hexo 官方文档 资源文件夹章节 ","date":"2018-05-31","objectID":"/posts/hexowrite/:2:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"2.1 markdown 添加 相对路径添加（我被这个相对路径搞得要死，前面各种出错，大家可以对照我的来插入图片 …） #直接写图片名就好了，图片实例见下 ![kyrie irving](294136.jpg) #如果改了 Permalink 就要加上文章名，即同名文件夹名 ![kyrie irving](hexo-添加图片，音乐，链接，视频/294136.jpg) #代码压缩后前面还要加一个/ ![kyrie irving](/hexo-添加图片，音乐，链接，视频/294136.jpg) ","date":"2018-05-31","objectID":"/posts/hexowrite/:2:1","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"2.2 插件添加 传送门 这种方式被很多人诟病，但有时候也不失一种好方式，简单快捷。 还有图片名字显示，不错的。 {% asset_img 297787.jpg kyrie irving %} ","date":"2018-05-31","objectID":"/posts/hexowrite/:2:2","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"3. 音乐 大家可以看 网易云音乐 的官网，播放音乐可以生成外链，直接拿来用就行了。iframe 插件可以在代码中设置宽高等参数，auto 为自动播放。flash 不可以自己设置参数。看喜好，随便你。 其他音乐，把插件中的链接替换成要播放的链接就可以了 #iframe 插件 \u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2\u0026id=66651\u0026auto=0\u0026height=66\"\u003e \u003c/iframe\u003e #flash 插件 \u003cembed src=\"//music.163.com/style/swf/widget.swf?sid=40249713\u0026type=2\u0026auto=0\u0026width=320\u0026height=66\" width=\"340\" height=\"86\" allowNetworking=\"all\"\u003e \u003c/embed\u003e ","date":"2018-05-31","objectID":"/posts/hexowrite/:3:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"4. 添加链接 [我的微博](https://weibo.com/liahao) {% link text url title %} ","date":"2018-05-31","objectID":"/posts/hexowrite/:4:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"5. 添加视频 视频链接最好是打开就是视频的链接（youku，YouTube，抖音等） 可以把视频上传到优酷，抖音等生成外链再拿来用。（优酷上传需要注册和实名认证） 插件参考资料 自拍手写视频（优酷） 实验室无聊拍的 \u003ciframe height=500 width=100% src=\"https://player.youku.com/embed/XMzY0MzgxNDMyOA==\" frameborder=0 allowfullscreen\u003e \u003c/iframe\u003e ","date":"2018-05-31","objectID":"/posts/hexowrite/:5:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["Memo"],"content":"工具集合 Picgo 马克飞象、CSDN、简书 SM.MS 图床 ","date":"2018-05-31","objectID":"/posts/hexowrite/:6:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["随笔"],"content":" “每天早晨叫醒你的不是鬧鐘，而是你的夢想。” 我有過靠著這種信念撐下來的日子，我見過自己努力的樣子，至於現在的自己配不配得上當初努力的自己， 其實也不重要了，還望披荊斬棘，不改初心。 不怕萬人阻擋，只怕自己投降。你如何回憶，決定你是一個怎樣的人！ 從大一伊始，打 ACM 比賽，訓練刷題，再到毅然決然離開實驗室，選擇陌生的 Web 開發，從工作前的一無所知到，到前端開發，後端開發，到教實習生，到面試新人，到開始乏味。這一路走來，好奇心，探索欲，瞎擇騰，或許還有愛意，都是支撐我的動力。 時間並不會因為你的迷茫和遲疑而停留，就像你在看到這篇博客的時候，不知道有多少人正風雨兼程趕赴夢想。沒有誰生來就是神牛，千裏之行，始於足下！比自己優秀的人有很多，永遠不要感動自己，保持謙遜，沉澱自己，感謝每一個曾經努力的自己。不必執著於過去，也不必過度擔憂未來，望披荊斬棘，不忘初心。 最開始寫博客，是在打 ACM 的時候，深受一個學長的博客影響，他的博客是 hexo 搭建的，ID 是 [戎碼一生]，所以我也照葫蘆畫瓢用 hexo 搭建了一個，一用就是 3 年，博客名字原 “博採眾長” 改为 “菠菜眾長”，因為不能用成語作為網站名字，就這個原因。 直到 21 年下半年，升級 windows 11, 系統出了 BUG, 整理磁盤不小心把代碼刪掉了，就乾脆換成 hugo 了。 現在並沒有刀槍入庫，馬放南山，衹是在奔赴另一片山海 ","date":"2018-05-28","objectID":"/posts/hello-world/:0:0","tags":["随笔"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":null,"content":"离线 - 菠菜眾長","date":"0001-01-01","objectID":"/offline/","tags":null,"title":"","uri":"/offline/"}]