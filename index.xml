<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>yejian's blog</title><link>https://jianye0428.github.io/</link><description>Lruihao's Note 李瑞豪的博客：探索、分享、记录自己在工作生活学习到一些东西。人知道得越多，就就会发现无知的越多。有更广袤世界可以探索，真是莫大的快乐啊！</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>18817571704@163.com (Jian YE)</managingEditor><webMaster>18817571704@163.com (Jian YE)</webMaster><lastBuildDate>Sun, 03 Sep 2023 19:31:13 +0800</lastBuildDate><atom:link href="https://jianye0428.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>BEVFormer 论文解读</title><link>https://jianye0428.github.io/posts/bevformer/</link><pubDate>Sun, 03 Sep 2023 19:31:13 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/bevformer/</guid><description><![CDATA[<h2 id="1-背景motivation">1. 背景/Motivation</h2>
<h3 id="11-为什么视觉感知要用bev">1.1 为什么视觉感知要用BEV？</h3>
<p>相机图像描述的是一个2D像素世界，然而自动驾驶中利用相机感知结果的后续决策、路径规划都是在车辆所处的3D世界下进行。由此引入的2D和3D维度不匹配，就导致基于相机感知结果直接进行自动驾驶变得异常困难。</p>
<p>这种感知和决策规划的空间维度不匹配的矛盾，也体现在学开车的新手上。倒车泊车时，新手通过后视镜观察车辆周围，很难直观地构建车子与周围障碍物的空间联系，容易导致误操作剐蹭或需要尝试多次才能泊车成功，本质上还是新手从2D图像到3D空间的转换能力较弱。基于相机图像平面感知结果进行决策规划的自动驾驶AI，就好比缺乏空间理解力的驾驶新手，很难把车开好。</p>
<p>实际上，利用感知结果进行决策和路径规划，问题还出现在多视角融合过程中：在每个相机上进行目标检测，然后对目标进行跨相机融合。如2021 TESLA AI Day给出的图1，带拖挂的卡车分布在多个相机感知野内，在这种场景下试图通过目标检测和融合来真实地描述卡车在真实世界中的姿态，存在非常大的挑战。</p>
<p></p>
<p>为了解决这些问题，很多公司采用硬件补充深度感知能力，如引入毫米波雷达或激光雷达与相机结合，辅助相机把图像平面感知结果转换到自车所在的3D世界，描述这个3D世界的专业术语叫做BEV map或BEV features(鸟瞰图或鸟瞰图特征)，如果忽略高度信息，就把拍扁后的自车坐标系叫做BEV坐标系(即鸟瞰俯视图坐标系)。</p>
<p>但另外一些公司则坚持不引入深度感知传感器，他们尝试从本质入手，基于视觉学习得到从图像理解空间的能力，让自动驾驶AI系统更像老司机，例如TESLA。Elon Musk认为：人类不是超人，也不是蝙蝠侠，不能够眼放激光，也没安装雷达，但是通过眼睛捕捉到的图像，人类反复练习就可以构建出对周围世界的3D空间理解能力从而很好地掌握驾驶这项能力，那么要像人一样单纯利用眼睛(相机)进行自动驾驶就必须<font color=red>具备从2D图像平面到3D自车空间(BEV)的转换能力</font>。</p>
<p>传统获取BEV map/features的方法有局限性，它一般是利用相机外参以及地面平面假设，即IPM(Inverse Perspective Mapping)方法，将图像平面的感知结果反投影到自车BEV坐标系。Tesla以前的方案也是这样，然而当车辆周围地面不满足平面假设，且多相机视野关联受到各种复杂环境影响的时候，这类方法就难以应付。</p>
<p>针对IPM方法获取BEV遇到的困难，TESLA自动驾驶感知负责人Andrej Karparthy的团队<font color=red><strong>直接在神经网络中完成图像平面到BEV的空间变换</strong></font>，这一改变成为了2020年10月发布的FSD Beta与之前Autopilot产品最显著的差别。TESLA利用Transformer生成BEV Featrues，得到的Features通道数是256(IPM方法最多保留RGB3个channel)，这样能极大程度地保留图像信息，用于后续基于BEV Features的各种任务，如动、静态目标检测和线检测等。</p>
<h3 id="12-生成bev视角的方法有哪些为何选用transformer呢">1.2 生成BEV视角的方法有哪些？为何选用Transformer呢？</h3>
<p><strong>把相机2D平面图像转换成BEV视角的方法有两种：<u>视觉几何方法</u>和<u>神经网络方法</u>。</strong></p>
<p><strong>视觉几何方法</strong>：基于IPM进行逐像素几何投影转换为BEV视角，再对多个视角的部分BEV图拼接形成完整BEV图。此方法有两个假设：1.路面与世界坐标系平行，2.车辆自身的坐标系与世界坐标系平行。前者在路面非平坦的情况下并不满足，后者依赖车辆姿态参数(Pitch和Roll)实时校正，且精度要求较高，不易实现。</p>
<p><strong>神经网络方法</strong>：用神经网络生成BEV，其中的关键要找到合适的方法实现神经网络内部Feature Map空间尺寸上的变换。</p>
<p>实现空间尺寸变换的神经网络主流操作有两种方法，如图2所示：MLP中的Fully Connected Layer和Transformer Cross Attention(图片引用自<a href="https://zhuanlan.zhihu.com/p/458076977"target="_blank" rel="external nofollow noopener noreferrer">《超长延迟的特斯拉AI Day解析：讲明白FSD车端感知》<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>)</p>
<p></p>
<p><strong>MLP Fully Connected Layer方法：</strong></p>
<p>$$O=Act(W_{mlp}*X+b)$$</p>
<p>忽略非线性激活函数和bias后，可以写成：</p>
<p>$$O=W_{mlp}*X$$</p>
<p><strong>Transformer Cross Attention方法:</strong></p>
<p>$$O=Softmax(Q*K^T)*V$$</p>
<p>其中，K和V是输入图像特征X经线性变换后得到的；在最终输出的BEV视角下，把自车周围空间中的索引量称作 $\boldsymbol{\Phi}$</p>
<p>$$O=Softmax(\Phi W_q*(XW_K)^T)*XW_V=W_{transformer}(X,\Phi)*XW_V$$</p>
<p>BEV变换的本质是利用两个操作中的任意一个，将输入的2D图像空间特征图转换成BEV特征图。在进行BEV转换之前，先通过多层CNN在图像上提取特征，得到图像空间特征图层尺寸($h * w$)，即X的尺寸。 BEV变换输出O所在的BEV空间尺寸，是以自车位置为原点的前后左右各若干米范围内建立的栅格空间(x * y)。</p>
<p>MLP Fully Connect Layer和Cross Attention的显著差别在于作用于输入量X的系数W：**全联接层的W，一旦训练结束后在Inference阶段是固定不变的；而Cross Attention的Transformer的系数W，是输入量X和索引量
的函数，在Inference阶段会根据输入量X和索引量的不同发生改变。从这个角度来讲，使用Cross Attention来进行空间变换可能使模型获得更强的表达能力。</p>
<p>TESLA在2021年AI Day上仅介绍了用Transformer转换BEV Features的技术思想，并未披露更多实现细节。论文BEVFormer充分研究了TESLA的技术思想后，利用Transformer融合图像的时、空特征，得到BEV Features，与TESLA的关键方法、实现效果都非常接近。BEVFormer既通过论文披露了详尽方法，又在2022年6月开源了工程，接下来就围绕BEVFormer介绍如何通过Transformer获取BEV Features。</p>
<h2 id="2-methodstrategybevformer">2. Method/Strategy——BEVFormer</h2>
<h3 id="21-overall-architecture">2.1 Overall Architecture</h3>
<p>如下图3所示：BEVFormer主体部分有6层结构相同的BEVFormer encoder layers，每一层都是由以transformer为核心的modules(TSA+SCA)，再加上FF、Add和Norm组成。BEVFormer encoder layer结构中有3个特别的设计：BEV Queries， Spatial Cross-attention(SCA)和Temporal Self-attention(TSA)。其中BEV Queries是栅格形可学习参数，承载着通过attention机制在multi-camera views中查询、聚合的features。SCA和TSA是以BEV Queries作为输入的注意力层，负责实施查询、聚合空间features(来自multi-camera images)和时间features(来自历史BEV)的过程。</p>
<p>下面分步骤观察BEV完整模型的前向推理过程：</p>
<ul>
<li>在t时刻，输入车上多个视角相机的图像到backbone，输出各图像的多尺度特征(multi-scale features)： $F_t={\left.F_t^i\right.}<em>{i=1}^{N</em>{view}}$
，其中 $F_{t}^{i}$ 是第i个视角相机的feature，$N_{view}$ 是多个相机视角的总数。同时，还要保留t-1时刻的BEV Features ${\boldsymbol{B}}_{t-1}$。</li>
<li>在每个BEVFormer Encoder layer中，首先用BEV Queries Q通过TSA模块从 ${\boldsymbol{B}}_{t-1}$ 中查询并融合时域信息(the temporal information)，得到修正后的BEV Queries $Q^{\prime}$；</li>
<li>然后在同一个BEVFormer Encoder layer中，对TSA“修证”过的BEV Queries $Q^{\prime}$ ，通过SCA模块从multi-camera features $F_{t}$ 查询并融合空域信息(spatial information)，得到进一步修正的BEV Queries $Q^{^{\prime\prime}}$ 。</li>
<li>这一层encoder layer把经过两次修正的BEV features $Q^{^{\prime\prime}}$ (也可以叫做BEV Queries)进行FF计算，然后输出，作为下一个encoder layer的输入。</li>
<li>如此堆叠6层，即经过6轮微调，t时刻的统一BEV features $B_{t}$ 就生成了。
最后，以BEV Features $B_{t}$ 作为输入，3D detection head和map segmentation head预测感知结果，例如3D bounding boxes和semantic map。</li>
</ul>
<p></p>
<h3 id="22-bev-queries">2.2 BEV Queries</h3>
<p>BEVFormer采用显性定义BEV的方式，BEV Queries就是其中的显性BEV features。</p>
<p>可从3个概念循序渐进地认识/理解BEV Queries：<strong>BEV平面 → BEV 感知空间 → BEV Queries</strong>。</p>
<ul>
<li>
<p>BEV 平面
BEV平面($(R^{H\times W\times1})$)是以自车为中心的栅格化二维平面，H、W是BEV平面在x、y方向的栅格尺寸，此平面显性地与车辆周围横、纵向物理空间关联，一个栅格表示s米，论文中把BEV平面中的栅格叫做2D参考点(2D reference points)。例如论文中定义nuScenes数据集栅格尺寸200x200，对应[-51.2米, 51.2米]，那么s就是0.512米。</p>
</li>
<li>
<p>BEV 感知空间
BEV感知空间( $(R^{H\times W\times N_{ref}})$ )把BEV平面在z轴方向选取 $N_{ref}$个<strong>3D参考点</strong>进行扩展，表示车辆周围有限空间。查看BEV开源工程可知，BEV感知空间的精确表示范围：在nuScenes数据集中，是以Lidar作为中心点，前后各51.2m、左右各51.2m、向上3m、向下5m的矩形空间。
仔细深究作者这样设置的用意，会发现蛮有意思/意义：nuScenes采集车上安装的Lidar距地面高约1.84m，[-5m, 3m]的设置让BEV Queries感知空间在自车轮胎接地点平面以上部分约4.84m，接地点平面以下部分约3.16m。前者确保不仅能感知高大目标物，如货车等，还能感知覆盖坡度9.5%(4.84m/51.2m100%)上坡场景，后者保证感知覆盖坡度6.2%(3.16m/51.2m100%)下坡场景。备注：坡度=(高程差/水平距离)x100%，车辆前进100m的垂直上升/下降高度，我国规定城市道路最大纵坡8％，公路9％。</p>
</li>
<li>
<p>BEV Queries
BEV Queries是预定义的一组栅格形(grid-shaped)可学习参数，简称 $Q\in R^{H\times W\times C}$，它是对上述BEV 感知空间的特征描述，可直白地理解为学习完成了，它就变成了BEV features。
BEV Queries的H、W与BEV平面在x、y方向的栅格尺寸定义一致，因此也继承了BEV平面显性地与车辆周围横、纵向物理空间关联的特性。但C是BEV Queries作为features时在channel维度的尺寸，并不显性地对应于BEV平面z轴的物理空间尺寸。特别指出，位于 $p=(x,y)$ 处的某个query $Q_{p}\in R^{1\times C}$，表示BEV queries中的一个栅格。在输入到BEVFormer之前，BEV Queries加上了可学习的位置编码(learnable positional embedding)。
论文中多处提及BEV Queries和BEV features，它俩什么关系？本质上描述的是同一个东西么？
先说答案：两者本质上是同一个东西。模型中预定义参数BEV Queries 输入到BEV Encoder layer，输出的就是经过1次微调过的BEV features，它作为下一层的输入时，又被看作下一层的BEV Queries。经过所有layers的多次微调，最后一个layer输出的就是BEV features ${\mathit{B}}_{t}$ ，作为各类感知task heads的输入。</p>
</li>
</ul>
<h3 id="23-sca-spatial-cross-attention">2.3 SCA: Spatial cross-attention</h3>
<p>如上图(b)所示，作者设计了一种空间交叉注意力机制，使 BEV queries 从多个相机的image Features中提取所需信息并转换为BEV Features。</p>
<p>每个BEV栅格的query在image features的哪些范围提取信息呢？这里有3个方案：</p>
<p>一、从image features的所有点上提取信息，即global attention。</p>
<p>二、从BEV栅格在image features的投影点上提取信息。</p>
<p>三、从BEV栅格在image features的投影点及其周围取信息，即deformable attention。</p>
<p>由于使用了多尺度图像特征和高分辨率 BEV 特征(200x200)，如果采用方案一 global attention ，会带来无法负担的计算代价(显存和计算复杂度)。但是，方案一完全用不到相机内外参，这算是它独有的优势。</p>
<p>方案二依赖非常精确的相机内、外参，且不能充分利用image features上的局部区域信息。</p>
<p>因此作者选用了方案三，基于deformable attention 的稀疏注意力机制，使BEV Queries中的每个Query 只与其所代表世界坐标系物理空间投影到图像上的部分区域进行交互，且解除了对相机内、外参的高精度依赖。注意，这里复数BEV Queries表示整个BEV图，而单数Query表示BEV 图中位于 $(x, y)$的一个栅格。</p>
<p>$$\mathrm{SCA}(Q_p,F_t)=\frac1{|\mathcal{V}<em>\mathrm{hit}|}\sum</em>{i\in\mathcal{V}<em>\mathrm{hit}}\sum</em>{j=1}^{N_\mathrm{ref}}\mathrm{Deform}\mathrm{Attn}(Q_p,\mathcal{P}(p,i,j),F_t^i)\quad\quad\quad\quad(2)$$</p>
<p>在DeformAttn()中，$Q_{p}$、$P(p,i,j)$ 和 $F_{t}^{i}$ 分别表示query, reference points和输入特征。</p>
<p>通俗理解公式：在BEV Query对应的图像2D features 有效区域附近计算注意力，把图像2D features加权融合到BEV Query作为SCA的输出。</p>
<p>参考图(b)和上述公式2，总结Spatial cross-attention的实现方式：</p>
<ol>
<li>对于每一个位于 $(x, y)$ 位置的 BEV query $Q_{p}$ ，计算其对应真实世界的坐标 $(x^{&rsquo;},y^{&rsquo;})$。然后将 BEV query 在z方向进行 lift 操作，设置 $N_{ref}$ 个 3D参考点，即对应 $N_{ref}$ 个世界坐标系下的3D空间参考点。</li>
<li>通过相机内外参，把第j个3D参考点投影到 $v_{hit}$ 个相机图像上。受相机感知范围限制，每个3D参考点一般只在 1-2 个相机上找到有效的投影点(反过来描述，每个相机的features只与部分BEV queries构成有效投影关系)。</li>
<li>基于 Deformable Attention，把像平面上的这些投影点作为2D图像参考点，在其周围对 $F_{t}^{i}$ 进行特征采样，得到sampled features。</li>
<li>最后，对 $V_{hit}$ 、$N_{ref}$ 个sampled features进行加权求和，作为spatial cross-attention的输出来更新BEV query，从而完成 spatial 空间的特征聚合。</li>
</ol>
<p>详细介绍一下第2步中如何把3D参考点投影到相机图像上获得2D参考点：</p>
<ul>
<li>首先计算位于 $p = (x, y)$ 的query $Q_{p}$ 在以车辆为中心世界坐标 $(x^{&rsquo;},y^{&rsquo;})$
$$x^{^{\prime}}=(x-W/2)*s; \quad y^{^{\prime}}=(y-{H}/2)*s$$
其中H和W是BEV queries的尺寸，s是BEV中一个栅格所代表的物理空间尺寸;</li>
<li>计算第j个3D参考点投影到第i个相机图像上的2D参考点坐标：
$$P(p,i,j)=(x_{i,j},y_{i,j})$$
其中，
$$z_{i,j}[x_{i,j},y_{i,j},1]^T=T_i*[x^{&rsquo;},y^{&rsquo;},z^{&rsquo;},1]^T$$
$T_i$ 是第 $i$ 个相机的投影矩阵。</li>
</ul>
<h3 id="24-tsa-temporal-self-attention">2.4 TSA: Temporal self-attention</h3>
<p>从经典 RNN 网络获得启发，将 BEV 特征 $B_t$ 视为能够传递序列信息的 memory。每一时刻生成的 BEV 特征 $B_t$ 都从上一时刻的 BEV 特征  $B_{t-1}$ 获取所需的时序信息，这样能保证动态地获取所需的时序特征，而非像堆叠不同时刻 BEV 特征那样只能获取定长的时序信息。</p>
<p></p>
<p>$$\text{TSA}(Q_p,{Q,B&rsquo;<em>{t-1}})=\sum</em>{V\in{Q,B&rsquo;_{t-1}}}\text{DeformAttn}(Q_p,p,V),\quad(5)$$</p>
<p>参考图4和上述公式5，总结temporal self-attention的实现方法：</p>
<ol>
<li>给定t-1时刻的 BEV 特征 $B_{t-1}$ ，先根据 ego motion 将 $B_{t-1}$ 对齐到 $t$ 时刻，来确保 $B_{t-1}$ 和 $B_{t}$ 在相同index位置的栅格对应于现实世界的同一位置，把时间对齐后的BEV特征记作 $B_{t-1}^{&rsquo;}$ 。</li>
<li>$t$ 时刻位于 $(x, y)$ 处的 BEV query所表征的物体可能静态或者动态，它在t-1时刻会出现在 $B_{t-1}^{&rsquo;}$ 的 $(x, y)$ 周围，因此利用 deformable attention 以 $(x, y)$ 作为参考点在其周围进行特征采样。</li>
</ol>
<p>上述方法<strong>没有显式地设计遗忘门</strong>，而是通过 attention 机制中的 attention weights 来平衡历史时序特征和当前 BEV 特征的融合过程。</p>
<p><strong>关于TSA的后记</strong>：BEVFormer V2对 BEVFormer的时域融合方法TSA做了修改。</p>
<p>BEVFormer中TSA采用了继承式的时域信息融合方式：利用attention机制在t时刻融合了t-1时刻的BEV features信息，由于t-1时刻的BEV features 也融合了更早时刻(t-2)的信息，因此t时刻BEV features间接地融合了比t-1时刻更早的信息。</p>
<p>但是这种继承式时域融合方式有遗忘的特点，即不能有效利用较长时间的历史信息。</p>
<p>BEVFormer V2把时域融合改成了：根据ego motion，把过去多个时刻的BEV features 对齐到当前时刻，然后在channel 维度把这些对齐后的BEV features 与当前时刻BEV features串联，然后用Residual 模块降低channel数，就完成了时域融合。</p>
<p>综合2.3和2.4节，观察6个 BEVFormer Encoder Layers的完整结构会发现， BEV query 既能通过 spatial cross-attention 聚合空间特征，又能通过 temporal self-attention 聚合时序特征，这个过程会重复多次，让时空特征融合能够相互促进，最终得到更好的融合BEV features。</p>
<h3 id="25-application-of-bev-features">2.5 Application of BEV Features</h3>
<p>BEV Features $B_{t}\in R^{H\times W\times C}$ 是可用于多种自动驾驶感知任务的2D feature map， 基于2D 感知方法稍加改动就可在 $B_t$ 上开发3D目标检测和map segmentation任务。</p>
<p><strong>3D object detection</strong></p>
<p>参考2D 目标检测器Deformable DETR，论文设计了end-to-end的3D目标检测head，修改部分包括：用single-scale 的BEV features $B_t$ 作为检测头的输入，预测输出3D b-boxes和速度而不是2D b-boxes，仅用 $L_1$ loss监督3D b-boxes的回归。继承DETR方法的优势，预测有限数目的候选目标集合(开源工程中设为300个)，这种end-to-end的检测头不需要NMS后处理。</p>
<p><strong>map segmentation</strong></p>
<p>参考2D segmentation 方法Panoptic SegFormer，论文设计了map segmentation head。因为基于BEV的map segmentation基本上与常见语义分割相同，作者利用了参考文章[22]中的mask decoder和class-fixed queries设计head来查找每个语义类别，包括car、vehicle、road(可通行区域)和车道线。</p>
<h3 id="26-implementation-details">2.6 Implementation details</h3>
<p>训练时的实施细节:</p>
<ul>
<li>对于时间t，在过去2s中随机选取3个时刻t-3、t-2和t-1；</li>
<li>在初始3个时刻，循环生成BEV features ${B_{t-3},B_{t-2},B_{t-1}}$，且在此阶段不计算梯度；</li>
<li>计算第一个时刻t-3的temporal self-attention输出时，它并没有前序BEV features，就用它自身作为前序时刻输入，那么temporal self-attention暂时退化成了self-attention。</li>
</ul>
<p>inference时的实施细节：</p>
<p>按照时间顺序计算图像序列中的每一帧，前序时刻的BEV features被保持下来并用于后一时刻，这种online的inference策略在应用中比较高效。</p>
<h2 id="3-experiments">3. Experiments</h2>
<h3 id="31-experimental-settings">3.1 experimental settings</h3>
<ol>
<li>采用两种Backbone：ResNet101-DCN，采用来自FCOS3D训练得到的参数；VoVnet-99，采用来自DD3D训练得到的参数。</li>
<li>默认情况下，使用FPN输出的多尺度 features的尺寸包含1/16，1/32，1/64(注意，代码中实际用好的1/8尺寸的features，即nuScenes中的116*200的FPN输出)，同时把dimension C设为256。</li>
<li>在nuScenes数据集试验中，BEV queries尺寸设为200x200，对应感x和y方向的知范围都是[-51.2m, 51.2m]，对应BEV Grid尺寸精度是0.512m。</li>
<li>在Waymo数据集试验中，BEV queries尺寸设为300x220，对应感x方向的感知范围是[-35.0m, 75.0m]，y方向的知范围是[-75.0m, 75.0m]，对应BEV Grid尺寸精度是0.5m。自车中心位于 BEV的(70，150)处。</li>
<li>对每个BEV query，在 spatial cross-attention模块中，设置 $N_{ref}=4$ 个3D参考点，预定义它们对应的高度范围是-5m到3m。</li>
<li>对每个2D图像参考点(3D参考点投影到2D view上的点)，在其周围选取4个采样点送入SCA。</li>
<li>默认情况下，训练24epoches，学习率设为 $12\times10^{-4}$。</li>
<li><strong>Baselines</strong>：为了合理评估task heads的影响，公平地与其它生成BEV方法对比。选择VPN和Lift-Splat作为baselines，对它们head之前的部分替换BEVFormer，保留task heads和其它设置。
论文中，通过把temporal self-attention修改为普通的self-attention，这样就使BEVFormer变成了一个静态模型，命名为<strong>BEVFormer-S</strong>，它不使用历史BEV Features。</li>
</ol>
<h3 id="32-3d目标检测结果">3.2 3D目标检测结果</h3>
<p>BEVFormer的3D检测性能，如Table1、Table2和Table3所示，远超之前最优方法DETR3D。</p>
<p>BEVFormer引入了temporal information，因此它在估计目标速度方面效果也很好。从速度估计指标mean Average Velocity (mAVE)来看，BEVFormer误差为0.378m/s，效果远好于同类基于相机的方法，甚至逼近了基于激光的方法。</p>
<p>
</p>
<h3 id="33-multi-tasks-perception-results">3.3 multi-tasks perception results</h3>
<p>联合训练3D detection和map segmentation任务，与单独训练比较训练效果，如Table4所示：对3D目标检测和分割中的车辆类语义感知，联合训练效果有提升；对分割中的road、lane类的语义感知，联合训练效果反而会下降。</p>
<p></p>
<h3 id="34-消融试验">3.4 消融试验</h3>
<p>Spatial Cross-attention有效性</p>
<p>为了验证SCA的有效性，利用不包含TSA的BEVFormer-S来设计消融试验，结果如Table5所示。</p>
<p>默认的SCA基于deformable attention，在对比试验中构建了基于2种不同attention机制的baselines：1. 用global attention取代deformable attention；2. 让每个query仅与它的图像参考点交互，而不是像SCA那样query与图像参考点周围区域交互。为了扩大对比范围，把BEVFormer中的BEV生成方法替换为了VPN和Lift-Spalt中的方法。从Table5结果可见Deformable Attention方法显著优于其它方法，且在GPU Memory使用量和query兴趣区域大小之间实现了balance。</p>
<p></p>
<p><strong>Temporal Self-attention有效性</strong></p>
<p>从Table1和Table4可见，在相同的设置下，BEVFormer相比于BEVFormer-S的性能大幅提升，针对有挑战性的检测任务提升更明显。TSA主要是在以下方面影响性能提升的：1.temporal information的引入对提高目标速度估计精度非常有益；2.利用temporal information，目标预测的location和orientations更精确；3.受益于temporal information包含过去时刻object的信息，如图4所示，严重遮挡目标的recall 更高。根据nuScenes标注的遮挡程度把验证数据集进行划分成4部分，来评估BEVFormer对各种程度遮挡的性能，针对每个数据子集都会计算average recall(匹配时把中心距离的阈值设为2m)。</p>
<p></p>
<p><strong>Model Scale and Latency</strong></p>
<p>针对不同Scale Settings的BEVFormer，对比检测性能和latency，结果如Table6所示。在3方面进行BEVFormer的Scale配置：1. 输入到BEVFormer Encoder的features是multi-scale还是single-scale；2.BEV Queries/features的尺寸；3. encoder layer数目。</p>
<p></p>
<p>从实验结果看来：Backbone的Latency远大于BEVFormer，因此Latency优化的主要瓶颈在于Backbone而不是BEVFormer(这里指BEVFormer Encoder部分)，BEVFormer可以采用不同的Scale，具备支持灵活平衡性能和efficiency的特性。</p>
<h2 id="4-discussion">4. Discussion</h2>
<p>理论上视觉图像的数据比激光数据稠密，但基于视觉的BEV效果还是比基于激光的方法性能差，那么也说明了理论上视觉还有可提升空间。
BEV Features能用于泊车位检测么？ 可能可以用BEVFormer在环视鱼眼相机上生成BEV features，用于泊车位检测或近距离目标的精确检测。
显性地引入BEV 特征，限制了最大检测距离，在高速公路场景，检测远处目标非常重要，如何权衡BEV的大小与检测距离是一个需要考虑的问题。
如何在检测精度和grid大小之间做平衡是一个问题。
针对2、3问题的一个优化方向：设计自适应尺寸的BEV特征。这里的自适应是指根据场景来调整BEV尺寸或精度。</p>
<h2 id="5-references">5. References</h2>
<p>论文：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/2203.17270.pdf"target="_blank" rel="external nofollow noopener noreferrer">《BEVFormer: Learning Bird’s-Eye-View Representation from Multi-Camera Images via Spatiotemporal Transformers》<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>开源工程：https://github.com/zhiqi-li/BEVFormer</p>
<p>参考中文解读</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/495819042"target="_blank" rel="external nofollow noopener noreferrer">使用Transformer融合时空信息的自动驾驶感知框架<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/491890969"target="_blank" rel="external nofollow noopener noreferrer">3d camera-only detection: BEVFormer<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/496284695"target="_blank" rel="external nofollow noopener noreferrer">BEVFormer，通过一个时空Transformer学习 BEV表征<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ol>
<p>类似工作：
Cross-view Transformers for real-time Map-view Semantic Segmentation
论文：https://arxiv.org/pdf/2205.02833v1.pdf</p>
<p>代码：https://github.com/bradyz/cross</p>
<p>REF:
[1]. <a href="https://zhuanlan.zhihu.com/p/538490215"target="_blank" rel="external nofollow noopener noreferrer">一文读懂BEVFormer论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
<a href="https://zhuanlan.zhihu.com/p/543335939"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/543335939<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
<a href="https://zhuanlan.zhihu.com/p/629792598"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/629792598<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>FastBEV:快速而强大的BEV感知基线</title><link>https://jianye0428.github.io/posts/fastbev/</link><pubDate>Sat, 02 Sep 2023 16:49:37 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/fastbev/</guid><description><![CDATA[<p>近年来，基于鸟瞰图(BEV)表示的感知任务越来越受到关注，BEV表示有望成为下一代自动驾驶车辆(AV)感知的基础。现有大多数的BEV解决方案要么需要大量资源来执行车载推理，要么性能不佳。本文提出了一种简单而有效的框架，称为Fast BEV，它能够在车载芯片上执行更快的BEV感知。为了实现这一目标，作者首先从经验上发现，BEV表示可以足够强大，而无需昂贵的基于transformer的变换或深度表示。Fast BEV由五个部分组成，论文新颖地提出：</p>
<p>(1)一种轻量级的、易于部署的视图转换，它将<strong>2D图像特征快速传输到3D体素空</strong>间;</br>
(2)一种利用<strong>多尺度信息</strong>获得更好性能的<strong>多尺度图像编码器</strong>;</br>
(3)一种高效的<strong>BEV编码器</strong>，它专门设计用于加快车载推理;</br>
(4)针对图像和BEV空间的强大<strong>数据增强策略</strong>以避免过度拟合;</br>
(5)利用时间信息的<strong>多帧特征融合</strong>机制。</p>
<p>其中，(1)和(3)使Fast BEV能够在车载芯片上快速推理和部署，(2)、(4)和(5)确保Fast BEV具有竞争性能。所有这些都使Fast BEV成为一种具有高性能、快速推理速度和在自动驾驶车载芯片上部署友好的解决方案。通过实验，在2080Ti平台上，R50模型可以在nuScenes验证集上以47.3%的NDS运行52.6 FPS，超过了BEVDepth-R50模型的41.3 FPS和47.5%的NDS，以及BEVDet4DR50模型的30.2 FPS和45.7%的NDS。最大的型号(R101@900x1600)在nuScenes验证集上建立了具有竞争力的53.5%NDS，论文在当前主流的车载芯片上进一步开发了具有相当高精度和效率的基准！</p>
<h2 id="领域现状">领域现状</h2>
<p>快速准确的3D感知系统对于自动驾驶至关重要。经典方法依赖于激光雷达点云提供的精确3D信息。然而，激光雷达传感器通常要花费数千美元，阻碍了它们在经济型车辆上的应用。基于纯相机的鸟瞰图(BEV)方法最近显示出其强大的3D感知能力和低成本的巨大潜力。它们基本上遵循这样的范式：将多摄像机2D图像特征转换为自我汽车坐标中的3D BEV特征，然后将特定头部应用于统一BEV表示以执行特定的3D任务，例如，3D检测、分割等。统一BEV表达可以单独处理单个任务或同时处理多个任务，这是高效和灵活的。</p>
<p>为了从2D图像特征执行3D感知，nuScenes上的现有BEV方法使用基于查询的transformation [17]，[18]或基于隐式/显式深度的transformation [13]，[15]，[26]。然而，它们很难部署在车载芯片上，并且推理速度慢：</p>
<ul>
<li>(1) 基于基于查询的transformation 方法如图1(a)所示，由于解码器需要transformer内的注意机制，这些方法通常需要专用芯片来支持。</li>
<li>(2) 基于深度变换的方法如图1(b)所示。</li>
</ul>
<p>这些方法通常需要加速不友好的体素池操作，甚至多线程CUDA内核也可能不是最佳解决方案。此外，这对于在资源受限或CUDA加速推理库不支持的芯片上运行是不方便的。此外，它们在推理上很耗时，这妨碍了它们的实际部署。本文旨在为车载芯片设计一种具有友好部署、高推理速度和竞争性能的BEV感知框架，例如Xavier、Orin、Tesla T4等。</p>
<p></p>
<p>基于这些观察结果，遵循M2BEV[16]的原理，该原理假设在图像到BEV(2D到3D)视图转换期间沿相机光线的深度分布均匀，我们提出<strong>Fast-Ray转换</strong>，如图1(c)所示，借助于“查找表”和“多视图到一个体素”操作，将BEV转换加速到一个新的水平。基于Fast Ray变换，论文进一步提出了Fast BEV，这是一种更快、更强的全卷积BEV感知框架，无需昂贵的视图transformer[17]、[18]或深度表示[15]、[23]、[26]。所提出的快速BEV包括五个部分，<font color=red>Fast-Ray变换</font>、<font color=red>多尺度图像编码器</font>、<font color=red>高效BEV编码器</font>、<font color=red>数据增强</font>和<font color=red>时间融合</font>，这些共同构成了一个框架，赋予Fast BEV快速推理速度和有竞争力的性能。</p>
<p>详细展开说，本文提出了Fast Ray变换，这是一种用于快速推理的轻量级和部署友好的视图变换，通过将多视图2D图像特征沿着相机射线的体素投影到3D来获得BEV表示。此外，还提出了两种操作，即“查找表”和“多视图到一个体素”，以优化车载平台的流程。现有工作的视图转换耗时，多尺度投影操作将具有较大的时间开销，因此难以在实践中使用。基于Fast Ray变换，本文的2D到3D投影具有极快的速度，使具有多尺度投影操作的多尺度图像编码器成为可能。具体而言，与大多数使用单尺度特征作为图像编码器输出的现有工作不同，论文在图像编码器输出部分使用了3层多尺度特征金字塔网络(FPN)结构。随后是相应的3级多尺度投影操作。对于BEV编码器，作者使用很少的原始残差网络作为基本BEV编码器。在此基础上，使用三维缩减操作来加速编码器，分别是“空间到信道”(S2C)算子、多尺度级联融合(MSCF)算子和多帧级联融合(MFCF)算子。论文还进一步为图像和BEV空间引入了强大的数据增强策略，如翻转、旋转、调整大小等。分别在图像空间和BEV中执行的数据增强不仅避免了过度拟合，而且实现了更好的性能。最后引入了时间融合[17]，[23]，它通过引入时间特征融合模块将Fast BEV从纯空间扩展到时空空间，使当前关键帧能够利用来自历史帧的信息。</p>
<p>BEV感知在学术界经常更新性能基准，如NuScenes基准，但很少在工业应用方面进行研究。本文首次在当前流行的车载芯片上开发了一个具有相当准确度和效率的基准，从延迟到不同计算能力的车载芯片之间的性能，这为BEV解决方案的实际部署提供了参考。凭借其高效率和具有竞争力的性能，Fast BEV打破了现有BEV解决方案难以在低计算芯片上部署的信念，<strong>简单</strong>和<strong>高效</strong>是其主要优势。所提出的Fast BEV表现出了出色的性能，可以轻松部署在车载平台上。在nuScenes数据集上，在2080Ti平台上，R50模型可以在nuScene验证集上运行52.6 FPS和47.3%的NDS，超过了BEVDepth-R50模型的41.3 FPS和47.5%的NDS以及BEVDet4D-R50模型的30.2 FPS和45.7%的NDS。最大的型号(R101@900x1600)在nuScenes验证集上建立了具有竞争力的53.5%NDS。</p>
<h2 id="领域的主流方案梳理">领域的主流方案梳理</h2>
<p><strong>1)基于camera的单目3D目标检测</strong></p>
<p>3D目标检测中的检测器旨在预测物体在3D空间中的位置和类别，给定由激光雷达或相机传感器生成的输入。基于LiDAR的方法，例如CenterPoint，倾向于使用3D CNN从LiDAR点提取空间特征，并进一步回归到3D属性，如目标的3D中心。与LiDAR传感器相比，仅将相机图像作为输入不仅成本更低，而且图像包含更丰富的语义信息。单目3D目标检测的一种实用方法是基于3D图像特征学习3D边界框，M3DRPN提出了3D区域建议网络和深度卷积层，以提高3D场景理解。在FCOS之后，FCOS3D[7]通过将3D目标转换为图像域，直接预测每个对象的3D边界框。PGD[9]使用对象之间的关系和概率表示来捕获深度不确定性，以便于3D对象检测的深度估计，DD3D[10]受益于深度预训练，并显著改善端到端3D检测！</p>
<p><strong>2)基于camera的环视3D目标检测</strong></p>
<p>一些大型基准的最新进展，特别是使用更多的周围视图，进一步推动了3D感知领域。在基于camera的3D目标检测中，新提出的多视图transformation 技术[11]、[12]、[13]、[14]将任务重新表述为立体匹配问题，其中周围的图像特征转换成立体表示，如BEV或3D体素。例如，LSS在预测的深度分布上投影逐像素特征，以生成相机截头体，然后转换截头体进入BEV grid。OFT[14]提出通过将预定义的体素投影到图像特征上来生成体素表示，BEVDet将LSS应用于全卷积方法，并首先验证了显式BEV的性能。M2BEV首先跟随OFT探索BEV多任务感知，BEVDepth进一步扩展了LSS[13]，具有强大的深度监督和高效的池化操作。视图转换的另一个路线图是网格状的BEV查询，DETR3D和Graph-DETR3D将每个BEV查询解码为3D参考点，以从图像中采样相关的2D特征进行细化。BEVFormer在二维到三维转换中引入了空间交叉关注，允许每个查询可以跨相机视图聚合其相关的二维特征。PETR提出3D坐标生成来感知3D位置感知特征，避免生成3D参考点。这些工作的成功激励我们有效和高效地扩展周围的多摄像机检测pipeline。作者发现在类似LSS的方法中，使用深度分布是不必要的，并且可以删除它以进一步加快整个pipeline的速度！</p>
<p><strong>3)基于camera的多视图时间融合</strong></p>
<p>最近，一些基于相机的方法试图在检测过程中引入多帧融合，这已被证明对基于LiDAR的检测器中的速度估计和box定位有效[20]，[21]，[22]。而BEV作为一种同时组合来自多个相机的视觉信息的中间特征，适合于时间对齐。[40]提出了一种动态模块，该模块使用过去的空间BEV特征来学习时空BEV表示，BEVDet4D通过对齐多帧特征并利用自我运动中的空间相关性来扩展BEVDet[15]。PETRv2基于3D位置嵌入的视角，直接实现3D空间中的时间对齐。BEVFormer设计了一种时间自关注，以递归地融合历史BEV信息，类似于RNN模型中的隐藏状态。本文的工作也受到时间对齐的启发，具体来说，我们应用该技术来进一步提高性能，同时保持高效率。</p>
<h2 id="本文的方法">本文的方法</h2>
<p>BEV感知中最重要的是如何将2D特征转移到3D空间。如图1所示，基于查询的方法通过变换器中的注意力机制获得3D BEV特征，这个过程可以表示为以下公式(1)，基于深度的方法通过计算2D特征和预测深度的外积来获得3D BEV特征，具体过程如公式(2)所示:</p>
<p>$$F_{bev}(x,y,z)=Attn(q,k,v)\quad(1)$$</p>
<p>$$F_{bev}(x,y,z)=Pool{F_{2D}(u,v)\otimes D(u,v)}_{x,y,z}\quad(2)$$</p>
<p>其中F2D(u,v)表示从图像中提取的2D特征，D(u,v)表示来自2D特征的深度预测。⊗表示out producter，Pool表示体素池操作。x、y、z是三维空间中的平均坐标，u，v在二维空间中的坐标。在CUDA多线程的支持下，这些方法大大提高了GPU平台上的推理速度，但在更大的分辨率和特征维度上会遇到计算速度瓶颈，并且在没有推理库支持的情况下转移到非GPU平台不是很友好。</p>
<p>作者提出了基于光线投影的Fast-Ray transformation方法，借助于查找表和多视图到一个体素操作，以便在GPU平台上实现极高的2D到3D推理速度。此外，由于其标量索引的高效性，当在CPU平台上运行时，它仍然具有优于现有解决方案的速度性能，这使得转移到更多平台成为可能。</p>
<p></p>
<p>M2BEV[16]是解决具有统一BEV表示的多摄像机多任务感知的第一个工作之一，因为它没有昂贵的视图转换器或深度表示，因此在车载平台上具有巨大的应用潜力。受其简单性的启发，本文提出了具有卓越速度和性能的Fast BEV，如图2所示，Fast BEV将多摄像机图像作为输入，并预测3D边界框(包括速度)作为输出。其主要框架可分为五个关键模块：Fast-Ray Transformation、Multi-Scale Image Encoder、Efficient BEV Encoder、Data Augmentation、Temporal Fusion！</p>
<p><strong>1) Fast-Ray Transformation</strong></p>
<p><font color=green><strong>视图转换</strong></font>是将特征从2D图像空间转换到3D BEV空间的关键组件，这通常在整个pipelines中花费大量时间。论文按照[16]，[34]假设沿射线的深度分布是均匀的，这种方式优点是，一旦获得了相机的内在/外在参数，就可以很容易地知道2D到3D的投影。由于这里没有使用可学习的参数，可以很容易地计算图像特征图和BEV特征图中的点之间的对应矩阵。基于这一假设，本文从两个角度进一步加速该过程：<font color=red>预计算投影索引(查找表)</font>和<font color=red>密集体素特征生成(多视图到一个体素)</font>。</p>
<p></p>
<p><font color=red><strong>查找表</strong></font>。投影索引是从2D图像空间到3D体素空间的映射索引，考虑到在构建感知系统时相机位置及其内在/外在参数是固定的，并且本文的方法既不依赖于数据相关的深度预测，也不依赖于transformer，因此每个输入的投影指数都是相同的。所以不需要为每次迭代计算相同的索引，只需预先计算固定投影索引并将其存储。在推断过程中，可以通过查询查找表来获得投影索引，这是边缘设备上的一个超级便宜的操作。此外，如果我们从单个帧扩展到多个帧，还可以很容易地预先计算内部和外部参数，并将它们与当前帧预对齐。如算法1所示，通过相机参数矩阵投影构建了具有与输出三维体素空间相同维度的查找表LUT。迭代每个体素单元，并通过投影计算对应于3D坐标的2D像素坐标。如果获得的2D像素坐标地址是合法的，可以将其填充到LUT中以建立与数据无关的索引映射！</p>
<p></p>
<p><font color=red><strong>多视图到一个体素</strong></font>。基本视图变换使用原始体素聚合操作，该操作为每个相机视图存储离散体素特征，然后<strong>聚合</strong>它们以生成最终体素特征。如图3(a)所示，这是填充的每个离散体素的鸟瞰图。因为每个相机只有有限的视角，所以每个体素特征非常稀疏，例如，只有大约17%的位置是非零的。我们发现这些体素特征的聚集是非常昂贵的，因为它们的巨大尺寸。<font color=green>本文建议生成密集体素特征以避免昂贵的体素聚集</font>，具体来说，让所有相机视图中的图像特征投影到同一个体素特征，从而在最后生成一个密集体素，名为“多视图到一个体元”。如图3(b)所示，这是填充了密集体素的鸟瞰图。如算法2所示的快速射线变换算法，其将输入的多视图2D图像特征转移到一个体素3d空间中，其中每个体素单元由预先计算的LUT填充相应的2D图像特征。对于具有重叠区域的多个视图的情况，直接采用第一个遇到的视图来提高表构建的速度。结合“查找表”和“多视图到一个体素”加速设计，视图转换操作具有极快的投影速度！</p>
<p></p>
<p><strong>2)多尺度Image Encoder</strong></p>
<p>多尺度图像编码器从多视图图像中提取多层次特征，N个图像∈$R^{H×W×3}$作为输入，F1/4、F1/8、F1/16三级特征作为输出。</p>
<p></p>
<p><strong>3)高效BEV编码器</strong></p>
<p>BEV特征是4D张量，时间融合将叠加特征，这将使BEV编码器具有大量计算量。三维缩减操作用于加快编码器的速度，即<u>“空间到信道”(S2C)算子</u>、多尺度，其中所述多帧融合(MFCF)算子分别是<font color=red><u>级联融合(MSCF)算子</u></font>和<font color=red><u>多帧凹融合(MFF)算子</u></font>。S2C算子将4D体素张量V∈RX×Y×Z×C转换为3D BEV张量V∈R X×Y×(ZC)，从而避免使用内存昂贵的3D卷积。在MFCF算子之前，值得注意的是，通过多尺度投影获得的BEV特征是不同的尺度。论文将首先对X和Y维度上的多尺度BEV特征进行上采样，使其大小相同，例如200×200。MSCF和MFCF运营商在信道维度中合并多尺度多帧特征，并将它们从较高的参数量融合到较低的参数量。此外，通过实验发现，BEV编码器和3D体素分辨率的大小对性能的影响相对较小，但占用了较大的速度消耗，因此更少的block和更小的体素分辨率也更为关键！</p>
<p><strong>4)数据增强</strong></p>
<p>数据扩充的好处已在学术界形成共识。此外，3D数据集(如NuScenes、KITTI)很难标记，且成本高昂，这导致数据集中样本数量较少，因此数据增强可以带来更显著的性能提升。<strong>本文在图像空间和BEV空间中添加了数据增强，主要遵循BEVDet</strong>。</p>
<p><strong>图像增强</strong>：由于3D场景中的图像与3D相机坐标有直接关系，因此3D目标检测中的数据增强比2D检测更具挑战性。因此，如果对图像应用数据增强，还需要改变相机固有矩阵。对于增强操作，基本上遵循常见的操作，例如翻转、裁剪和旋转，在图5的左侧部分，展示了一些图像增强的示例。</p>
<p><strong>BEV增强</strong>：类似于图像增强，类似的操作可以应用于BEV空间，例如翻转、缩放和旋转。注意，增强变换应应用于BEV特征图和3D GT框，以保持一致性。BEV增强变换可以通过相应地修改相机外部矩阵来控制，在图5的右侧部分，展示了随机旋转增强，一种BEV增强！</p>
<p></p>
<p><strong>5)时间融合</strong></p>
<p>受BEVDet4D和BEVFormer的启发，作者还将历史帧引入到当前帧中以进行时间特征融合。<strong>通过空间对齐操作和级联操作，将历史帧的特征与当前帧的对应特征融合</strong>。时间融合可以被认为是帧级的特征增强，在一定范围内较长的时间序列可以带来更多的性能增益。具体来说，用三个历史关键帧对当前帧进行采样;每个关键帧具有0.5s间隔，本文采用了BEVDet4D中的多帧特征对齐方法。如图6所示，在获得四个对齐的BEV特征后，直接将它们连接起来，并将它们馈送到BEV编码器。在训练阶段，使用图像编码器在线提取历史帧特征，在测试阶段，历史帧功能可以离线保存，并直接取出用于加速。与BEVDet4D和BEVFormer进行比较，BEVDet4D只引入了一个历史框架，我们认为这不足以利用历史信息。Fast BEV使用三个历史帧，从而显著提高了性能，通过使用两个历史帧，BEVFormer略优于BEVDet4D。然而，由于记忆问题，在训练阶段，历史特征在没有梯度的情况下被分离，这不是最佳的。此外，BEVFormer使用RNN样式来顺序融合特征，这是低效的。相比之下，Fast BEV中的所有帧都以端到端的方式进行训练，这与普通GPU相比更易于训练！</p>
<h2 id="实验">实验</h2>
<p>数据集描述：评估了nuScenes数据集上的 Fast BEV，该数据集包含1000个自动驾驶场景，每个场景20秒。数据集被分成850个场景用于训练/验证，其余150个场景用于测试。虽然nuScenes数据集提供来自不同传感器的数据，但我们只使用相机数据。相机有六个视图：左前、前、右前、左后、后、右后。</p>
<p>评估指标。为了全面评估检测任务，使用平均精度(mAP)和nuScenes检测分数(NDS)的标准评估指标进行3D目标检测评估。此外，为了计算相应方面的精度(例如，平移、缩放、方向、速度和属性)，使用平均平移误差(mATE)、平均缩放误差(mASE)、平均方向误差(mAOE)、平均速度误差(mAVE)，以及平均属性误差(mAAE)作为度量。</p>
<p>和主流方法的Latency进行比较：</p>
<p></p>
<p>在可比性能下，Fast BEV、BEVDet4D和BEVDepth方案的端到端延迟比较。表的上部是三种方案的详细设置，包括每个组件的具体配置。表的下半部分是在可比性能下三种方案的每个部分的延迟和总延迟的比较。2D到3D部分包括CPU和CUDA两个平台的延迟，MSO表示多尺度输出。</p>
<p></p>
<p>nuScenes集的比较。“L”表示激光雷达，“C”表示摄像机，“D”表示深度/激光雷达监控。MS表示图像和BEV编码器中的多尺度。“¶”表示我们使用MS、scale NMS和测试时间数据增强的方法。</p>
<p></p>
<p>更多消融实验对比：</p>
<p></p>
<p></p>
<p>高效型号系列：为了满足不同计算能力平台的部署需求，本文设计了一系列从M0到M5的高效模型，如表10所示。设置了不同的图像编码器(从ResNet18到ResNet50)，图像分辨率(从256×704到900×1600)、体素分辨率(从200×200×4到250×250×6)和BEV编码器(从2b-192c到6b-256c)来设计模型尺寸。从表10可以看出，从M0到M5，随着图像编码器、图像分辨率、体素分辨率和BEV编码器逐渐变大，模型性能逐渐提高。</p>
<p>在流行设备上部署：除了注重性能，还将M系列车型部署在不同的车载平台(Xavier、Orin、T4)上，并使用CUDA-TensorRT-INT8加速。具体而言，AGX Xavier在没有使用CUDA11.4-TRTT8.4.0-INT8部署DLA加速的情况下的计算能力为22TOPS，AGX Orin 64G在没有使用CUDA11.4-TTRT8.4.0-INT8部署DLB加速的情况下的计算能力是170TOPS，T4在使用CUDA11.1-TRT7.2.1-INT8部署时的计算能力则是130TOPS。如表11所示，评估了这些车载设备上M系列模型的延迟，并将延迟分解为2D/2D到3D/3D三个部分。</p>
<p>从表11中可以看出：(1)随着M系列型号逐渐变大，性能逐渐提高，同一计算平台上的延迟也基本上逐渐增加，2D和3D部分的延迟也分别增加。(2) 从左到右，随着这三个设备的实际计算能力1逐渐增加，M系列的每个模型的延迟逐渐减少，2D和3D部分的延迟分别减少。(3) 结合表11中M系列的性能，可以发现，仅考虑延迟时，M0模型在Xavier等低计算平台上可以达到19.7FPS，这可以实现实时推理速度。考虑到性能，M2模型在性能和延迟之间具有最合理的权衡。在与表2中R50系列模型的性能相当的前提下，它在Orin平台上可以达到43.3 FPS，这可以实现实际的实时推理要求。</p>
<p>目前，BEV感知解决方案越来越多，但它们主要追求学术领域的性能，很少考虑如何更好地将其部署在车载芯片上，尤其是低计算芯片上。不能否认，BEVDet和BEVDepth等工作是当前考虑的首批可能解决方案，因为它们在部署车载芯片时非常方便。但Fast BEV在以下情况下提供了应用的可能性：</p>
<p>低计算能力芯片：尽管自动驾驶芯片的计算能力在逐渐增加，但一些计算能力较低的芯片，如英伟达Xavier，仍被用于经济型车辆。Fast BEV可以以更快的速度在低计算能力芯片上表现得更好。</p>
<p>非GPU部署：DEVEDepth和BEVDet的成功部署和应用主要依赖于CUDA多线程支持的高效体素池操作。然而，没有CUDA库的非GPU芯片，例如以DSP为计算单元的德州仪器芯片，很难开发DSP多线程处理器，CPU速度不够快，这使得它们的解决方案在此类芯片上失去了优势。Fast BEV以其快速的CPU速度提供了在非GPU芯片上部署的便利。</p>
<p>实践中可扩展：随着技术的发展，许多自动驾驶制造商已经开始放弃激光雷达，只使用纯摄像头进行感知。结果，在真实车辆收集的大量数据中没有深度信息。在实际开发中，模型放大或数据放大通常基于从真实车辆收集的数据，以利用数据潜力提高性能。在这种情况下，基于深度监控的解决方案遇到瓶颈，而Fast BEV不引入任何深度信息，可以更好地应用！</p>
<p>ref:</br>
[1]. 论文：https://arxiv.org/abs/2301.12511</br>
[2]. 代码：https://github.com/Sense-GVT/Fast-BEV</br>
[3]. <a href="https://mp.weixin.qq.com/s/aVbaw2qYc6-i21zbCNhfOg"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/aVbaw2qYc6-i21zbCNhfOg<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[4]. <a href="https://zhuanlan.zhihu.com/p/608929598"target="_blank" rel="external nofollow noopener noreferrer">FastBEV 代码注释<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
]]></description></item><item><title>Effective STL [37] | 用accumulate或for_each来统计区间</title><link>https://jianye0428.github.io/posts/clause_37/</link><pubDate>Sat, 02 Sep 2023 10:28:36 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_37/</guid><description><![CDATA[<h2 id="操作区间的函数">操作区间的函数</h2>
<p>有时候你需要把整个区间提炼成一个单独的数，或，更一般地，一个单独的对象。</p>
<p>对于一般需要的信息，<code>count</code>告诉你区间中有多少等于某个值的元素，而<code>count_if</code>告诉你有多少元素满足一个判断式。</p>
<p>区间中的最小和最大值可以通过<code>min_element</code>和<code>max_element</code>获得。</p>
<p>但有时，你需要用一些自定义的方式统计（summarize）区间，而且在那些情况中，你需要比<code>count</code>、<code>count_if</code>、<code>min_element</code>或<code>max_element</code>更灵活的东西。</p>
<p>你可能想要对一个容器中的字符串长度求和。你可能想要数的区间的乘积。你可能想要point区间的平均坐标。在那些情况中，<strong>你需要统计一个区间，但你需要有定义你需要统计的东西的能力。</strong></p>
<h2 id="accumulate"><code>accumulate</code></h2>
<p><code>accumulate</code>和<code>inner_product</code>、<code>adjacent_difference</code>和<code>partial_sum</code>算法在头文件<numeric>中。</p>
<p><code>accumulate</code>存在两种形式。</p>
<p><strong>带有一对迭代器和初始值的形式可以返回初始值加由迭代器划分出的区间中值的和</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 建立一个list，放一些double进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">ld</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算它们的和，从0.0开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ld</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">意初始值指定为0.0，不是简单的0。
0.0的类型是double，所以accumulate内部使用了一个double类型的变量来存储计算的和。</div>
    </div>
  </div>
<p>如果这么写这个调用:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 计算它们的和，从0开始；这不正确！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ld</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果初始值是int 0，所以<strong>accumulate内部就会使用一个int来保存它计算的值。那个int最后变成accumulate的返回值，而且它用来初始化和变量</strong>。这代码可以编译和运行，但和的值可能不对。不是保存真的double的list的和，它可能保存了所有的double加起来的结果，但每次加法后把结果转换为一个int。</p>
<p><strong>输入迭代器</strong></p>
<p><code>accumulate</code>只需要输入迭代器，所以你甚至可以使用<code>istream_iterator</code>和<code>istreambuf_iterator</code></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 打印cin中 那些int的和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The sum of the ints on the standard input is&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cin</span><span class="p">),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>带有一个初始和值与一个任意的统计函数</strong></p>
<p>比如，考虑怎么使用accumulate来计算容器中的字符串的长度和。要计算这个和，accumulate需要知道两个东 西。第一，<strong>它必须知道和的开始</strong>。在我们的例子中，它是0。第二，<strong>它必须知道每次看到一个新的字 符串时怎么更新这个和</strong>。要完成这个任务，我们写一个函数，它带有目前的和与新的字符串，而且返回更新的和:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// string::size_type的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">stringLengthSum</span><span class="p">(</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">sumSoFar</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">sumSoFar</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>每个标准STL容器都有一个typedef叫做size_type，那是容器计量东西的类型。比如，这是容器的size函数的返回类型。对于所有的标准容器，size_type必须是size_t。</p>
<p><code>stringLengthSum</code>是<code>accmulate</code>使用的统计函数的代表。它带有到目前为止区间的统计值和区间的下一个元素，它返回新的统计值。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ss</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立字符串的容器，进行一些操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把lengthSum设为对 ss中的每个元素调用stringLengthSum的结果，使用0作为初始统计值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">lengthSum</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">accumulate</span><span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ss</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stringLengthSum</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>计算数值区间的积甚至更简单，因为我们不用写自己的求和函数。我们可以使用标准multiplies仿函数类:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 建立float的容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">vf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 进行一些操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 把product设为对vf中的每个元素调用， multiplies&lt;float&gt;的结果，用1.0f作为初始统计值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">product</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">         <span class="n">accumulate</span><span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vf</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mf">1.0f</span><span class="p">,</span> <span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里唯一需要小心的东西是记得把<code>1.0f</code>作为初始统计值，而不是0。如果我们使用0作为开始值，结果会总是0，因为0乘以任何东西也是0。</p>
<p><strong>寻找point的区间的平均值</strong></p>
<p>寻找point的区间的平均值，point看起来像这样:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">initX</span><span class="p">,</span> <span class="kt">double</span> <span class="n">initY</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">initX</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">initY</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>求和函数应该是一个叫做PointAverage的仿函数类的对象，但在我们察看PointAverage之前，让我们看看它在调用accumulate中的使用方法：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">lp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对Ip中的point求平均值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Point</span> <span class="n">avg</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">lp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">PointAverage</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>初始和值是在原点的point对象，我们需要记得的是当计算区间的平均值时不要考虑那个点。</p>
<p><code>PointAverage</code>通过记录它看到的point的个数和它们x和y部分的和的来工作。每次调用时，它更新那些值并返回目前检查过的point的平均坐标，因为它对于区间中的每个点只调用一次，它把x与y的和除以区间中的point的个数，忽略传给accumulate的初始point值，它就应该是这样：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PointAverage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Point</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">PointAverage</span><span class="p">()</span> <span class="o">:</span> <span class="n">numPoints</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">xSum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">ySum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">Point</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">avgSoFar</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">numPoints</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xSum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ySum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">xSum</span> <span class="o">/</span> <span class="n">numPoints</span><span class="p">,</span> <span class="n">ySum</span> <span class="o">/</span> <span class="n">numPoints</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">numPoints</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">xSum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">ySum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>成员变量numPoints、xSum和ySum的修改造成了一个副作用，所以，技术上讲，上述例子展示的代码会导致结果未定义。</p>
<h2 id="for_each">for_each</h2>
<p><code>for_each</code>带有一个区间和一个函数（一般是一个函数对象）来调用区间中的每个元素，但传给<code>for_each</code>的函数只接收一个实参（当前的区间元素），而且当完成时<code>for_each</code>返回它的函数。（实际上，它返回它的函数的一个拷贝。</p>
<p>首先，<code>accumulate</code>的名字表示它是一个产生区间统计的算法，<code>for_each</code>听起来好像你只是要对区间的每个元素进行一些操作。</p>
<p>用<code>for_each</code>来统计一个区间是合法的，但是它没有accumulate清楚。</p>
<p><code>accumulate</code>直接返回那些我们想要的统计值，而for_each返回一个函数对象，我们必须从这个对象中提取想要的统计信息。</p>
<p>在C++里，那意味着我们必须给仿函数类添加一个成员函数，让我们找回我们追求的统计信息。</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">PointAverage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 参见条款40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">PointAverage</span><span class="p">()</span> <span class="o">:</span> <span class="n">xSum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">ySum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">numPoints</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">numPoints</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">xSum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ySum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span> <span class="nf">result</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">xSum</span> <span class="o">/</span> <span class="n">numPoints</span><span class="p">,</span> <span class="n">ySum</span> <span class="o">/</span> <span class="n">numPoints</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">numPoints</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">xSum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">ySum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">lp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span> <span class="n">avg</span> <span class="o">=</span> <span class="n">for_each</span><span class="p">(</span><span class="n">lp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">PointAverage</span><span class="p">()).</span><span class="n">result</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>就个人来说，我更喜欢用<code>accumulate</code>来统计，因为我认为它最清楚地表达了正在做什么，但是<code>for_each</code>也可以，而且不像<code>accumulate</code>，副作用的问题并不跟随<code>for_each</code>。</p>
]]></description></item><item><title>Effective STL 精读总结 [1] | 容器</title><link>https://jianye0428.github.io/posts/partone/</link><pubDate>Fri, 01 Sep 2023 08:38:45 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partone/</guid><description><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-STL总结系列分为七部分，本文为第一部分，涉及原书第一章，内容范围Rule01~12。为方便书写，Rule12简写为R12。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-STL系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<h2 id="r01-慎重选择容器类型">R01 慎重选择容器类型</h2>
<p>STL 容器不是简单的好，而是确实很好。</p>
<p>容器类型如下：</p>
<ul>
<li>标准 STL 序列容器：<code>vector</code>、<code>string</code>、<code>deque</code>、<code>list</code>。</li>
<li>标准 STL 关联容器：<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>。</li>
<li>非标准序列容器 <code>slist</code> 和 <code>rope</code>。<code>slist</code> 是一个单向链表，<code>rope</code> 本质上是一个 &ldquo;重型&rdquo; <code>string</code>。</li>
<li>非标准的关联容器：<code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>、<code>hash_multimap</code>。</li>
<li><code>vector</code> 作为 <code>string</code> 的替代。</li>
<li><code>vector</code> 作为标准关联容器的替代：有时 <code>vector</code> 在运行时间和空间上都要优于标准关联容器。</li>
<li>几种标准的非 STL 容器：<code>array</code>、<code>bitset</code>、<code>valarray</code>、<code>stack</code>、<code>queue</code>、<code>priority_queue</code>。</li>
</ul>
<p>容器选择标准:</p>
<ol>
<li>vector、list和deque有着不同的复杂度，vector是默认使用的序列类型。当需要频繁在序列中间做插入和删除操作时，应使用list。当大多数插入和删除操作发生在序列的头部和尾部时，应使用deque。</li>
<li>可以将容器分为连续内存容器和基于节点的容器两类。连续内存容器把元素存放在一块或多块(动态分配的)内存中，当有新元素插入或已有的元素被删除时，同一块内存中的其他元素要向前或向后移动，以便为新元素让出空间，或者是填充被删除元素所留下的空隙。这种移动会影响到效率和异常安全性。标准的连续内存容器有vector、string和deque，非标准的有rope。</li>
<li>基于节点的容器在每一个(动态分配的)内存块中只存放一个元素。容器中元素的插入或删除只影响指向节点的指针，而不影响节点本身，所以插入或删除操作时元素是不需要移动的。链表实现的容器list和slist是基于节点的，标准关联容器也是(通常的实现方式是平衡树)，非标准的哈希容器使用不同的基于节点的实现。</li>
<li>是否需要在容器的任意位置插入新元素？需要则选择序列容器，关联容器是不行的。</li>
<li>是否关心容器中的元素是如何排序的？如果不关心，可以选择哈希容器，否则不能选哈希容器(unordered)。</li>
<li>需要哪种类型的迭代器？如果是随机访问迭代器，那就只能选择vector、deque和string。如果使用双向迭代器，那么就不能选slist和哈希容器。</li>
<li>是否希望在插入或删除元素时避免移动元素？如果是，则不能选择连续内存的容器。</li>
<li>容器的数据布局是否需要和C兼容？如果需要只能选<code>vector</code>。</li>
<li>元素的查找速度是否是关键的考虑因素？如果是就考虑哈希容器、排序的<code>vector</code>和标准关联容器。</li>
<li>是否介意容器内部使用引用计数技术，如果是则避免使用<code>string</code>，因为<code>string</code>的实现大多使用了引用计数，可以考虑用<code>vector&lt;char&gt;</code>替代。</li>
<li>对插入和删除操作需要提供事务语义吗？就是说在插入和删除操作失败时，需要回滚的能力吗？如果需要则使用基于节点的容器。如果是对多个元素的插入操作(针对区间)需要事务语义，则需要选择<code>list</code>，因为在标准容器中，只有<code>list</code>对多个元素的插入操作提供了事务语义。对希望编写异常安全代码的程序员，事务语义尤为重要。使用连续内存的容器也可以获得事务语义，但是要付出性能上的代价，而且代码也不那么直截了当。</li>
<li>需要使迭代器、指针和引用变为无效的次数最少吗？如果是则选择基于节点的容器，因为对这类容器的插入和删除操作从来不会使迭代器、指针和引用变成无效(除非它们指向一个正在删除的元素)。而对连续内存容器的插入和删除一般会使得指向该容器的迭代器、指针和引用变为无效。</li>
</ol>
<h2 id="r02-不要试图编写独立于容器类型的代码">R02 不要试图编写独立于容器类型的代码</h2>
<ol>
<li>
<p>容器是以类型作为参数的，而试图把容器本身作为参数，写出独立于容器类型的代码是不可能实现的。因为不同的容器支持的操作是不同的，即使操作是相同的，但是实现又是不同的，比如带有一个迭代器参数的erase作用于序列容器时，会返回一个新的迭代器，但作用于关联容器则没有返回值。这些限制的根源在于，对于不同类型的序列容器，使迭代器、指针和引用无效的规则是不同的。</p>
</li>
<li>
<p>有时候不可避免要从一个容器类型转到另一种，可以使用封装技术来实现。最简单的方式是对容器类型和其迭代器类型使用typedef，如<code>typedef vector&lt;Widget&gt; widgetContainer</code>; <code>typedef widgetContainer::iterator WCIterator</code>; 如果想减少在替换容器类型时所需要修改的代码，可以把容器隐藏到一个类中，并尽量减少那些通过类接口可见的、与容器有关的信息。</p>
</li>
</ol>
<p><strong>一种容器类型转换为另一种容器类型：typedef</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">WidgetContainer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">WidgetContainer</span> <span class="n">cw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">bestWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">WidgetContainer</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">cw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bestWidget</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样就使得改变容器类型要容易得多，尤其当这种改变仅仅是增加一个自定义得分配子时，就显得更为方便（这一改变不影响使迭代器/指针/引用无效的规则）。</p>
<h2 id="r03-确保容器中的对象拷贝正确而高效">R03 确保容器中的对象拷贝正确而高效</h2>
<ul>
<li>存在继承关系的情况下，拷贝动作会导致<strong>剥离</strong>（slicing）: 如果创建了一个存放基类对象的容器，却向其中插入派生类对象，那么在派生类对象（通过基类的拷贝构造函数）被拷贝进容器时，它所特有的部分（即派生类中的信息）将会丢失。
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">vw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecialWidget</span><span class="o">:</span>			<span class="c1">// SpecialWidget 继承于上面的 Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">public</span> <span class="n">Widget</span><span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="n">SpecialWidget</span> <span class="n">sw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vw</span><span class="p">.</span><span class="n">push_back</span><span class="p">();</span>					<span class="c1">// sw 作为基类对象被拷贝进 vw 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 它的派生类特有部分在拷贝时被丢掉了
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>剥离意味着向基类对象中的容器中插入派生类对象几乎总是错误的</strong>。</li>
<li>解决剥离问题的简单方法：<u>使容器包含指针而不是对象</u>。</li>
</ul>
<ol>
<li>容器中保存的对象，并不是你提供给容器的那些对象。从容器中取出对象时，也不是容器中保存的那份对象。当通过如insert或push_back之类的操作向容器中加入对象时，存入容器的是该对象的拷贝。当通过如front或back之类的操作从容器中 取出对象时，所得到的是容器中对象的拷贝。进去会拷贝，出来也是拷贝，这就是STL的工作方式。</li>
<li>当对象被保存到容器中，它经常会进一步被拷贝。当对vector、string或deque进行元素的插入或删除时，现有元素的位置通常会被移动（拷贝）。如果使用下列任何算法，next_permutation或previous_permutation，remove、unique，rotate或reverse等等，那么对象将会被移动（拷贝），这就是STL的工作方式。</li>
<li>如果向容器中填充的对象拷贝操作很费时，那么向容器中填充对象这一简单操作将会成为程序的性能瓶颈。而且如果这些对象的拷贝有特殊含义，那么把它们放入容器还将不可避免地会产生错误。</li>
<li>当存在继承关系时，拷贝动作会导致剥离。也就是说，如果创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么派生类对象（通过基类的拷贝构造函数）被拷贝进容器时，它派生类的部分将会丢失。</li>
<li>使拷贝动作高效、正确，并防止剥离问题发生的一个简单办法就是使容器包含对象指针，而不是对象本身。拷贝指针的速度非常快，而且总是会按你期望的方式进行。如果考虑资源的释放，智能指针是一个很好的选择。</li>
</ol>
<h2 id="r04-调用-empty-而不是检查-size是否为0">R04 调用 empty 而不是检查 size()是否为0</h2>
<ul>
<li><code>empty</code> 通常被实现为内联函数（inline function），并且它做的仅仅是返回 size() 是否为 0.</li>
<li><code>empty</code> 对所有标准容器都是常数时间操作，而对于一些 list 实现，size 耗费线性时间</li>
</ul>
<p>ref:
[1]. <a href="https://www.cnblogs.com/Sherry4869/p/15128250.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/Sherry4869/p/15128250.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[2]. <a href="https://blog.csdn.net/zhuikefeng/article/details/108164117#t42"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/zhuikefeng/article/details/108164117#t42<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [36] | 了解copy_if的正确实现</title><link>https://jianye0428.github.io/posts/clause_36/</link><pubDate>Wed, 30 Aug 2023 20:20:55 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_36/</guid><description><![CDATA[<h2 id="stl中copy算法">STL中copy算法</h2>
<p>STL有很多有趣的地方，其中一个是虽然有11个名字带“copy”的算法，但没有一个是copy_if。</p>
<ul>
<li>copy</li>
<li>copy_backward replace_copy</li>
<li>reverse_copy</li>
<li>replace_copy_if</li>
<li>unique_copy</li>
<li>remove_copy</li>
<li>rotate_copy remove_copy_if</li>
<li>partial_sort_copy</li>
<li>unintialized_copy</li>
</ul>
<p>如果你只是简单地想要拷贝一个区间中满足某个判断式的元素，你只能自己做。</p>
<h2 id="自己实现">自己实现</h2>
<p>假设你有一个函数来决定一个Widget是否有缺陷的：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isDefective</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>而且你希望把一个vector中所有有缺陷的Widget写到cerr。如果存在copy_if，你可以简单地这么做：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">widgets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这无法编译：STL中并没有copy_if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">copy_if</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">isDefective</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一个不很正确的copy_if实现</strong></p>
<p>这里有一个合理的看待copy_if：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OutputIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">OutputIterator</span> <span class="n">copy_if</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">,</span> <span class="n">OutputIterator</span> <span class="n">destBegin</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nf">remove_copy_if</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">destBegin</span><span class="p">,</span> <span class="n">not1</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然STL并没有让你说“拷贝每个判断式为true的东西”，但它的确让你说了“拷贝除了判断式不为true以外的每个东西”。</p>
<p>要实现copy_if，似乎我们需要做的就只是加一个not1在我们希望传给copy_if的判断式前面，然后把这个结果判断式传给remove_copy_if，结果就是上面的代码。</p>
<p>如果上面的理由有效，我们就可以用这种方法写出有缺陷的Widget：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 不会编译的善意代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">copy_if</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span>  <span class="n">isDefective</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你的STL平台将会敌视这段代码，因为它试图对isDefective应用not1（这个应用出现在copy_if内部）。</p>
<p><strong><code>not1</code>不能直接应用于一个函数指针，函数指针必须先传给ptr_fun。要调用这个copy_if实现，你必须传递的不仅是一个函数对象，而且是一个可适配的函数对象。</strong></p>
<p>标准STL算法从来不要求它们的仿函数是可适配的，copy_if也不应该要求。</p>
<h2 id="正确的实现">正确的实现</h2>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OutputIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">OutputIterator</span> <span class="n">copy_if</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">end</span><span class="p">,</span> <span class="n">OutputIterator</span> <span class="n">destBegin</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span><span class="n">destBegin</span><span class="o">++</span> <span class="o">==</span> <span class="o">*</span><span class="n">begin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">begin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">destBegin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Effective STL 精读总结 [7] | 在程序中使用STL</title><link>https://jianye0428.github.io/posts/partseven/</link><pubDate>Mon, 28 Aug 2023 07:58:09 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partseven/</guid><description><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-STL总结系列分为七部分，本文为第七部分，涉及原书第七章，内容范围Rule43~50。为方便书写，Rule43简写为R43。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-STL系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<h2 id="r43-算法调用优先于手写的循环">R43 算法调用优先于手写的循环</h2>
<p>调用算法优于手写循环：</p>
<ul>
<li>效率：<strong>算法</strong>比手写的循环<strong>效率更高</strong>。</li>
<li>正确性：手写循环比使用算法容易出错。</li>
<li>可维护性：使用算法的代码更加简洁明了。</li>
</ul>
<p>例子：P155，</p>
<p>算法的名称表明了它的功能，而 for、while、do 循环不能。</p>
<p>手写循环需要维护迭代器的有效性。</p>
<h2 id="r44-容器的成员函数优先于同名的算法">R44 容器的成员函数优先于同名的算法</h2>
<p>原因:</p>
<ol>
<li>成员函数往往速度快。</li>
<li>成员函数通常与容器结合得更加紧密。（同样的名称做不同的事情）</li>
</ol>
<p>对于 map 和 multimap 而言:</p>
<ol>
<li>成员函数可以获得对数时间的性能。</li>
<li>成员函数的相同是等价，而算法是相等。</li>
<li>它们的成员函数只统计检查每个 pair 对象的键部分。而算法同时检查键和值/(key,value)对。</li>
</ol>
<p>对于 list 而言，list 成员函数只是简单地维护指针，可以提供更好的性能。list 的 remove、remove_if、unqiue 则实实在在的删除了元素。sort 算法不能直接应用于 list，因为 sort 需要随机访问迭代器，而 list 的迭代器是双向迭代器。</p>
<h2 id="r45-正确区分countfindbinary_searchlower_boundupper_bound和equal_range">R45 正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</h2>
<ol>
<li>假设你要在容器中查找一些信息，标题列出的几个函数应该怎么选择呢？首先应该考虑区间是否是排序的，如果是排序的，则binary_search、lower_bound、upper_bound和equal_range具有更快的查找速度，如果不是排序的，那么你只能选择count、count_if、find、find_if，这些算法仅提供线性时间的查找效率。但是这些函数还是有区别的，count、count_if、find、find_if使用相等性进行查找，binary_search、lower_bound、upper_bound和equal_range使用等价性进行查找。</li>
<li>考虑count和find的区别，count表示区间是否存在待查找的值，如果存在有多少个？find表示区间是否存在待查找的值，如果存在它在哪里？假设你只想知道区间中是否存在待查找的值，如果是使用count会更方便一些，因为使用find还需要比较find返回的指针是否是容器的end()，但是因为find找到第一个符合查找的值就会返回，count一定会遍历到容器的末尾，所以find的效率更高。</li>
<li>当你的区间是排序的，那么你就可以使用对数时间查找的四种方法。与标准C/C++函数库中的bsearch不同的是，binary_search仅判断区间是否存在待查找的值（返回值是bool），如果你还想知道待查找值得位置，可以使用其他三种方法，先考虑lower_bound，lower_bound查找特定值会返回一个迭代器，同样你需要判断这个迭代器的结果，除了要判断这个迭代器是否是end()，还要判断其指向的值是否是待查找的值，所以很多人会这么写：</li>
</ol>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">i</span> <span class="o">==</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span><span class="c1">//这里有一个错误
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里<code>*i == w</code>是一个相等性测试，但是lower_bound使用等价性进行搜索的，虽然大多数情况下等价性测试和相等性测试的结果相同，但是条款19也说明了违背这个情况也很常见，所以正确也更方便的方式是使用equal_range，equal_range会返回一对迭代器，第一个迭代器等于lower_bound返回的迭代器，第二个迭代器等于upper_bound返回的迭代器，equal_range返回了一个子区间，其中的值与待查找的值等价，如果返回的两个迭代器相同，等说明查找的区间没有待查找的值，而子区间的长度就是等价值的个数，可以使用distance得到。</p>
<ol start="4">
<li>再考虑lower_bound和upper_bound的使用场景，这次我不是希望查找某个元素，而是想找到第一个比特定值大的元素的位置，这个特定值可能不在容器中，那么可以使用lower_bound，如果希望找到第一个大于或等于特定值的元素的位置，那么可以使用upper_bound。</li>
</ol>
<h2 id="r46-考虑使用函数对象而不是函数作为-stl-算法的参数">R46 考虑使用函数对象而不是函数作为 STL 算法的参数</h2>
<ol>
<li>第一个原因是因为效率。随着抽象程度的提高，所生成代码的效率是在降低的，比如几乎在所有情况下，操作包含一个double的对象比直接操作double都是要慢的，但是可能令你感到惊讶的是，将函数对象传递给STL算法往往比传递函数更加高效。比如说你想生成一个降序排列的vector<double>，你可以使用函数对象，即greater<double>，也可以使用一个自定义的比较函数，而第一种情况往往是更快的，这是因为如果一个函数对象的operator()函数被声明是内联的（可以通过inline显式声明，也可以定义在类中隐式声明），那么它的函数体可被编译器直接优化，但是传递函数指针则不行，编译器不能优化。
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">doubleGreater</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>使用<code>greater&lt;double&gt;()</code>的sort调用比使用<code>doubleGreater</code>的 sort 调用快得多。原因：<strong>函数内联，sort 不包含函数调用</strong>。
抽象性利益：C++ 的 sort 算法性能总是优于 C 的 qsort。在运行时，sort 算法以内联方式调用它的比较函数，而 qsort 则通过函数指针调用它的比较函数。
使用函数对象，可以让你的程序正确地通过编译，避免语言本身的缺陷。
2. 第二个原因是正确性，有的时候STL平台会拒绝一些完全合法的代码，如下：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//完全合法的代码但是不能通过编译
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">transform</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">mem_fun_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="o">::</span><span class="n">size</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//可以改用函数对象的形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">stringSize</span> <span class="o">:</span> <span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="r47-避免产生-直写型-write-only的代码">R47 避免产生 “直写型” （write only）的代码</h2>
<p>所谓”直写型“的代码是指一行代码中有过于复杂的嵌套函数调用，可能对于编写代码的人，这行代码看似非常直接和简单，但是对于阅读代码的人则显得难以理解。所以在遇到这种写出“直写型”代码时，应该将其拆分成多行代码，或者使用typedef起别名的形式，让代码更易于阅读。</p>
<h2 id="r48-总是包含include正确的头文件">R48 总是包含（#include）正确的头文件</h2>
<p>有的时候即使漏掉了必要的头文件，程序同样可以编译，这是因为C++标准并没有规定标准库中头文件之间的相互包含关系，这就导致了某个头文件包含了其他头文件，如<vector>包含了<string>。但是这种程序往往是不可移植的，即使在你的平台上可以编译，但是在其他平台上就可能会编译不过，所以解决此类问题的一条原则就是总是include必要的头文件</p>
<h2 id="r49-学会分析与-stl-相关的编译器诊断信息">R49 学会分析与 STL 相关的编译器诊断信息</h2>
<p>在程序编译或者运行出错时，有时编译器给出的诊断信息非常混乱和难以阅读。对于这些信息可以使用同义词替换的方法进行简化，比如说将std::basic_string&lt;&gt;替换成string，将std::map&lt;&gt;替换成map，将看不懂的STL内部模板std::_Tree替换成something</p>
<h2 id="r50-熟悉与-stl-相关的-web-站点">R50 熟悉与 STL 相关的 web 站点</h2>
<p><a href="http://www.sgi.com/tech/stl"target="_blank" rel="external nofollow noopener noreferrer">SGI STL 站点<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
<a href="http://www.stlport.org/"target="_blank" rel="external nofollow noopener noreferrer">STLport 站点<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
<a href="http://www.boost.org/"target="_blank" rel="external nofollow noopener noreferrer">Boost 站点<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>Ref:</br>
[1]. htTps://www.cnblogs.com/Sherry4869/p/15162253.html</br>
[2]. <a href="https://blog.csdn.net/zhuikefeng/article/details/108164117#t35"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/zhuikefeng/article/details/108164117#t35<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
[3]. <a href="https://zhuanlan.zhihu.com/p/458156007"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/458156007<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></p>
]]></description></item><item><title>KL Divergence 详解</title><link>https://jianye0428.github.io/posts/kldivergence/</link><pubDate>Sat, 26 Aug 2023 13:59:37 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/kldivergence/</guid><description><![CDATA[<h2 id="一-基本定义">一、 基本定义</h2>
<p>假设给定事件 $x$, 则我们有以下定义:</p>
<ol>
<li><strong>Probability:</strong>
取值0~1</li>
</ol>
<p>$$p(x) 或 q(x)$$</p>
<ol start="2">
<li>
<p><strong>Information:</strong>
对$p(x)$取对数，加符号得正值
$$I(p)=-\log p(x)$$
概率越高，包含的信息小，因为事件越来越确定。相反，概率越低，包含的信息越多，因为事件具有很大的不确定性。</p>
</li>
<li>
<p><strong>(Shannon)Entropy(信息熵):</strong></p>
</li>
</ol>
<p>$p(x)$对$I(x)$ 平均
$$
\begin{aligned}
H(p)&amp; =\mathbb{E}_{x\sim P}[I(p)]  \
&amp;=\sum p(x)I(p) \
&amp;=-\sum p(x)\log p(x)
\end{aligned}
$$
熵是信息的平均，直观上，Shannon熵是信息在<strong>同一分布</strong>下的平均。</p>
<p>KL散度来源于信息论，信息论的目的是以信息含量来度量数据。信息论的核心概念是信息熵(Entropy)，使用H来表示。概率论中概率分布所含的信息量同样可以使用信息熵来度量。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">对于任意概率事件，由于其概率$p(x) \geq 0$ 且 $p(x) \leq 0$, 因此 $H(p) \geq 0$.</div>
    </div>
  </div>
<ol start="4">
<li>
<p><strong>Cross-Entropy:</strong>
$p(x)$对$I(q)$平均:
$$
\begin{aligned}
H(p,q)&amp; =\mathbb{E}_{x\sim P}[I(q)]  \
&amp;=\sum p(x)I(q) \
&amp;=-\sum p(x)\log q(x)
\end{aligned}
$$
熵是信息的平均，直观上，交叉熵是信息在不同分布下的平均。</p>
</li>
<li>
<p><strong>KL divergence(Relative entropy/Information gain):</strong>
$$
\begin{aligned}
D_{KL}(p||q)&amp; =H(p,q)-H(p)  \
&amp;=-\sum p(x)\log q(x)+\sum p(x)\log p(x) \
&amp;=-\sum p(x)\log\frac{q(x)}{p(x)} \
&amp;=\sum p(x)\log\frac{p(x)}{q(x)}
\end{aligned}
$$</p>
<ul>
<li>相对熵 = 交叉熵 - shannon熵</li>
<li>非对称$D_{KL}(p||q)\neq D_{KL}(q||p)$，亦不满足三角不等式，故不是距离。</li>
<li>$D_{KL}(p||q)$为$p$相对于$q$，值非负，取零若$p=q$。从公式上看，就是拿$q$替代$p$后熵的变化。</li>
<li>$KL = Kullback-Leibler$</li>
</ul>
</li>
</ol>
<p>所谓KL散度，是指当某分布q(x)被用于近似p(x)时的信息损失。</p>
<p>$$
D(p||q)=\sum_{x\in X}p(x)\log\frac{p(x)}{q(x)}
$$
也就是说，q(x)能在多大程度上表达p(x)所包含的信息，KL散度越大，表达效果越差。</p>
<h2 id="二-kl-divergence-一些性质非正式证明">二、 KL divergence 一些性质（非正式）证明</h2>
<ol>
<li>
<p>非对称性
$$
D_{KL}(p||q)-D_{KL}(q||p)=\sum\left(p(x)+q(x)\right)\log\frac{p(x)}{q(x)}
$$
易知，当$p(x) \neq q(x)$时，上式不为0。故，$D_{KL}(p||q)$和$D_{KL}(q||p)$非对称，是不同的。（此部分侧重于说明它们不是不同的）</p>
</li>
<li>
<p>非负性
$$
\begin{aligned}
-D_{KL}(p||q)&amp; =\sum p(x)\log\frac{q(x)}{p(x)}  \cr
&amp;\leq\log\sum p(x)\frac{q(x)}{p(x)} \cr
&amp;=\log1 \cr
&amp;=0
\end{aligned}
$$
其中，不等式部分使用了<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Jensen%2527s_inequality"target="_blank" rel="external nofollow noopener noreferrer">Jensen&rsquo;s inequality<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
<li>
<p>凹性
$$
\begin{aligned}
&amp;D_{KL}[\lambda p_1(x)+(1-\lambda)p_2(x)||\lambda q_1(x)+(1-\lambda)q_2(x)] \cr
&amp;=\sum\left[\lambda p_1(x)+(1-\lambda)p_2(x)\right]\log\frac{[\lambda p_1(x)+(1-\lambda)p_2(x)]}{[\lambda q_1(x)+(1-\lambda)q_2(x)]} \cr
&amp;\leq\sum\left[\lambda p_1(x)\log\frac{\lambda p_1(x)}{\lambda q_1(x)}+(1-\lambda)p_2(x)\log\frac{(1-\lambda)p_2(x)}{(1-\lambda)q_2(x)}\right] \cr
&amp;=\lambda\sum p_1(x)\log\frac{p_1(x)}{q_1(x)}+(1-\lambda)\sum p_2(x)\log\frac{p_2(x)}{q_2(x)} \cr
&amp;=\lambda D_{KL}[p_1(x)||q_1(x)]+(1-\lambda)D_{KL}[p_2(x)||q_2(x)]
\end{aligned}
$$</p>
</li>
</ol>
<p>其中，不等式部分用到了<a href="https://link.zhihu.com/?target=https%3A//statproofbook.github.io/P/logsum-ineq"target="_blank" rel="external nofollow noopener noreferrer">log sum inequality<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="三最小化kl-divergence目标函数">三、最小化KL divergence目标函数</h2>
<p>为了方便说明，我们基于定义在某个空间$X$上的分布$P$和$Q$来重写一下KL， 如下所示：
$$
D_{KL}(P||Q)=\mathbb{E}_{x\sim P}[\log\frac{P(X)}{Q(X)}]
$$</p>
<p>假设，$P$为真实的分布函数，我们想要用带参数 $\theta$ 的分布函数 $Q$，即 $Q_{\theta}$ ，去近似。也就是说，通过选取参数$\theta$， 让 $Q_{\theta}$ 和 $P$ 在某种意义上具有相似性。下面，我们分别将选取正向KL和反向KL做为目标函数进行说明。为了方便，我们假设 $P$ 为双峰分布，$Q_{\theta}$ 为正太分布，故 $\theta$ 包含均值和方差两个参数。</p>
<p></p>
<ol>
<li>最小化正向KL目标函数
目标函数如下：
$$
\begin{aligned}
&amp;\arg\min_{\theta}D_{KL}(P||Q_{\theta}) \cr
&amp;=\arg\min_\theta\mathbb{E}<em>{x\sim P}[\log\frac{P(X)}{Q(X)}] \cr
&amp;=\arg\min</em>\theta\mathbb{E}<em>{x\sim P}[-\log Q</em>\theta(X)]-H[P(X)] \cr
&amp;=\arg\min_\theta\mathbb{E}<em>{x\sim P}[-\log Q</em>\theta(X)] \cr
&amp;=\arg\max_\theta\mathbb{E}<em>{x\sim P}[\log Q</em>\theta(X)]
\end{aligned}
$$
从此处可以看出最小化正向KL目标函数，其实是等价于通过 $Q_{\theta}$ 进行最大似然估计。也就是说，数据 $x$ 由 $P$ 产生，基于这些数据，我们选取 $\theta$ 让平均在 $P(X)$ 上的 $\log Q_{\theta}(X)$ 似然函数最大，即:</li>
</ol>
<p><strong>平均P(X)各个峰太，P(X)概率高的地方，$Q_{\theta}(X)$ 概率也要高</strong></p>
<p>所以我们有下图mean-seeking的结果</p>
<p></p>
<p>(你也可以从信息/熵的角度去理解，道理是一样的)</p>
<ol start="2">
<li>最小化反向KL目标函数
目标函数如下：</li>
</ol>
<p>$$
\begin{aligned}
&amp;\arg\min_{\theta}D_{KL}(Q_{\theta}||P) \cr
&amp;=\arg\min_\theta\mathbb{E}<em>{x\sim Q</em>\theta}[\log\frac{Q_\theta}{P(X)}] \cr
&amp;=\arg\min_\theta\mathbb{E}<em>{x\sim Q</em>\theta}[-\log P(X)]-H[Q_\theta(X)] \cr
&amp;=\arg\max_\theta\mathbb{E}<em>{x\sim Q</em>\theta}\left[\log P(X)\right]+H[Q_\theta(X)]
\end{aligned}
$$</p>
<p>此时，我们需要选取参数 $\theta$，让平均在 $Q_{\theta}(X)$ 上的 $\log P(X)$ 似然函数最大;同时，让Shannon熵 $H(Q_{\theta}(X))$
也比较大，即约束 $Q_{\theta}(X)$ 不要过于集中。总的来看，我们有：</p>
<p><strong>平均 $Q_{\theta}(X)$ 各个峰太，$Q_{\theta}(X)$ 概率高的地方，$P(X)$ 概率也要高，但 $Q_{\theta}(X)$ 不能过于集中</strong></p>
<p>可以想象，如果没有 $H[Q_{\theta}(X)]$ 的约束，可能会调整 $\theta$，让 $Q_{\theta}(X)$ 集中于 $P(X)$ 最大的地方，得到的值也会比较大。所以，$H[Q_{\theta}(X)]$ 起到了一个正则化（regularization）的效果。</p>
<p>所以我们有下图mode-seeking 的结果:</p>
<p></p>
<p>正向最小化和反向最小化放在一起对比：</p>
<p></p>
<p>正向和反向最小化 此部分代码来自参考文献3，但在调用logsumexp时，有点问题，故做了一个微小改动，代码放在微信公众号MoData文章最后，如果感兴趣，<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg4NDY5NTk5NA%3D%3D%26amp%3Bmid%3D2247483795%26amp%3Bidx%3D1%26amp%3Bsn%3D25f1bcf1e725090c22fcf37d181e875e%26amp%3Bchksm%3Dcfb57746f8c2fe50ffefbd47620e447542d43639774fb8f462c97c4953643238e62619db81ba%26token%3D1055919935%26lang%3Dzh_CN%23rd"target="_blank" rel="external nofollow noopener noreferrer">点击此处<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
<p><strong>相关参考资料</strong>
[1]. Cover, T. M., and J. A. Thomas. &ldquo;Elements of Information Theory,(2nd edn, 2006).&rdquo; DOI: https://doi. org/10.1002 X 47174882 (2006).
[2]. <a href="https://dibyaghosh.com/blog/probability/kldivergence.html"target="_blank" rel="external nofollow noopener noreferrer">https://dibyaghosh.com/blog/probability/kldivergence.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[3]. <a href="https://www.tuananhle.co.uk/notes/r"target="_blank" rel="external nofollow noopener noreferrer">https://www.tuananhle.co.uk/notes/r<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>ref:
[1]. <a href="https://zhuanlan.zhihu.com/p/425693597"target="_blank" rel="external nofollow noopener noreferrer">KL-Divergence详解<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[2]. <a href="https://www.zhihu.com/tardis/zm/art/95687720?source_id=1005"target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/tardis/zm/art/95687720?source_id=1005<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[3]. <a href="http://hanj.cs.illinois.edu/cs412/bk3/KL-divergence.pdf"target="_blank" rel="external nofollow noopener noreferrer">http://hanj.cs.illinois.edu/cs412/bk3/KL-divergence.pdf<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[4]. <a href="https://zhuanlan.zhihu.com/p/372835186"target="_blank" rel="external nofollow noopener noreferrer">KL 进阶<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [34] | 注意哪个算法需要有序区间</title><link>https://jianye0428.github.io/posts/clause_34/</link><pubDate>Sat, 26 Aug 2023 10:55:58 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_34/</guid><description><![CDATA[<p>不是所有算法可以用于任意区间。比如，<strong>remove需要前向迭代器和可以通过这些迭代器赋值的能力</strong>。所以，它不能应用于由输入迭代器划分的区间，也不能是map或multimap，也不能是set和multiset的一些实现。</p>
<p>同样，<strong>很多排序算法需要随机访问迭代器</strong>，所以不可能在一个list的元素上调用这些算法。</p>
<p>最常见的就是一些算法<strong>需要有序值的区间</strong>。无论何时都应该坚持这个需求，因为冒犯它不仅会导致编译器诊断，而且会造成未定义的运行期行为。</p>
<p>既可以和有序又可以和无序区间合作的算法很少，但<strong>当操作有序区间的时候它们最有用</strong>。</p>
<h2 id="只能操作有序数据的算法的表">只能操作有序数据的算法的表</h2>
<ul>
<li>binary_search</li>
<li>lower_bound</li>
<li>upper_bound</li>
<li>equal_range</li>
<li>set_union</li>
<li>set_intersection</li>
<li>set_difference</li>
<li>set_symmetric_difference</li>
<li>merge</li>
<li>inplace_merge</li>
<li>includes</li>
</ul>
<h2 id="一般用于有序区间但不强制要求">一般用于有序区间，但不强制要求</h2>
<ul>
<li>unique</li>
<li>unique_copy</li>
</ul>
<h2 id="binary_searchlower_boundupper_bound和equal_range"><code>binary_search</code>、<code>lower_bound</code>、<code>upper_bound</code>和<code>equal_range</code></h2>
<p>搜索算法binary_search、lower_bound、upper_bound和equal_range需要<strong>有序区间</strong>，因为它们<strong>使用二分法查找来搜索</strong>值。像C库中的bsearch，这些算法保证了<strong>对数时间的查找</strong>，但作为交换的是，你必须给它们已经排过序的值。</p>
<p>实际上，仅当传给它们的是随机访问迭代器时它们才能保证有那样的性能。</p>
<p>如果给它们威力比较小的迭代器（比如双向迭代器），它们仍然进行对数次比较，但运行是线性时间的。那是因为，缺乏进行“<strong>迭代器算术（arithmetic）</strong>”的能力。它们在搜索的区间中需要花费线性时间来从一个地方移动到另一个地方。</p>
<h2 id="unionset_intersectionset_difference和set_symmetric_difference"><code>union</code>、<code>set_intersection</code>、<code>set_difference</code>和<code>set_symmetric_difference</code></h2>
<p>算法<code>set_union</code>、<code>set_intersection</code>、<code>set_difference</code>和<code>set_symmetric_difference</code>的四人组提供了线性时间设置它们名字所提出的操作的性能。</p>
<p>为什么它们需要有序区间？因为如果不是的话，它们不能以线性时间完成它们的工作。</p>
<p>你会发现，<strong>需要有序区间的算法为了比它们用于可能无序区间提供更好的性能而这么做</strong>。</p>
<h2 id="merge和inplace_merge">merge和inplace_merge</h2>
<p>merge和inplace_merge执行了有效的单遍合并排序算法：它们读取两个有序区间，然后产生一个包含了两个源区间所有元素的新有序区间。</p>
<p>它们以线性时间执行，如果它们不知道源区间已经有序就不能完成。</p>
<h2 id="includes">includes</h2>
<p>includes 用来检测是否一个区间的所有对象也在另一个区间中。</p>
<p>因为includes可能假设它的两个区间都已经有序，所以它保证了线性时间性能。没有那个保证，一般来说它会变慢。</p>
<h2 id="unique和unique_copy">unique和unique_copy</h2>
<p>unique和unique_copy甚至在无序区间上也提供了定义良好的行为。</p>
<p>看看标准是怎么描述unique的行为的：</p>
<blockquote>
<p>从每个相等元素的连续组中去除第一个以外所有的元素。</p>
</blockquote>
<p>如果你要unique从一个区间去除所有重复值（也就是，让区间中所有值“唯一”），你必须先确保所有重复值一个接着一个。那是排序完成的东西之一。</p>
<p>实际上，unique一般用于从区间中去除所有重复值，所以你几乎总是要确保你传递给unique（或unique_copy）的区间是有序的。Unix开发者会发现STL的unique和Unix的uniq之间有惊人的相似。</p>
<p>顺便说说，unique从一个区间除去元素的方式和remove一样，也就是说它只是区分出不除去的元素。</p>
<h2 id="排序">排序</h2>
<p>因为STL允许你指定用于排序的比较函数，<strong>不同的区间可能以不同的方式排序</strong>。</p>
<p>比如，给定两个int的区间，一个可能以默认方式排序（也就是升序），而另一个使用<code>greater&lt;int&gt;</code>排序，因此是降序。</p>
<p>给定Widget的两个区间，一个可能以价格排序而另一个可能以年龄排序。因为有很多不同的方式来排序，所以保证给STL所使用的排序相关信息一致是很重要的。</p>
<p><strong>如果你传一个区间给一个也带有比较函数的算法，确保你传递的比较函数行为和你用于排序这个区间的一样。</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector，把一些数据放进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">// 降序排列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用这个vector（没有改变它）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在这个vector中搜索5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">is3Exists</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 假设它是升序排列！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下，binary_search假设它搜索的区间是以“&lt;”排序（也就是，值是升序），但在本例中，这个vector是降序。当你在值的排列顺序和算法所期望的不同的区间上调用binary_search (或lower_bound等）会导致未定义的结果。</p>
<h3 id="正确排序方式">正确排序方式</h3>
<p>要让代码行为正确，你必须告诉binary_search要使用和sort同样的比较函数：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">is3Exists</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 搜索3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 比较函数把greater作为
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=blue>所有需要有序区间的算法（也就是除了unique和unique_copy外本条款的所有算法）通过等价来判断两个值是否“相同”，就像标准关联容器（它们本身是有序的）。相反，unique和unique_copy判断两个对象“相同”的默认方式是通过相等</font>，但是你可以通过传给这些算法一个定义了“相同”的意义的判断式来覆盖这个默认情况。</p>
<h2 id="总结">总结</h2>
<p>11个需要有序区间的算法为了比其他可能性提供更好的性能而<font color=blue>需要传给它们有序区间，需要保证用于算法的比较函数和用于排序的一致</font>。</p>
]]></description></item><item><title>Effective STL [33] | 提防在指针的容器上使用类似remove的算法</title><link>https://jianye0428.github.io/posts/clause_33/</link><pubDate>Sat, 26 Aug 2023 10:55:54 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_33/</guid><description><![CDATA[<h2 id="删除含有指针的容器元素">删除含有指针的容器元素</h2>
<p>如果你在管理一堆动态分配的Widgets，每一个都可能通过检验，你把结果指针保存在一个vector中：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个Widget是否通过检验
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isCertified</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector然后用动态分配的Widget的指针填充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当和v工作一段时间后，你决定除去未通过检验的Widget，因为你不再需要它们了。</p>
<p><strong>尽量用算法调用代替显式循环和关于remove和erase之间关系的描述</strong>，你自然会想到转向erase-remove惯用法，虽然这次你使用了remove_if：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 删除未通过检验的Widget指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">not1</span><span class="p">(</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">isCertified</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 关于mem_fun的信息参见条款41
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>条款7介绍过摧毁容器中的一个指针也不会删除指针指向的东西的讨论，所以这里当调用erase时，极可能你已经泄漏了资源。</p>
<h2 id="资源泄露分析">资源泄露分析</h2>
<p>我们假设在调用remove_if前，v看起来像这样：</p>
<p></p>
<p>在调用remove_if后，一般来说v看起来像这样（包含从remove_if返回的迭代器）：</p>
<p></p>
<p>资源泄漏的理由现在很明朗了。指向Widget B和C的“删除的”指针被vector中后面的“不删除的”指针覆盖。没有什么指向两个未通过检验的Widget，它们也没有被删除，它们的内存和其他资源泄漏了。</p>
<p>一旦remove_if和erase返回后，情况看起来像这样：</p>
<p></p>
<p>现在你也很清楚为什么应该努力避免在动态分配的指针的容器上使用remove和类似算法（remove_if和unique）。</p>
<p>在很多情况下，你会发现<strong>partition算法是合理的替代品</strong>。</p>
<h2 id="正确删除做法">正确删除做法</h2>
<p>如果你无法避免在那样的容器上使用remove，排除这个问题一种方法是在<strong>应用erase-remove惯用法之前先删除指针并设置它们为空，然后除去容器中的所有空指针</strong>：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">delAndNullifyUncertified</span><span class="p">(</span><span class="n">Widget</span> <span class="o">*&amp;</span><span class="n">pWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果*pWidget是一个未通过检验Widget，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pWidget</span><span class="o">-&gt;</span><span class="n">isCertified</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 删除指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">delete</span> <span class="n">pWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 并且设置它为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pWidget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 把所有指向未通过检验Widget的指针删除并且设置为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">delAndNullifyUncertified</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 从v中除去空指针0必须映射到一个指针，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">               <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">*&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 让C++可以正确地推出remove的第三个参数的类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，这假设vector并不容纳任何你想保留的空指针。如果有的话，你可能必须自己写循环来按你的方式删除指针。</p>
<h3 id="智能指针">智能指针</h3>
<p>如果你把指针的容器替换成<strong>执行引用计数的智能指针的容器</strong>，删除相关的困难就不存在了，你可以直接使用erase-remove惯用法：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RCSP = “引用计数智能指针”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">RCSP</span> <span class="p">{</span> <span class="p">...};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RCSPW = “RCSP to Widget”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">RCSP</span><span class="o">&lt;</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">RCSPW</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector，用动态分配Widget的智能指针填充它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RCSPW</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">RCSPW</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// erase未通过检验的Widget的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">  <span class="n">not1</span> <span class="p">(</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">isCertified</span><span class="p">))),</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 没有资源泄漏
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要让这些工作，你的<strong>智能指针类型就必须可以（比如<code>RCSP&lt;Widget&gt;</code>）隐式转换为相应的内建指针类型（比如<code>Widget*</code>）</strong>。那是因为容器持有智能指针，但被调用的成员函数（比如<code>Widget::isCertified</code>）要的是内建指针。如果不存在隐式转换，你的编译器会抗议的。</p>
]]></description></item><item><title>Effective STL [32] | 如果你真的想删除东西的话就在类似remove的算法后接上erase</title><link>https://jianye0428.github.io/posts/clause_32/</link><pubDate>Sat, 26 Aug 2023 10:55:50 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_32/</guid><description><![CDATA[<h2 id="remove实际作用">remove实际作用</h2>
<h3 id="remove的声明">remove的声明</h3>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ForwardIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardIterator</span> <span class="n">remove</span><span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>remove接收指定它操作的元素区间的一对迭代器。它不接收一个容器，所以<strong>remove不知道它作用于哪个容器</strong>。</p>
<p>此外，remove也不可能发现容器，因为没有办法从一个迭代器获取对应于它的容器。</p>
<h3 id="remove不做什么">remove不做什么</h3>
<p>从容器中除去一个元素，唯一的方法是调用那个容器的一个成员函数，几乎都是erase的某个形式，(list有几个除去元素的成员函数不叫erase，但它们仍然是成员函数。)因为唯一从容器中除去一个元素的方法是在那个容器上调用一个成员函数，而且因为remove无法知道它正在操作的容器，所以remove不可能从一个容器中除去元素。</p>
<p>从一个容器中remove元素不会改变容器中元素的个数：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立一个vector&lt;int&gt; 用1-10填充它(调用reserve的解释在条款14)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 打印10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设置3个元素为99
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">);</span> <span class="c1">// 删除所有等于99的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// 仍然是10！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=blue>remove并不“真的”删除东西，因为它做不到。</font></p>
<p><strong>remove不知道它要从哪个容器删除东西，而没有容器，它就没有办法调用成员函数。</strong></p>
<h3 id="remove-做了什么">remove 做了什么</h3>
<p>remove移动指定区间中的元素直到所有“不删除的”元素在区间的开头(相对位置和原来它们的一样)。它返回一个指向最后一个的下一个“不删除的”元素的迭代器。返回值是区间的“新逻辑终点”。</p>
<p>举个例子，这是v在调用remove前看起来的样子：</p>
<p></p>
<p>如果我们把remove的返回值存放在一个叫做newEnd的新迭代器中:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">newEnd</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是调用后v看起来的样子:</p>
<p></p>
<p>如果“不删除的”元素在v中的v.begin()和newEnd之间，“删除的”元素就必须在newEnd和v.end()之间。</p>
<p><strong>remove并没有改变区间中元素的顺序，所以不会把所有“删除的”元素放在结尾，并安排所有“不删除的”值在开头。</strong></p>
<p>如果你不想失去任何值，你可能应该调用partition或stable_partition而不是remove。</p>
<h3 id="remove-实际操作流程">remove 实际操作流程</h3>
<p>在内部，remove遍历这个区间，把要“删除的”值覆盖为后面要保留的值。这个覆盖通过对持有被覆盖的值的元素赋值来完成。</p>
<ol>
<li>remove检测v[0]，发现它的值不是要被删除的，然后移动到v[1]。同样的情况发生在v[1]和v[2]。</li>
<li>发现v[3]应该被删除，所以它记录下v[3]的值应该被覆盖，然后它移动到v[4]。这类似记录v[3]是一个需要填充的“洞”。</li>
<li>发现v[4]的值应该被保持，所以它把v[4]赋给v[3]，记录下v[4]应该被覆盖，然后移动到v[5]。继续类似的压缩，它用v[4]“填充”v[3]而且记录v[4]现在是一个洞。</li>
<li>发现v[5]应该被删除，所以忽略并它移动到v[6]。仍然记得v[4]是一个等待填充的洞。</li>
<li>发现v[6]是一个应该保留的值，所以把v[6]赋给v[4]。记得v[5]现在是下一个要被填充的洞，然后移到v[7]。</li>
<li>在某种意义上类似上面的，检查v[7]、v[8]和v[9]。把v[7]赋给v[5]，v[8]赋给v[6]，忽略v[9]，因为v[9]的值是要被删除的。</li>
<li>返回指定下一个要被覆盖的元素的迭代器，在这个例子中这个元素是v[7]。</li>
</ol>
<p></p>
<p>事实上当remove在删除时覆盖的值是指针时，会有重要的影响。但是对于本条款，知道remove不从容器中除去任何元素因为它做不到就够了。</p>
<h2 id="应该在remove后面接上erase">应该在remove后面接上erase</h2>
<p>只有容器成员函数可以除去容器元素，而那是本条款的整个要点：<strong>如果你真的要删除东西的话，你应该在remove后面接上erase</strong>。</p>
<p>要除去那些元素，你要做的所有事情就是用那两个迭代器调用erase的区间形式。因为remove本身很方便地返回了区间新逻辑终点的迭代器:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正如从前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">99</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 真的删除所有等于99的元素，现在返回7
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>事实上，remove和erase是亲密联盟，这两个整合到list成员函数remove中。这是STL中唯一名叫remove又能从容器中除去元素的函数：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">li</span><span class="p">;</span>  <span class="c1">// 建立一个list放一些值进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">li</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">99</span><span class="p">);</span> <span class="c1">// 除去所有等于99的元素：真的删除元素，所以它的大小可能改变了
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用这个remove函数是一个STL中的矛盾。在关联容器中类似的函数叫erase，list的remove也可以叫做erase。但它没有，所以我们都必须习惯它。</p>
<p><strong>对于list，调用remove成员函数比应用erase-remove惯用法更高效。</strong></p>
<h2 id="类似remove的算法">类似remove的算法</h2>
<p><code>remove_if</code>和<code>unique</code>。 remove和remove_if之间的相似性很直截了当。</p>
<p>unique行为也像remove。它用来从一个区间删除东西(邻近的重复值)而不用访问持有区间元素的容器。如果你真的要从容器中删除元素，你也必须成对调用unique和erase，unique在list中也类似于remove。正像list::remove真的删除东西(而且比erase-remove惯用法高效得多)。</p>
<p><code>list::unique</code>也真的删除邻近的重复值(也比erase-unique高效)。</p>
]]></description></item><item><title>Effective STL [31] | 了解你的排序选择</title><link>https://jianye0428.github.io/posts/clause_31/</link><pubDate>Sat, 26 Aug 2023 10:19:35 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_31/</guid><description><![CDATA[<h2 id="稳定排序-vs-不稳定排序">稳定排序 VS 不稳定排序</h2>
<p>有些排序算法是稳定的。在稳定排序中，如果一个区间中的两个元素有等价的值，它们的相对位置在排序后不改变。不稳定的算法没做这个保证。</p>
<p>例如，在（未排序的）widgets vector中Widget A在Widget B之前，而且两者都有相同的质量等级，那么稳定排序算法会保证在这个vector排序后，Widget A仍然在Widget B之前。</p>
<h2 id="partial_sort"><code>partial_sort</code></h2>
<p>sort是个令人称赞的算法，如果不需要完全排序时，比如有一个存有Widget 的vector，你想选择20个质量最高的Widget发送给客户，20个之外的Widget可以保持无序，也就是你需要的是部分排序，这时就可以用partial_sort。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">qualityCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回lhs的质量是不是比rhs的质量好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把最好的20个元素（按顺序）放在widgets的前端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">partial_sort</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用widgets...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用完partial_sort后，widgets的前20个元素是容器中最好的而且它们按顺序排列，质量最高的Widget是widgets[0]，第二高的是widgets[1]等。</p>
<p>partial_sort是不稳定的。</p>
<h2 id="nth_element">nth_element</h2>
<p>如果你不关心哪个Widget给哪个客户，你需要的只是任意顺序的20个最好的Widget。STL中nth_element可以精确地完成了你需要的。</p>
<p>nth_element排序一个区间，在n位置（你指定的）的元素是如果区间被完全排序后会出现在那儿的元素。</p>
<p><strong>Example</strong></p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">randy</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//默认求第m大的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">randy</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//定义cmp可求第m小的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">randy</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">randy</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>函数是将第 m 大的元素放在 arr 数组数组中适当位置，其他元素按照第 m 元素的大小划分。 在[ 0, n ]这个范围内，在第 m 个元素之前的元素都小于或等于第 m 个元素，而且第 m 个元素后面的每个元素都会比它大。</p>
<p><code>nth_element()</code>函数仅将第 m 大/小的数在 randy 数组中排好了位置，并不返回值。输出 randy[m] 即是第 m 大/小的数。</p>
<p><strong>排序Widget数组</strong></p>
<p>使用nth_element来保证最好的20个Widget在widgets vector的前端：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">nth_element</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">19</span><span class="p">,</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把最好的20个元素放在widgets前端，但不用担心它们的顺序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用nth_element本质上等价于调用partial_sort，两个算法都把20个质量最高的Widget移动到vector前端。</p>
<p>它们结果的唯一区别是partial_sort排序了在位置1-20的元素，而nth_element不排序。</p>
<p><strong>其他用法</strong></p>
<p>除了能帮你找到区间顶部的n个元素，它也可以用于找到区间的中值或者找到在指定百分点的元素：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 迭代器的变量方便地表示widgets的起点和终点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这个迭代器指示了下面代码要找的中等质量等级的Widget的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">goalPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 兴趣的Widget会是有序的vector的中间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">goalPosition</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">widgets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 找到widgets中中等质量等级的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">nth_element</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">goalPosition</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// goalPosition现在指向中等质量等级的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 下面的代码能找到质量等级为75%的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1">// 指出兴趣的Widget离开始有多远
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">goalOffset</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">widgets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 找到质量值为75%的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">nth_element</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">goalOffset</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">qualityCompare</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// begin + goalOffset现在指向质量等级为75%的Widget
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="元素有同样质量">元素有同样质量</h2>
<p>假设有12个元素质量是1级（可能是最好的），15个元素质量是2级（第二好的）。在这种情况下，选择20个最好的Widget就是选择12个1级的和15个中的8个2级的。partial_sort和nth_element怎么判断15个中的哪些要放到最好的20个中？对于这个问题，当多个元素有等价的值时sort怎么判断元素的顺序？</p>
<p>partial_sort和nth_element以任何它们喜欢的方式排序值等价的元素，而且你不能控制它们在这方面行为。</p>
<p>nth_element、sort也没有提供稳定性。</p>
<h2 id="stable_sort">stable_sort</h2>
<p>stable_sort 是稳定排序，STL并不包含partial_sort和nth_element的稳定版本。</p>
<p>当指定范围内包含多个相等的元素时，sort() 排序函数无法保证不改变它们的相对位置。那么，如果既要完成排序又要保证相等元素的相对位置，可以使用stable_sort()函数</p>
<p>stable_sort() 函数完全可以看作是 sort() 函数在功能方面的升级版。stable_sort() 和 sort() 具有相同的使用场景，就连语法格式也是相同的（后续会讲），只不过前者在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">//对 [first, last) 区域内的元素做默认的升序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">stable_sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">stable_sort</span> <span class="p">(</span> <span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;     // std::cout</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;    // std::stable_sort</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // std::vector</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//以普通函数的方式实现自定义排序规则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">randy_comp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//以函数对象的方式实现自定义排序规则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">kim_comp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">jeff_num</span><span class="p">{</span><span class="mi">88</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>  <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 2 13 22 88 1 30 3 33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//利用STL标准库提供greater&lt;T&gt;进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>  <span class="c1">// 88 22 13 2 1 30 3 33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">//通过自定义比较规则进行排序,这里也可以换成 kim_comp()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">randy_comp</span><span class="p">);</span>  <span class="c1">// 1 2 3 13 22 30 33 88
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">jeff_num</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="partition">partition</h2>
<p>但是完全排序需要很多工作，而且对于这个任务做了很多不必要的工作。一个更好的策略是使用partition算法，它重排区间中的元素以使所有满足某个标准的元素都在区间的开头。</p>
<p>比如，移动所有质量等级为2或更好的Widget到widgets前端：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">hasAcceptableQuality</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 返回w质量等级是否是2或更高;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 把所有满足hasAcceptableQuality的widgets移动到widgets前端，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 并且返回一个指向第一个不满足的widget的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">goodEnd</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">hasAcceptableQuality</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此调用完成后，从widgets.begin()到goodEnd的区间容纳了所有质量是1或2的Widget，从goodEnd到widgets.end()的区间包含了所有质量等级更低的Widget。</p>
<p>如果在分割时保持同样质量等级的Widget的相对位置很重要，我们自然会用stable_partition来代替partition。</p>
<p><strong>list排序</strong></p>
<p>唯一我们可能会但不能使用<code>sort</code>、<code>stable_sort</code>、<code>partial_sort</code>或<code>nth_element</code>的容器是<code>list</code>，<code>list</code>通过提供<code>sort</code>成员函数做了一些补偿。（有趣的是，list::sort提供了<u>稳定排序</u>。）</p>
<p>如果你想要对list中的对象进行partial_sort或nth_element，你必须间接完成：</p>
<ol>
<li>把元素拷贝到一个支持随机访问迭代器的容器中，然后对它应用需要的算法;</li>
<li>建立一个list::iterator的容器，对那个容器使用算法，然后通过迭代器访问list元素;</li>
<li>使用有序的迭代器容器的信息来迭代地把list的元素接合到你想让它们所处的位置。</li>
</ol>
<h2 id="总结">总结</h2>
<p><strong>算法sort、stable_sort、partial_sort和nth_element需要随机访问迭代器，所以它们可能只能用于vector、string、deque和数组。</strong></p>
<p>对标准关联容器排序元素没有意义，因为这样的容器使用它们的比较函数来在任何时候保持有序。</p>
<p>partition和stable_partition与sort、stable_sort、partial_sort和nth_element不同，它们只需要双向迭代器。因此你可以在任何标准序列迭代器上使用partition和stable_partition。</p>
<ol>
<li>如果需要在vector、string、deque或数组上进行<strong>完全排序</strong>，你可以使用<code>sort</code>或<code>stable_sort</code>。</li>
<li>如果你有一个vector、string、deque或数组，<strong>只需要排序前n个元素</strong>，应该用<code>partial_sort</code>。</li>
<li>如果你有一个vector、string、deque或数组，<strong>需要鉴别出第n个元素或你需要鉴别出最前的n个元素，而不用知道它们的顺序</strong>，nth_element是你应该注意和调用的。</li>
<li>如果你需要<strong>把标准序列容器的元素或数组分隔为满足和不满足某个标准</strong>，你大概就要找partition或stable_partition。</li>
<li>如果你的数据是在list中，你可以直接使用partition和stable_partition，你可以使用list的sort来代替sort和stable_sort。如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务。</li>
</ol>
<p>你可以通过把数据放在标准关联容器中的方法以<strong>保持在任何时候东西都有序</strong>。你也可能会考虑标准非STL容器priority_queue，它也可以总是保持它的元素有序。</p>
<p>一般来说，<font color=blue>做更多工作的算法比做得少的要花更长时间，而必须稳定排序的算法比忽略稳定性的算法要花更长时间</font>。</p>
<p>本节讨论的算法需要更少资源（时间和空间）的算法排序：</p>
<ol>
<li>partition</li>
<li>partial_sort</li>
<li>stable_partition</li>
<li>sort</li>
<li>nth_element</li>
<li>stable_sort</li>
</ol>
]]></description></item><item><title>Effective STL 精度总结 [6] | 仿函数、仿函数类、函数等</title><link>https://jianye0428.github.io/posts/partsix/</link><pubDate>Tue, 22 Aug 2023 19:22:49 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/partsix/</guid><description><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Effective-STL总结系列分为七部分，本文为第六部分，涉及原书第六章，内容范围Rule38~42。为方便书写，Rule38简写为R38。</p>
</blockquote>
<div class="details admonition Note">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Effective-STL系列List<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">本博客站点系列内容如下：</br>
💡 <a href="https://jianye0428.github.io/posts/partone/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(一)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/parttwo/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(二)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partthree/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(三)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br>
💡 <a href="https://jianye0428.github.io/posts/partfour/"target="_blank" rel="external nofollow noopener noreferrer">Effective STL(第3版)精读总结(四)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></br></div>
    </div>
  </div>
<h2 id="r38-遵循按值传递的原则来设计函数子类">R38: 遵循按值传递的原则来设计函数子类</h2>
<p>函数指针是按值传递的。</p>
<p>函数对象往往按值传递和返回。所以，编写的函数对象必须尽可能地小巧，否则复制的开销大；函数对象必须是<strong>单态</strong>的(不是多态)，不得使用虚函数。</p>
<p>如果你希望创建一个包含大量数据并且使用了多态性的函数子类，该怎么办呢？</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFCImpl</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">BPFCImpl</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">friend</span> <span class="k">class</span> <span class="nc">BPFC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>					<span class="c1">// 允许BPFC访问内部数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFC</span><span class="o">:</span>								<span class="c1">// 新的BPFC类：短小、单态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">BPFCImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>					<span class="c1">// BPFC唯一的数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span>	<span class="c1">// 现在这是一个非虚函数，将调用转到BPFCImpl中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pImpl</span><span class="o">-&gt;</span><span class="k">operator</span><span class="p">()(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么你应该创建一个小巧、单态的类，其中包含一个指针，指向另一个实现类，并且将所有的数据和虚函数都放在实现类中(“Pimpl Idiom”)。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFCImpl</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">BPFCImpl</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">friend</span> <span class="k">class</span> <span class="nc">BPFC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>					<span class="c1">// 允许BPFC访问内部数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BPFC</span><span class="o">:</span>								<span class="c1">// 新的BPFC类：短小、单态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">BPFCImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>					<span class="c1">// BPFC唯一的数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span>	<span class="c1">// 现在这是一个非虚函数，将调用转到BPFCImpl中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pImpl</span><span class="o">-&gt;</span><span class="k">operator</span><span class="p">()(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="r39-确保判别式是-纯函数">R39 确保判别式是 “纯函数”</h2>
<p><strong>判别式(predicate)：一个返回值为 bool 类型的函数。</strong></p>
<p><strong>纯函数：指返回值仅仅依赖于其参数的函数。</strong></p>
<p>判别式类(predicate class)：一个函数子类，它的 operator() 函数是一个判别式(返回 true 或 false)。</p>
<p>STL 中凡是可以接受一个判别式类对象的地方，也就可以接受一个判别式函数。</p>
<p>判别式应该是一个纯函数，而纯函数应该没有状态。</p>
<h2 id="r40-使仿函数类可适配">R40 使仿函数类可适配</h2>
<p>对函数指针，要先应用<code>ptr_fun</code>之后再应用<code>not1</code>之后才可以工作。</p>
<p>4 个标准的函数配接器(<code>not1</code>、<code>not2</code>、<code>bind1st</code>、<code>bind2nd</code>)都要求一些特殊的类型定义，提供这些必要类型定义(<code>argument_type</code>、<code>first_argument_type</code>、<code>second_argument_type</code>、<code>result_type</code>)的函数对象被称为可配接(可适配)(<code>adaptable</code>)的函数对象。</p>
<p>提供这些类型定义最简单的方法：让函数子从一个基结构继承。</p>
<ul>
<li>对于 unary_function，必须指定函数子类 operator() 所带的参数类型，以及 operator() 返回类型。</li>
<li>对于 binary_function，必须指定 3 个类型：operator() 第一个和第二个参数类型，以及 operator() 返回类型。</li>
</ul>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MeetsThreshold</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">unary_function</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">T</span> <span class="n">threshold</span><span class="p">;</span>						<span class="c1">// 包含状态信息，使用类封装。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MeetsThreshold</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">threshold</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">WidgetNameCompare</span><span class="o">:</span>					<span class="c1">// STL中所有无状态函数子类一般都被定义成结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">Widget</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，一般情况下，传递给 binary_function 或 unary_function 的非指针类型需要去掉 const 和应用(&amp;)部分。</p>
<h2 id="r41-理解-ptr_funmem_fun-和-mem_fun_ref-的来由">R41 理解 ptr_fun、mem_fun 和 mem_fun_ref 的来由</h2>
<p>STL语法惯例：函数或者函数对象被调用时，总是使用非成员函数的语法形式。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">test</span><span class="p">);</span>					<span class="c1">// 调用1：f(x)，f为非成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Widget</span><span class="o">::</span><span class="n">test</span><span class="p">);</span>			<span class="c1">// 调用2：x.f()，f为成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">// x是一个对象或对象的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">*&gt;</span> <span class="n">lpw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">lpw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lpw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Widgettest</span><span class="p">);</span>			<span class="c1">// 调用3：p-&gt;f()，f为成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">// p是一个指向对象x的指针。
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>mem_fun、mem_fun_t：mem_fun 将语法 3 调整为语法 1。</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>		<span class="c1">//该mem_fun声明针对不带参数的非const成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mem_fun_t</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span>							<span class="c1">//C是类，R是所指向的成员函数返回的类型。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mem_fun</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">pmf</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>mem_fun 带一个指向某个成员函数的指针参数 pmf，并且返回一个 mem_fun_t 类型的对象。</p>
<p>mem_fun_t 是一个函数子类，它拥有该成员函数的指针，并提供了 operator() 函数，在 operator() 中调用了通过参数传递进来的对象上的该成员函数。</p>
<p>类似地，mem_fun_ref 将语法 2 调整为语法 1。</p>
<p><strong>总结:</strong></p>
<ul>
<li>std::ptr_fun：将函数指针转换为函数对象。</li>
<li>std::mem_fun：将成员函数转换为函数对象(指针版本)。</li>
<li>std::mem_fun_ref：将成员函数转换为函数对象(引用版本)。</li>
</ul>
<h2 id="r42-确保lesst与operator具有相同的语义">R42 确保less<T>与operator&lt;具有相同的语义</h2>
<p>尽量避免修改 less 的行为，可能会误导其他程序员。</p>
<p>如果你使用了 less，无论是显式地还是隐式地，都需要确保它与 operator&lt; 具有相同的意义。</p>
<p>如果你希望以一种特殊的方式来排列对象，那么最好创建一个特殊的函数子类。</p>
<p>假设有一个multiset<Widget>容器，它默认的比较函数是less<Widget>，而less<Widget>在默认情况下会调用operator&lt;来完成multiset的排序，而operator&lt;是按照Widget中成员变量weight来排序的，现在特殊情况下需要一个按Widget中成员变量speed来排序的multiset，一种方法是全特化less<Widget>，但是这种做法并不好，因为用户可能是觉得自己按照weight来排序，但是其实做的却是按照speed来排序，更好的办法是创建一个函数子类，然后用该子类做比较函数，而不是改变less的默认行为。</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">speedCompare</span> <span class="o">:</span> <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">Widget</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">maxSpeed</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">maxSpeed</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">multiset</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">speedCompare</span><span class="o">&gt;</span> <span class="n">widgets</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Ref:</p>
<p>[1]. <a href="https://www.cnblogs.com/Sherry4869/p/15162253.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/Sherry4869/p/15162253.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[2]. <a href="https://blog.csdn.net/zhuikefeng/article/details/108164117#t35"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/zhuikefeng/article/details/108164117#t35<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
[3]. <a href="https://zhuanlan.zhihu.com/p/458156007"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/458156007<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Transformer Q &amp; A</title><link>https://jianye0428.github.io/posts/transformerqanda/</link><pubDate>Mon, 21 Aug 2023 07:59:36 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/transformerqanda/</guid><description><![CDATA[<h2 id="1-2017年深度学习领域的重大突破是什么">1. 2017年深度学习领域的重大突破是什么？</h2>
<p>Transformer。有两方面的原因:</p>
<p>1.1 一方面，Transformer是深度学习领域继MLP、RNN、CNN之后的第4大特征提取器(也被称为基础模型)。</br>
<strong>什么是特征提取器？</strong></br>
特征提取器是计算机模仿大脑，与外部世界(图像、文字、语音等)交互的方式，如图1所示。举例而言: Imagenet数据集中包含1000类图像，人们已经根据自己的经验把这一百万张图像分好1000类，每一类图像(如美洲豹)都有独特的特征。这时，神经网络(如ResNet18)也是想通过这种分类的方式，把每一类图像的特征尽可能提取或识别出来。分类不是最终目的，而是一种提取图像特征的手段，掩码补全图像也是一种提取特征的方式，图像块顺序打乱也是一种提取特征的方式。</p>
<p></p>
<p>1.2 另一方面，Transformer在深度学习领域扮演的角色: 第3次和第4次热潮的基石，如下图2所示。</p>
<p></p>
<h2 id="2-transformer的提出背景是什么">2. Transformer的提出背景是什么？</h2>
<p><strong>2.1 在领域发展背景层面</strong>: 当时时处2017年，深度学习在计算机视觉领域已经火了几年。从Alexnet、VGG、GoogleNet、ResNet、DenseNet;从图像分类、目标检测再到语义分割;但在自然语言处理领域并没有引起很大反响。</p>
<p><strong>2.2 技术背景层面</strong>:
(1)当时主流的序列转录任务(如机器翻译)的解决方案如下图3所示，在Sequence to Sequence架构下(Encoder-Decoder的一种)，RNN来提取特征，Attention机制将Encoder提取到的特征高效传递给Decoder。
(2)这种做法有两个不足之处，一方面是在提取特征时的RNN天生<strong>从前向后时序传递</strong>的结构决定了其无法并行运算，其次是当序列长度过长时，最前面序列的信息有可能被遗忘掉。因此可以看到，在这个框架下，RNN是相对薄弱急需改进的地方。</p>
<p></p>
<h2 id="3-transformer到底是什么">3. Transformer到底是什么？</h2>
<p>3.1 Transformer是一种由Encoder和Decoder组成的架构。那么什么是架构呢？最简单的架构就是A + B + C。</p>
<p>3.2 Transformer也可以理解为一个函数，输入是“我爱学习”，输出是“I love study”。</p>
<p>3.3 如果把Transformer的架构进行分拆，如图4所示。</p>
<p></p>
<h2 id="4-什么是transformer-encoder">4. 什么是Transformer Encoder？</h2>
<p>4.1 从<font color=red>功能角度</font>，Transformer Encoder的核心作用是<strong>提取特征</strong>，也有使用Transformer Decoder来提取特征。例如，一个人学习跳舞，Encoder是看别人是如何跳舞的，Decoder是将学习到的经验和记忆(key和value的匹配程度)，展现出来</p>
<p>4.2 从<font color=red>结构角度</font>，如图5所示，Transformer Encoder = Embedding + Positional Embedding + N * (子Encoder block1 + 子Encoder block2);</p>
<p>子Encoder block1 = Multi head attention + ADD + Norm;</p>
<p>子Encoder block2 = Feed Forward + ADD + Norm;</p>
<p>4.3 从<font color=red>输入输出角度</font>，N个Transformer Encoder block中的第一个Encoder block的输入为一组向量 X = (Embedding + Positional Embedding)，向量维度通常为512*512，其他N个TransformerEncoder block的输入为上一个 Transformer Encoder block的输出，输出向量的维度也为<code>512*512</code>(输入输出大小相同)。</p>
<p>4.4 为什么是<code>512*512</code>？<font color=red>前者是指token的个数</font>，如“我爱学习”是4个token，这里设置为512是为了囊括不同的序列长度，不够时padding。<font color=red>后者是指每一个token生成的向量维度</font>，也就是每一个token使用一个序列长度为512的向量表示。人们常说，Transformer不能超过512，否则硬件很难支撑;其实512是指前者，也就是token的个数，因为每一个token要做self attention操作;但是后者的512不宜过大，否则计算起来也很慢。</p>
<p></p>
<h2 id="5-什么是transformer-decoder">5. 什么是Transformer Decoder？</h2>
<p>5.1 从功能角度，相比于Transformer Encoder，Transformer Decoder更擅长做<strong>生成式任务</strong>，尤其对于自然语言处理问题。</p>
<p>5.2 从结构角度，如图6所示，Transformer Decoder = Embedding + Positional Embedding + N*(子Decoder block1 + 子Decoder block2 + 子Decoder block3)+ Linear + Softmax;</p>
<p>子Decoder block1 = Mask Multi head attention + ADD + Norm;</p>
<p>子Decoder block2 = Multi head attention + ADD + Norm;</p>
<p>子Decoder block3 = Feed Forward + ADD + Norm;</p>
<p></p>
<p>5.3 从(Embedding+Positional Embedding)(N个Decoder block)(Linear + softmax) 这三个每一个单独作用角度:</p>
<p>Embedding + Positional Embedding: 以机器翻译为例，输入“Machine Learning”，输出“机器学习”; 这里的Embedding是把“机器学习”也转化成向量的形式。</p>
<p>N个Decoder block: 特征处理和传递过程。</p>
<p>Linear + softmax: softmax是预测下一个词出现的概率，如图7所示，前面的Linear层类似于分类网络(ResNet18)最后分类层前接的MLP层。</p>
<p></p>
<p>5.4 Transformer Decoder的输入、输出是什么？在Train和Test时是不同的。</p>
<p>在Train阶段，如图8所示。这时是知道label的，decoder的第一个输入是begin字符，输出第一个向量与label中第一个字符使用cross entropy loss。Decoder的第二个输入是第一个向量的label，Decoder的第N个输入对应的输出是End字符，到此结束。这里也可以看到，在Train阶段是可以进行<strong>并行训练</strong>的。</p>
<p></p>
<p>在Test阶段，下一个时刻的输入是前一个时刻的输出，如图9所示。因此，Train和Test时候，Decoder的输入会出现Mismatch，在Test时候确实有可能会出现一步错，步步错的情况。有两种解决方案: 一种是train时偶尔给一些错误，另一种是Scheduled sampling。</p>
<p></p>
<p>5.5 Transformer Decoder block内部的输入和输出是什么？</p>
<p>前面提到的是在整体train和test阶段，Decoder的输入和输出，那么Transformer Decoder内部的Transformer Decoder block，如图10所示，的输入输出又是什么呢？</p>
<p></p>
<p>对于N=6中的第1次循环(N=1时): 子Decoder block1 的输入是 embedding +Positional Embedding，子Decoder block2 的输入的Q来自子Decoder block1的输出，KV来自Transformer Encoder最后一层的输出。</p>
<p>对于N=6的第2次循环: 子Decoder block1的输入是N=1时，子Decoder block3的输出，KV同样来自Transformer Encoder的最后一层的输出。</p>
<p>总的来说，可以看到，无论在Train还是Test时，Transformer Decoder的输入不仅来自(ground truth或者上一个时刻Decoder的输出)，还来自Transformer Encoder的最后一层。</p>
<p>训练时: 第i个decoder的输入 = encoder输出 + ground truth embedding。</p>
<p>预测时: 第i个decoder的输入 = encoder输出 + 第(i-1)个decoder输出.</p>
<h2 id="6-transformer-encoder和transformer-decoder有哪些不同">6. Transformer Encoder和Transformer Decoder有哪些不同？</h2>
<p>6.1 作用上，Transformer Encoder常用来<strong>提取特征</strong>，Transformer Decoder常用于<strong>生成式任务</strong>。Transformer Encoder和Transformer Decoder是两条不同的技术路线，<strong>Bert采用的前者，GPT系列模型采用的是后者</strong>。</p>
<p>6.2 结构上，Transformer Decoder block包括了3个子Decoder block，而Transformer Encoder block 包括2个子Encoder block，且Transformer Decoder中使用了Mask multi-head Attention。</p>
<p>6.3 从二者的输入输出角度，N个Transformer Encoder运算完成之后，它的输出才正式输入进Transformer Decoder，作为QKV中的K和V，给Transformer Decoder使用。那么TransformerEncoder最后层的输出是如何送给Decoder呢？如图11所示。</p>
<p></p>
<p>那么，为什么Encoder和Decoder必须要用这种交互的方式呢？其实也并不一定，后续有不同交互方式的提出，如图12。</p>
<p></p>
<h2 id="7-什么是embedding">7. 什么是Embedding？</h2>
<p>7.1 Embedding在Transformer架构中的位置如图13所示。</p>
<p>7.2 提出背景:  计算机无法直接处理一个单词或者一个汉字，需要把一个token转化成计算机可以识别的向量，这也就是embedding过程。</p>
<p>7.3 实现方式:  最简单的embedding操作就是one hot vector，但one hot vector有一个弊端就是没有考虑词语前后之间的关系，后来也就产生了WordEmbedding，如图13。</p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">wordembedding将单词token向量化，并且考虑的单词与单词之间的相关性。</div>
    </div>
  </div>
<p></p>
<h2 id="8-什么是positional-embedding">8. 什么是Positional Embedding？</h2>
<p>8.1 Positional Embedding在Transformer架构中的位置如图14所示。</p>
<p>8.2 提出背景:  RNN作为特征提取器，是自带词的前后顺序信息的;而Attention机制并没有考虑先后顺序信息，但前后顺序信息对语义影响很大，因此需要通过Positional Embedding这种方式把前后位置信息加在输入的Embedding上。</p>
<p>8.3 实现方式:  传统位置编码和神经网络自动训练得到。</p>
<p></p>
<h2 id="9-什么是attention">9. 什么是Attention？</h2>
<p>9.1 介绍Transformer，为什么要介绍Attention呢？因为在Transformer中最多的multi head attention和Mask multi head attention来自Scaled dot product attention，而scaled dot product attention来自self attention，而self attention是attention的一种，因此首先需要了解Attention，如图15所示。</p>
<p></p>
<p>9.2 Attention到底是什么意思呢？</p>
<p>对于图像而言，attention就是人们看到图像中的核心关注的区域，是图像中的重点，如图16所示。对于序列而言，Attention机制本质上是为了找到<strong>输入中不同token之间的相互关系</strong>，通过权重矩阵来自发地找到词与词之间的关系。</p>
<p></p>
<p>9.3 Attention是如何实现的呢？</p>
<p>是通过QKV实现的。</p>
<p>那么什么是QKV呢？Q是query，K是keys，V是values。如图17所示，举例而言，Q是大脑发出的信号，我口渴了;K是环境信息，眼睛看到的世界;V是对环境中不同的物品赋予不同的比重，水的比重加大。</p>
<p>总之，Attention就是通过计算QK的相似度，与V相乘得到注意力数值。</p>
<p>$$\text{Attention}(\mathrm{Query},\mathrm{Source})=\sum\text{Similarity}(\mathrm{Query},\mathrm{Key}<em>\mathrm{i})*\mathrm{Value}</em>\mathrm{i}$$</p>
<p></p>
<p>9.4 为什么必须要有QKV三者？</p>
<p>为什么不是只有Q？因为Q1与Q2之间的关系权重，不止需要a12，也需要a21。你可能会问？我们让a12=a21不行吗？也可以尝试，但从原理上讲效果应该没有a12和a21效果好。</p>
<p>为什么不是只有QK？求得的权重系数需要放到输入中，可以乘Q，也可以乘K，为什么要重新乘V呢？我觉得可能是多了一组可训练参数$W_V$，使网络具有更强的学习能力。</p>
<h2 id="10-什么是self-attention">10. 什么是Self Attention？</h2>
<p>10.1 介绍Transformer，为什么要介绍self Attention呢？因为在Transformer中最多的multi head attention和Mask multi head attention来自Scaled dot product attention，而scaled dot product attention来自self attention，如图15所示。</p>
<p>10.2 什么是Self Attention呢？self attention和local attention、stride attention都是attention的一种;self attention是每一个Q与每一个K依次计算注意力系数，如图18所示，而像local attention是Q只与相邻的K计算注意力系数，stride attention是Q通过跳连的方式与K计算注意力系数。</p>
<p></p>
<p>10.3 Self attention为什么可以用于处理像机器翻译这种序列数据?</p>
<p>输入序列中的每一个位置的数据，可以关注其他位置的信息，由此通过Attention score来提取特征或者捕获输入序列每一个token之间的关系。</p>
<p>10.4 Self attention是如何具体实现的? 总共分为4步，如图19所示</p>
<p></p>
<h2 id="11-什么是scaled-dot-product-attention">11. 什么是Scaled dot product attention？</h2>
<p>11.1 self attention最常见的有两种，一种是dot product attention、另一种是additive attention，如图20所示，前者的计算效率更高。</p>
<p></p>
<p>11.2 什么是Scaled ?</p>
<p>scaled的具体实现方式如图21所示，这一操作的目的是为了防止内积过大，从梯度角度考虑，避免靠近1，易训练;与batch normalization有一些相似的功能。</p>
<p>$$\text{Attention}(Q,K,V)=\text{softmax}(\frac{QK^T}{\sqrt{d_k}})V$$</p>
<h2 id="12-什么是multi-head-attention">12. 什么是Multi head attention？</h2>
<p>12.1 Multi head attention在Transformer架构中的位置如图15所示。</p>
<p>12.2 提出背景: CNN具有多个channel，可以提取图像不同维度的特征信息，那么Self attention是否可以有类似操作，可以提取不同距离token的多个维度信息呢？</p>
<p>12.3 什么是group 卷积？如图22所示，将输入的特征多个channel分成几个group单独做卷积，最后再进行con c操作。</p>
<p></p>
<p>12.4 Multi head attention的实现方式？与self attention根本不同是什么？</p>
<p>如图23所示，以2个head的为例，将输入的Q、K、V分成两份，每一小份的Q与对应的K、V分别操作，最后计算得到的向量再进行conc操作，由此可以看出，Multi head attention与group卷积有着相似的实现方式。</p>
<p></p>
<p>12.5 如何从输入输出的维度来理解Multi head attention？如图24所示。</p>
<p></p>
<h2 id="13-什么是mask-multi-head-attention">13. 什么是Mask Multi head attention？</h2>
<p>13.1 Mask Multi head attention在transformer架构中的位置如图15所示。</p>
<p>13.2 为什么要有Mask这种操作？</p>
<p>Transformer预测第T个时刻的输出，不能看到T时刻之后的那些输入，从而保证训练和预测一致。</p>
<p>通过 Masked 操作可以防止第 i 个单词知道 i+1 个单词之后的信息，如图25所示。</p>
<p></p>
<p>13.3 Mask操作是如何具体实现的呢？</p>
<p>Q1只跟K1计算，Q2只跟K1、K2计算，而对于K3、K4等，在softmax之前给一个非常大的负数，由此经过softmax之后变为0，其在矩阵上的计算原理实现如图26所示。</p>
<p></p>
<h2 id="14-什么是add">14. 什么是ADD？</h2>
<p>14.1 Add就是残差连接，由2015年ResNet这篇文章发扬光大(目前引用量已超过16万)，与Skip connection的区别在于需要大小维度全部相同。</p>
<p>14.2 作为大道至简想法的极致，几乎每一个深度学习模型都会用到这个技术，可以<strong>防止网络退化</strong>，常用于解决多层网络难训练的问题。</p>
<p></p>
<h2 id="15-什么是norm">15. 什么是Norm？</h2>
<p>15.1 Norm就是layer normalization。</p>
<p>15.2 核心作用: 为了训练更加稳定，和batch normalization有相同的作用，都是为了使输入的样本均值为零，方差为1。</p>
<p>15.3 为什么不使用batch normalization，使用的是layer normalization呢？因为一个时序数据，句子输入长度有长有短，如果使用batch normalization，则很容易造成因样本长短不一造成“训练不稳定”。BN是对同一个batch内的所有数据的同一个特征数据进行操作;而LN是对同一个样本进行操作。</p>
<p></p>
<ol start="16">
<li>什么是FFN？</li>
</ol>
<p>16.1 FFN就是feed forward networks。</p>
<p>16.2 为什么有了Self attention层，还要有FFN？Attention已经有了想要的序列信息特征，MLP的作用是把信息投影到特定的空间里，再做一次非线性映射，和Self attention交替使用。</p>
<p>16.3 结构上: 包括两层MLP，第一层的维度为$512<em>2048$，第二层的维度为$2048</em>512$，且第二层MLP没有使用激活函数，如图29所示。</p>
<p></p>
<h2 id="17-transformer是如何训练出来的">17. Transformer是如何训练出来的？</h2>
<p>17.1 数据上，在Transformer论文中有提到，用到了4.5M和36M的翻译句子对。</p>
<p>17.2 硬件上，base模型是8个P100 GPU训练了12个小时，大模型是训练了3.5天。</p>
<p>17.3 模型参数和调参层面:</p>
<p>第一，可训练的参数包括$W_Q$、$W_K$、$W_V$、$W_O$，换包括$FFN$层的参数。</p>
<p>第二，可调的参数包括: 每一个token向量表示的维度(d_model)、head的头数、Encoder和Decoder中block重复的次数N、FFN中间层向量的维度、Label smoothing(置信度0.1)和dropout(0.1)。</p>
<h2 id="18-transformer为什么效果好">18. Transformer为什么效果好？</h2>
<p>18.1 虽然题目是Attention is all you need，但后续一些研究表明，Attention、残差连接、layer normalization、FFN，这些因素共同成就了Transformer。</p>
<p>18.2 Transformer优点包括:</p>
<p>第一，提出深度学习继MLP、CNN、RNN后的第4大特征提取器。</p>
<p>第二，一开始用在机器翻译，随着GPT和Bert彻底出圈;是一个转折点，在这个点之后，NLP领域快速发展，之后多模态、大模型、视觉Transformer等开始兴起。</p>
<p>第三，给人们信心，原来CNN和RNN之后，还可以有效果更好的特征提取器。</p>
<p>18.3 Transformer的不足之处？</p>
<p>第一，计算量大，对硬件要求高。</p>
<p>第二，因为无归纳偏置，需要很多数据才可以取得很好的效果。</p>
<p>Ref:</br>
[1]. <a href="https://mp.weixin.qq.com/s/sNyh3SzhIdsk8feYfQlTSA"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/sNyh3SzhIdsk8feYfQlTSA<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Transformer | 如何理解attention中的Q,K,V？</title><link>https://jianye0428.github.io/posts/attentionaqkv/</link><pubDate>Sun, 20 Aug 2023 17:44:07 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/attentionaqkv/</guid><description><![CDATA[<h2 id="解答一">解答一</h2>
<p>我们直接用torch实现一个SelfAttention来说一说：</p>
<ol>
<li>首先定义三个线性变换矩阵，query, key, value：</li>
</ol>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">  <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，这里的query, key, value只是一种操作(线性变换)的名称，实际的Q/K/V是它们三个的输出
2. 假设三种操作的输入都是同一个矩阵(暂且先别管为什么输入是同一个矩阵)，这里暂且定为长度为L的句子，每个token的特征维度是768，那么输入就是(L, 768)，每一行就是一个字，像这样：

乘以上面三种操作就得到了Q/K/V，(L, 768)*(768,768) = (L,768)，维度其实没变，即此刻的Q/K/V分别为：

代码为:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden_states</span><span class="p">):</span> <span class="c1"># hidden_states 维度是(L, 768)</span>
</span></span><span class="line"><span class="cl">     <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>
<p>然后来实现这个操作:
$$Attention(Q,K_i,V_i)\color{red}{\boxed{=softmax(\frac{Q^TK_i}{\sqrt{d_k}})V_i}}$$
① 首先是Q和K矩阵乘，(L, 768)*(L, 768)的转置=(L,L)，看图：

首先用Q的第一行，即“我”字的768特征和K中“我”字的768为特征点乘求和，得到输出(0，0)位置的数值，这个数值就代表了“我想吃酸菜鱼”中“我”字对“我”字的注意力权重，然后显而易见输出的第一行就是“我”字对“我想吃酸菜鱼”里面每个字的注意力权重；整个结果自然就是“我想吃酸菜鱼”里面每个字对其它字(包括自己)的注意力权重(就是一个数值)了~</p>
<p>② 然后是除以根号dim，这个dim就是768，至于为什么要除以这个数值？主要是为了缩小点积范围，确保softmax梯度稳定性，具体推导可以看这里：<a href="https://zhuanlan.zhihu.com/p/149903065"target="_blank" rel="external nofollow noopener noreferrer">莲生三十二：Self-attention中dot-product操作为什么要被缩放<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，然后就是为什么要softmax，一种解释是为了保证注意力权重的非负性，同时增加非线性，还有一些工作对去掉softmax进行了实验，如<a href="https://zhuanlan.zhihu.com/p/157490738"target="_blank" rel="external nofollow noopener noreferrer">PaperWeekly：线性Attention的探索：Attention必须有个Softmax吗？<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>③ 然后就是刚才的注意力权重和V矩阵乘了，如图：
</p>
<p>注意力权重 x VALUE矩阵 = 最终结果 </br>
首先是“我”这个字对“我想吃酸菜鱼”这句话里面每个字的注意力权重，和V中“我想吃酸菜鱼”里面每个字的第一维特征进行相乘再求和，这个过程其实就相当于用每个字的权重对每个字的特征进行加权求和，然后再用“我”这个字对对“我想吃酸菜鱼”这句话里面每个字的注意力权重和V中“我想吃酸菜鱼”里面每个字的第二维特征进行相乘再求和，依次类推~最终也就得到了(L,768)的结果矩阵，和输入保持一致~</p>
<p>整个过程在草稿纸上画一画简单的矩阵乘就出来了，一目了然~最后上代码：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BertSelfAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_head_size</span><span class="p">)</span> <span class="c1"># 输入768， 输出768</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hidden_states</span><span class="p">):</span> <span class="c1"># hidden_states 维度是(L, 768)</span>
</span></span><span class="line"><span class="cl">     <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">hidden_states</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">     <span class="n">attention_scores</span> <span class="o">=</span> <span class="n">attention_scores</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attention_head_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">attention_probs</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">attention_scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attention_probs</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">out</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>为什么叫<strong>自注意力网络</strong>？</br>
因为可以看到Q/K/V都是通过同一句话的输入算出来的，按照上面的流程也就是一句话内每个字对其它字(包括自己)的权重分配；那如果不是自注意力呢？简单来说，Q来自于句A，K、V来自于句B即可~</br></p>
</li>
<li>
<p>注意，K/V中，如果同时替换任意两个字的位置，对最终的结果是不会有影响的，至于为什么，可以自己在草稿纸上画一画矩阵乘；也就是说注意力机制是没有位置信息的，不像CNN/RNN/LSTM；这也是为什么要引入positional embeding的原因。</p>
</li>
</ol>
<h2 id="解答二">解答二</h2>
<p>其实直接用邱锡鹏老师PPT里的一张图就可以直观理解——假设D是输入序列的内容，完全忽略线性变换的话可以近似认为Q=K=V=D(所以叫做Self-Attention，因为这是输入的序列对它自己的注意力)，于是序列中的每一个元素经过Self-Attention之后的表示就可以这样展现：</p>
<p></p>
<p>也就是说，The这个词的表示，实际上是整个序列加权求和的结果——权重从哪来？点积之后Softmax得到——这里Softmax(QK)就是求权重的体现。我们知道，向量点积的值可以表征词与词之间的相似性，而此处的“整个序列”包括The这个词自己(再一次强调这是Self-Attention)，所以最后输出的词的表示，其“主要成分”就主要地包含它自身和跟它相似的词的表示，其他无关的词的表示对应的权重就会比较低。</p>
<h2 id="解答三">解答三</h2>
<p>首先附上链接：<a href="https://zhuanlan.zhihu.com/p/37601161"target="_blank" rel="external nofollow noopener noreferrer">张俊林：深度学习中的注意力模型(2017版)<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 。这个几乎是我读到过的讲解Attention最为透彻的篇章之一了。</p>
<p>Q(Querry)代表查询值，对应Decoder的H(t-1)状态。这里要正确理解H(t-1)，想要解码出t时刻的输出，你送入Decoder的必然有前一时刻计算出的隐状态。好了，所谓查询，就是你要拿着这个Decoder中的H(t-1)去和Encoder中各个时刻的隐状态<a href="%e4%b9%9f%e5%b0%b1%e6%98%af%e5%90%84%e4%b8%aaKey">H(1), H(2), &hellip; , H(T)</a>去比，也就是二者计算相似度(对应于文献中的各种energy函数)。最后算出来的结果用Softmax归一化，这个算出来的权重就是带有注意力机制的权重，其实在翻译任务中，Key和Value是相等的。在Transformer的实现源码中，Key和Value的初始值也是相等的。有了这个权重之后，就可以用这个权重对Value进行加权求和，生成的这个新的向量就是带有注意力机制的语义向量 Context vector，而这个语义向量会权衡Target与Source的token与token的关系，从而实现解码输出时，与Source中“真正有决定意义”的token关联。</p>
<p>姑且画蛇添足的再说几句：
首先，Attention机制是由Encoder-Decoder架构而来，且最初是用于完成NLP领域中的翻译(Translation)任务。那么输入输出就是非常明显的 Source-Target的对应关系，经典的Seq2Seq结构是从Encoder生成出一个语义向量(Context vector)而不再变化，然后将这个语义向量送入Decoder配合解码输出。这种方法的最大问题就是这个语义向量，我们是希望它一成不变好呢？还是它最好能配合Decoder动态调整自己，来使Target中的某些token与Source中的真正“有决定意义”的token关联起来好呢？
这就是为什么会有Attention机制的原因。说到底，Attention机制就是想生成会动态变化的语义向量来配合解码输出。而新贵 Self-Attention则是为了解决Target与Source各自内部token与token的关系。在Transformer中，这两种注意力机制得到了有机的统一，释放出了异常惊人的潜力。</p>
<p>ref:</br>
[1]. <a href="https://mp.weixin.qq.com/s/v7N3lhMBSdoGCz4K3TmsmA"target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/v7N3lhMBSdoGCz4K3TmsmA<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Effective STL [30] | 确保目标区间足够大</title><link>https://jianye0428.github.io/posts/clause_30/</link><pubDate>Sat, 19 Aug 2023 15:32:43 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_30/</guid><description><![CDATA[<p>STL容器在被添加时（通过insert、push_front、push_back等）自动扩展它们自己来容纳新对象。</p>
<h2 id="插入数据">插入数据</h2>
<p><strong>尾部插入 back_inserter</strong></p>
<p>当你想向容器中插入对象但并没有告诉STL他们所想的时，问题出现了:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">transmogrify</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 自定义的这个函数从x产生一些新值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把数据放入values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify应用于values中的每个对象
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把这个返回的values附加到results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这段代码有bug！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>transform被告知它的目的区间是从<code>results.end()</code>开始的，所以那就是开始写在values的每个元素上调用<code>transmogrify</code>的结果的地方。</p>
<p>就像所有使用目标区间的算法，<code>transform</code>通过对目标区间的元素赋值的方法写入结果，<code>transform</code>会把<code>transmogrify</code>应用于<code>values[0]</code>并把结果赋给<code>*results.end()</code>。</p>
<p>然后它会把<code>transmogrify</code>应用于<code>value[1]</code>并把结果赋给<code>*(results.end()+1)</code>。</p>
<p>那只能带来灾难，因为在<code>*results.end()</code>没有对象，<code>*(results.end()+1)</code>也没有！因为<code>transform</code>并没有在尾部创造新的对象。</p>
<p>调用<code>transform</code>是错误的，因为它会给不存在的对象赋值。</p>
<p><strong>正确做法</strong></p>
<p>把<code>transform</code>的结果放入<code>results</code>容器的结尾的方式是调用<code>back_inserter</code>来产生指定目标区间起点的迭代器:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify应用于values中的每个对象，在results的结尾插入返回的values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在内部，<code>back_inserter</code>返回的迭代器会调用<code>push_back</code>，所以你可以在任何提供<code>push_back</code>的容器上使用<code>back_inserter</code>(也就是任何标准序列容器: <code>vector</code>、<code>string</code>、<code>deque</code>和<code>list</code>)。</p>
<p><strong>前端插入 front_inserter</strong></p>
<p>如果你想让一个算法在容器的前端插入东西，你可以使用<code>front_inserter</code>。</p>
<p>在内部，<code>front_inserter</code>利用了<code>push_front</code>，所以<code>front_insert</code>只和提供那个成员函数的容器配合(也就是<code>deque</code>和<code>list</code>):</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// results现在是list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 在results前端   以反序   插入transform的结果
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为<code>front_inserter</code>用<code>push_front</code>把每个对象添加到<code>results</code>，<code>results</code>中的对象顺序会和<code>values</code>中对应的对象顺序相反。</p>
<p><code>vector</code>不提供<code>push_front</code>，所以<code>front_inserter</code>不能用于<code>vector</code>。</p>
<p><strong>同序插入</strong></p>
<p>如果你要<code>transform</code>把输出结果放在<code>results</code>前端，但你也要输出和<code>values</code>中对应的对象顺序相同，只要以相反的顺序迭代<code>values</code>:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在results前端 插入transform的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span><span class="n">transmogrify</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 保持相对的对象顺序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>任意位置插入 inserter</strong></p>
<p><code>front_inserter</code>让你强制算法在容器前端插入它们的结果，<code>back_inserter</code>让你告诉它们把结果放在容器后端，有点惊人的是<code>inserter</code>允许你强制算法把它们的结果插入容器中的任意位置:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同上，除了现在在调用transform前 results已经有一些数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify的结果插入results的中间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">inserter</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="插入效率">插入效率</h2>
<p>不管你是否使用了<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>，<code>transform</code>会对目的区间每次写入一个值，你无法改变。</p>
<p>当你要插入的容器是<code>vector</code>或<code>string</code>时，你可以最小化这个代价，<strong>预先调用<code>reserve</code></strong>。</p>
<p>你仍然要承受每次发生插入时移动元素的开销，但至少你避免了重新分配容器的内在内存:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 确定results至少还能装得下values.size()个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上，但results没有任何重新分配操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">inserter</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当使用<code>reserve</code>来提高一连串插入的效率时，总是应该记住<code>reserve</code><strong>只增加容器的容量：容器的大小仍然没有改变</strong>。</p>
<p>即使调用完<code>reserve</code>，当你想要让容器把新元素加入到<code>vector</code>或<code>string</code>时，你也必须对算法使用插入迭代器(比如，从<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>返回的迭代器之一)，因为赋值只在两个对象之间操作时有意义，而不是在一个对象和一块原始的比特之间。</p>
<p>第一个例子正确的写法:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把transmogrify的结果写入results的结尾，处理时避免了重新分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="p">,</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="覆盖原始数据">覆盖原始数据</h2>
<p>有时候你要覆盖现有容器的元素而不是插入新的。</p>
<p><strong>当这种情况时，你不需要插入迭代器，但你仍然需要按照本条款的建议来确保你的目的区间足够大。</strong></p>
<p>假设你让<code>transform</code>覆盖<code>results</code>的元素。如果<code>results</code>至少有和<code>values</code>一样多的元素，那很简单。如果没有， 你也必须使用<code>resize</code>来确保它有。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 确保results至少和values一样大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl"> <span class="n">results</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 覆盖values.size()个 results的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者你可以清空results然后用通常的方式使用插入迭代器:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 销毁results中的所有元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">results</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 保留足够空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把transform地返回值// 放入results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span> <span class="n">transmogrify</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>无论何时你使用一个要求指定目的区间的算法，确保目的区间已经足够大或者在算法执行时可以增加大小。</p>
<p>如果你选择增加大小，就使用插入迭代器，比如<code>ostream_iterators</code>或从<code>back_inserter</code>、<code>front_inserter</code>或<code>inserter</code>返回的迭代器。</p>
]]></description></item><item><title>Effective STL [29] | 需要一个一个字符输入时考虑使用istreambuf_iterator</title><link>https://jianye0428.github.io/posts/clause_29/</link><pubDate>Fri, 18 Aug 2023 07:55:51 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_29/</guid><description><![CDATA[<h2 id="istream_iterator-拷贝文件">istream_iterator 拷贝文件</h2>
<p>假设要把一个文本文件拷贝到一个字符串对象中。似乎可以用一种很有道理的方法完成：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 把inputFile读入fileData；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 关于为什么它不是很正确请看下文关于这个语法的警告参见条款6
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很快你就会发现这种方法无法把文件中的空格拷贝到字符串中。</p>
<p>那是因为<code>istream_iterators</code>使用<code>operator&gt;&gt;</code>函数来进行真的读取，而且<code>operator&gt;&gt;</code>函数在默认情况下忽略空格。</p>
<p>假如你想保留空格，你要的做就是覆盖默认情况。只要清除输入流的skipws标志就行了：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">inputFile</span><span class="p">.</span><span class="n">unset</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">skipws</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 关闭inputFile的忽略空格标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在inputFile中的所有字符都拷贝到fileData中了。</p>
<p><strong>拷贝速度</strong></p>
<p>你会发现它们的拷贝速度不像你想象的那么快。</p>
<p><code>istream_iterators</code>所依靠的<code>operator&gt;&gt;</code>函数进行的是格式化输入，这意味着每次你调用的时候它们都必须做大量工作：</p>
<ol>
<li>
<p>必须建立和销毁岗哨（sentry）对象（为每个<code>operator&gt;&gt;</code>调用进行建立和清除活动的特殊的<code>iostream</code>对象）；</p>
</li>
<li>
<p>必须检查可能影响它们行为的流标志（比如skipws）；</p>
</li>
<li>
<p>必须进行全面的读取错误检查；</p>
</li>
<li>
<p>如果它们遇到问题，它们必须检查流的异常掩码来决定是否该抛出一个异常。</p>
</li>
</ol>
<p>如果进行格式化输入，那些都是重要的活动，但如果你需要的只是从输入流中抓取下一个字符，那就过度了。</p>
<h2 id="istreambuf_iterators-拷贝文件">istreambuf_iterators 拷贝文件</h2>
<p>你可以像<code>istream_iterator</code>一样使用<code>istreambuf_iterator</code>，但<code>istream_iterator&lt;char&gt;</code>对象使用<code>operator&gt;&gt;</code>来从输入流中读取单个字符。 <code>istreambuf_iterator</code>对象进入流的缓冲区并直接读取下一个字符。（更明确地说，<code>istreambuf_iterator&lt;char&gt;</code> 对象从一个<code>istream s</code>中读取会调用<code>s.rdbuf()-&gt;sgetc()</code>来读<code>s</code>的下一个字符。）把我们的文件读取代码改为使用<code>istreambuf_iterator</code>相当简单，大多数Visual Basic程序员都可以在两次尝试内做对：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">ifstream</span> <span class="nf">inputFile</span><span class="p">(</span><span class="s">&#34;interestingData.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">fileData</span><span class="p">((</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl"><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意这里不需要“<code>unset</code>” <code>skipws</code>标志，<code>istreambuf_iterator</code>不忽略任何字符。它们只抓取流缓冲区的下一个字符。</p>
<p>相对于<code>istream_iterator</code>，它们抓取得更快。</p>
<p>如果你需要一个一个地读取流中的字符，你不需要格式化输入的威力，你关心的是它们花多少时间来读取流，和明显的性能提高相比，为每个迭代器多键入三个字符的代价是微弱的。对于无格式的一个一个字符输入，你总是应该考虑使用<code>istreambuf_iterator</code>。</p>
<h2 id="结论">结论</h2>
<p>当你了解它之后，你也应该考虑把<code>ostreambuf_iterator</code>用于相应的无格式一个一个字符输出的作。</p>
<p>它们没有了<code>ostream_iterator</code>的开销（和灵活性），所以它们通常也做得更好。</p>
]]></description></item><item><title>Effective STL [28] | 了解如何通过reverse_iterator的base得到iterator</title><link>https://jianye0428.github.io/posts/clause_28/</link><pubDate>Thu, 17 Aug 2023 20:04:40 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_28/</guid><description><![CDATA[<h2 id="example">Example</h2>
<p>通过reverse_iterator的base初始化一个iterator:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 参见条款14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="err">；</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 向vector插入1到5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">ri</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 使ri指向3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 使i和ri的base一样
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>执行上述代码后，可以想到产生的结果就像这样:</p>
<p></p>
<p>上图显示了<code>reverse_iterator</code>和它对应的<code>base iterator</code>之间特有的偏移量，就像<code>rbegin()</code>和<code>rend()</code>与相关的<code>begin()</code>和<code>end()</code>一样，但是它并没有解释怎样在<code>ri</code>上实现你在i上想要完成的操作。</p>
<p>正如条款26解释的，有些容器的成员函数只接受<code>iterator</code>类型的参数，所以如果你想要在<code>ri</code>所指的位置插入一个新元素，你不能直接这么做，因为<code>vector</code>的<code>insert</code>函数不接受<code>reverse_iterator</code>。</p>
<p>如果你想要删除ri所指位置上的元素也会有同样的问题。<code>erase</code>成员函数会拒绝<code>reverse_iterator</code>，坚持要求<code>iterator</code>。</p>
<h2 id="reverse_iterator转换成iterator">reverse_iterator转换成iterator</h2>
<p>为了完成删除和一些形式的插入操作，你必须先通过base函数将reverse_iterator转换成iterator，然后用iterator来完成工作。</p>
<p><strong>插入操作</strong></p>
<p>假设你要在ri指出的位置上把一个新元素插入v。假设你要插入的值是99。</p>
<p>**ri在上图中遍历的顺序是自右向左，而且插入操作会将新元素插入到ri位置，并且将原先ri位置的元素移到遍历过程的“下一个”位置，我们认为3应该出现在99的左侧。**插入操作之后，v看起来像这样:</p>
<p></p>
<p>我们不能用<code>ri</code>来指定插入的地方，因为它不是一个<code>iterator</code>。我们必须用<code>i</code>来代替。如上所述，当<code>ri</code>指向3时，<code>i</code>（就是<code>ri.base()</code>）指向4。</p>
<p>如果我们用<code>ri</code>来指定插入位置，那么用i指向插入位置，那个假设就是正确的。</p>
<p><strong>结论</strong></p>
<blockquote>
<p>要实现在一个reverse_iterator ri指出的位置上插入新元素，在ri.base()指向的位置插入就行了。
对于insert操作而言，ri和ri.base()是等价的，而且ri.base()真的是ri对应的iterator。</p>
</blockquote>
<p><strong>删除操作</strong></p>
<p>如果你要删除ri指向的元素，你不能直接使用i了，因为i与ri不是指向同一个元素。因此，你要删除的是i的前一个元素。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 向v插入1到5，同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vecot</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">ri</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 同上，ri指向3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="o">--</span><span class="n">ri</span><span class="p">.</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 尝试删除ri.base()前面的元素；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 对于vector，一般来说编译不通过
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>--ri.base()</code>确实能够指出我们需要删除的元素。而且，它们能够处理除了<code>vector</code>和<code>string</code>之外的其他所有容器。</p>
<p>它可能也能处理vector和string，但对于大多数vector和string的实现，它无法通过编译。</p>
<p>在这样的实现下，<code>iterator</code>(和<code>const_iterator</code>)会采用内建的指针来实现，所以<code>ri.base()</code>的结果是一个指针。</p>
<p><strong>原因剖析</strong></p>
<p>C和C++都规定了不能直接修改函数返回的指针，所以在string和vector的迭代器是指针的STL平台上，像<code>--ri.base()</code>这样的表达式无法通过编译。</p>
<p>要移植从一个由<code>reverse_iterator</code>指出的位置删除元素时，你应该尽量避免修改base的返回值。</p>
<p>所以，如果你不能减少调用<code>base</code>的返回值，只需要先增加<code>reverse_iterator</code>的值，然后再调用<code>base</code>！</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">((</span><span class="o">++</span><span class="n">ri</span><span class="p">).</span><span class="n">base</span><span class="p">());</span> <span class="c1">// 删除ri指向的元素；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这下编译没问题了！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>这个方法适用于所有的标准容器，这是删除一个由reverse_iterator指出的元素时首选的技巧</strong></p>
<h2 id="结论">结论</h2>
<p><code>reverse_iterator</code>的<code>base</code>成员函数返回一个“对应的”<code>iterator</code>的说法并不准确：对于插入操作而言，的确如此; 但是对于删除操作，并非如此。</p>
<p>当需要把<code>reverse_iterator</code>转换成<code>iterator</code>的时候，有一点非常重要的是你必须知道你准备怎么处理返回的<code>iterator</code>，因为只有这样你才能决定你得到的<code>iterator</code>是否是你需要的。</p>
]]></description></item><item><title>Effective STL [27] | 用distance和advance把const_iterator转化成iterator</title><link>https://jianye0428.github.io/posts/clause_27/</link><pubDate>Thu, 17 Aug 2023 07:54:00 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_27/</guid><description><![CDATA[<h2 id="把const_iterator转化为iterator">把const_iterator转化为iterator</h2>
<p>有些容器成员函数只接受iterator作为参数，而不是const_iterator。如果你只有一个const_iterator，要在它所指向的容器位置上插入新元素呢？</p>
<p>上一条款说并不存在从const_iterator到iterator之间的隐式转换，那该怎么办？</p>
<p>看看当你把一个const_iterator映射为iterator时会发生什么:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 方便的typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// ci是const_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// 错误！没有从const_iterator 到iterator隐式转换的途径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="nf">i</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Iter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ci</span><span class="p">));</span> <span class="c1">// 仍是个错误！不能从const_iterator 映射为iterator！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里只是以deque为例，但是用其它容器类——list、set、multiset、map、multimap甚至条款25描述的散列表容器——的结果一样。使用映射的行也许在vector或string的代码时能够编译，但这是我们马上要讨论的非常特殊的情形。</p>
<p>上述代码不能通过编译的原因在于，对于这些容器而言，<font color=red>iterator和const_iterator是完全不同的类。</font></p>
<p>在两个毫无关联的类之间进行<code>const_cast</code>映射是荒谬的，所以<code>reinterpret_cast</code>、<code>static_cast</code>甚至C风格的映射也会导致同样的结果。</p>
<p><strong>不能编译的代码对于vector和string容器来说也许能够通过编译</strong></p>
<p>那是因为通常情况下大多数实现都会采用真实的指针作为那些容器的迭代器。</p>
<p>就这种实现而言，<code>vector&lt;T&gt;::iterator</code>是<code>T*</code>的<code>typedef</code>，而<code>vector&lt;T&gt;::const_iterator</code>是<code>const T*</code>的<code>typedef</code>，<code>string::iterator</code>是<code>char</code>的<code>typedef</code>，而<code>string::const_iterator</code>是<code>const char*</code>的<code>typedef</code>。</p>
<p>在这种实现的情况下，用<code>const_cast</code>把<code>const_iterator</code>映射成<code>iterator</code>当然可以编译而且没有问题，因为<code>const_iterator</code>与<code>iterator</code>之间的<code>const_cast</code>映射被最终解释成<code>const T*</code>到<code>T*</code>的映射。但是，即使是在这种实现中，<code>reverse_iterator</code>和<code>const_reverse_iterator</code>也是真正的类，所以你仍然不能直接用<code>const_cast</code>把<code>const_reverse_iterator</code>映射成<code>reverse_iterator</code>。</p>
<p>而且这些实现通常只会在Release模式时才使用指针表示vector和string的迭代器。</p>
<p>所有这些事实表明，把const迭代器映射为迭代器是病态的，即使是对vector和string来说也时，因为移植性很值得怀疑。</p>
<h2 id="const_iterator转换为iterator">const_iterator转换为iterator</h2>
<p>有一种安全的、可移植的方法获取它所对应的iterator，而且，用不着陷入类型系统的转换。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 和以前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">IntDeque</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 让ci指向d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// 初始化i为d.begin()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 把i移到指向ci位置（但请留意下面关于为什么在它编译前要调整的原因）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要得到与const_iterator指向同一位置的iterator:</p>
<ol>
<li>将iterator指向容器的起始位置，</li>
<li>把它向前移到和const_iterator距离容器起始位置的偏移量一样的位置即可</li>
</ol>
<p>这个任务得到了两个函数模板advance和distance的帮助，它们都在<iterator>中声明:</p>
<ul>
<li>distance返回两个指向同一个容器的iterator之间的距离；</li>
<li>advance则用于将一个iterator移动指定的距离。</li>
</ul>
<p>如果<code>i</code>和<code>ci</code>指向同一个容器，那么表达式<code>advance(i, distance(i, ci))</code>会将<code>i</code>移动到与<code>ci</code>相同的位置上。</p>
<p>上述代码编译存在问题。</p>
<p>先来看看distance的定义：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_InputIterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="n">_GLIBCXX17_CONSTEXPR</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_InputIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span>
</span></span><span class="line"><span class="cl">  <span class="n">distance</span><span class="p">(</span><span class="n">_InputIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_InputIterator</span> <span class="n">__last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// concept requirements -- taken care of in __distance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">__distance</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">__iterator_category</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当遇到<code>distance</code>调用时，你的编译器需要根据使用的实参类型推断出<code>InputIterator</code>的类型。</p>
<p>再来看看我所说的不太正确的<code>distance</code>调用:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 调整i，指向ci位置
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有两个参数传递给distance，i和ci。i的类型是Iter，即<code>deque&lt;int&gt;::iterator</code>的typedef。</p>
<p>对编译器来说，这表明调用<code>distance</code>的<code>InputIterator</code>是<code>deque::iterator</code>。但<code>ci</code>是<code>ConstIter</code>，即<code>deque::const_iterator</code>的<code>typedef</code>。</p>
<p>表明那个<code>InputIterator</code>是<code>deque&lt;int&gt;::const_iterator</code>。</p>
<p><code>InputIterator</code>不可能同时有两种不同的类型，所以调用<code>distance</code>失败。</p>
<p>一般会造成一些冗长的出错信息，可能会也可能不会说明是编译器无法得出<code>InputIterator</code>是什么类型。</p>
<p>要顺利地调用<code>distance</code>，你需要排除歧义。</p>
<p>最简单的办法就是显式的指明<code>distance</code>调用的模板参数类型，从而避免编译器自己得出它们的类型:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们现在知道了怎么通过<code>advance</code>和<code>distance</code>获取<code>const_iterator</code>相应的<code>iterator</code>了。</p>
<p><strong>效率如何？</strong></p>
<p>答案很简单。<strong>取决于你所转换的究竟是什么样的迭代器。</strong></p>
<p>对于<strong>随机访问的迭代器</strong>（比如<code>vector</code>、<code>string</code>和<code>deque</code>的）而言，这是<strong>常数时间</strong>的操作。</p>
<p>对于<strong>双向迭代器</strong>（也就是，所有其它容器和包括散列容器的一些实现）而言，这是<strong>线性时间</strong>的操作。</p>
<p>因为它可能花费线性时间的代价来产生一个和<code>const_iterator</code>等价的<code>iterator</code>，并且因为如果不能访问<code>const_iterator</code>所属的容器这个操作就无法完成。</p>
<p>从这个角度出发，也许你需要重新审视你从<code>const_iterator</code>产生<code>iterator</code>的设计。</p>
<p>当处理容器时尽量用<code>iterator</code>代替<code>const</code>和<code>reverse</code>迭代器。</p>
]]></description></item><item><title>Effective STL [26] | 尽量用iterator代替const_iterator，reverse_iterator和const_reverse_iterator</title><link>https://jianye0428.github.io/posts/clause_26/</link><pubDate>Wed, 16 Aug 2023 19:06:25 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_26/</guid><description><![CDATA[<h2 id="4种迭代器">4种迭代器</h2>
<p>每个标准容器类都提供4种迭代器类型:<code>iterator</code>,<code>const_iterator</code>，<code>reverse_iterator</code>和<code>const_reverse_iterator</code></p>
<p>对于<code>container&lt;T&gt;</code>而言，<code>iterator</code>的作用相当于<code>T*</code>，而<code>const_iterator</code>则相当于<code>const T*</code>。</p>
<p>增加一个<code>iterator</code>或者<code>const_iterator</code>可以在一个从容器开头趋向尾部的遍历中让你移动到容器的下一个元素。</p>
<p><code>reverse_iterator</code>与<code>const_reverse_iterator</code>同样相当于对应的<code>T</code>和<code>const T</code>，所不同的是，增加<code>reverse_iterator</code>或者<code>const_reverse_iterator</code>会在从尾到头的遍历中让你移动到容器的下一个元素。</p>
<h2 id="vectort的insert和erase的样式">vector<T>的insert和erase的样式</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">rangeBegin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">rangeEnd</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些方法只接受<code>iterator</code>类型的参数，而不是<code>const_iterator</code>、<code>reverse_iterator</code>或<code>const_reverse_iterator</code>。总是<code>iterator</code>。</p>
<h2 id="迭代器之间存在的转换关系">迭代器之间存在的转换关系</h2>
<p></p>
<p>图中显示了从<code>iterator</code>到<code>const_iterator</code>、从<code>iterator</code>到<code>reverse_iterator</code>和从<code>reverse_iterator</code>到<code>const_reverse_iterator</code>可以进行隐式转换。</p>
<p>并且，<code>reverse_iterator</code>可以通过调用其<code>base成员函数</code>转换为<code>iterator</code>。<code>const_reverse_iterator</code>也可以类似地通过<code>base</code>转换成为<code>const_iterator</code>。</p>
<p>通过base得到的也许并非你所期待的iterator。</p>
<p>而且，<strong>没有办法从一个const_iterator转换得到一个iterator，也无法从const_reverse_iterator得到reverse_iterator</strong>。</p>
<p>所以，当你需要指出插入位置或删除的元素时，const迭代器几乎没有用。</p>
<h2 id="尽量使用iterator取代const或者reverse类型的迭代器">尽量使用iterator取代const或者reverse类型的迭代器</h2>
<ol>
<li>
<p><code>insert</code>和<code>erase</code>的一些版本要求<code>iterator</code>。如果你需要调用这些函数，你就必须产生<code>iterator</code>，而不能用<code>const</code>或<code>reverse iterators</code>。</p>
</li>
<li>
<p>不可能把<code>const_iterator</code>隐式转换成<code>iterator</code>。从一个<code>const_iterator</code>产生一个<code>iterator</code>的技术并不普遍适用，而且不保证高效。</p>
</li>
<li>
<p>从<code>reverse_iterator</code>转换而来的<code>iterator</code>在转换之后可能需要相应的调整。</p>
</li>
</ol>
<p><code>iterator</code>与<code>reverse_iterator</code>之间的选择显而易见——依赖于从前到后或从后到前的遍历。</p>
<p><strong>迭代器比较</strong></p>
<p>当在<code>iterator</code>和<code>const_iterator</code>之间作选择的时候，你有更充分的理由选择<code>iterator</code>，即使<code>const_iterator</code>同样可行而且即使你并不需要调用容器类的任何成员函数。其中的令人讨厌的原因包括<code>iterator</code>与<code>const_iterator</code>之间的比较：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// typedef可以极大地简化STL容器类和iterator的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 同一个容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ci</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 比较iterator和const_iterator
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>唯一的变化是等号的一边的类型是<code>iterator</code>，而另一边的类型是<code>const_iterator</code>。</p>
<p><strong>因为<code>iterator</code>应该在比较之前隐式的转换成<code>const_iterator</code>，真正的比较应该在两个<code>const_iterator</code>之间进行。</strong></p>
<p><strong>如果一些实现将<code>const_iterator</code>的<code>operator==</code>作为<code>const_iterator</code>的一个成员函数而不是非成员函数。</strong></p>
<p>而问题的解决之道显得非常有趣：只要像这样交换两个<code>iterator</code>的位置：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ci</span> <span class="o">==</span> <span class="n">i</span><span class="p">)...</span> <span class="c1">// 当上面比较无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>迭代器混用</strong></p>
<p>不仅是比较是否相等，只要你在同一个表达式中混用<code>iterator</code>和<code>const_iterator</code>（或者<code>reverse_iterator</code>和<code>const_reverse_iterator</code>），这样的问题就可能会出现:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 如果i与ci之间至少有三个元素...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果迭代器的类型不同，你的正确的代码可能会被错误地拒绝。</p>
<p>本例中最简单的解决方法是<strong>通过一个（安全的）映射把iterator转换为const_iterator</strong>:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 当上面的代码无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>避免这类问题的最简单的方法是减少混用不同类型的迭代器的机会。</strong></p>
]]></description></item><item><title>Effective STL [25] | 熟悉非标准散列容器</title><link>https://jianye0428.github.io/posts/clause_25/</link><pubDate>Wed, 16 Aug 2023 08:21:08 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_25/</guid><description><![CDATA[<p><strong>STL没有散列表。</strong></p>
<p>兼容STL的散列关联容器可以从多个来源获得，而且它们甚至有事实上的标准名字：<code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>和<code>hash_multimap</code>。在C++标准委员会的议案中，散列容器的名字是<code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>和<code>unordered_multimap</code>。</p>
<p><strong>它们在接口、能力、内在数据结构和支持操作的相关效率方面不同。</strong></p>
<p>最常见的两个来自<code>SGI</code>和<code>Dinkumware</code>，<code>STLport</code>也提供散列容器，但是<code>STLport</code>的散列容器是基于来自<code>SGI</code>的。</p>
<p>散列容器是关联容器，它们需要知道储存在容器中的对象类型，用于这些对象的比较函数，以及用于这些对象的分配器。</p>
<h2 id="散列容器声明">散列容器声明</h2>
<p>散列容器需要散列函数的说明。下面是散列容器声明：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_container</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这非常接近于散列容器的SGI声明，主要差别是SGI为HashFunction和CompareFunction提供了默认类型。</p>
<p><strong>SGI 设计举例</strong></p>
<p><code>hash_set</code>的SGI声明看起来基本上像这样：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">equa_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>SGI</code>设计的一个值得注意的方面是使用<code>equal_to</code>作为默认比较函数。<strong>这违背标准关联容器的约定——默认比较函数是less。</strong></p>
<p><code>SGI</code>的散列容器确定在一个散列容器中的两个对象是否有相同的值是通过相等测试，而不是等价。</p>
<p>因为散列关联容器，不像它们在标准中的（通常基于树）兄弟，不需要保持有序。</p>
<p><strong>Dinkumware 设计举例</strong></p>
<p>Dinkumware设计的散列容器采取一些不同的策略。它仍然允许你指定对象类型、散列函数类型、比较函数类型和分配器类型，但是<strong>它把默认的散列和比较函数移进一个单独的类似特性的叫做hash_compare的类</strong>，而且它把<code>hash_compare</code>作为容器模板的<code>HashingInfo</code>实参的默认值。</p>
<p>这是<code>Dinkumware</code>的hash_set声明（再次为演示而调整过）:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">HashingInfo</span> <span class="o">=</span> <span class="n">hash_compare</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种接口设计有趣的地方是<code>HashingInfo</code>的使用。</p>
<p><strong>容器的散列和比较函数储存在<code>HashingInfo</code>中，但HashingInfo类型也容纳了控制表中桶（bucket）最小数量，以及容器元素对桶的最大允许比率的枚举。</strong></p>
<p>当这比率被超过时，表中桶的数量就增加，而表中的一些元素需要重新散列。（SGI提供具有类似控制表中桶和表中元素对桶比率的成员函数。）</p>
<p><strong>hash_compare</strong></p>
<p><code>hash_compare</code>（HashingInfo的默认值）看起来或多或少像这样:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bucket_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// 元素对桶的最大比率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">min_buckets</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1">// 桶的最小数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 散列函数比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// 忽略一些东西，包括 CompareFunction的使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>重载<code>operator()</code>（在这里是实现散列和比较函数）是比你可以想象的更经常出现的一个策略。</p>
<p><code>Dinkumware</code>设计允许你写你自己的类似hash_compare的类（也许通过从<code>hash_compare</code>本身派生而来），而且只要你的类定义了<code>bucket_size</code>、<code>min_buckets</code>、两个<code>operator()</code>函数（一个带有一个实参，一个带有两个），加上已经省去的一些东西，就能使用它来控制Dinkumware的<code>hash_set</code>或<code>hash_multiset</code>的配置和行为。</p>
<p><code>hash_map</code>和<code>hash_multimap</code>的配置控制也相似。</p>
<h2 id="决策留给实现">决策留给实现</h2>
<p>注意不管是SGI还是Dinkumware的设计，你都能把全部决策留给实现:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 建立一个int的散列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">hash_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intTable</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要让这个可以编译，散列表必须容纳一个整数类型（例如int），因为<strong>默认散列函数一般局限于整数类型。</strong></p>
<p><strong>实现方法不同</strong></p>
<p>在后端，SGI和Dinkumware的实现方法非常不同。</p>
<ol>
<li>SGI利用常用的一个元素的单链表的指针数组（桶）组成的开放散列法。</li>
<li>Dinkumware也利用了开放散列法，但是它的设计是基于一种新颖的数据结构——由迭代器（本质是桶）的数组组成的元素双向链表，迭代器的相邻对表示在每个桶里元素的范围。</li>
</ol>
<p><strong>链表不同</strong></p>
<ol>
<li>SGI实现在<strong>单链表</strong>中储存表的元素</li>
<li>Dinkumware实现使用一个双向链表</li>
</ol>
<p><strong>迭代器种类不同</strong></p>
<ol>
<li>SGI的散列容器提供了前向迭代器，因此你得放弃进行反向迭代的能力：在SGI的散列容器中没有rbegin或者rend成员函数。</li>
<li>用于Dinkumware散列容器的迭代器是双向的，所以它们可以提供前向和反向遍历。</li>
</ol>
<p><strong>内存使用量方面不同</strong></p>
<p>SGI的设计比Dinkumware的节俭一点点。</p>
<h2 id="结论">结论</h2>
<p>虽然STL本身缺乏散列容器，兼容STL的散列容器（有不同的接口、能力和行为权衡）不难得到。就SGI和STLport的实现而言，你甚至可以免费下载得到它们。</p>
]]></description></item></channel></rss>