<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Effective STL - 标签 - yejian's blog</title><link>https://jianye0428.github.io/tags/effective-stl/</link><description>Effective STL - 标签 - yejian's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>18817571704@163.com (Jian YE)</managingEditor><webMaster>18817571704@163.com (Jian YE)</webMaster><lastBuildDate>Thu, 17 Aug 2023 07:54:00 +0800</lastBuildDate><atom:link href="https://jianye0428.github.io/tags/effective-stl/" rel="self" type="application/rss+xml"/><item><title>Effective STL [27] | 用distance和advance把const_iterator转化成iterator</title><link>https://jianye0428.github.io/posts/clause_27/</link><pubDate>Thu, 17 Aug 2023 07:54:00 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_27/</guid><description><![CDATA[<h2 id="把const_iterator转化为iterator">把const_iterator转化为iterator</h2>
<p>有些容器成员函数只接受iterator作为参数，而不是const_iterator。如果你只有一个const_iterator，要在它所指向的容器位置上插入新元素呢？</p>
<p>上一条款说并不存在从const_iterator到iterator之间的隐式转换，那该怎么办？</p>
<p>看看当你把一个const_iterator映射为iterator时会发生什么:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 方便的typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// ci是const_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// 错误！没有从const_iterator 到iterator隐式转换的途径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="nf">i</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Iter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ci</span><span class="p">));</span> <span class="c1">// 仍是个错误！不能从const_iterator 映射为iterator！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里只是以deque为例，但是用其它容器类——list、set、multiset、map、multimap甚至条款25描述的散列表容器——的结果一样。使用映射的行也许在vector或string的代码时能够编译，但这是我们马上要讨论的非常特殊的情形。</p>
<p>上述代码不能通过编译的原因在于，对于这些容器而言，<font color=red>iterator和const_iterator是完全不同的类。</font></p>
<p>在两个毫无关联的类之间进行<code>const_cast</code>映射是荒谬的，所以<code>reinterpret_cast</code>、<code>static_cast</code>甚至C风格的映射也会导致同样的结果。</p>
<p><strong>不能编译的代码对于vector和string容器来说也许能够通过编译</strong></p>
<p>那是因为通常情况下大多数实现都会采用真实的指针作为那些容器的迭代器。</p>
<p>就这种实现而言，<code>vector&lt;T&gt;::iterator</code>是<code>T*</code>的<code>typedef</code>，而<code>vector&lt;T&gt;::const_iterator</code>是<code>const T*</code>的<code>typedef</code>，<code>string::iterator</code>是<code>char</code>的<code>typedef</code>，而<code>string::const_iterator</code>是<code>const char*</code>的<code>typedef</code>。</p>
<p>在这种实现的情况下，用<code>const_cast</code>把<code>const_iterator</code>映射成<code>iterator</code>当然可以编译而且没有问题，因为<code>const_iterator</code>与<code>iterator</code>之间的<code>const_cast</code>映射被最终解释成<code>const T*</code>到<code>T*</code>的映射。但是，即使是在这种实现中，<code>reverse_iterator</code>和<code>const_reverse_iterator</code>也是真正的类，所以你仍然不能直接用<code>const_cast</code>把<code>const_reverse_iterator</code>映射成<code>reverse_iterator</code>。</p>
<p>而且这些实现通常只会在Release模式时才使用指针表示vector和string的迭代器。</p>
<p>所有这些事实表明，把const迭代器映射为迭代器是病态的，即使是对vector和string来说也时，因为移植性很值得怀疑。</p>
<h2 id="const_iterator转换为iterator">const_iterator转换为iterator</h2>
<p>有一种安全的、可移植的方法获取它所对应的iterator，而且，用不着陷入类型系统的转换。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// 和以前一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">IntDeque</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 让ci指向d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Iter</span> <span class="n">i</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="c1">// 初始化i为d.begin()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 把i移到指向ci位置（但请留意下面关于为什么在它编译前要调整的原因）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要得到与const_iterator指向同一位置的iterator:</p>
<ol>
<li>将iterator指向容器的起始位置，</li>
<li>把它向前移到和const_iterator距离容器起始位置的偏移量一样的位置即可</li>
</ol>
<p>这个任务得到了两个函数模板advance和distance的帮助，它们都在<iterator>中声明:</p>
<ul>
<li>distance返回两个指向同一个容器的iterator之间的距离；</li>
<li>advance则用于将一个iterator移动指定的距离。</li>
</ul>
<p>如果<code>i</code>和<code>ci</code>指向同一个容器，那么表达式<code>advance(i, distance(i, ci))</code>会将<code>i</code>移动到与<code>ci</code>相同的位置上。</p>
<p>上述代码编译存在问题。</p>
<p>先来看看distance的定义：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_InputIterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="n">_GLIBCXX17_CONSTEXPR</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_InputIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span>
</span></span><span class="line"><span class="cl">  <span class="n">distance</span><span class="p">(</span><span class="n">_InputIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_InputIterator</span> <span class="n">__last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// concept requirements -- taken care of in __distance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">__distance</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">__iterator_category</span><span class="p">(</span><span class="n">__first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当遇到<code>distance</code>调用时，你的编译器需要根据使用的实参类型推断出<code>InputIterator</code>的类型。</p>
<p>再来看看我所说的不太正确的<code>distance</code>调用:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span> <span class="c1">// 调整i，指向ci位置
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有两个参数传递给distance，i和ci。i的类型是Iter，即<code>deque&lt;int&gt;::iterator</code>的typedef。</p>
<p>对编译器来说，这表明调用<code>distance</code>的<code>InputIterator</code>是<code>deque::iterator</code>。但<code>ci</code>是<code>ConstIter</code>，即<code>deque::const_iterator</code>的<code>typedef</code>。</p>
<p>表明那个<code>InputIterator</code>是<code>deque&lt;int&gt;::const_iterator</code>。</p>
<p><code>InputIterator</code>不可能同时有两种不同的类型，所以调用<code>distance</code>失败。</p>
<p>一般会造成一些冗长的出错信息，可能会也可能不会说明是编译器无法得出<code>InputIterator</code>是什么类型。</p>
<p>要顺利地调用<code>distance</code>，你需要排除歧义。</p>
<p>最简单的办法就是显式的指明<code>distance</code>调用的模板参数类型，从而避免编译器自己得出它们的类型:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">distance</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们现在知道了怎么通过<code>advance</code>和<code>distance</code>获取<code>const_iterator</code>相应的<code>iterator</code>了。</p>
<p><strong>效率如何？</strong></p>
<p>答案很简单。<strong>取决于你所转换的究竟是什么样的迭代器。</strong></p>
<p>对于<strong>随机访问的迭代器</strong>（比如<code>vector</code>、<code>string</code>和<code>deque</code>的）而言，这是<strong>常数时间</strong>的操作。</p>
<p>对于<strong>双向迭代器</strong>（也就是，所有其它容器和包括散列容器的一些实现）而言，这是<strong>线性时间</strong>的操作。</p>
<p>因为它可能花费线性时间的代价来产生一个和<code>const_iterator</code>等价的<code>iterator</code>，并且因为如果不能访问<code>const_iterator</code>所属的容器这个操作就无法完成。</p>
<p>从这个角度出发，也许你需要重新审视你从<code>const_iterator</code>产生<code>iterator</code>的设计。</p>
<p>当处理容器时尽量用<code>iterator</code>代替<code>const</code>和<code>reverse</code>迭代器。</p>
]]></description></item><item><title>Effective STL [26] | 尽量用iterator代替const_iterator，reverse_iterator和const_reverse_iterator</title><link>https://jianye0428.github.io/posts/clause_26/</link><pubDate>Wed, 16 Aug 2023 19:06:25 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_26/</guid><description><![CDATA[<h2 id="4种迭代器">4种迭代器</h2>
<p>每个标准容器类都提供4种迭代器类型:<code>iterator</code>,<code>const_iterator</code>，<code>reverse_iterator</code>和<code>const_reverse_iterator</code></p>
<p>对于<code>container&lt;T&gt;</code>而言，<code>iterator</code>的作用相当于<code>T*</code>，而<code>const_iterator</code>则相当于<code>const T*</code>。</p>
<p>增加一个<code>iterator</code>或者<code>const_iterator</code>可以在一个从容器开头趋向尾部的遍历中让你移动到容器的下一个元素。</p>
<p><code>reverse_iterator</code>与<code>const_reverse_iterator</code>同样相当于对应的<code>T</code>和<code>const T</code>，所不同的是，增加<code>reverse_iterator</code>或者<code>const_reverse_iterator</code>会在从尾到头的遍历中让你移动到容器的下一个元素。</p>
<h2 id="vectort的insert和erase的样式">vector<T>的insert和erase的样式</h2>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">rangeBegin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">rangeEnd</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些方法只接受<code>iterator</code>类型的参数，而不是<code>const_iterator</code>、<code>reverse_iterator</code>或<code>const_reverse_iterator</code>。总是<code>iterator</code>。</p>
<h2 id="迭代器之间存在的转换关系">迭代器之间存在的转换关系</h2>
<p></p>
<p>图中显示了从<code>iterator</code>到<code>const_iterator</code>、从<code>iterator</code>到<code>reverse_iterator</code>和从<code>reverse_iterator</code>到<code>const_reverse_iterator</code>可以进行隐式转换。</p>
<p>并且，<code>reverse_iterator</code>可以通过调用其<code>base成员函数</code>转换为<code>iterator</code>。<code>const_reverse_iterator</code>也可以类似地通过<code>base</code>转换成为<code>const_iterator</code>。</p>
<p>通过base得到的也许并非你所期待的iterator。</p>
<p>而且，<strong>没有办法从一个const_iterator转换得到一个iterator，也无法从const_reverse_iterator得到reverse_iterator</strong>。</p>
<p>所以，当你需要指出插入位置或删除的元素时，const迭代器几乎没有用。</p>
<h2 id="尽量使用iterator取代const或者reverse类型的迭代器">尽量使用iterator取代const或者reverse类型的迭代器</h2>
<ol>
<li>
<p><code>insert</code>和<code>erase</code>的一些版本要求<code>iterator</code>。如果你需要调用这些函数，你就必须产生<code>iterator</code>，而不能用<code>const</code>或<code>reverse iterators</code>。</p>
</li>
<li>
<p>不可能把<code>const_iterator</code>隐式转换成<code>iterator</code>。从一个<code>const_iterator</code>产生一个<code>iterator</code>的技术并不普遍适用，而且不保证高效。</p>
</li>
<li>
<p>从<code>reverse_iterator</code>转换而来的<code>iterator</code>在转换之后可能需要相应的调整。</p>
</li>
</ol>
<p><code>iterator</code>与<code>reverse_iterator</code>之间的选择显而易见——依赖于从前到后或从后到前的遍历。</p>
<p><strong>迭代器比较</strong></p>
<p>当在<code>iterator</code>和<code>const_iterator</code>之间作选择的时候，你有更充分的理由选择<code>iterator</code>，即使<code>const_iterator</code>同样可行而且即使你并不需要调用容器类的任何成员函数。其中的令人讨厌的原因包括<code>iterator</code>与<code>const_iterator</code>之间的比较：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">IntDeque</span><span class="p">;</span> <span class="c1">// typedef可以极大地简化STL容器类和iterator的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">IntDeque</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ConstIter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Iter</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConstIter</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 同一个容器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ci</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 比较iterator和const_iterator
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>唯一的变化是等号的一边的类型是<code>iterator</code>，而另一边的类型是<code>const_iterator</code>。</p>
<p><strong>因为<code>iterator</code>应该在比较之前隐式的转换成<code>const_iterator</code>，真正的比较应该在两个<code>const_iterator</code>之间进行。</strong></p>
<p><strong>如果一些实现将<code>const_iterator</code>的<code>operator==</code>作为<code>const_iterator</code>的一个成员函数而不是非成员函数。</strong></p>
<p>而问题的解决之道显得非常有趣：只要像这样交换两个<code>iterator</code>的位置：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ci</span> <span class="o">==</span> <span class="n">i</span><span class="p">)...</span> <span class="c1">// 当上面比较无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>迭代器混用</strong></p>
<p>不仅是比较是否相等，只要你在同一个表达式中混用<code>iterator</code>和<code>const_iterator</code>（或者<code>reverse_iterator</code>和<code>const_reverse_iterator</code>），这样的问题就可能会出现:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 如果i与ci之间至少有三个元素...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果迭代器的类型不同，你的正确的代码可能会被错误地拒绝。</p>
<p>本例中最简单的解决方法是<strong>通过一个（安全的）映射把iterator转换为const_iterator</strong>:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">ci</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 当上面的代码无法通过编译时的解决方法
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>避免这类问题的最简单的方法是减少混用不同类型的迭代器的机会。</strong></p>
]]></description></item><item><title>Effective STL [25] | 熟悉非标准散列容器</title><link>https://jianye0428.github.io/posts/clause_25/</link><pubDate>Wed, 16 Aug 2023 08:21:08 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_25/</guid><description><![CDATA[<p><strong>STL没有散列表。</strong></p>
<p>兼容STL的散列关联容器可以从多个来源获得，而且它们甚至有事实上的标准名字：<code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>和<code>hash_multimap</code>。在C++标准委员会的议案中，散列容器的名字是<code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>和<code>unordered_multimap</code>。</p>
<p><strong>它们在接口、能力、内在数据结构和支持操作的相关效率方面不同。</strong></p>
<p>最常见的两个来自<code>SGI</code>和<code>Dinkumware</code>，<code>STLport</code>也提供散列容器，但是<code>STLport</code>的散列容器是基于来自<code>SGI</code>的。</p>
<p>散列容器是关联容器，它们需要知道储存在容器中的对象类型，用于这些对象的比较函数，以及用于这些对象的分配器。</p>
<h2 id="散列容器声明">散列容器声明</h2>
<p>散列容器需要散列函数的说明。下面是散列容器声明：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_container</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这非常接近于散列容器的SGI声明，主要差别是SGI为HashFunction和CompareFunction提供了默认类型。</p>
<p><strong>SGI 设计举例</strong></p>
<p><code>hash_set</code>的SGI声明看起来基本上像这样：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">HashFunction</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">equa_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>SGI</code>设计的一个值得注意的方面是使用<code>equal_to</code>作为默认比较函数。<strong>这违背标准关联容器的约定——默认比较函数是less。</strong></p>
<p><code>SGI</code>的散列容器确定在一个散列容器中的两个对象是否有相同的值是通过相等测试，而不是等价。</p>
<p>因为散列关联容器，不像它们在标准中的（通常基于树）兄弟，不需要保持有序。</p>
<p><strong>Dinkumware 设计举例</strong></p>
<p>Dinkumware设计的散列容器采取一些不同的策略。它仍然允许你指定对象类型、散列函数类型、比较函数类型和分配器类型，但是<strong>它把默认的散列和比较函数移进一个单独的类似特性的叫做hash_compare的类</strong>，而且它把<code>hash_compare</code>作为容器模板的<code>HashingInfo</code>实参的默认值。</p>
<p>这是<code>Dinkumware</code>的hash_set声明（再次为演示而调整过）:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">HashingInfo</span> <span class="o">=</span> <span class="n">hash_compare</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_set</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种接口设计有趣的地方是<code>HashingInfo</code>的使用。</p>
<p><strong>容器的散列和比较函数储存在<code>HashingInfo</code>中，但HashingInfo类型也容纳了控制表中桶（bucket）最小数量，以及容器元素对桶的最大允许比率的枚举。</strong></p>
<p>当这比率被超过时，表中桶的数量就增加，而表中的一些元素需要重新散列。（SGI提供具有类似控制表中桶和表中元素对桶比率的成员函数。）</p>
<p><strong>hash_compare</strong></p>
<p><code>hash_compare</code>（HashingInfo的默认值）看起来或多或少像这样:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareFunction</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hash_compare</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bucket_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// 元素对桶的最大比率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">min_buckets</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1">// 桶的最小数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 散列函数比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// 忽略一些东西，包括 CompareFunction的使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>重载<code>operator()</code>（在这里是实现散列和比较函数）是比你可以想象的更经常出现的一个策略。</p>
<p><code>Dinkumware</code>设计允许你写你自己的类似hash_compare的类（也许通过从<code>hash_compare</code>本身派生而来），而且只要你的类定义了<code>bucket_size</code>、<code>min_buckets</code>、两个<code>operator()</code>函数（一个带有一个实参，一个带有两个），加上已经省去的一些东西，就能使用它来控制Dinkumware的<code>hash_set</code>或<code>hash_multiset</code>的配置和行为。</p>
<p><code>hash_map</code>和<code>hash_multimap</code>的配置控制也相似。</p>
<h2 id="决策留给实现">决策留给实现</h2>
<p>注意不管是SGI还是Dinkumware的设计，你都能把全部决策留给实现:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 建立一个int的散列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">hash_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intTable</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要让这个可以编译，散列表必须容纳一个整数类型（例如int），因为<strong>默认散列函数一般局限于整数类型。</strong></p>
<p><strong>实现方法不同</strong></p>
<p>在后端，SGI和Dinkumware的实现方法非常不同。</p>
<ol>
<li>SGI利用常用的一个元素的单链表的指针数组（桶）组成的开放散列法。</li>
<li>Dinkumware也利用了开放散列法，但是它的设计是基于一种新颖的数据结构——由迭代器（本质是桶）的数组组成的元素双向链表，迭代器的相邻对表示在每个桶里元素的范围。</li>
</ol>
<p><strong>链表不同</strong></p>
<ol>
<li>SGI实现在<strong>单链表</strong>中储存表的元素</li>
<li>Dinkumware实现使用一个双向链表</li>
</ol>
<p><strong>迭代器种类不同</strong></p>
<ol>
<li>SGI的散列容器提供了前向迭代器，因此你得放弃进行反向迭代的能力：在SGI的散列容器中没有rbegin或者rend成员函数。</li>
<li>用于Dinkumware散列容器的迭代器是双向的，所以它们可以提供前向和反向遍历。</li>
</ol>
<p><strong>内存使用量方面不同</strong></p>
<p>SGI的设计比Dinkumware的节俭一点点。</p>
<h2 id="结论">结论</h2>
<p>虽然STL本身缺乏散列容器，兼容STL的散列容器（有不同的接口、能力和行为权衡）不难得到。就SGI和STLport的实现而言，你甚至可以免费下载得到它们。</p>
]]></description></item><item><title>Effective STL [24] | 当关乎效率时应该在map::operator[]和map-insert之间仔细选择</title><link>https://jianye0428.github.io/posts/clause_24/</link><pubDate>Tue, 15 Aug 2023 08:10:23 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_24/</guid><description><![CDATA[<h2 id="example-map插入">Example map插入</h2>
<p>假设有一个支持默认构造函数以及从一个double构造和赋值的Widget类:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设我们想建立一个从int到Widget的map，而且我们想有初始化有特定值的映射:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.67</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">45.8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0003</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>map operator[] 工作原理</strong></p>
<p>map的<code>operator[]</code>函数是个奇怪的东西。它与vector、deque和string的<code>operator[]</code>函数无关，也和内建的数组operator[]无关。</p>
<p><code>map::operator[]</code>被设计为简化“添加或更新”功能。即，给定<code>map&lt;K, V&gt; m</code>;这个表达式</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>检查键k是否已经在map里。如果不，就添加上，以v作为它的对应值。如果k已经在map里，它的关联值被更新成v。</strong></p>
<p>这项工作的原理是<code>operator[]</code>返回一个与k关联的值对象的引用。然后v赋值给所引用（<code>从operator[]</code>返回的）的对象。</p>
<p>当要更新一个已存在的键的关联值时很直接，因为已经有<code>operator[]</code>可以用来返回引用的值对象。</p>
<p>但是如果k还不在map里，<code>operator[]</code>就没有可以引用的值对象。那样的话，它使用值类型的默认构造函数从头开始建立一个，然后<code>operator[]</code>返回这个新建立对象的引用。</p>
<p>让我们再次地看看原先例子的第一部分：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>m[1]</code>是<code>m.operator[](1)</code>的简化，所以这是一个<code>map::operator[]</code>的调用。</p>
<p>这个函数必须返回一个Widget的引用，因为m 的映射类型是Widget。</p>
<p>在这里，m里面还没有任何东西，所以键1在map里没有入口。因此<code>operator[]</code>默认构造一个Widget来作为关联到1的值，然后返回到那个Widget的引用。</p>
<p>最后，Widget成为赋值目标：被赋值的值是1.50。</p>
<p>所以，下面这个语句</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>功能上等价于这个:</strong></p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 方便的 typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">IntWidgetMap</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 用键1建立新映射入口和一个默认构造的值对象；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Widget</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 赋值给值类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="mf">1.50</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>现在已经很清楚为什么这种方法可能降低性能了：先默认构造一个Widget，然后我们立即赋给它新值。</strong></p>
<p><strong><code>map insert</code>更高效</strong></p>
<p>如果<strong>用想要的值构造Widget比默认构造Widget然后进行赋值显然更高效</strong>，就应该用直截了当的insert调用来替换operator[]的使用（包括它的构造加赋值）:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.50</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这与上面的那些代码有相同的最终效果，除了它<strong>通常节省了3次函数调用</strong>：</p>
<ol>
<li>一个建立临时的默认构造Widget对象</li>
<li>一个销毁那个临时的对象</li>
<li>一个对Widget的赋值操作。</li>
</ol>
<p>这些函数调用越昂贵，你通过使用map-insert代替<code>map::operator[]</code>就能节省越多。</p>
<p>上面的代码利用了每个标准容器都提供的value_type typedef。这typedef没有什么特别重要的，但对于map和multimap（以及非标准容器的hash_map和hash_multimap——参见条款25），记住它是很重要的，容器元素的类型总是某种pair。</p>
<p>之前谈及的<code>operator[]</code>被设计为简化“添加或更新”功能，而且现在我们理解了当“增加”被执行时，<code>insert</code>比<code>operator[]</code>更高效。当做更新时，情形正好相反，也就是，当一个等价的键这已经在map里时。</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 使用operator[]来把k的值更新为v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 来把k的值更新为v使用insert
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">IntWidgetMap</span><span class="o">::</span><span class="n">value_type</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)).</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="operator-与-insert-权衡">operator[] 与 insert 权衡</h2>
<p>insert的调用需要<code>IntWidgetMap::value_type</code>类型的实参（即<code>pair&lt;int, Widget&gt;</code>），所以当调用insert时，我们必须构造和析构一个那种类型的对象。那耗费了一对构造函数和析构函数，也会造成一个Widget的构造和析构，因为<code>pair&lt;int, Widget&gt;</code>本身包含了一个Widget对象，<strong>operator[]没有使用pair对象，所以没有构造和析构pair和Widget。</strong></p>
<div class="details admonition Note open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content"><p>情形选择:</p>
<ol>
<li>因此出于对效率的考虑，当给<code>map</code>添加一个元素时，我们断定<code>insert</code>比<code>operator[]</code>好；</li>
<li>从效率和美学考虑，当更新已经在<code>map</code>里的元素值时<code>operator[]</code>更好。</li>
</ol>
</div>
    </div>
  </div>
<p>如果STL提供一个两全其美的函数，即，在句法上吸引人的包中的高效的“添加或更新”功能:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 如果键k不再map m中；高效地把pair(k, v)添加到m中；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 否则高效地把和k关联的值更新为v。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 返回一个指向添加或修改的pair的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">iterator</span> <span class="n">affectedPair</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是，在STL内没有像这样的函数，正如下面的代码所演示的，自己写一个并不难。那些注释总结了正在做什么，而且随后的段落也提供了一些附加的解释。</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// map的类型KeyArgType和ValueArgtype是类型参数的原因请看下面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MapType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">KeyArgType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ValueArgtype</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">MapType</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">KeyArgType</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValueArgtype</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="c1">// 找到k在或应该在哪里；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Ib</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果Ib指向一个pair, 它的键等价于k...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span><span class="p">(</span><span class="n">Ib</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">k</span><span class="p">,</span> <span class="n">Ib</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 更新这个pair的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Ib</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 并返回指向pair的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">Ib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">MapType</span><span class="o">::</span><span class="n">value_type</span> <span class="n">MVT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 把pair(k, v)添加到m并// 返回指向新map元素的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Ib</span><span class="p">,</span> <span class="n">MVT</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>执行一个高效的增加或更新，我们需要能<strong>找出k的值是否在map中; 如果是这样，那它在哪里; 如果不是，它该被插入哪里。</strong></p>
<p>这个工作是为<code>low_bound</code>量身定做的，所以在这里我们调用那个函数。确定lower_bound是否用我们要寻找的键找到了一个元素，我们对后半部分进行一个等价测试，一定要对map使用正确的比较函数: 通过<code>map::key_comp</code>提供的比较函数。等价测试的结果告诉我们应该进行增加还是更新。</p>
<p>如果是更新，代码很直截了当。插入分支更有趣，因为它使用了insert的“提示”形式。结构<code>m.insert(Ib，MVT(k，v))</code>“提示”了**<code>Ib</code>鉴别出了键等价于k的新元素正确的插入位置，而且保证如果提示正确，那么插入将在分摊的常数时间内发生，而不是对数时间**。在<code>efficientAddOrUpdate</code>里，我们知道Ib鉴别出了适当的插入位置，因此insert的调用被保证为是一次常数时间操作。</p>
<p><strong>KeyArgType和ValueArgType</strong></p>
<p>这个实现的一个有趣方面是<code>KeyArgType</code>和<code>ValueArgType</code>不必是储存在map里的类型。它们只需要可以转换到储存在map里的类型。</p>
<p>一个可选的方法是去掉类型参数<code>KeyArgType</code>和<code>ValueArgType</code>，改为使用<code>MapType::key_type</code>和<code>MapType::mapped_type</code>。</p>
<p>但是，如果我们那么做，<strong>在调用时我们可能强迫发生不必要的类型转换</strong>:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 别忘了Widget接受从一个double赋值：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在考虑<code>efficientAddOrUpdate</code>的调用:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">efficientAddOrUpdate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设是一次更新操作，即，m已经包含键是10的元素。那样的话，上面的模板推断出<code>ValueArgType</code>是<code>double</code>，<strong>函数体直接把1.5作为double赋给与10相关的那个Widget</strong>。那是通过调用<code>Widget::operator(double)</code>完成的。</p>
<p>如果我们用了<code>MapType::mapped_type</code>作为<code>efficientAddOrUpdate</code>的第3个参数的类型，在调用时我们得把1.5转化成一个Widget，那样的话我们就得<strong>花费本来不需要的一次Widget构造（以及随后的析构）</strong>。</p>
<h2 id="结论">结论</h2>
<p>当关乎效率时应该在map::operator[]和map-insert之间仔细选择。</p>
<p><font color=red>如果你要更新已存在的map元素，operator[]更好，但如果你要增加一个新元素，insert则有优势。</font></p>
]]></description></item><item><title>Effective STL [23] | 考虑用有序vector代替关联容器</title><link>https://jianye0428.github.io/posts/clause_23/</link><pubDate>Mon, 14 Aug 2023 19:13:32 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_23/</guid><description><![CDATA[<p>当需要一个提供快速查找的数据结构时，很多STL程序员立刻会想到标准关联容器：<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>。</p>
<p>如果使用了合适的散列函数，则可以认为散列容器提供了常数时间的查找。</p>
<p>对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的<code>set</code>、<code>map</code>和它们的<code>multi</code>同事。</p>
<p>即使你需要的就只是==对数时间==查找的保证，标准关联容器仍然可能不是你的最佳选择。和直觉相反，对于标准关联容器，所提供的性能也经常劣于本该比较次的<code>vector</code>。</p>
<h2 id="关联容器数据结构">关联容器数据结构</h2>
<p>标准关联容器的典型实现是<strong>平衡二叉查找树</strong>。</p>
<p>一个平衡二叉查找树是一个对<strong>插入</strong>、<strong>删除</strong>和<strong>查找</strong>的混合操作优化的数据结构。</p>
<p>换句话说，它被设计为应用于进行一些插入，然后一些查找，然后可能再进行一些插入，然后也许一些删除，然后再来一些查找，然后更多的插入或删除，然后更多的查找等。这个事件序列的关键特征是插入、删除和查找都是混合在一起的。</p>
<p>一般来说，没有办法预测对树的下一个操作是什么。</p>
<p><strong>使用数据结构的3阶段</strong></p>
<ol>
<li><strong>建立</strong>。通过插入很多元素建立一个新的数据结构。在这个阶段，几乎所有的操作都是插入和删除。几乎没有或根本没有查找。</li>
<li><strong>查找</strong>。在数据结构中查找指定的信息片。在这个阶段，几乎所有的操作都是查找。几乎没有或根本没有插入和删除。</li>
<li><strong>重组</strong>。修改数据结构的内容，通过删除所有现有数据和在原地插入新数据。从动作上说，这个阶段等价于阶段1。一旦这个阶段完成，应用程序返回阶段2。</li>
</ol>
<h2 id="有序vector更高效">有序vector更高效</h2>
<p>一个vector可能比一个关联容器能提供更高的性能（时间和空间上都是）。</p>
<p>但不是任意的<code>vector</code>都会，只有有序vector。因为只有有序容器才能正确地使用查找算法——<code>binary_search</code>、<code>lower_bound</code>、<code>equal_range</code>等。</p>
<p>Q: 为什么一个（有序的）vector的二分法查找比一个二叉树的二分法查找提供了更好的性能？</p>
<p>A: 其中的一个是<strong>大小问题</strong>，其中的一个是<strong>引用局部性问题</strong>。</p>
<p><strong>大小问题</strong></p>
<p>假设我们需要一个容器来容纳Widget对象，而且，因为查找速度对我们很重要，我们考虑一个Widget的关联容器和一个有序<code>vector&lt;Widget&gt;</code>。</p>
<p><strong>关联容器数据结构</strong></p>
<p>如果选择一个关联容器，我们几乎确定了要使用平衡二叉树。这样的树是由树节点组成，每个都不仅容纳了一个Widget，而且保存了一个该节点到左孩子的指针，一个到它右孩子的指针，和（典型的）一个到它父节点的指针。</p>
<p>这意味着<strong>在关联容器中用于存储一个Widget的空间开销至少会是三个指针</strong>。</p>
<p><strong>vector数据结构</strong></p>
<p>与之相对的是，当在vector中存储Widget并没有开销：简单地存储一个Widget。</p>
<p>当然，<strong>vector本身有开销</strong>，在vector结尾也可能有空的（保留）空间，但是每个vector开销是可以忽略的（通常是三个机器字，比如，三个指针或两个指针和一个int），而且如果必要的话，末尾空的空间可以通过“交换技巧”去掉。即使这个附加的空间没有去掉，也并不影响下面的分析，因为当查找时不会引用那段内存。</p>
<p><strong>内存大小</strong></p>
<p>假设我们的数据结构足够大，它们可以分成多个内存页面，但是vector比关联容器需要的页面要少。</p>
<p>因为vector不需要每个Widget的开销，而关联容器给每个Widget上附加了三个指针。</p>
<p>假设在你使用的系统上一个Widget的大小是12个字节，指针是4个字节，一个内存页面是4096（4K）字节。</p>
<p>忽略每个容器的开销，当用vector保存时，你可以在一页面上放置341个Widget $(4096\div12\approx341)$，但使用关联容器时你最多只能放170个 $4096\div(12+4\times3)\approx170)$。</p>
<p><strong>因此关联容器和vector比起来，你将会使用大约两倍的内存。</strong></p>
<p>如果你使用的环境可以用<strong>虚拟内存</strong>，就很可以容易地看出那会<strong>造成大量的页面错误，因此一个系统会因为大数据量而明显慢下来</strong>。</p>
<p><strong>引用局部性问题</strong></p>
<p>假设在二叉树中的节点都群集在一个相关的小内存页面集中，实际情况下关联容器很乐观的。</p>
<p><strong>大部分STL实现使用自定义内存管理器来达到这样的群集，但是如果你的STL实现没有改进树节点中的引用局部性，这些节点会分散在所有你的内存空间。那会导致更多的页面错误。</strong></p>
<p>即使使用了自定义群集内存管理器，关联容器也会导致很多页面错误，因为，不像连续内存容器，比如vector，<strong>基于节点的容器更难保证在容器的遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个。</strong></p>
<p><strong>当进行二分查找时那种内存组织方式（译注：遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个）正好是页面错误最少的。</strong></p>
<h2 id="vector的缺点">vector的缺点</h2>
<p><font color=red>有序vector的大缺点是必须保持有序！</font></p>
<p>因为vector中所有的元素都必须拷贝，所以：</p>
<ol>
<li>
<p>当一个新元素插入时，大于这个新元素的所有东西都必须向上移一位，非常昂贵；</p>
</li>
<li>
<p>如果vector必须重新分配它的内在内存，则会更昂贵；</p>
</li>
<li>
<p>如果一个元素从vector中被删除，所有大于它的元素都要向下移动。</p>
</li>
</ol>
<p>vector的插入和删除都很昂贵，但是关联容器的插入和删除则很轻量。</p>
<p>这就是为什么只有当你知道你的数据结构使用的时候查找几乎不和插入和删除混合时，使用有序vector代替关联容器才有意义。</p>
<p><strong>概要</strong></p>
<ol>
<li>
<p>在有序vector中存储数据很有可能比在标准关联容器中保存相同的数据消耗更少的内存；</p>
</li>
<li>
<p>当页面错误值得重视的时候，在有序vector中通过二分法查找可能比在一个标准关联容器中查找更快。</p>
</li>
</ol>
<h2 id="example">Example</h2>
<blockquote>
<p>vector代替set</p>
</blockquote>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="c1">// 代替set&lt;Widget&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">vw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结束建立阶段。（当模拟一个multiset时，你可能更喜欢用stable_sort 来代替；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于查找的值的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span><span class="c1">// 开始查找阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过binary_search查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过lower_bound查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 条款19解释了“!(w &lt; *i)”测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">i</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过equal_range查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                       <span class="n">equal_range</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">)...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 结束查找阶段，开始重组阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 开始新的查找阶段...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>里面最难的东西就是<strong>怎么在搜索算法中做出选择</strong>（比如，<code>binary_search</code>、<code>lower_bound</code>等）</p>
<blockquote>
<p>vector代替map或multimap</p>
</blockquote>
<p>当你决定用vector代替map或multimap时，事情会变得更有趣，因为<strong>vector必须容纳pair对象</strong>。</p>
<p>但是要注意，如果你声明一个map&lt;K, V&gt;的对象（或者等价的multimap），保存在map中的元素类型是<code>pair&lt;const K, V&gt;</code>。</p>
<p>如果要用vector模拟<code>map</code>或者<code>multimap</code>，<strong>必须去掉const</strong>，因为当你对vector排序时，元素的值将会通过赋值移动，那意味着pair的两个组件都必须是可赋值的。</p>
<p>当使用vector来模拟map&lt;K, V&gt;时，<strong>保存在vector中数据的类型将是<code>pair&lt;K, V&gt;</code></strong>，而不是<code>pair&lt;const K, V&gt;</code>。</p>
<p>map和multimap以顺序的方式保存他们的元素，但<strong>用于排序目的时它们只作用于元素的key部分</strong>（pair的第一个组件），所以当排序vector时你必须做一样的事情。</p>
<p>你需要为你的pair写一个自定义比较函数，因为<code>pair</code>的<code>operator&lt;</code>作用于pair的两个组件。</p>
<p><strong>2个比较函数来进行查找</strong></p>
<p>用来排序的比较函数将作用于两个pair对象，但是查找只用到key值。</p>
<p>必须传给用于查找的比较函数一个key类型的对象（要查找的值）和一个pair（存储在vector中的一个pair）——两个不同的类型。</p>
<p>还有一个附加的麻烦，你不会知道key还是pair是作为第一个实参传递的，所以你真的需要两个用于查找的比较函数：<strong>一个key值先传递，一个pair先传递</strong></p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">Data</span><span class="p">;</span> <span class="c1">// 在这个例子里&#34;map&#34;容纳的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DataCompare</span> <span class="p">{</span> <span class="c1">// 用于比较的类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于排序的比较函数keyLess在下面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">keyLess</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于查找的比较函数（形式1）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">Ihs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">keyLess</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于查找的比较函数（形式2）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span>  <span class="k">const</span> <span class="n">Data</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">keyLessfk</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// “真的”比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">keyLess</span><span class="p">(</span><span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Data</span><span class="o">::</span><span class="n">first_type</span><span class="o">&amp;</span> <span class="n">k2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">k1</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们假设有序vector将模拟<code>map&lt;string, int&gt;</code>。</p>
<p>这段代码几乎是上面讨论的字面转换，除了存在成员函数<code>keyLess</code>。</p>
<p>那个函数的存在是用来<strong>保证几个不同的<code>operator()</code>函数之间的一致性</strong>。</p>
<p>每个这样的函数只是简单地比较两个key的值，所以我们把这个测试放在keyLess中并让operator()函数返回keyLess所做的事情，这比复制那个逻辑要好。</p>
<p>这个软件工程中绝妙的动作增强了<code>DataCompare</code>的可维护性，但<strong>有一个小缺点，它提供了有不同参数类型的operator()函数，这将导致函数对象无法适配。</strong></p>
<p>把有序vector用作map本质上和用作set一样。</p>
<p><strong>唯一大的区别是必须把DataCompare对象用作比较函数:</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 代替map&lt;string, int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;</span> <span class="n">vd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 建立阶段：很多插入，几乎没有查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结束建立阶段。（当模拟multimap时，你可能更喜欢用stable_sort来代替）；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于查找的值的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 开始查找阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过binary_search查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">()))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 再次通过lower_bound查找，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 条款45解释了“!DataCompare()(s, *i)”测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">DataCompare</span><span class="p">()(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">i</span><span class="p">))...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过equal_range查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">equal_range</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">DataCompare</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">)...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 结束查找阶段，开始重组阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 开始新的查找阶段...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DataCompare</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如你所见，一旦你写了DataCompare，东西都很好地依序排列了。</p>
<p>而一旦位置合适了，它们往往比相应的使用真的map的设计运行得更快而且使用更少内存。</p>
<p>如果你的程序不是按照阶段的方式操作数据结构，那么使用有序vector代替标准关联容器几乎可以确定是在浪费时间。</p>
]]></description></item><item><title>Effective STL [22] | 避免原地修改set和multiset的键</title><link>https://jianye0428.github.io/posts/clause_22/</link><pubDate>Mon, 14 Aug 2023 08:13:21 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_22/</guid><description><![CDATA[<p><strong>所有标准关联容器，set和multiset保持它们的元素有序，这些容器的正确行为依赖于它们保持有序。</strong></p>
<p>如果你改了关联容器里的一个元素的值（例如，把10变为1000），新值可能不在正确的位置，而且那将破坏容器的有序性。</p>
<h2 id="修改map和multimap值">修改map和multimap值</h2>
<p>试图改变这些容器里的一个键值的程序将不能编译:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 错误！map键不能改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">mm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">mm</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 错误！multimap键也不能改变
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition tip open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-lightbulb fa-fw" aria-hidden="true"></i>Note<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">因为<code>map&lt;K, V&gt;</code>或<code>multimap&lt;K, V&gt;</code>类型的对象中元素的类型是<code>pair&lt;const K, V&gt;</code>。因为键的类型const K，它不能改变。</div>
    </div>
  </div>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">map</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">key_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Tp</span>     <span class="n">mapped_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&gt;</span>  <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span>     <span class="n">key_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Alloc</span>     <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你使用一个<code>const_cast</code>，或许能改变它，后面会讨论到。</p>
<h2 id="修改set和multiset值">修改set和multiset值</h2>
<p>对于<code>set&lt;T&gt;</code>或<code>multiset&lt;T&gt;</code>类型的对象来说，储存在容器里的元素类型只不过是<code>T</code>，并非<code>const T</code>。因此，<code>set</code>或<code>multiset</code>里的元素可能在你想要的任何时候改变。不需要映射。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">_Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">set</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// typedefs:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///@{
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Public typedefs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">key_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Key</span>     <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span> <span class="n">key_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Compare</span> <span class="n">value_compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Alloc</span>   <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">///@}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>为什么set或multiset里的元素不是常数？</strong></p>
<p>假设我们有一个雇员的类:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Employee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>       <span class="c1">// 获取雇员名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span> <span class="c1">// 设置雇员名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">getTitle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>   <span class="c1">// 获取雇员头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setTitle</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">);</span>     <span class="c1">// 设置雇员头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">idNumber</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>             <span class="c1">// 获取雇员ID号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们做合理的假设，每个雇员有唯一的ID号，就是<code>idNumber</code>函数返回的数字。然后，建立一个雇员的<code>set</code>，很显然应该只以<code>ID</code>号来排序<code>set</code>:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">IDNumberLess</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">Employee</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 参见条款40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Employees</span> <span class="n">lhs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">idNumber</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">idNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">Employee</span><span class="p">,</span> <span class="n">IDNumberLess</span><span class="o">&gt;</span> <span class="n">EmpIDSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EmpIDSet</span> <span class="n">se</span><span class="p">;</span> <span class="c1">// se是雇员的set， 按照ID号排序
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，雇员的<code>ID</code>号是<code>set</code>中元素的键。<strong>其余的雇员数据只是虚有其表</strong>。在这里，没有理由不能把一个特定雇员的头衔改成某个有趣的东西:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Employee</span> <span class="n">selectedID</span><span class="p">;</span> <span class="c1">// 容纳被选择的雇员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span> <span class="c1">// ID号的变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">-&gt;</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 给雇员新头衔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为在这里我们只是改变雇员的一个与set排序的方式无关的方面（一个雇员的非键部分），所以这段代码不会破坏set。那是它合法的原因。但它的合法排除了<code>set/multiset</code>的元素是<code>const</code>的可能。而且那是它们为什么不是的原因。</p>
<p>因为<code>set</code>或<code>multiset</code>里的值不是<code>const</code>，所以试图改变它们可以编译。</p>
<p><font color=red>如果你改变<code>set</code>或<code>multiset</code>里的元素， 你必须<strong>确保不改变一个键部分——影响容器有序性的元素部分</strong>。如果你做了，你会破坏容器，再使用那个容器将产生未定义的结果， 而且那是你的错误。另一方面，这个限制只应用于被包含对象的键部分。对被包含元素的所有其他部分来说，是开放的: 随便改变！</font></p>
<h2 id="阻止修改set和multiset值">阻止修改set和multiset值</h2>
<p>即使<code>set</code>和<code>multiset</code>的元素不是<code>const</code>，实现仍然有很多方式可以阻止它们被修改。</p>
<p>例如，实现可以让用于<code>set&lt;T&gt;::iterator的operator*</code>返回一个常数<code>T&amp;</code>。即，它可以让<code>set</code>的迭代器解引用的结果是<code>set</code>元素的常量引用。</p>
<p>在这样的实现下，将没有办法修改<code>set</code>或<code>multiset</code>的元素，因为所有访问那些元素的方法都将在让你访问之前加一个<code>const</code>。</p>
<h2 id="要不要修改set和multiset值">要不要修改set和multiset值</h2>
<ol>
<li>如果<strong>不关心移植性</strong>，你想要改变set或multiset中元素的值，而且你的STL实现让你侥幸成功，继续做。只是要确定不要改变元素的键部分，即，会影响容器有序性的元素部分。</li>
<li>如果<strong>在乎移植性</strong>，就认为set和multiset中的元素不能被修改，至少不能在没有映射的情况下</li>
</ol>
<p><strong>Solution: 映射到一个引用</strong></p>
<p>有时候完全有理由改变<code>set</code>或<code>multiset</code>元素的非键部分。例如刚看的不能在一些实现下编译的<code>setTitle</code>调用:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">-&gt;</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 有些STL实现会拒绝这样，因为*i是const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了让它可以编译并且行为正确，我们必须映射掉*i的常量性。这是那么做的正确方法:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 映射掉*i的常量性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>这可以得到i指向的对象，告诉你的编译器把映射的结果当作一个（非常数）Employee的引用，然后在那个引用上调用setTitle。</strong></p>
<p><strong>错误版本的映射</strong></p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">  <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 把*i映射到一个Employee
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>它也等价于如下内容:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">((</span><span class="n">Employee</span><span class="p">)(</span><span class="o">*</span><span class="n">i</span><span class="p">)).</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 使用C映射语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这两个都能编译，而且因为它们等价，所以它们错的原因也相同。</p>
<p><strong>在运行期，它们不能修改<code>*i</code>！</strong></p>
<p><strong>在这两个情况里，映射的结果是一个<code>*i</code>副本的临时匿名对象，而setTitle是在匿名的物体上调用，不在<code>*i</code>上<code>！*i</code>没被修改，因为setTitle从未在那个对象上调用，它在那个对象的副本上调用。</strong></p>
<p>两个句法形式等价于这个:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Employee</span> <span class="nf">tempCopy</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 把*i拷贝到tempCopy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tempCopy</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 修改tempCopy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过映射到引用，我们避免了建立一个新对象。</p>
<p>取而代之的是，映射的结果是一个现有对象的引用，<code>i</code>指向的对象。</p>
<p>当我们在有这个引用指定的对象上调用setTitle时，我们是在<code>*i</code>上调用setTitle，而且那正是我们想要的。</p>
<p><strong>为什么不能去掉map和multimap的常量性</strong></p>
<p>注意<code>map&lt;K, V&gt;</code>或<code>multimap&lt;K, V&gt;</code>包含<code>pair&lt;const K, V&gt;</code>类型的元素。</p>
<p>那个<code>const</code>表明<code>pair</code>的第一个组件被定义为常量，而那意味着试图修改它是未定义的行为（即使映射掉它的常量性）。</p>
<p>理论上，一个STL实现可能把这样的值写到一个只读的内存位置（比如，一旦写了就通过系统调用进行写保护的虚拟内存页），而且试图映射掉它的常量性，最多，没有效果。</p>
<p>如果你是一个坚持遵循标准拟定的规则的人，你绝不会试图映射掉<code>map</code>或<code>multimap</code>键的常量性。</p>
<h2 id="安全修改元素步骤">安全修改元素步骤</h2>
<p>想要总是可以工作而且总是安全地改变set、multiset、map或multimap里的元素，按5个简单的步骤去做：</p>
<ol>
<li>定位你想要改变的容器元素。如果你不确定最好的方法， 条款45提供了关于怎样进行适当搜寻的指导。</li>
<li>拷贝一份要被修改的元素。对map或multimap而言，确定不要把副本的第一个元素声明为const。毕竟，你想要改变它！</li>
<li>修改副本，使它有你想要在容器里的值。</li>
<li>从容器里删除元素，通常通过调用erase（参见条款9）。</li>
<li>把新值插入容器。如果新元素在容器的排序顺序中的位置正好相同或相邻于删除的元素，使用insert的“提示”形式把插入的效率从对数时间改进到分摊的常数时间。使用你从第一步获得的迭代器作为提示。</li>
</ol>
<p><strong>一句话概括就是：先删除，再插入新的。</strong></p>
<p><strong>Example:</strong></p>
<p>这是同一个累人的雇员例子，这次以安全、可移植的方式写:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EmpIDSet</span> <span class="n">se</span><span class="p">;</span> <span class="c1">// 同前，se是一个以ID号排序的雇员set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Employee</span> <span class="n">selectedID</span><span class="p">;</span> <span class="c1">// 同前，selectedID是一个带有需要ID号的雇员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">EmpIDSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">selectedID</span><span class="p">);</span> <span class="c1">// 第一步：找到要改变的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">se</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Employee</span> <span class="nf">e</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 第二步：拷贝这个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">se</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>  <span class="c1">// 第三步：删除这个元素；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// 自增这个迭代器以
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="c1">// 保持它有效（参见条款9）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">e</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">&#34;Corporate Deity&#34;</span><span class="p">);</span> <span class="c1">// 第四步：修改这个副本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">se</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>               <span class="c1">// 第五步：插入新值；提示它的位置和原先元素的一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Effective STL [21] | 永远让比较函数对相等的值返回false</title><link>https://jianye0428.github.io/posts/clause_21/</link><pubDate>Fri, 11 Aug 2023 17:11:35 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_21/</guid><description><![CDATA[<h2 id="example-set">Example set</h2>
<p>建立一个set，比较类型用<code>less_equal</code>，然后插入整型数字33(称为 $33_{A}$):</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// s以“&lt;=”排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span> <span class="c1">// 插入33
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在尝试再插入一次33(称为 $33_{B}$):</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于这个insert的调用，set必须先要判断出 $33_{A}$ 是否已经位于其中了，查找哪儿适合插入 $33_{B}$。最终，它总要检查 $33_{B}$是否与 $33_{A}$ 相同。</p>
<p>关联容器对“相同”的定义是等价，因此set测试 $33_{B}$是否等价于 $33_{A}$。</p>
<p>当执行这个测试时，它自然是使用set的比较函数。在这一例子里，是<code>operator&lt;=</code>，因为我们指定<code>set</code>的比较函数为<code>less_equal</code>，而<code>less_equal</code>意思就是<code>operator&lt;=</code>。</p>
<p>可以看看<code>less_equal</code>的源码实现：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// One of the @link comparison_functors comparison functors@endlink.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">less_equal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_GLIBCXX14_CONSTEXPR</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__y</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span> <span class="o">&lt;=</span> <span class="n">__y</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 此处是 &lt;=
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>于是，set将计算这个表达式是否为真:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="mi">33</span><span class="n">A</span> <span class="o">&lt;=</span> <span class="mi">33</span><span class="n">B</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="mi">33</span><span class="n">B</span> <span class="o">&lt;=</span> <span class="mi">33</span><span class="n">A</span><span class="p">)</span> <span class="c1">// 测试33A和33B是否等价
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>$33_{A}$ 和 $33_{B}$ 都是33，因此， $33_{A}$&lt;=$33_{B}$ 肯定为真。同样清楚的是，$33_{B}$ &lt;= $33_{A}$。于是上述的表达式简化为:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再简化就是</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果当然是false。</p>
<p>也就是说，set得出的结论是 $33_{B}$ 与 $33_{B}$ 不等价，因此不一样，于是它将 $33_{B}$ 插入容器中的旁边。</p>
<p>在技术上而言，这个做法导致未定义的行为，但是通常的结果是set以拥有了两个为33的值的拷贝而告终，也就是说它不再是一个set了。通过使用less_equal作为我们的比较类型，我们破坏了容器！</p>
<p><strong>测试</strong></p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">snumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">snumber</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">snumber</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">for_each</span><span class="p">(</span><span class="n">snumber</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">snumber</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">33</span>
</span></span><span class="line"><span class="cl"><span class="mi">33</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="example-string">Example string*</h2>
<p><code>条款20</code>描述了该如何写一个比较函数以使得容纳<code>string*</code>指针的容器根据string的值排序，而不是对指针的值排序。那个比较函数是按升序排序的，但现在假设你需要<code>string*</code>指针的容器的降序排序的比较函数。</p>
<p>自然是抓现成的代码来修改了。如果不细心，可能会这么干:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrGreater</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 这代码是有瑕疵的！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">);</span> <span class="c1">// 只是相反了旧的测试；这是不对的！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的想法是通过将比较函数内部结果取反来达到反序的结果。很不幸，取反“&lt;”不会给你（你所期望的）“&gt;”，它给你的是 “&gt;=”。</p>
<p>而你现在知道，因为它将对相等的值返回true，对关联容器来说，它是一个无效的比较函数。</p>
<p>你真正需要的比较类型是这个:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrGreater</span><span class="o">:</span> <span class="c1">// 对关联容器来说这是有效的比较类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="n">ps2</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps1</span><span class="p">;</span> <span class="c1">// 返回*ps2是否大于*ps1（也就是交换操作数的顺序）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要避免掉入这个陷阱，你所要记住的就是比较函数的返回值表明的是在此函数定义的排序方式下，一个值是否大于另一个。</p>
<p><strong>相等的值绝不该一个大于另一个，所以比较函数总应该对相等的值返回<code>false</code></strong></p>
<h2 id="example-multiset">Example multiset</h2>
<p>multiset和multimap那些容器可以容纳复本可能包含副本，如果容器认为两个值相等的对象不等价，它将会把两个都存储进去的，这正是multi系列容器的所要支持的事情。</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">msnum</span><span class="p">;</span> <span class="c1">// 仍然以“&lt;=”排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">msnum</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// 插入22A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">msnum</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// 插入22B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">for_each</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">22</span>
</span></span><span class="line"><span class="cl"><span class="mi">22</span></span></span></code></pre></td></tr></table>
</div>
</div><p>s里有两个22的拷贝，<strong>因此我们期望如果我们在它上面做一个<code>equal_range</code>，我们将会得到一对指出包含这两个拷贝的范围的迭代器。但那是不可能的。</strong></p>
<p><code>equal_range</code>，虽然叫这个名字，但不是指示出相等的值的范围，而是等价的值的范围。在这个例子中，s的比较函数说22A和22B是不等价的，所以不可能让它们同时出现在equal_range所指示的范围内。</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">range2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//在 myvector 容器中找到所有的元素 22
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">range2</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">22</span><span class="p">,</span> <span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">my multiset：&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">range2</span><span class="p">.</span><span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">range2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果没有得到期望结果:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">my multiset:</span></span></code></pre></td></tr></table>
</div>
</div><p>如果改为<code>less</code>比较:</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">range2</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">msnum</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msnum</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">22</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">my</span> <span class="n">multiset</span><span class="err">：</span><span class="mi">22</span> <span class="mi">22</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red><strong>除非你的比较函数总是为相等的值返回false，你将会打破所有的标准关联型容器，不管它们是否允许存储复本。</strong></font></p>
<h2 id="总结">总结</h2>
<p>从技术上说，用于排序关联容器的比较函数必须在它们所比较的对象上定义一个“<strong>严格的弱序化(strict weakordering)</strong>”。（传给sort等算法（参见条款31）的比较函数也有同样的限制）。</p>
<p><strong>任何一个定义了严格的弱序化的函数都必须在传入相同的值的两个拷贝时返回false。</strong></p>
]]></description></item><item><title>Effective STL [20] | 为指针的关联容器指定比较类型</title><link>https://jianye0428.github.io/posts/clause_20/</link><pubDate>Fri, 11 Aug 2023 16:10:59 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_20/</guid><description><![CDATA[<h2 id="example">Example</h2>
<p>假定你有一个string*指针的set，你把一些动物的名字插入进set:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Anteater&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Wombat&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Lemur&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">ssp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Penguin&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ssp = “set of string ptrs”
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后你写了下列代码打印set的内容，希望字符串按字母顺序出现。毕竟，确定set保持它们的内容有序。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你期望看到</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Anteater
</span></span><span class="line"><span class="cl">Wombat
</span></span><span class="line"><span class="cl">Lemur
</span></span><span class="line"><span class="cl">Penguin</span></span></code></pre></td></tr></table>
</div>
</div><p>实际运行结果:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mh">0x5566364b5eb0</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5f10</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5f70</span>
</span></span><span class="line"><span class="cl"><span class="mh">0x5566364b5fd0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果是4个十六进制的数，代表指针的值。 因为set容纳指针，<code>*i</code>不是一个<code>string</code>，是一个<code>string</code>的指针。</p>
<p>如果你已经改为调用copy算法，</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">copy</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span><span class="c1">// 把ssp中的字符串拷贝到cout（但这不能编译）
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个copy的调用将不能编译，因为<code>ostream_iterator</code>需要知道被打印的对象的类型，所以当你告诉它是一个string时（通过作为模板参数传递），编译器检测到那和ssp中储存的对象类型(是<code>string*</code>)之间不匹配，它们会拒绝编译代码。</p>
<p>把显式循环中的<code>*i</code>改为<code>**i</code>，你可能可以得到你想要的输出，但也可能不。动物名字将被打印，但它们按字母顺序出现的机会只是24份之1。ssp保持它的内容有序，但是它容纳的是指针，所以它以指针的值排序，而不以string值。对于四个指针值可能有24种排列（），所以指针被储存时有24种可能的顺序。因此你看见字符串按字母排序有24份之1的几率。</p>
<p>或者打印 <code>*string</code>的<code>char*</code>数组</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="solution">Solution</h2>
<p>当我们写下<code>set&lt;string*&gt; ssp</code>;，其实省略了一个默认参数<code>set&lt;string*, less&lt;string*&gt; &gt; ssp</code>;，实际上还有个默认参数:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">,</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="自定义仿函数">自定义仿函数</h2>
<p>如果想要<code>string*</code>指针以字符串值确定顺序被储存在<code>set</code>中，不能使用默认比较仿函数类<code>less&lt;string*&gt;</code>。</p>
<p><strong>必须改为写自己的比较仿函数类，它的对象带有string*指针并按照指向的字符串值来进行排序:</strong></p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StringPtrLess</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span> <span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后可以使用<code>StringPtrLess</code>作为<code>ssp</code>的比较类型:</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">StringPtrLess</span><span class="o">&gt;</span> <span class="n">StringPtrSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">StringPtrSet</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立字符串的集合，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 按照StringPtrLess定义的顺序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 和前面一样插入
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同样四个字符串
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在循环最后将做想要它做的（也就是前面你使用*i代替**i所修正的问题）:</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">StringPtrSet</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">**</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>指针之前对它们解引用的函数，然后和<code>for_each</code>联用那个函数:</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ps</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">print</span><span class="p">);</span><span class="c1">// 在ssp中的每个元素上调用print
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者你想象并写出了泛型的解引用仿函数类，然后让它和transform与ostream_iterator连用:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 当本类型的仿函数被传入一个T*时，它们返回一个const T&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Dereference</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过解引用“转换” ssp中的每个元素，把结果写入cout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">transform</span><span class="p">(</span><span class="n">ssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">Dereference</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要点是无论何时你建立一个指针的标准关联容器，你必须记住容器会以指针的值排序。这基本上不是你想要的，所以你几乎总是需要建立自己的仿函数类作为比较类型。</p>
<p><strong>比较类型 vs 比较函数</strong></p>
<p>注意到这里写的是“比较类型”。</p>
<p>你可能奇怪为什么必须特意创造一个仿函数类而不是简单地为set写一个比较函数:</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">stringPtrLess</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">ps1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">ps2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 将成为用于按字符串值排序的string*指针的比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">return</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ps2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">stringPtrLess</span><span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span><span class="c1">// 假设使用stringPtrLess 作为ssp的比较函数；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这不能编译
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的问题是每个set模板的第三个参数都是一种类型，而<code>stringPtrLess</code>不是一种类型，它是一个函数。这就是为什么尝试使用<code>stringPtrLess</code>作为set的比较函数不能编译的原因，set不要一个函数，它要的是能在内部用实例化建立函数的一种类型。</p>
<p><strong>无论何时你建立指针的关联容器，注意你也得指定容器的比较类型。</strong></p>
<p>大多数时候，你的比较类型只是解引用指针并比较所指向的对象（就像上面的<code>StringPtrLess</code>做的那样）。</p>
<p>鉴于这种情况，你手头最好也能有一个用于那种比较的仿函数模板。像这样:</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DereferenceLess</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PtrType</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">PtrType</span> <span class="n">pT1</span><span class="p">,</span> <span class="n">PtrType</span> <span class="n">pT2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="c1">// 参数是值传递的因为我们希望它们是（或行为像）指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">pT1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pT2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的模板消除了写像<code>StringPtrLess</code>那样的类的需要，因为我们可以改为使用<code>DereferenceLess</code>:</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">DereferenceLess</span><span class="o">&gt;</span> <span class="n">ssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 行为就像 set&lt;string*, StringPtrLess&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>本条款是关于指针的关联容器，但它也可以应用于表现为指针的对象的容器，例如，智能指针和迭代器。</p>
<p>如果你有一个智能指针或迭代器的关联容器，那也得为它指定比较类型。幸运的是，指针的这个解决方案也可以用于类似指针的对象。正如DereferenceLess适合作为T*的关联容器的比较类型一样，它也 可以作为T对象的迭代器和智能指针容器的比较类型。</p>
<p>实际上，这24种排列很可能不是平等的，所以“24份之1”的陈述有点使人误解。确实，有24个不同的顺序，而且你可能得到它们中的任何一个。</p>
]]></description></item><item><title>Effective STL [19] | 了解相等和等价的区别</title><link>https://jianye0428.github.io/posts/clause_19/</link><pubDate>Thu, 10 Aug 2023 08:30:55 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_19/</guid><description><![CDATA[<h2 id="比较对象">比较对象</h2>
<p>STL充满了比较对象是否有同样的值。比如，当你用<code>find</code>来定位区间中第一个有特定值的对象的位置，<code>find</code>必须可以比较两个对象，看看一个的值是否与另一个相等。同样，当你尝试向<code>set</code>中插入一个新元素时，<code>set::insert</code>必须可以判断那个元素的值是否已经在<code>set</code>中了。</p>
<p><code>find</code>算法和<code>set</code>的<code>insert</code>成员函数是很多必须判断两个值是否相同的函数的代表。但它们实现方式不同，find对“相同”的定义是相等，基于<code>operator==</code>。<code>set::insert</code>对“相同”的定义是等价，通常基于<code>operator&lt;</code>。因为有定义不同，所以有可能一个定义规定了两个对象有相同的值而另一个定义判定它们没有。结果，如果你想有效使用STL，那么你必须明白相等和等价的区别。</p>
<p><strong>相等</strong></p>
<p>操作上来说，相等的概念是基于<code>operator</code>的。如果表达式“<code>x == y</code>”返回true，<code>x</code>和<code>y</code>有相等的值，否则它们没有。</p>
<p><strong><font color=red>x和y有相等的值并不意味着所有它们的成员有相等的值</font></strong>。比如，我们可能有一个内部记录了最后一次访问的Widget类。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="n">TimeStamp</span> <span class="n">lastAccessed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以有一个用于Widget的忽略这个域的operator:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 忽略lastAccessed域的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，两个<code>Widget</code>即使它们的<code>lastAccessed</code>域不同也可以有相等的值。</p>
<p>一般而言，相等意味着两个变量的值相同，但是如果比较2个对象，因为比较函数可以自定义，因此有时候对象的某些成员变量值不同也会设定2个对象相等。</p>
<p><strong>等价</strong></p>
<p>==等价是基于在一个有序区间中对象值的相对位置==。</p>
<p>等价一般在每种标准关联容器（比如，set、multiset、map和multimap）的一部分——排序顺序方面有意义。注意这里的应用场景是==排序==。</p>
<p>两个对象x和y如果在关联容器c的排序顺序中没有哪个排在另一个之前，那么它们关于c使用的排序顺序有等价的值。</p>
<p>举一个例子，一个set<Widget> s。两个Widget w1和w2，如果在s的排序顺序中没有哪个在另一个之前，那么关于s它们有等价的值。set<Widget>的默认比较函数是less<Widget>，而默认的less<Widget>简单地对Widget调用operator&lt;，所以w1和w2关于operator&lt;有等价的值如果下面表达式为真：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="p">(</span><span class="n">w1</span> <span class="o">&lt;</span> <span class="n">w2</span><span class="p">)</span> <span class="c1">// w1 &lt; w2时它非真
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&amp;&amp;</span> <span class="c1">// 而且
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">!</span><span class="p">(</span><span class="n">w2</span><span class="o">&lt;</span><span class="n">w1</span><span class="p">)</span> <span class="c1">// w2 &lt; w1时它非真
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个有意义：<font color=red>两个值如果没有哪个在另一个之前（关于某个排序标准），那么它们等价（按照那个标准）。</font>在一般情况下，用于关联容器的比较函数不是<code>operator&lt;</code>或甚至<code>less</code>，它是用户定义的判断式。每个标准关联容器通过它的<code>key_comp</code>成员函数来访问排序判断式，所以如果下式求值为真，两个对象x和y关于一个关联容器c的排序标准有等价的值：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// 在c的排序顺序中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果x在y之前它非真，同时在c的排序顺序中,如果y在x之前它非真
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要完全领会==相等==和==等价==的含义，考虑一个忽略大小写的<code>set&lt;string&gt;</code>，也就是set的比较函数忽略字符串中字符大小写的<code>set&lt;string&gt;</code>。这样的比较函数会认为“STL”和“stL”是等价的。条款35演示了怎么实现一个函数，<code>ciStringCompare</code>，它进行了忽略大小写比较，但set要一个比较函数的类型，不是真的函数。要填平这个鸿沟，我们写一个operator()调用了ciStringCompare的仿函数类:</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CIStringCompare</span><span class="o">:</span> <span class="c1">// 用于忽略大小写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span> <span class="c1">// 字符串比较的类；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">ciStringCompare</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// 关于ciStringCompare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>具体实现为:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">ciCharCompare</span><span class="p">(</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">)</span> <span class="c1">// 忽略大小写比较字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>   <span class="c1">// c1和c2，如果c1 &lt; c2返回-1，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果c1==c2返回0，如果c1 &gt; c2返回1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Ic1</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c1</span><span class="p">));</span><span class="c1">// 转成小写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Ic2</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Ic1</span> <span class="o">&lt;</span> <span class="n">Ic2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">lc1</span> <span class="o">&gt;</span> <span class="n">Ic2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>给定<code>CIStringCompare</code>，要建立一个忽略大小写的set<string>就很简单了:</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">CIStringCompare</span><span class="o">&gt;</span> <span class="n">ciss</span><span class="p">;</span> <span class="c1">// ciss = “case-insensitive
</span></span></span><span class="line"><span class="cl"><span class="c1">// string set”
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们向这个set中插入“<code>Persephone</code>”和“<code>persephone</code>”，只有第一个字符串加入了，因为第二个等价于第一个：</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ciss</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">);</span> <span class="c1">// 一个新元素添加到set中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ciss</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">);</span> <span class="c1">// 没有新元素添加到set中
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们现在使用set的find成员函数搜索字符串“persephone”，搜索会成功，</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ciss</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试会成功
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但如果我们用非成员的find算法，搜索会失败：</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">ciss</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ciss</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试会失败
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那是因为“<code>persephone</code>”等价于“<code>Persephone</code>”（关于比较仿函数CIStringCompare），但不等于它（因为string(&ldquo;persephone&rdquo;) != string(&ldquo;Persephone&rdquo;)）。你可能会奇怪为什么标准关联容器是基于等价而不是相等。毕竟，大多数程序员对相等有感觉而缺乏等价的感觉。</p>
<p><font color=red>标准关联容器保持有序，所以每个容器必须有一个定义了怎么保持东西有序的比较函数（默认是less）。等价是根据这个比较函数定义的，所以标准关联容器的用户只需要为他们要使用的任意容器指定一个比较函数（决定排序顺序的那个）。</p>
<p>如果关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器就需要，除了用于排序的比较函数，还需要一个用于判断两个值是否相等的比较函数。（默认的，这个比较函数大概应该是equal_to，但有趣的是equal_to从没有在STL中用做默认比较函数。当在STL中需要相等时，习惯是简单地直接调用operator==。比如，这是非成员find算法所作的。）</font></p>
<p><strong><font color=blue>说白了，就是等价是为容器排序服务的，如果容器想要插入多个转化为小写后相等的单词，容器会判定这些单词等价，虽然它们本身不相等，这样就能够很好地保持容器内单词的唯一性和单词的有序性。否则通过查找或插入该单词的时候，容器内部就会发生歧义，造成不符合使用者逻辑。</font></strong></p>
<p>让我们假设我们有一个类似set的STL容器叫做<code>set2CF</code>，“set with two comparison functions”。<strong><font color=red>第一个比较函数用来决定set的排序顺序，第二个用来决定是否两个对象有相同的值。</font></strong> 现在考虑这set2CF：</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set2CF</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">CIStringCompare</span><span class="p">,</span> <span class="n">equal_to</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，s内部排序它的字符串时不考虑大小写，等价标准直觉上是这样：如果两个字符串中一个等于另一个，那么它们有相同的值。让我们向s中插入哈迪斯强娶的新娘（Persephone）的两个拼写:</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Persephone&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如果我们说<code>&quot;Persephone&quot; != &quot;persephone&quot;</code>然后两个都插入s，它们应该是什么顺序？</p>
</blockquote>
<p>记住排序函数不能分别告诉它们。我们可以以任意顺序插入，因此放弃以确定的顺序遍历set内容的能力吗？（不能以确定的顺序遍历关联容器元素已经折磨着<code>multiset</code>和<code>multimap</code>了，因为标准没有规定等价的值（对于multiset）或键（对于multimap）的相对顺序。）或者我们坚持s的内容的一个确定顺序并忽略第二次插入的尝试（“persephone”的那个）? 如果我们那么做，这里会发生什么？</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;persephone&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())...</span> <span class="c1">// 这个测试成功或失败？
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>大概**<font color=red>find使用了等价检查</font>**，但如果我们为了维护s中元素的一个确定顺序而忽略了第二个insert的调用，这个find会失败，即使“persephone”的插入由于它是一个重复的值的原则而被忽略！</p>
<h2 id="总结">总结</h2>
<p>通过只使用一个比较函数并使用等价作为两个值“相等”的意义的仲裁者，标准关联容器避开了很多会由允许两个比较函数而引发的困难。</p>
<p>一开始行为可能看起来有些奇怪（特别是当你发现成员和非成员find可能返回不同结果），但最后，它避免了会由在标准关联容器中混用相等和等价造成的混乱。</p>
]]></description></item><item><title>Effective STL [18] | 避免使用vector&lt;bool></title><link>https://jianye0428.github.io/posts/clause_18/</link><pubDate>Wed, 09 Aug 2023 14:39:18 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_18/</guid><description><![CDATA[<h2 id="vectorbool-问题">vector<bool> 问题</h2>
<p>作为一个STL容器，vector<bool>确实只有1个问题:</p>
<ul>
<li>它不是一个STL容器；</li>
<li>它并不容纳bool。</li>
</ul>
<h2 id="剖析">剖析</h2>
<p>一个东西要成为STL容器就必须满足所有在C++标准23.1节中列出的容器必要条件。</p>
<p>如果c是一个T类型对象的容器，且c支持operator[]，那么以下代码必须能够编译:</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">T</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 无论operator[]返回什么，都可以用这个地址初始化一个T*
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>换句话说，如果你使用<code>operator[]</code>来得到Container中的一个T对象，你可以通过取它的地址而获得指向那个对象的指针。(假设T没有倔强地重载一些操作符。) 然而如果vector是一个容器，这段代码必须能够编译：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 用vector&lt;bool&gt;::operator[]返回的东西的地址初始化一个bool*
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但它不能编译。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">test_vector.cpp:154:19: error: taking address of rvalue <span class="o">[</span>-fpermissive<span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="m">154</span> <span class="p">|</span>   bool *pb <span class="o">=</span> <span class="p">&amp;</span>r2<span class="o">[</span>0<span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>                   ^
</span></span><span class="line"><span class="cl">test_vector.cpp:154:14: error: cannot convert ‘std::vector&lt;bool&gt;::reference*’ <span class="o">{</span>aka ‘std::_Bit_reference*’<span class="o">}</span> to ‘bool*’ in initialization
</span></span><span class="line"><span class="cl">  <span class="m">154</span> <span class="p">|</span>   bool *pb <span class="o">=</span> <span class="p">&amp;</span>r2<span class="o">[</span>0<span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              ^~~~~~
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              <span class="p">|</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>              std::vector&lt;bool&gt;::reference* <span class="o">{</span>aka std::_Bit_reference*<span class="o">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为<code>vector&lt;bool&gt;</code>是一个伪容器，并不保存真正的bool，而是打包bool以节省空间。在一个典型的实现中，每个保存在“vector”中的“bool”占用一个单独的比特，而一个8比特的字节将容纳8个“bool”。</p>
<p>在内部，<code>vector&lt;bool&gt;</code>使用了与位域（bitfield）等价的思想来表示它假装容纳的bool。</p>
<p><font color=blue>位域也只表现为两种可能的值，但真的bool和化装成bool的位域之间有一个重要的不同：你可以创建指向真的bool的指针，但却禁止有指向单个比特的指针。</font></p>
<h2 id="实际实现">实际实现</h2>
<p>vector::operator[]返回一个对象，其行为类似于比特的引用，也称为代理对象。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">_Bvector_base</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bvector_base</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;</span>   <span class="n">_Base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_Bit_pointer</span>  <span class="n">_Bit_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_Bit_alloc_traits</span>  <span class="n">_Bit_alloc_traits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if __cplusplus &gt;= 201103L
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="k">friend</span> <span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="kt">bool</span>     <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">size_t</span>     <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">ptrdiff_t</span>     <span class="n">difference_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_reference</span>    <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="kt">bool</span>     <span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_reference</span><span class="o">*</span>    <span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="k">const</span> <span class="kt">bool</span><span class="o">*</span>    <span class="n">const_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_iterator</span>    <span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Bit_const_iterator</span>   <span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">const_reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span>  <span class="n">reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">typedef</span> <span class="n">_Alloc</span>     <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">allocator_type</span>
</span></span><span class="line"><span class="cl">      <span class="nf">get_allocator</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="k">return</span> <span class="n">_Base</span><span class="o">::</span><span class="n">get_allocator</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_allocate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_deallocate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_S_nword</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">_Base</span><span class="o">::</span><span class="n">_M_get_Bit_allocator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="n">reference</span>
</span></span><span class="line"><span class="cl">      <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">__n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="nf">iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_p</span>
</span></span><span class="line"><span class="cl">    <span class="o">+</span> <span class="n">__n</span> <span class="o">/</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">),</span> <span class="n">__n</span> <span class="o">%</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">const_reference</span>
</span></span><span class="line"><span class="cl">      <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">__n</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="nf">const_iterator</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">.</span><span class="n">_M_p</span>
</span></span><span class="line"><span class="cl">        <span class="o">+</span> <span class="n">__n</span> <span class="o">/</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">),</span> <span class="n">__n</span> <span class="o">%</span> <span class="kt">int</span><span class="p">(</span><span class="n">_S_word_bit</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码不能编译的原因很明显：<code>bool *pb = &amp;v[0]</code>右边的表达式是<code>vector&lt;bool&gt;::reference*</code>类型，不是<code>bool*</code>。</p>
<h2 id="替代品">替代品</h2>
<h3 id="1-dequebool">1. deque<bool></h3>
<p><code>deque</code>提供了几乎所有<code>vector</code>所提供的（唯一值得注意的是<code>reserve</code>和<code>capacity</code>），而<code>deque&lt;bool&gt;</code>是一个STL容器，它保存真正的<code>bool</code>值。</p>
<p><code>deque</code>内部内存不是连续的。所以不能传递<code>deque&lt;bool&gt;</code>中的数据给一个希望得到<code>bool</code>数组的<code>C API</code>。</p>
<p>条款16中用于<code>vector</code>的技术不能在<code>vector&lt;bool&gt;</code>上通过编译，因为它们依赖于能够取得指向容器中包含的元素类型的指针。</p>
<h3 id="2-bitset">2. bitset</h3>
<p><code>bitset</code>不是一个STL容器，但它是C++标准库的一部分。与STL容器不同，<strong>它的大小（元素数量）在编译期固定</strong>，因此它不支持插入和删除元素。</p>
<p>因为它不是一个STL容器，它也不支持iterator。但就像<code>vector&lt;bool&gt;</code>，<strong>它使用一个压缩的表示法，使得它包含的每个值只占用一比特。</strong></p>
<p>它提供<code>vector&lt;bool&gt;</code>特有的<code>flip</code>成员函数，还有一系列其他操作位集<code>(collection of bits)</code>所特有的成员函数。</p>
<h2 id="总结">总结</h2>
<p><code>vector&lt;bool&gt;</code>不满足STL容器的必要条件，你最好不要使用它；</p>
<p>而<code>deque&lt;bool&gt;</code>和<code>bitset</code>是基本能满足你对<code>vector&lt;bool&gt;</code>提供的性能的需要的替代数据结构。</p>
]]></description></item><item><title>Effective STL [17] | 使用“交换技巧”来修整过剩容量(仅适用于vector和string)</title><link>https://jianye0428.github.io/posts/clause_17/</link><pubDate>Tue, 08 Aug 2023 08:48:22 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_17/</guid><description><![CDATA[<blockquote>
<p>注意: 这里的容量指的是capacity</p>
</blockquote>
<p>假如有一个海选，需要从申请者中挑选一些人进入到下一轮比赛当中，我们可能会建立一个vector用来存储申请者：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Contestant</span> <span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">contestants</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>vector</code>会很快获得很多元素，你可能会将能够进入到下一轮的申请者放到 vector 的前端（可能通过 <code>partial_sort</code>或<code>partition</code>），如果没有参与到下一轮的申请者就会从vector 中删除（典型的方法就是调用 erase 的区间形式，具体见条款5）。</p>
<p>这样很好地减少了 vector 的大小，<strong>但是没有减少它的容量</strong>。</p>
<p>当然可以通过resize方法去改变，但是如果我不知道大概要多少，我只知道有一些符合我的要求，如果直接用resize可能大了很多，或者抛弃了原本符合要求的元素。所以最好有一种shrink_to_fit的方式。</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">contestants</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contestants</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">contestants</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=Aqua><strong>具体工作原理：</strong></font></p>
<ol>
<li>表达式<code>vector&lt;Contestant&gt;(contestants)</code>建立一个临时<code>vector</code>，它是<code>contestants</code>的一份拷贝：<code>vector</code>的拷贝构造函数做了这个工作。<strong>vector的拷贝构造函数只分配拷贝的元素需要的内存</strong>，就是说<code>contestants</code>真实包含多少元素，就分配多少内存空间，按照<code>size()</code>的个数，而不是capicatiy个数，所以这个临时vector没有多余的容量。</li>
<li>让临时<code>vector</code>和<code>contestants</code>交换数据，这时contestants只有临时变量的修整过的容量(size)，而这个临时变量则持有了曾经在contestants中的发胀的容量(capacity)。在这里（这个语句结尾），临时vector被销毁，因此释放了以前contestants使用的内存。  收缩到合适。</li>
<li>完成收缩内存的同时，也拷贝了实际<code>size()</code>个内存，也有性能消耗。</li>
</ol>
<p><strong>TEST</strong></p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r1</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// r1 包含100个1，即100个申请者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">r1</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span> <span class="c1">// 只保留前50名申请者进入下一轮
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r1</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span> <span class="c1">// shrink to fit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>结果:</strong></p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">r1 size: <span class="m">100</span> capacity: <span class="m">100</span>
</span></span><span class="line"><span class="cl">r1 size: <span class="m">50</span> capacity: <span class="m">100</span>
</span></span><span class="line"><span class="cl">r1 size: <span class="m">50</span> capacity: <span class="m">50</span>
</span></span><span class="line"><span class="cl">r1 size: <span class="m">0</span> capacity: <span class="m">0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>string也同样适用：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contest</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>	<span class="c1">//清楚v并把它的容量变为最小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>			<span class="c1">//清楚s并把它的容量变为最小
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>另外，在swap的时候，不仅仅容器内容被交换，其迭代器、指针和引用也被交换(string除外)。因此，在发生交换后，原来的迭代器、指针和引用依然有效，并指向同样的元素——但这些元素已经在另外一个容器中。</p>
<h2 id="清空容器并减少容量到最小">清空容器并减少容量到最小</h2>
<p><strong>交换技巧的变体可以用于清除容器和减少它的容量到你的实现提供的最小值。</strong></p>
<p>可以简单地和一个默认构造的临时vector或string做个交换：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 使用v和s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Contestant</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 清除v而且最小化它的容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// 清除s而且最小化它的容量
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试代码：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r1</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// r1 包含100个1，即100个申请者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span> <span class="c1">// 清空 r1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;r1 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果:</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">r1</span> <span class="nl">size</span><span class="p">:</span> <span class="mi">100</span> <span class="nl">capacity</span><span class="p">:</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">r1</span> <span class="nl">size</span><span class="p">:</span> <span class="mi">0</span> <span class="nl">capacity</span><span class="p">:</span> <span class="mi">0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>ref:</br>
[1]. <a href="https://blog.csdn.net/u011058765/article/details/51205757?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=3"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/u011058765/article/details/51205757?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51205757-blog-18826.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=3<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item></channel></rss>