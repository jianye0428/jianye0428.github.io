<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>STL - 标签 - yejian's blog</title><link>https://jianye0428.github.io/tags/stl/</link><description>STL - 标签 - yejian's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>18817571704@163.com (Jian YE)</managingEditor><webMaster>18817571704@163.com (Jian YE)</webMaster><lastBuildDate>Wed, 02 Aug 2023 08:03:42 +0800</lastBuildDate><atom:link href="https://jianye0428.github.io/tags/stl/" rel="self" type="application/rss+xml"/><item><title>Effective STL [12] | 理解自定义分配器的正确用法</title><link>https://jianye0428.github.io/posts/clause_12/</link><pubDate>Wed, 02 Aug 2023 08:03:42 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_12/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="多线程维护的规则">多线程维护的规则</h2>
<p>多线程程序是很普遍的，所以大部分STL厂商努力使他们的实现在线程环境中可以正常工作。</p>
<p>但是，即使他们做得很好，「<strong>大部分负担仍在你肩上，而理解为什么会这样是很重要的</strong>」。</p>
<p>在STL容器（和大多数厂商的愿望）里对多线程支持的黄金规则已经由SGI定义，并且在它们的STL网站上发布：</p>
<ul>
<li>「<strong>多个读取者是安全的</strong>」。多线程可能同时读取一个容器的内容，在读取时「不能有任何写入者操作这个容器」。</li>
<li>「<strong>对不同容器的多个写入者是安全的</strong>」。多线程可以同时写不同的容器。对同一个容器同时多线程写入是不安全的。</li>
</ul>
<h2 id="完全线程安全">完全线程安全？</h2>
<p>很多程序员希望STL实现是完全线程安全，这非常难以实现。</p>
<p>一个库可能试图以下列方式实现这样完全线程安全的容器：</p>
<ul>
<li>每次调用容器的成员函数期间都要锁定该容器」</li>
<li>在「<strong>每个容器返回的迭代器(例如通过调用begin或end)的生存期之内都要锁定该容器</strong>」</li>
<li>在「<strong>每个在容器上调用的算法执行期间锁定该容器</strong>」。（这事实上没有意义，因为算法没有办法识别出它们正在操作的容器）</li>
</ul>
<h2 id="example-多线程修改">Example 多线程修改</h2>
<p>搜寻一个vector<int>中第一次出现3这个值的地方，如果它找到了，就把这个值改为2。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first3</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// line 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">first3</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span> <span class="c1">// line 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">first3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// line 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>多线程访问时，会有很多「问题」:</p>
<ol>
<li>在多线程环境里，另一个线程可能在行1完成之后立刻修改v中的数据。如果是那样，行2对first3和v.end的检测将是无意义的，因为v的值可能和它们在行1结束时的值不同。</li>
<li>这样的检测会产生未定义的结果，因为另一线程可能插在行1和行2之间，使first3失效，或许通过进行一次插入操作造成vector重新分配它的内在内存。（那将使vector全部的迭代器失效）</li>
<li>行3中对<code>*first3</code>的赋值是不安全的，因为另一个线程可能在行2和行3之间执行，并以某种方式使<code>first3</code>失效，可能通过删除它指向（或至少曾经指向）的元素。</li>
</ol>
<p><strong>解决办法：加锁</strong></p>
<p>要让上面的代码成为线程安全的，「<strong>v必须从行1到行3保持锁定</strong>」，让最多一个线程在1-3行的过程中能访问v。很难想象STL实现怎么能自动推断出这个。</p>
<p>而「<strong>同步原语（例如，信号灯，互斥量，等等）通常开销很大</strong>」，更难想象怎么实现在程序没有明显性能损失的情况下做到前面所说的。</p>
<p>因此你必须「<strong>手工对付</strong>」这些情况中的同步控制</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">getMutexFor</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first3</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">first3</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 这里现在安全了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">first3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 这里也是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">releaseMutexFor</span><span class="p">(</span><span class="n">v</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>「<strong>改进</strong>：」一个更面向对象的解决方案是「<strong>创建一个Lock类</strong>」，在它的「<strong>构造函数里获得互斥量并在它的析构函数里释放它</strong>」，这样使<strong>getMutexFor</strong>和<strong>releaseMutexFor</strong>的「<strong>调用不匹配的机会减到最小</strong>」:</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">&gt;</span> <span class="c1">// 获取和释放容器的互斥量的类的模板核心；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span> <span class="o">/</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> <span class="c1">// 忽略了很多细节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Lock</span><span class="p">(</span><span class="k">const</span> <span class="n">Containers</span> <span class="n">container</span><span class="p">)</span><span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">getMutexFor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// 在构造函数获取互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">releaseMutexFor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// 在析构函数里释放它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用一个类（像Lock）来管理资源的生存期（例如互斥量）的办法通常称为<strong>资源获得即初始化</strong>。</p>
<p>应用到上述例子：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="c1">// 建立新块；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Lock</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 获取互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first3</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">first3</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">first3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 关闭块，自动
</span></span></span><span class="line"><span class="cl"><span class="c1">// 释放互斥量
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>基于Lock的方法在有异常的情况下是稳健的</strong></p>
<p>因为Lock对象在Lock的析构函数里释放容器的的互斥量，所以在互斥量需要释放是就销毁Lock是很重要的。为了让这件事发生，我们建立一个里面定义了Lock的新块，而且当我们不再需要互斥量时就关闭那个块。</p>
<p>C++保证如果抛出了异常，局部对象就会被销毁，所以即使当我们正在使用Lock对象时有异常抛出，Lock也将释放它的互斥量。如果我们依赖手工调用<code>getMutexFor</code>和<code>releaseMutexFor</code>，那么在调用<code>getMutexFor</code>之后<code>releaseMutexFor</code>之前如果有异常抛出，我们将不会释放互斥量。</p>
<h2 id="结论">结论</h2>
<ul>
<li>
<p>当涉及到线程安全和STL容器时，你可以确定库实现允许在一个容器上的多读取者和不同容器上的多写入者。</p>
</li>
<li>
<p>「你不能希望库消除对手工并行控制的需要，而且你完全不能依赖于任何线程支持」</p>
</li>
</ul>]]></description></item><item><title>Effective STL [11] | 理解自定义分配器的正确用法</title><link>https://jianye0428.github.io/posts/clause_11/</link><pubDate>Sun, 30 Jul 2023 09:21:58 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_11/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="自定义分配器">自定义分配器</h2>
<p>很多时候，你会有建立自定义分配器的想法：</p>
<ul>
<li><code>allocator&lt;T&gt;</code>对线程安全采取了措拖，但是你只对单线程的程序感兴趣，你不想花费不需要的同步开销</li>
<li>在某些容器里的对象通常一同被使用，所以你想在一个特别的堆里把它们放得很近使引用的区域性最大化</li>
<li>你想建立一个相当共享内存的唯一的堆，然后把一个或多个容器放在那块内存里，因为这样它们可以被其他进程共享。</li>
</ul>
<h3 id="管理共享内存">管理共享内存</h3>
<p>假定你有仿效<code>malloc</code>和<code>free</code>的特别程序，用于管理共享内存的堆</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">mallocShared</span><span class="p">(</span><span class="n">size_t</span> <span class="n">bytesNeeded</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">freeShared</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>并且你希望能把STL容器的内容放在共享内存中:</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SharedMemoryAllocator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">pointer</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size_type</span> <span class="n">numObiects</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">localityHint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mallocShared</span><span class="p">(</span><span class="n">numObiects</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="n">pointer</span> <span class="n">ptrToMemory</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">numObjects</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">freeShared</span><span class="p">(</span><span class="n">ptrToMiemory</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>SharedMemoryAllocator</code>：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 方便的typedef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">SharedMemoryAllocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">SharedDoubleVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="c1">// 开始一个块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SharedDoubleVec</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 建立一个元素在
</span></span></span><span class="line"><span class="cl"><span class="c1">// 共享内存中的vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span> <span class="c1">// 结束这个块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>「问题：」<strong>v</strong>使用<code>SharedMemoryAllocator</code>，所以<strong>v</strong>分配来容纳它元素的内存将来自共享内存，但<strong>v本身——包括它的全部数据成员——几乎将肯定不被放在共享内存里，v只是一个普通的基于堆的对象，所以它将被放在运行时系统为所有普通的基于堆的对象使用的任何内存</strong>。那几乎不会是共享内存。</br></p>
<p>为了把v的内容和v本身放进共享内存，必须这么做:</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">pVectorMemory</span> <span class="o">=</span> <span class="n">mallocShared</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SharedDoubleVec</span><span class="p">));</span><span class="c1">// 分配足够的共享内存来容纳一个SharedDoubleVec对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SharedDoubleVec</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">pVectorMemory</span><span class="p">)</span> <span class="n">SharedDoubleVec</span><span class="p">;</span> <span class="c1">// 使用“placement new”来 在那块内存中建立 一个SharedDoubleVec对象；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 参见下面这个对象的使用（通过pv）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">pv</span><span class="o">-&gt;~</span><span class="n">SharedDoubleVec</span><span class="p">();</span> <span class="c1">// 销毁共享内存中的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">freeShared</span><span class="p">(</span><span class="n">pVectorMemory</span><span class="p">);</span> <span class="c1">// 销毁原来的共享内存块
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这就是<code>「手工的四步分配/建造/销毁/回收的过程」</code>：获得一些共享内存 <code>——&gt;</code> 在里面建立一个用共享内存为自己内部分配的vector <code>——&gt;</code> 用完这个vector时，调用它的析构函数 <code>——&gt;</code> 释放vector占用的内存。</p>
<p>这段代码有2点需要注意：</p>
<ul>
<li>
<p>忽略了<code>mallocShared</code>可能返回一个null指针。</p>
</li>
<li>
<p>共享内存中的vector的建立由“placement new”完成。</p>
</li>
</ul>
<h3 id="管理分配和回收的堆">管理分配和回收的堆</h3>
<p>假设有2个堆，类<code>Heap1</code>和<code>Heap2</code>。</p>
<p>每个堆类有用于进行「分配」和「回收」的「静态成员函数」：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Heap1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">alloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numBytes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">memoryBlockToBeNear</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="nf">dealloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Heap2</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">// 有相同的alloc/dealloc接口
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你想在不同的堆里联合定位一些STL容器的内容。</p>
<p>首先，设计一个分配器，使用像Heap1和Heap2那样用于真实内存管理的类：</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">typenameT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Heap</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecificHeapAllocator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">pointer</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size_type</span> <span class="n">numObjects</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">localityHint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Heap</span><span class="o">::</span><span class="n">alloc</span><span class="p">(</span><span class="n">numObjects</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">localityHint</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="n">pointer</span> <span class="n">ptrToMemory</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">numObjects</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Heap</span><span class="o">::</span><span class="n">dealloc</span><span class="p">(</span><span class="n">ptrToMemory</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后，使用<code>SpecificHeapAllocator</code>来把容器的元素集合在一起：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Heap1</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 把v和s的元素放进Heap1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Heap1</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">Heap2</span><span class="o">&gt;&gt;</span> <span class="n">L</span><span class="p">;</span> <span class="c1">// 把L和m的元素 放进Heap2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SpecificHeapAllocator</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Heap2</span><span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子里，很重要的一点是「<strong>Heap1和Heap2是类型而不是对象</strong>」。</p>
<p>STL为用不同的分配器对象初始化相同类型的不同STL容器提供了语法。那是「<strong>因为如果Heap1和Heap2是对象而不是类型，那么它们将是不等价的分配器，那就违反了分配器的等价约束</strong>」。</p>
<p>只要遵循「<strong>相同类型的所有分配器都一定等价的限制条件</strong>」，你将毫不费力地使用自定义分配器来「<strong>控制一般内存管理策略，群集关系和使用共享内存以及其他特殊的堆</strong>」。</p>]]></description></item><item><title>Effective STL [8] | 永不建立auto_ptr的容器</title><link>https://jianye0428.github.io/posts/clause_8/</link><pubDate>Thu, 27 Jul 2023 07:45:11 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_8/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="拷贝一个auto_ptr将改变它的值">拷贝一个auto_ptr将改变它的值</h2>
<p>当你拷贝一个<code>auto_ptr</code>时，<code>auto_ptr</code>所指向对象的所有权被转移到拷贝的<code>auto_ptr</code>，而被拷贝的<code>auto_ptr</code>被设为<code>NULL</code>。</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">in</span><span class="p">)</span> <span class="o">:</span> <span class="n">randy</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">randy</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">.</span><span class="n">randy</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">randy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw1</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span> <span class="c1">// pw1指向一个Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw2</span><span class="p">(</span><span class="n">pw1</span><span class="p">);</span> <span class="c1">// pw2指向pw1的Widget; pw1被设为NULL。（Widget的所有权从pw1转移到pw2。）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pw1</span> <span class="o">=</span> <span class="n">pw2</span><span class="p">;</span> <span class="c1">// pw1现在再次指向Widget； pw2被设为NULL
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有意思的是，如果你建立一个<code>auto_ptr&lt;Widget&gt;</code>的<code>vector</code>，然后使用一个指向的<code>Widget</code>的值的函数对它进行排序：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">widgetAPCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="o">*</span><span class="n">lhs</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">rhs</span><span class="p">;</span> <span class="c1">// 假设Widget 存在operator&lt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">w1</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">w2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">widgets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">w1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">widgets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">w2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">widgets</span><span class="p">;</span> <span class="c1">// 建立一个vector，然后用Widget的auto_ptr填充它；
</span></span></span><span class="line"><span class="cl"><span class="c1">// 记住这将不能编译！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">widgets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">widgets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">widgetAPCompare</span><span class="p">);</span><span class="c1">// 排序这个vector
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码将不能编译</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">warning: ‘template&lt;class&gt; class std::auto_ptr’ is deprecated <span class="o">[</span>-Wdeprecated-declarations<span class="o">]</span>
</span></span><span class="line"><span class="cl">   <span class="m">30</span> <span class="p">|</span>   std::vector&lt;auto_ptr&lt;Widget&gt; &gt;
</span></span><span class="line"><span class="cl">      <span class="p">|</span>               ^~~~~~~~
</span></span><span class="line"><span class="cl">In file included from /usr/include/c++/9/memory:80,
</span></span><span class="line"><span class="cl">                 from temp.cpp:10:
</span></span><span class="line"><span class="cl">/usr/include/c++/9/bits/unique_ptr.h:53:28: note: declared here
</span></span><span class="line"><span class="cl">   <span class="m">53</span> <span class="p">|</span>   template&lt;typename&gt; class auto_ptr<span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>                            ^~~~~~~~
</span></span><span class="line"><span class="cl">temp.cpp:33:3: warning: ‘template&lt;class&gt; class std::auto_ptr’ is deprecated <span class="o">[</span>-Wdeprecated-declarations<span class="o">]</span>
</span></span><span class="line"><span class="cl">   <span class="m">33</span> <span class="p">|</span>   auto_ptr&lt;Widget&gt; w1<span class="o">(</span>new Widget<span class="o">(</span>3<span class="o">))</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">|</span>   ^~~~~~~~</span></span></code></pre></td></tr></table>
</div>
</div><p>从概念上看所有东西也都很合理，但结果却完全不合理。例如，在排序过程中widgets中的一个或多个auto_ptr可能已经被设为NULL。</p>
<p>排序这个vector的行为可能已经改变了它的内容！</p>
<h2 id="剖析">剖析</h2>
<p>实现<code>sort</code>的方法是使用了<strong>快速排序算法</strong>的某种变体。</p>
<p>排序一个容器的<strong>基本思想</strong>是，选择容器的某个元素作为“主元”，然后对大于和小于或等于主元的值进行递归排序。</p>
<p>在sort内部，这样的方法看起来像这样：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">RandomAccessIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Compare</span><span class="o">&gt;</span><span class="c1">// 这个sort的声明直接来自于标准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这个typedef在下面解释
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">ElementType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">RandomAccessIterator</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// 让i指向主元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ElementType</span> <span class="n">pivotValue</span><span class="p">(</span><span class="o">*</span><span class="p">);</span> <span class="c1">// 把主元拷贝到一个局部临时变量中；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">...</span> <span class="c1">// wor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>源码为：</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_RandomAccessIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Compare</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">_RandomAccessIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_RandomAccessIterator</span> <span class="n">__last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">_Compare</span> <span class="n">__comp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// concept requirements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">__glibcxx_function_requires</span><span class="p">(</span><span class="n">_Mutable_RandomAccessIteratorConcept</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_RandomAccessIterator</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">__glibcxx_function_requires</span><span class="p">(</span><span class="n">_BinaryPredicateConcept</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_RandomAccessIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">__glibcxx_requires_valid_range</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">__glibcxx_requires_irreflexive_pred</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span> <span class="n">__comp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">__sort</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span> <span class="n">__gnu_cxx</span><span class="o">::</span><span class="n">__ops</span><span class="o">::</span><span class="n">__iter_comp_iter</span><span class="p">(</span><span class="n">__comp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 上面 __gnu_cxx::__ops::__iter_comp_iter(__comp) 的实现如下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Compare</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Iterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">inline</span> <span class="n">_Iter_comp_to_iter</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="p">,</span> <span class="n">_Iterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__iter_comp_iter</span><span class="p">(</span><span class="n">_Iter_comp_iter</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="o">&gt;</span> <span class="n">__comp</span><span class="p">,</span> <span class="n">_Iterator</span> <span class="n">__it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">_Iter_comp_to_iter</span><span class="o">&lt;</span><span class="n">_Compare</span><span class="p">,</span> <span class="n">_Iterator</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="n">_GLIBCXX_MOVE</span><span class="p">(</span><span class="n">__comp</span><span class="p">.</span><span class="n">_M_comp</span><span class="p">),</span> <span class="n">__it</span><span class="p">);</span> <span class="c1">// 这里有move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当涉及<code>iterator_traits&lt;RandomAccessIterator&gt;::value_type</code>时，必须在它前面写上<code>typename</code>，因为它是一个<strong>依赖于模板参数类型的名字</strong>，在这里是<code>RandomAccessIterator</code>。</p>
<p>上面代码中棘手的是这一行:</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ElementType</span> <span class="nf">pivotValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为它把一个元素从保存的区间拷贝到局部临时对象中。</p>
<p>在例子里，这个元素是一个<code>auto_ptr&lt;Widget&gt;</code>，所以这个拷贝操作默默地把被拷贝的<code>auto_ptr——vector</code>中的那个——设为<code>NULL</code>。</p>
<p>另外，当<code>pivotValue</code>出了生存期，它会自动删除指向的<code>Widget</code>。这时sort调用返回了，<code>vector</code>的内容已经改变了，而且至少一个<code>Widget</code>已经被删除了。</p>
<p>也可能有几个<code>vector</code>元素已经被设为<code>NULL</code>，而且几个<code>widget</code>已经被删除，因为快速排序是一种递归算法，递归的每一层都会拷贝一个主元。</p>
<h2 id="结论">结论</h2>
<p>智能指针的容器是很好的， 但是<code>auto_ptr</code><font color=red>完全不是那样的智能指针</font>。</p>]]></description></item><item><title>Effective STL [7] | 当使用new得指针的容器时，记得在销毁容器前delete那些指针</title><link>https://jianye0428.github.io/posts/clause_7/</link><pubDate>Wed, 26 Jul 2023 18:18:11 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_7/</guid><description><![CDATA[<!-- <div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">note abstract info tip success question warning failure danger bug example quote</div>
    </div>
  </div> -->
<h2 id="stl容器能够做的事情">STL容器能够做的事情</h2>
<ul>
<li>
<p>提供了前向和逆向遍历的迭代器（通过<code>begin</code>、<code>end</code>、<code>rbegin</code>等）；</p>
</li>
<li>
<p>能告诉你所容纳的对象类型（通过<code>value_type</code>的<code>ttypedef</code>）；</p>
</li>
<li>
<p>在插入和删除中，负责任何需要的内存管理；</p>
</li>
<li>
<p>报告容纳了多少对象和最多可能容纳的数量（分别通过<code>size</code>和<code>max_size</code>）；</p>
</li>
<li>
<p>当容器自己被销毁时会自动销毁容纳的每个对象。</p>
</li>
</ul>
<h2 id="容器内包含指针">容器内包含指针</h2>
<p>虽然STL容器被销毁时，能够自动销毁容纳的每个对象，但是如果这些对象是通过new分配的对象的指针时，它不会调用<code>delete</code>，销毁指针所指向的对象。</p>
<p><strong>Example</strong></p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;</span> <span class="n">vwp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SOME_MAGIC_NUMBER</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vwp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// Widgets在这里泄漏！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码将直接导致内存泄露。</p>
<p>当<code>vwp</code>结束其生命周期后，<code>vwp</code>的每个元素都被销毁，但不会<code>delete</code>每个<code>new</code>得到的对象。</p>
<p>那样的删除是你的职责，而不是vector的。这是一个特性。只有你知道一个指针是否应该被删除。</p>
<p>可以很简单地实现：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;</span> <span class="n">vwp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vwp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">!=</span> <span class="n">vwp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">delete</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段销毁的代码，仍然有2个问题：</p>
<ul>
<li>新的for循环代码比for_each多得多，没有使用for_each来的清楚</li>
<li>这段代码不是异常安全的。如果在用指针填充了vwp的时候和你要删除它们之间抛出了一个异常，你会再次资源泄漏。</li>
</ul>
<p><strong>for_each删除对象</strong></p>
<p>要把你的类似for_each的循环转化为真正使用for_each，你需要把delete转入一个函数对象中。</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DeleteObject</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 这里有这个继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在可以这么删除对象</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">HappyWork</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">for_each</span><span class="p">(</span><span class="n">vwp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vwp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DeleteObject</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>问题</strong></p>
<p>如果有人编写了一个类，该类继承了 string</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecialString</span><span class="o">:</span> <span class="k">public</span> <span class="n">string</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是很危险的行为，因为string，就像所有的标准STL容器，<strong>缺少虚析构函数</strong>，而从没有虚析构函数的类公有继承是一个大的C++禁忌。</p>
<p>当他删除 SpecialString 时就会资源泄露</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">deque</span><span class="o">&lt;</span><span class="n">SpecialString</span><span class="o">*&gt;</span> <span class="n">dssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">for_each</span><span class="p">(</span><span class="n">dssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="c1">// 行为未定义！通过没有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DeleteObject</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">// 虚析构函数的基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// 指针来删除派生对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>解决</strong></p>
<p>可以通过编译器推断传给<code>DeleteObject::operator()</code>的指针的类型来消除这个错误（也减少DeleteObject的用户需要的击键次数）。</p>
<p><strong>把模板化从DeleteObject移到它的operator()</strong>：</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DeleteObject</span> <span class="p">{</span> <span class="c1">// 删除这里的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 模板化和基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 模板化加在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过传给<code>DeleteObject::operator()</code>的指针的类型，自动实例化一个<code>operator()</code>。这种类型演绎下降让我们放弃使<code>DeleteObject</code>可适配的能力</p>
<p>现在删除 SpecialString 就会正常了</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">deque</span><span class="o">&lt;</span><span class="n">SpecialString</span><span class="o">*&gt;</span> <span class="n">dssp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">for_each</span><span class="p">(</span><span class="n">dssp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dssp</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DeleteObject</span><span class="p">());</span> <span class="c1">// good！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red>现在仍不是异常安全的。</font></p>
<p>果在SpecialString被new但在调用for_each之前抛出一个异常，就会发生泄漏。</p>
<p>这个问题可以以多种方式被解决，但最简单的可能是用<strong>智能指针的容器来代替指针的容器，典型的是引用计数指针</strong>。</p>
<h2 id="boost库中的shared_ptr">Boost库中的shared_ptr</h2>
<p>利用Boost的shared_ptr，本条款的原始例子可以重写为这样：</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_</span> <span class="n">ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">SPW</span><span class="p">;</span> <span class="c1">//SPW = &#34;shared_ptr to Widget&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">SPW</span><span class="o">&gt;</span> <span class="n">vwp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SOME_MAGIC_NUMBER</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">vwp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SPW</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">));</span> <span class="c1">// 从一个Widget建立SPW,然后进行一次push_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">...</span> <span class="c1">// work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// 这里没有Widget泄漏，甚至在上面代码中抛出异常
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>STL容器很智能，但它们没有智能到知道是否应该删除它们所包含的指针。</p>
<p>当你要删除指针的容器时要避免资源泄漏，你必须<strong>用智能引用计数指针对象</strong>（比如<code>Boost</code>的<code>shared_ptr</code>）来代替指针，或者你<strong>必须在容器销毁前手动删除容器中的每个指针</strong>。</p>]]></description></item><item><title>Effective STL [3] | 使容器里对象的拷贝操作轻量而正确</title><link>https://jianye0428.github.io/posts/clause_3/</link><pubDate>Mon, 24 Jul 2023 09:11:28 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_3/</guid><description><![CDATA[<h2 id="拷贝对象是stl的方式">拷贝对象是STL的方式</h2>
<ul>
<li>
<p>当一个对象进入一个容器，它已经不是你添加（<code>insert</code>或<code>push_back</code>等）的那个对象了，进入容器的是你指定的对象的拷贝；</p>
</li>
<li>
<p>当从容器中取出一个对象时，所得到的也不是容器里的对象；</p>
</li>
<li>
<p>如果从<code>vector</code>、<code>string</code>或<code>deque</code>中插入或删除了什么，现有的容器元素会移动（拷贝）</p>
</li>
<li>
<p>如果使用了任何排序算法：<code>next_permutation</code>或者<code>previous_permutation</code>；</p>
</li>
<li>
<p><code>remove</code>、<code>unique</code>或它们的同类；</p>
</li>
<li>
<p><code>rotate</code>或<code>reverse</code>等，对象会移动（拷贝）</p>
</li>
</ul>
<p><strong>拷进去，拷出来</strong>。这就是STL的方式.</p>
<p>因为拷贝，还解决了一个 double free 的 bug<a href="https://mp.weixin.qq.com/s?__biz=MzUyMDc2MDMxNg==&amp;mid=2247490628&amp;idx=1&amp;sn=43650727bc93d8064fd2969733873fdc&amp;chksm=f9e422d7ce93abc1d2784bcb5772536f55aa79902bbb783003c3314df7ed6461a014ed3cce25&amp;token=235869638&amp;lang=zh_CN&amp;scene=21#wechat_redirect"target="_blank" rel="external nofollow noopener noreferrer">点击查看<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="how-copy-如何完成拷贝">How Copy? 如何完成拷贝</h2>
<div class="details admonition info open">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-info-circle fa-fw" aria-hidden="true"></i>Notice<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">通过拷贝构造函数和拷贝复制操作符完成！</div>
    </div>
  </div>
<p>一个对象通过使用它的拷贝成员函数来拷贝，特别是它的拷贝构造函数和它的拷贝赋值操作符。</p>
<p>对于用户自定义类，比如Widget，这些函数传统上是这么声明的：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 拷贝赋值操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>如果你自己没有声明这些函数，你的编译器始终会为你声明它们。</strong></p>
<p>拷贝内建类型（比如int、指针等）也始终是通过简单地拷贝他们的内在比特来完成的。（请参考《Effective C++》中，条款11和27专注于这些函数的行为。）</p>
<h2 id="拷贝带来的问题">拷贝带来的问题</h2>
<p><strong>性能瓶颈</strong></p>
<p>拷贝会导致把对象放进容器也会被证明为是一个性能瓶颈。</p>
<p>容器中移动越多的东西，你就会在拷贝上浪费越多的内存和时钟周期。</p>
<p><strong>切片分割</strong></p>
<p>当然由于继承的存在，拷贝会导致分割。</p>
<p>如果以基类对象建立一个容器，而你试图插入派生类对象，那么当对象（通过基类的拷贝构造函数）拷入容器的时候对象的派生部分会被删除：</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">randy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SpecialWidget</span><span class="o">:</span> <span class="k">public</span> <span class="n">Widget</span> <span class="p">{...};</span> <span class="c1">// SpecialWidget从上面的Widget派生
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SpecialWidget</span> <span class="n">sw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">randy</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sw</span><span class="p">);</span> <span class="c1">// sw被当作基类对象拷入randy，当拷贝时它的特殊部分丢失了
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>分割问题暗示了把一个派生类对象插入基类对象的容器几乎总是错的。</p>
<p>如果你希望结果对象表现为派生类对象，比如，调用派生类的虚函数等，总是错的。</p>
<h2 id="解决">解决</h2>
<p>一个使拷贝更高效、正确而且对分割问题免疫的简单的方式是<strong>建立指针的容器而不是对象的容器</strong>。</p>
<p>也就是说，不是建立一个Widget的容器，建立一个Widget*的容器。</p>
<p><strong>拷贝指针很快，它总是严密地做你希望的（指针拷贝比特），而且当指针拷贝时没有分割，就是int类型的地址。</strong></p>
<p><font color=red>但是一定要记得在销毁容器的时候，使用delete 销毁里面保存的每个指针。而且一定要定义对象的深拷贝构造函数和深拷贝拷贝赋值操作符，否则delete 的时候会报错。</font></p>
<h2 id="和数组对比stl容器更文明">和数组对比，STL容器更文明</h2>
<p><strong>STL容器只建立（通过拷贝）你需要的个数的对象，而且它们只在你指定的时候做。</strong></p>
<p>STL进行了大量拷贝，但它通常设计为避免不必要的对象拷贝，实际上，它也被实现为避免不必要的对象拷贝。</p>
<ol>
<li>数组在声明的时候，会默认先构造好每个元素；STL容器可以实现动态扩展</li>
</ol>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">randy</span><span class="p">[</span><span class="n">maxNumWidgets</span><span class="p">];</span> <span class="c1">// 建立一个大小为maxNumWidgets的Widgets数组
</span></span></span><span class="line"><span class="cl"><span class="c1">// 默认构造每个元素
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>即使只使用其中的一些或者我们立刻使用从某个地方获取（比如，一个文件）的值覆盖每个默认构造的值，这也得构造maxNumWidgets个Widget对象。</p>
<p>使用STL来代替数组，你可以使用一个可以在需要的时候增长的vector，就是动态数组的概念：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">randy</span><span class="p">;</span> <span class="c1">// 建立一个0个Widget对象的vector
</span></span></span><span class="line"><span class="cl"><span class="c1">// 需要的时候可以扩展
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>建立一个可以足够包含maxNumWidgets个Widget的空vector，但不去构造Widget，需要时再构造：</li>
</ol>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">randy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">randy</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">maxNumWidgets</span><span class="p">);</span> <span class="c1">// reserve的详细信息请参见条款14
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>即便需要知道STL容器使用了拷贝，但是别忘了一个事实：比起数组它们仍然是一个进步。</p>
]]></description></item><item><title>Effective STL [2] | 小心对“容器无关代码”的幻想</title><link>https://jianye0428.github.io/posts/clause_2/</link><pubDate>Thu, 20 Jul 2023 15:58:12 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_2/</guid><description><![CDATA[<h2 id="stl-容器特点">STL 容器特点</h2>
<p>STL是建立在<strong>泛化</strong>之上的</p>
<ul>
<li>数组泛化为容器，参数化了所包含的对象的类型</br></li>
<li>函数泛化为算法，参数化了所用的迭代器的类型</br></li>
<li>指针泛化为迭代器，参数化了所指向的对象的类型</br></li>
</ul>
<p><strong>独立的容器类型泛化为序列或关联容器，而且类似的容器拥有类似的功能。</strong></p>
<p>标准的内存相邻容器都提供随机访问迭代器，标准的基于节点的容器都提供双向迭代器。</p>
<p>序列容器支持<code>push_front</code>或<code>push_back</code>，但关联容器不支持。关联容器提供对数时间复杂度的<code>lower_bound</code>、<code>upper_bound</code>和<code>equal_range</code>成员函数，但序列容器却没有。</p>
<p>举例:</p>
<ul>
<li>标准序列容器: vector、string、deque 和 list</li>
<li>标准关联容器: set、multiset、map 和 multimap</li>
</ul>
<h2 id="推行自己的容器">推行自己的容器</h2>
<p>很多人会试图在他们的软件中泛化容器的不同，而不是针对容器的特殊性编程，他们会想在vector 中使用 deque 或者 list的特性，这往往会带来麻烦。</p>
<p>比如：</p>
<ul>
<li>
<p>只有序列容器支持push_front或push_back，只有关联容器支持count和lower_bound</p>
</li>
<li>
<p>即便是 insert和erase这样的操作在名称和语义上也有差别</p>
<ul>
<li>当把对象插入序列容器中，该对象会保留在你放置的位置上;</li>
<li>当你把对象插入到一个关联容器中，容器会按照排列顺序把对象移到它应该在的位置;</li>
</ul>
</li>
<li>
<p>在序列容器上用一个迭代器作为参数调用 erase，会返回一个新的迭代器；在关联容器上什么都不返回。</p>
</li>
</ul>
<p><strong>容器能力的交集</strong></p>
<p>如果你想写一个可以用在常用序列容器上的代码—— 包含vector, deque和list。你必须使用它们能力的交集来编写。</p>
<p>但要考虑几点：</p>
<ul>
<li><code>deque</code>和<code>list</code>不支持<code>reserve</code>或<code>capacity</code></li>
<li><code>list</code>不支持<code>operator[]</code>操作，且受限于双向迭代器的性能</li>
<li>不能使用需要随机访问迭代器的算法，包括<code>sort</code>，<code>stable_sort</code>，<code>partial_sort</code>和<code>nth_element</code></li>
<li>如果想支持<code>vector</code>的规则，则不能使用<code>push_front</code>和<code>pop_front</code></li>
<li><code>vector</code>和<code>deque</code>都会使<code>splice</code>和成员函数方式的<code>sort</code>失败</li>
<li>因为<code>deque::insert</code>会使所有迭代器失效，而且因为缺少<code>capacity</code>，<code>vector::insert</code>也必须假设使所有指针和引用失效，而deque是唯一一个在迭代器失效的情况下, 指针和引用仍然有效的东西</li>
<li><strong>不能把容器里的数据传递给C风格的界面</strong>，只有vector支持这么做</li>
<li><strong>不能用bool作为保存的对象来实例化你的容器</strong>，因为vector 并非总表现为一个vector，实际上它并没有真正保存bool值。</li>
<li>不能期望享受到list的常数时间复杂度的插入和删除，vector和deque的插入和删除操作是线性时间复杂度的</li>
</ul>
<p>所以，真正开发时，如果都考虑到上面几点，那想开发的容器只剩下一个&quot;泛化的序列容器&quot;，但是你不能调用<code>reserve</code>、<code>capacity</code>、<code>operator[]</code>、<code>push_front</code>、<code>pop_front</code>、<code>splice</code>或任何需要随机访问迭代器的算法；调用insert和erase会有线性时间复杂度而且会使所有迭代器、指针和引用失效；而且不能兼容C风格的界面，不能存储bool。</p>
<p>如果你放弃了序列容器，把代码改为只能和不同的关联容器配合，这情况并没有什么改善。</p>
<ul>
<li>要同时兼容set和map几乎是不可能的，因为set保存单个对象，而map保存对象对。</li>
<li>甚至要同时兼容set和multiset（或map和multimap）也是很难的。</li>
<li><code>set/map</code>的<code>insert</code>成员函数只返回一个值，和他们的multi兄弟的返回类型不同，而且你必须避免对一个保存在容器中的值的拷贝份数作出任何假设。</li>
<li>对于<code>map</code>和<code>multimap</code>，你必须避免使用<code>operator[]</code>，因为这个成员函数只存在于map中。</li>
</ul>
<h2 id="封装">封装</h2>
<p>如果想改变容器类型，就使用<strong>封装</strong>。</p>
<p><strong>Method 1: typedef</strong>
一种最简单的方法是通过自由地对容器和迭代器类型使用typedef</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">vw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">bestWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> <span class="c1">// 给bestWidget一个值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span>  <span class="c1">// 寻找和bestWidget相等的Widget
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">find</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bestWidget</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以简化上述写法</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">WidgetContainer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">WidgetContainer</span><span class="o">::</span><span class="n">iterator</span> <span class="n">WCIterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">WidgetContainer</span> <span class="n">cw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">bestWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">WCIterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">cw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bestWidg</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果需要加上用户的allocator，也特别方便。（一个不影响对迭代器/指针/参考的失效规则的改变）</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 关于为什么这里需要一个template
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SpecialAllocator</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">// 请参见条款10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="p">,</span> <span class="n">SpecialAllocator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">WidgetContainer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">WidgetContainer</span><span class="o">::</span><span class="n">iterator</span> <span class="n">WCIterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">WidgetContainer</span> <span class="n">cw</span><span class="p">;</span> <span class="c1">// 仍然能用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">bestWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">WCIterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">cw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bestWidget</span><span class="p">);</span> <span class="c1">// 仍然能用
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><font color=red><code>typedef</code>只是其它类型的同义字，所以它提供的的封装是纯的词法（译注：不像#define是在预编译阶段替换的）。<code>typedef</code>并不能阻止用户使用（或依赖）任何他们不应该用的（或依赖的）。</font></p>
<p><strong>Method 2: class</strong></p>
<p>要限制如果用一个容器类型替换了另一个容器可能需要修改的代码，就需要在类中隐藏那个容器，而且要通过类的接口限制容器特殊信息可见性的数量。</p>
<p>比如需要隐藏 真实的容器 list 建立客户列表：</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CustomerList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">Customer</span><span class="o">&gt;</span> <span class="n">CustomerContainer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">CustomerContainer</span><span class="o">::</span><span class="n">iterator</span> <span class="n">CCIterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">CustomerContainer</span> <span class="n">customers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> <span class="c1">// 通过这个接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span> <span class="c1">// 限制list特殊信息的可见性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用过程中，你发现从列表的中部插入和删除客户并不像你想象的那么频繁，仅仅需要快速确定客户列表顶部的20%——一个为nth_element算法量身定做的任务。</p>
<p>但<code>nth_element</code>需要随机访问迭代器，不能兼容<code>list</code>。</p>
<p>在这种情况下，你的客户&quot;list&quot;可能更应该用&quot;vector&quot;或&quot;deque&quot;来实现</p>
<p>当你决定作这种更改的时候，你仍然<strong>必须检查每个CustomerList的成员函数和每个友元，看看他们受影响的程度（根据性能和迭代器/指针/引用失效的情况等等）</strong>。</p>
<p>但如果你做好了对CustomerList地实现细节做好封装的话，那对CustomerList的客户的影响将会很小。</p>
]]></description></item><item><title>Effective STL [1] | 仔细选择你的容器</title><link>https://jianye0428.github.io/posts/clause_1/</link><pubDate>Wed, 19 Jul 2023 08:51:49 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/clause_1/</guid><description><![CDATA[<div class="details admonition quote">
    <div class="details-summary admonition-title">
      <i class="icon fa-solid fa-quote-right fa-fw" aria-hidden="true"></i>quote<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
    </div>
    <div class="details-content">
      <div class="admonition-content">选择容器需要注意的几个方面</div>
    </div>
  </div>
<h2 id="迭代器">迭代器</h2>
<ol>
<li>输入迭代器</li>
</ol>
<ul>
<li>每个迭代位置<strong>只能被读1次</strong>的只读迭代器，通常表现为 istream_iterator</li>
</ul>
<ol start="2">
<li>输出迭代器</li>
</ol>
<ul>
<li>每个迭代位置<strong>只能被写1次</strong>的只写迭代器，通常表现为 ostream_iterator</li>
</ul>
<ol start="3">
<li>前向迭代器</li>
</ol>
<ul>
<li>
<p>有<strong>输入</strong>和<strong>输出</strong>迭代器的能力，可以反复读写1个位置，<u>不支持 operator&ndash;</u>，可以高效地向前移动任意次数</p>
</li>
<li>
<p>散列容器的一种设计可以产生前向迭代器；</p>
</li>
<li>
<p>单链表容器也提供前向迭代器</p>
</li>
</ul>
<ol start="4">
<li>双向迭代器</li>
</ol>
<ul>
<li>像前向迭代器一样，后退很容易。标准关联容器都提供双向迭代器，list也有</li>
</ul>
<ol start="5">
<li>随机访问迭代器</li>
</ol>
<ul>
<li>
<p>可以做双向迭代器一样的事情，但也提供“迭代器算术”，即迭代器有一步向前或向后跳的能力。</p>
</li>
<li>
<p>vector、string 和 deque 都提供随机访问迭代器。</p>
</li>
<li>
<p>指针数组的指针可以作为数组的随机访问迭代器。</p>
</li>
</ul>
<h2 id="容器">容器</h2>
<p>STL有<font color=red><strong>迭代器</strong></font>、<font color=red><strong>算法</strong></font>和<font color=red><strong>函数对象</strong></font>，但对于大多数C++程序员，容器是最突出的。</p>
<p>它们比数组更强大更灵活，可以动态增长（也常是缩减），可以管理属于它们自己的内存，可以跟踪它们拥有的对象数目，可以限制它们支持操作的算法复杂度等等。</p>
<p><strong>分类</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">类别</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">标准STL序列容器</td>
<td style="text-align:left">vector、string、deque和list</td>
</tr>
<tr>
<td style="text-align:left">标准STL关联容器</td>
<td style="text-align:left">set、multiset、map和multimap</td>
</tr>
<tr>
<td style="text-align:left">非标准序列容器slist和rope</td>
<td style="text-align:left">slist是一个单向链表，rope本质上是一个重型字符串。(&ldquo;绳子(rope)&ldquo;是重型的&quot;线(string)&rdquo;)</td>
</tr>
<tr>
<td style="text-align:left">非标准关联容器</td>
<td style="text-align:left">hash_set、hash_multiset、hash_map和hash_multimap</td>
</tr>
<tr>
<td style="text-align:left">vector	可以作为string的替代品</td>
<td style="text-align:left">vector作为标准关联容器的替代品</br>	有时候vector可以在时间和空间上都表现得比标准关联容器好</td>
</tr>
<tr>
<td style="text-align:left">标准非STL容器</td>
<td style="text-align:left">包括数组、bitset、valarray、stack、queue和priority_queue 。</br>值得注意的是，数组可以和STL算法配合，因为指针可以当作数组的迭代器使用</td>
</tr>
</tbody>
</table>
<p><code>vector</code>、<code>list</code>和<code>deque</code>提供给程序员不同的复杂度，因此应该这么用：</p>
<ul>
<li>vector是一种可以默认使用的序列类型</br></li>
<li>当很频繁地对序列中部进行插入和删除时应该用list</br></li>
<li>当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构</br></li>
</ul>
<p><strong>连续内存容器和基于节点的容器的区别</strong></p>
<ul>
<li><strong>连续内存容器（也叫做基于数组的容器）</strong>
<ul>
<li>
<p>在一个或多个（动态分配）的内存块中保存它们的元素。</p>
</li>
<li>
<p>如果一个新元素被查入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提供空间或者填充原来被删除的元素所占的空间。</p>
</li>
<li>
<p>这种移动影响了效率和异常安全。</p>
</li>
<li>
<p>标准的连续内存容器是vector、string和deque。</p>
</li>
<li>
<p>非标准的rope也是连续内存容器。</p>
</li>
</ul>
</li>
<li><strong>基于节点的容器</strong>
<ul>
<li>
<p>在每个内存块（动态分配）中只保存一个元素。</p>
</li>
<li>
<p>容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。</p>
</li>
<li>
<p>所以当有东西插入或删除时，元素值不需要移动。</p>
</li>
<li>
<p>表现为链表的容器——比如list和slist——是基于节点的，所有的标准关联容器也是（它们的典型实现是平衡树）。</p>
</li>
<li>
<p>非标准的散列容器使用不同的基于节点的实现。</p>
</li>
</ul>
</li>
</ul>
<h2 id="如何选择容器">如何选择容器?</h2>
<ol>
<li>你需要“可以在容器的任意位置插入一个新元素”的能力吗？
<ul>
<li>如果是，你需要<strong>序列容器</strong>，关联容器做不到。
</br></li>
</ul>
</li>
<li>你关心元素在容器中的顺序吗？
<ul>
<li><strong>如果不，散列容器就是可行的选择</strong>。否则，你要避免使用散列容器。
</br></li>
</ul>
</li>
<li>必须使用标准C++中的容器吗?
<ul>
<li>如果是，就可以除去散列容器、slist和rope。
</br></li>
</ul>
</li>
<li>你需要哪一类迭代器？
<ul>
<li>如果必须是<strong>随机访问迭代器</strong>，在技术上你就只能限于<code>vector</code>、<code>deque</code>和<code>string</code>，但你也可能会考虑<code>rope</code>。</li>
<li>如果需要<strong>双向迭代器</strong>，你就<strong>用不了</strong><code>slist </code>和<code>散列容器</code>的一般实现。
</br></li>
</ul>
</li>
<li>当插入或者删除数据时，是否非常在意容器内现有元素的移动？
<ul>
<li>如果是，你就必须<strong>放弃连续内存容器</strong>。
</br></li>
</ul>
</li>
<li>容器中的数据的内存布局需要兼容C吗？
<ul>
<li>如果是，你就只能用vector。
</br></li>
</ul>
</li>
<li>查找速度很重要吗？
<ul>
<li>如果是，你就应该看看散列容器，排序的vector和标准的关联容器——大概是这个顺序。
</br></li>
</ul>
</li>
<li>你介意如果容器的底层使用了引用计数吗？
<ul>
<li>如果是，你就得避开string，因为很多string的实现是用引用计数。</li>
<li>你也<strong>不能用rope</strong>，因为<strong>权威的rope实现是基于引用计数的</strong>。</li>
<li>于是你得重新审核你的string，你可以考虑使用vector<char>
</br></li>
</ul>
</li>
<li>你需要插入和删除的事务性语义吗？也就是说，你需要有可靠地回退插入和删除的能力吗？
<ul>
<li>如果是，你就需要使用<strong>基于节点的容器</strong>。</li>
<li>如果你需要<strong>多元素插入</strong>（比如，以范围的方式）的事务性语义，你就应该选择<code>list</code>，因为<strong>list是唯一提供多元素插入事务性语义的标准容器</strong>。</li>
<li>事务性语义对于有兴趣写异常安全代码的程序员来说非常重要。（事务性语义也可以在连续内存容器上实现，但会有一个性能开销，而且代码不那么直观）
</br></li>
</ul>
</li>
<li>你要把迭代器、指针和引用的失效次数减到最少吗？
<ul>
<li>如果是，你就应该<strong>使用基于节点的容器</strong>，因为在这些容器上进行插入和删除不会使迭代器、指针和引用失效（除非它们指向你删除的元素）。</li>
<li>一般来说，<strong>在连续内存容器上插入和删除会使所有指向容器的迭代器、指针和引用失效</strong>。
</br></li>
</ul>
</li>
<li>你需要具有以下特性的序列容器吗：1） 可以使用随机访问迭代器；2） 只要没有删除而且插入只发生在容器结尾，指针和引用的数据就不会失效？
<ul>
<li>这个一个非常特殊的情况，但如果你遇到这种情况，<strong>deque就是你梦想的容器</strong>。</li>
<li>有趣的是，<strong>当插入只在容器结尾时，deque的迭代器也可能会失效</strong>，<code>deque</code>是**唯一一个“在迭代器失效时不会使它的指针和引用失效”**的标准STL容器。</li>
</ul>
</li>
</ol>
<h2 id="结语">结语</h2>
<p><font color=green><strong>当面对容器时，STL给了你很多选项。如果你的视线超越了STL的范围，那就会有更多的选项。在选择一个容器前，要保证考虑了所有你的选项。</strong></font></p>]]></description></item><item><title>sort 排序</title><link>https://jianye0428.github.io/posts/c-sort/</link><pubDate>Thu, 14 Jun 2018 20:23:03 +0000</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/c-sort/</guid><description><![CDATA[<p>sort 使用<code>#include&lt;algorithm&gt;</code>头文件，</p>
<p>sort（开始地址，结束地址，排序方式），其中第三参数可以没有，则默认为升序排序。</p>
<p>或者简单的用
<code>less&lt;参数类型&gt;()</code>表示升序</p>
<p><code>greater&lt;参数类型&gt;()</code>表示降序</p>
<p>也可以用一个 bool 型函数，比如：</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">;</span><span class="c1">//表从大到小，即降序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设自己定义了一个结构体 node</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">node</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">note</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有一个 node 类型的数组 node arr[100]，想对它进行排序：先按 a 值升序排列，如果 a 值相同，再按 b 值降序排列，如果 b 还相同，就按 c 降序排列。就可以写这样一个比较函数：</p>
<p>以下是代码片段：</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">node</span> <span class="n">x</span><span class="p">,</span><span class="n">node</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">a</span><span class="o">!=</span><span class="n">y</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">a</span><span class="o">&lt;</span><span class="n">y</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">b</span><span class="o">!=</span><span class="n">y</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span><span class="n">y</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">c</span><span class="o">&gt;</span><span class="n">y</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>sort() 函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组，数组类型可以是 int,char 等。</p>
<p>实例：先降序再升序</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">data</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">date</span> <span class="n">a</span><span class="p">,</span><span class="n">date</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="o">!=</span><span class="n">b</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="o">&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">date</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="p">{{</span><span class="mi">5</span><span class="p">,</span><span class="mf">56.5</span><span class="p">},{</span><span class="mi">4</span><span class="p">,</span><span class="mf">56.5</span><span class="p">},{</span><span class="mi">8</span><span class="p">,</span><span class="mi">85</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="n">cmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34;-&#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://weibo.com/ttarticle/p/show?id=2309404237869425234111&amp;mod=zwenzhang"target="_blank" rel="external nofollow noopener noreferrer">传送门<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>C++ with STL</title><link>https://jianye0428.github.io/posts/c-with-stl/</link><pubDate>Thu, 14 Jun 2018 20:22:06 +0000</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/c-with-stl/</guid><description><![CDATA[<h2 id="1swap交换两元素值在-algorithm-下用法swapab">1.swap（交换两元素值，在 algorithm 下，用法：swap(a,b);）</h2>
<p>交换两元素的值在 C 语言课上作为指针讲解的典例。</p>
<p>int a=1,b=2;</p>
<p>swap(a,b);</p>
<p>//此时 a=2,b=1</p>
<p>（可以是其他类型）</p>
<h2 id="2sort">2.sort(,,)</h2>
<p>sort 排序是不稳定的，stl 中的 stable_sort 才是稳定的</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">inta</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">stable_sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="3reverse翻转序列在-algorithm-下">3.reverse（翻转序列，在 algorithm 下）</h2>
<p>//常用在字符串上</p>
<p>int a[5]={1,2,3,4,5};</p>
<p>reverse(a,a+5);</p>
<p>//序列现在是 5 4 3 2 1</p>
<p>char s[]=&ldquo;ericxie&rdquo;;</p>
<p>reverse(s,s+strlen(s));</p>
<p>//序列现在是 &ldquo;eixcire&rdquo;</p>
<p>//同样适用于 string</p>
<p>string s=&ldquo;qwer&rdquo;;</p>
<p>reverse(s.begin(),s.end());</p>
<h2 id="4minmax取大取小">4.min，max（取大，取小）</h2>
<p>int a=1,b=2,c;</p>
<p>c=min(a,b);</p>
<p>//此时 c 等于 1</p>
<p>c=max(a,b);</p>
<p>//此时 c 等于 2</p>
<p>string s=&ldquo;qwer&rdquo;,d=&ldquo;asjk&rdquo;,c;</p>
<p>c=min(s,d);</p>
<p>//c=&ldquo;asjk&rdquo;</p>
<h2 id="5__gcd最大公约数">5.<code>__gcd</code>（最大公约数）</h2>
<p>手写 gcd 函数也行，辗转相除，辗转相减；</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span> <span class="o">?</span> <span class="nl">b</span> <span class="p">:</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>//直接用</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="nf">__gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>//注意下划线，此时 c 等于 2</p>
<h2 id="6lower_bound-和-upper_bound二分查找">6.lower_bound 和 upper_bound（二分查找）</h2>
<p>lower_bound 意思就是：找到第一个位置，使得：如果在这个位置插入 value 后，原有序序列依旧有序。</p>
<p>upper_bound 是找到最后一个符合数位置后一个位置，使得：如果在这个位置插入 value 后，原有序序列依旧有序。</p>
<p>//数组</p>
<p>int a[8]={1,2,4,4,9,12,12,15};</p>
<p>int pos1 = lower_bound(a,a+8,4)-a;</p>
<p>int pos2 = upper_bound(a,a+8,4)-a-1;</p>
<p>//在这个样例下 pos1!=pos2;pos1=2;pos2=3;</p>
<p>根据我的理解 lower_bound(a,a+8,value)</p>
<p>得到的是一个地址，拿这个地址减去数组首地址 a[0]，那么刚好就是 value 应该放入的位置。</p>
<p>//vector</p>
<p><code>vector&lt;int&gt; a;</code></p>
<p>若 a 中目前的元素也是{1,2,4,4,9,12,12,15};</p>
<p>那么这里用 lower_bound 得到的应该也是一个类似于指针的东西，为什么不叫它指针呢？因为他有了一个名字，叫做迭代器。</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">it</span> <span class="o">=</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span><span class="n">a</span><span class="p">.</span><span class="nf">end</span><span class="p">(),</span><span class="mi">4</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>//这里的 it 就是迭代器，那么* it 就是该下标对应的 value 了。</p>
<p>//set 集合</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">lower_bound</span><span class="p">(</span><span class="n">value</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="7next_permutation-排列">7.next_permutation （排列）</h2>
<p>bool next_permutation( iterator start, iterator end ); 通常用于生成序列的全排列。用之前先保证有序；</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">do</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="nf">next_permutation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果为：</p>
<pre><code>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
</code></pre>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">string</span> <span class="n">str</span><span class="o">=</span><span class="s">&#34;STL&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sort</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="nf">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">do</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="nf">next_permutation</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span><span class="n">str</span><span class="p">.</span><span class="nf">end</span><span class="p">()))</span><span class="err">；</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果：</p>
<pre><code>LST
LTS
SLT
STL
TLS
TSL
</code></pre>
<p>大数据 c 比 c++效率高</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">gets</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">length</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sort</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">str</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">do</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="nf">puts</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="nf">next_permutation</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">str</span><span class="o">+</span><span class="n">length</span><span class="p">))</span><span class="err">；</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="8unique-去重">8.unique （去重）</h2>
<p>如何把序列 a 中的重复元素去除呢？首先需要对原序列 a 进行排序，保证有序后，调用 unique(a.head , a.tail ) 就可以了。unique 会返回一个类似指针的东西（和 lower_bound 有点像），-a 后表示去重之后序列的长度。</p>
<p>下面是实例。</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">11</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">11</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果为：1 2 3 5 7 9</p>
<p><a href="https://weibo.com/ttarticle/p/show?id=2309404241150725776250&amp;mod=zwenzhang"target="_blank" rel="external nofollow noopener noreferrer">传送门<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item></channel></rss>