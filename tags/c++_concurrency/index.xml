<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>C++_Concurrency - 标签 - yejian's blog</title><link>https://jianye0428.github.io/tags/c++_concurrency/</link><description>C++_Concurrency - 标签 - yejian's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>18817571704@163.com (Jian YE)</managingEditor><webMaster>18817571704@163.com (Jian YE)</webMaster><lastBuildDate>Sun, 19 Nov 2023 13:06:06 +0800</lastBuildDate><atom:link href="https://jianye0428.github.io/tags/c++_concurrency/" rel="self" type="application/rss+xml"/><item><title>C++ Concurrency in Action | Processes and Threads</title><link>https://jianye0428.github.io/posts/processesandthreads/</link><pubDate>Sun, 19 Nov 2023 13:06:06 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/processesandthreads/</guid><description><![CDATA[<h2 id="进程">进程</h2>
<ul>
<li>
<p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程(sequential process)，简称进程(process)，一个进程就是就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值</p>
</li>
<li>
<p>概念上来说，每个进程有自己的虚拟 CPU，但实际上真正的 CPU(假设只有一个 CPU)在各进程之间来回切换，同一时刻实际只有一个进程在运行</p>
</li>
<li>
<p>实际只有一个物理程序计数器。每个进程运行时，它的逻辑程序计数器被装入实际的程序计数器。当进程结束时，物理程序计数器保存到内存中该进程的逻辑程序计数器中</p>
</li>
<li>
<p>进程创建主要有四种形式</p>
<ul>
<li>系统初始化：启动系统时会创建若干进程，包括和用户交互的前台进程和停在后台的守护进程，守护进程可以通过 UNIX 的 ps 指令或 Window 的任务管理器查看</li>
<li>运行中的程序执行创建进程的系统调用：比如启动一个程序，该程序要启动更多进程来分配任务</li>
<li>用户请求创建一个新进程：比如用户双击图标启动程序</li>
<li>大型机批处理作业的初始化</li>
</ul>
</li>
<li>
<p>创建进程的系统调用在 UNIX 中是 <code>fork</code>，在 Windows 中是 <code>CreateProcess</code>，进程创建后，父子进程有不同的地址空间</p>
</li>
<li>
<p>进程终止通常也有四种形式</p>
<ul>
<li>正常退出(自愿的)：比如点击浏览器的关闭图标。进程退出的系统调用在 UNIX 中是 <code>exit</code>，在 Windows 中是 <code>ExitProcess</code></li>
<li>出错退出(自愿的)：比如执行 <code>cc foo.c</code> 编译 <code>foo.c</code> 而该文件不存在</li>
<li>严重错误(非自愿)：比如执行非法指令、引用不存在的内存、除数是零，UNIX中会希望自行处理这些错误以通知操作系统，进程会收到信号被中断而非终止</li>
<li>被其他进程杀死(非自愿)：UNIX 中是 <code>kill</code>，Windows 中是 <code>TerminateProcess</code></li>
</ul>
</li>
<li>
<p>UNIX中，进程和其所有子进程(包括其后裔)组成一个进程组，当用户发出一个键盘信号，该信号会发送给进程组所有成员</p>
</li>
<li>
<p>Windows中没有进程层次的概念，所有进程地位相同</p>
</li>
<li>
<p>进程阻塞有两种情况，一是正常情况，比如操作系统调度另一个进程占用 CPU，二是异常情况，比如没有足够的 CPU 可调用</p>
</li>
<li>
<p>进程有三种状态：运行、就绪、阻塞</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">运行 &lt;-&gt; 就绪
</span></span><span class="line"><span class="cl">  ↘    ↗
</span></span><span class="line"><span class="cl">    阻塞
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">运行：该时刻实际占用 CPU
</span></span><span class="line"><span class="cl">就绪：操作系统调度了其他进程运行而暂时停止
</span></span><span class="line"><span class="cl">阻塞：逻辑上不能继续运行，比如等待用户输入</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>操作系统通过维护一张进程表(一个结构数组)来实现进程模型，每个进程占一个表项(即进程控制块，Processing Control Block)。PCB 包含了进程状态的主要信息，如程序计数器、堆栈指针、内存分配状态、所打开的文件状态、账号和调度信息、进程状态切换时必须保存的信息</p>
</li>
<li>
<p>所有中断都从保存寄存器开始，通常会保存到当前进程的 PCB 中。一个进程在执行过程中可能中断几千次，但恢复时，被中断的进程都将返回到与中断发生前完全相同的状态</p>
</li>
<li>
<p>发生中断后，操作系统最底层的工作过程</p>
<ul>
<li>中断硬件将程序计数器、程序状态字、寄存器压入堆栈</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>通过汇编保存寄存器值(因为这类操作无法用高级语言完成)</li>
<li>通过汇编设置新的堆栈</li>
<li>运行C语言(假设操作系统用C编写)中断服务例程</li>
<li>调用调度程序，决定接下来要运行的进程</li>
<li>C返回到汇编</li>
<li>通过汇编运行新进程</li>
</ul>
</li>
<li>
<p>假设一个进程等待 I/O 操作与其在内存中停留的时间比为 <code>p</code>，则 <code>n</code> 个进程都在等待(此时 CPU 空转)的概率为 <code>p ^ n</code>，CPU 利用率为 <code>1 - p ^ n</code>，因此一般(该模型只是粗略情况)I/O 时间越短、运行进程越多，CPU 利用率越高</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">假如内存为 8G，操作系统和相关表格占 2G，用户程序也占 2G，内存最多容纳 3 个用户程序
</span></span><span class="line"><span class="cl">假设 80% 时间用于等待 I/O 操作
</span></span><span class="line"><span class="cl">CPU 利用率 = 1 - 0.8 ^ 3 = 49%
</span></span><span class="line"><span class="cl">如果增加 8G 内存，则最多容纳 7 个用户程序
</span></span><span class="line"><span class="cl">CPU 利用率 = 1 - 0.8 ^ 7 = 79%，吞吐量提高为 79% - 49% = 30%
</span></span><span class="line"><span class="cl">如果再增加 8G 内存，则最多容纳 11 个用户程序
</span></span><span class="line"><span class="cl">CPU 利用率 = 1 - 0.8 ^ 11 = 91%，吞吐量只提高了 12%，可见第一次增加内存比较划算</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="线程">线程</h2>
<ul>
<li>正如进程提供的抽象使得避免了对中断、定时器、上下文切换的考虑，多线程提供了一种新抽象，即并行实例共享同一地址空间和所有可用数据，这正是多进程模型(地址空间不同)无法表达的</li>
<li>第二个需要多线程的理由是，线程更轻量，创建和撤销都更快(通常创建一个线程比创建一个进程快 10 - 100 倍)</li>
<li>第三个理由是多核 CPU 系统中，多线程为真正的并行提供了可能</li>
<li>线程包含一个程序计数器(记录接下来要执行哪一条指令)、寄存器(保存线程当前的工作变量)、堆栈指针(记录执行历史，每个线程的堆栈有一帧，每一帧保存一个已调用但还未返回的过程，如局部变量、返回地址)</li>
<li>各线程可以访问进程地址空间的每一个内存地址，因此一个线程可以读写甚至清除另一个线程的堆栈。线程之间没有保护，因为不可能，也没必要</li>
<li>除了共享地址空间，线程还共享同一个打开文件集、子进程、定时器及相关信号量</li>
<li>线程可以处在运行、就绪、阻塞、终止等状态中的任何一个</li>
<li>thread_yield 允许线程自动放弃 CPU 转让给另一个线程运行，提供这个调用是因为，不同于进程，线程库不能利用时钟中断强制线程让出 CPU</li>
<li>实现线程包主要有两种方式，一是用户级线程(User-Level Thread)，二是内核级线程(Kernel-Level Thread)，另外也有混合实现</li>
<li>用户级线程把整个线程包放在用户空间中，内核对其一无所知，不需要内核支持，可以在不支持线程的操作系统上实现。在用户空间管理线程时，每个进程需要有其专用的线程表(thread table)，这些表和内核中的进程表类似，只不过记录的是各个线程的属性，如程序计数器、寄存器、堆栈指针和状态等。该线程表由运行时系统管理，当线程转换到就绪或阻塞状态时，在线程表中存放重启该线程所需的信息，与内核在进程表中存放进程的信息完全一样</li>
<li>用户级线程允许进程有自己定制的调度算法，具有更好的可扩展性(因为内核级线程需要一些固定表格空间和堆栈空间)，性能更好。用户级线程的切换需要少量机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延迟</li>
<li>用户级线程的问题是如何实现阻塞系统调用，比如线程读取键盘，在没有按下任何按键之前不能让该线程实际进行该系统调用，因为这会停止所有线程。另一个问题是，如果一个线程开始运行，则其所在进程的其他线程就不能运行，除非运行线程自动放弃 CPU。而使用内核级线程时，线程阻塞在 I/O 上时，不需要将整个进程挂起</li>
<li>内核级线程的线程表(和用户级线程的线程表一样，记录寄存器、状态和其他信息)存在于内核中，当一个线程希望创建一个新线程或撤销一个已有线程时，将进行一个系统调用，这个系统调用通过对线程表的更新完成创建或撤销工作</li>
<li>当内核级线程阻塞时，内核可以运行同一进程中的另一线程，或者运行另一个进程的线程。而对于用户级线程，运行时系统始终运行其所在进程的线程，直到内核剥夺 CPU(或没有可运行的线程存在)为止</li>
<li>在内核中创建或撤销线程的代价较大，因此内核级线程被撤销时，系统会将其标记为不可运行的，但其内核数据结构未受影响，之后必须创建新线程时就重新启动一个旧线程。用户级线程也可以这样回收，但因为管理代价很小，所以没必要</li>
</ul>
<h2 id="进程间通信inter-process-communication">进程间通信(Inter Process Communication)</h2>
<ul>
<li>
<p>对共享内存进行访问的程序片段称为临界区(critical region、critical section)，如果同一时刻临界区只有一个进程，就能避免 race condition</p>
</li>
<li>
<p>单处理器系统中实现这点的简单做法是，在每个进程刚进入临界区后立即屏蔽所有中断，在即将离开时再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU 只有发生时钟中断或其他中断才会进行进程切换，这样 CPU 就不会切换到其他进程</p>
</li>
<li>
<p>但这个方案并不好，因为把屏蔽中断的权力交给用户进程是不明智的，如果一个进程屏蔽中断后不打开，就可能导致整个系统终止。此外如果系统是多处理器，则屏蔽中断只对执行了 disable 指令的 CPU 有效，其他 CPU 仍将运行</p>
</li>
<li>
<p>对于内核来说，更新变量或列表的几条指令期间屏蔽中断很方便，因此屏蔽中断对操作系统本身是一项很有用的技术，但对用户进程则不是一种合适的互斥机制</p>
</li>
<li>
<p>第二种方式是一种软件方案，假设有一个共享锁变量，其初始值为 0，当进程要进入临界区时，首先测试锁，如果值为 0 则将锁设为1并进入临界区，如果锁的值已经为 1，则进程等待其值为 0</p>
</li>
<li>
<p>这种方式的问题在于，如果在一个进程检查到锁为 0，并要将锁设为 1 之前，恰好另一个线程被调度运行将锁设为 1，而第一个进程恢复运行时也将把锁设为 1 并进入临界区，此时临界区就有了两个进程</p>
</li>
<li>
<p>第三种方式是忙等待(busy waiting)，用一个循环不断测试变量值，直到变量值改变才进入临界区，用于忙等待的锁称为自旋锁(spin lock)。这种方式的问题是，在循环中浪费了大量 CPU 时间，应该避免，除非等待时间非常短才有使用的理由</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 进程 A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// 允许进程 B 进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">noncritical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程 B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 允许进程 A 进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">noncritical_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第四种方式是 1981 年由 G. L. Peterson 提出的 Peterson 算法</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 进程数量为2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// 轮到的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">interested</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enter_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">process</span><span class="p">;</span>  <span class="c1">// 另一进程(进程号为 0 或 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">turn</span> <span class="o">=</span> <span class="n">process</span><span class="p">;</span>  <span class="c1">// turn 只有一个，即使两个进程调用也只有后一个赋值会保留
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">process</span> <span class="o">&amp;&amp;</span> <span class="n">interested</span><span class="p">[</span><span class="n">other</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">leave_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 调用上述函数完成后调用此函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 若进程 A 调用 enter_region 则很快返回，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 此时进程 B 调用将在 while 循环挂起，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 直到进程 A 调用 leave_region
</span></span></span><span class="line"><span class="cl"><span class="c1">// 若进程 AB 同时调用 enter_region，
</span></span></span><span class="line"><span class="cl"><span class="c1">// turn 为后赋值者，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 则先赋值者退出循环并调用 leave_region，后赋值者再退出循环
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第五种方式是一种硬件方式，需要借助 TSL 指令，即测试并加锁(test and set lock)，该指令是一个原子操作，执行 TSL 指令的 CPU 将锁住内存总线以禁止其他 CPU 在指令结束前访问该内存</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">TSL</span> <span class="n">RX</span><span class="p">,</span> <span class="n">LOCK</span> <span class="c1">// 将内存字 LOCK 读到寄存器 RX 中，然后在该内存地址写一个非零值，读写是原子操作
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>为了使用 TSL 指令实现互斥，用一个共享变量 <code>LOCK</code> 来协调对内存的访问，其值为 0 时任何进程都能用 TSL 指令将值设为 1 并读写共享内存，操作结束时再用 move 指令将值重置为 0</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">enter_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">TSL</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="no">LOCK</span>  <span class="c1">;复制锁到寄存器并设置值为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMP</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#0    ;值是否为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span> <span class="no">enter_region</span>    <span class="c1">;不是 0 则循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>                 <span class="c1">;返回，进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">leave_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">LOCK</span><span class="p">,</span> <span class="c1">#0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>可以用 XCHG 指令替代 TSL 指令，它原子交换两个位置的内容</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">enter_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#1    ;在寄存器放一个 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">XCHG</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="no">LOCK</span>  <span class="c1">;原子交换寄存器和锁变量的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMP</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#0     ;值是否为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JNE</span> <span class="no">enter_region</span>     <span class="c1">;不是 0 则循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span>                  <span class="c1">;返回，进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">leave_region:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">LOCK</span><span class="p">,</span> <span class="c1">#0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Peterson 算法和 TSL 或 XCHG 解法同样都有忙等待的问题，它们的本质都是在进程进入临界区时检查是否允许进入，不允许则原地等待直到允许为止</p>
</li>
</ul>
<h2 id="生产者-消费者问题">生产者-消费者问题</h2>
<ul>
<li>
<p>两个进程共享一个固定大小的缓冲区，生产者进程将消息放入缓冲区，消费者进程从缓冲区取出消息</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 缓冲区的槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>            <span class="c1">// 缓冲区数据数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>  <span class="c1">// 生成新数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sleep</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>  <span class="c1">// 将消息放入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>              <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">wakeup</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>  <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sleep</span><span class="p">();</span>  <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span>  <span class="c1">// 从缓冲区取一个数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">--</span><span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">wakeup</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>  <span class="c1">// 打印数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 问题在于 cnt 的访问存在 race condition，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果消费者执行到 3 处，cnt 为 0，在即将 sleep 之前，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 生产者在此之后才执行到 1 处，此时 cnt 为 1，执行到 2 处，调用 wakeup，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但此时消费者还未 sleep，因此 wakeup 的信号丢失，没有实际作用，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 接着消费者 sleep，生产者开始下一轮循环，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 生产者下一轮循环到 1 处，cnt 为 2，到 2 处，不再调用 wakeup，消费者保持 sleep，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 生产者继续之后的循环，并且每一轮都不会唤醒消费者，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 最终生产者执行到 cnt 为 N 时 sleep，两个进程都将永久 sleep
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="信号量semaphore">信号量(semaphore)</h2>
<ul>
<li>
<p>信号量是由 E. W. Dijkstra 于 1965 年提出的一种方法，它使用一个整型变量作为信号量，值为 0 表示没有保存下来的唤醒操作，值为正数表示唤醒操作的次数</p>
</li>
<li>
<p>信号量有 down 和 up 两种操作，Dijkstra 在论文中称其为 P 和 V 操作(荷兰语中的 Proberen 意为尝试，Verhogen 意为增加或升高)</p>
</li>
<li>
<p>down 操作检查值是否大于 0，若大于 0 则减 1 并继续，若为 0 则进程睡眠，并且此时 down 操作未结束</p>
</li>
<li>
<p>up 操作对值加 1。如果有进程在信号量上睡眠，无法完成一个先前的 down 操作，则由系统选择其中一个以允许完成其 down 操作。于是，对一个有睡眠进程的信号量执行一次 up 操作，信号量值仍为 0，但睡眠进程少了一个</p>
</li>
<li>
<p>down 操作和 up 操作中的所有操作都是原子的，一般作为系统调用实现。操作系统只要在执行测试信号量、更新信号量、使进程睡眠等操作时暂时屏蔽全部中断，这些动作只需要几条指令，所以屏蔽中断不会带来什么副作用。如果使用多个 CPU，则每个信号量应由一个一个锁保护，使用 TSL 或 XCHG 指令来确保同一时刻只有一个 CPU 对信号量进行操作</p>
</li>
<li>
<p>注意，这里使用 TSL 或 XCHG 指令来防止多 CPU 同时访问一个信号量，与生产者或消费者用忙等待来等待对方腾出或填充缓冲区是完全不同的。信号量操作只需要几毫秒，而生产者或消费者则可能需要任意长时间</p>
</li>
<li>
<p>使用三个信号量解决生产者-消费者问题：full 记录已充满的缓冲槽数，初值为 0；empty 记录空的缓冲槽数，初值为缓冲区中槽的数目；mutex 确保生产者和消费者不会同时访问缓冲区，初值为 1</p>
</li>
<li>
<p>供多个进程使用的信号量初值为 1，保证同时只有一个进程可以进入临界区，这种信号量称为二元信号量(binary semaphore)。如果每个进程进入临界区前执行一个 down 操作，并在刚退出时执行一个 up 操作，就能实现互斥</p>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 缓冲区的槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>  <span class="c1">// 缓冲区空槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 缓冲区满槽数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>信号量的另一个作用是实现同步(synchronization)，这里 full 和 empty 保证缓冲区满时生产者停止运行，缓冲区空时消费者停止运行</p>
</li>
</ul>
<h2 id="互斥量mutex">互斥量(mutex)</h2>
<ul>
<li>
<p>如果不需要信号量的计数功能，可以使用其称为互斥量的简化版本。互斥量仅适用于管理共享资源或一小段代码。互斥量实现简单且有效，在实现用户空间线程包时十分有用</p>
</li>
<li>
<p>互斥量只有加锁和解锁两种状态，只需要一个二进制位表示，不过实际上一般用整型量，0 表示解锁，其他值表示加锁</p>
</li>
<li>
<p>线程需要访问临界区时调用 mutex_lock，如果互斥量是解锁的则临界区可用，调用成功，线程可以进入临界区，否则线程被阻塞，直到临界区中的线程完成并调用 mutex_unlock。如果多个线程阻塞在该互斥量上，则随机选择一个线程并允许它获得锁</p>
</li>
<li>
<p>用 TSL 或 XCHG 指令就可以很容易地在用户空间实现互斥量</p>
<div class="highlight" id="id-10"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">mutex_lock:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">TSL</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="no">MUTEX</span>  <span class="c1">;将互斥量复制到寄存器，并将互斥量置为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CMP</span> <span class="no">REGISTER</span><span class="p">,</span> <span class="c1">#0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JZE</span> <span class="no">ok</span>               <span class="c1">;如果互斥量为 0，它被解锁，所以返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CALL</span> <span class="no">thread_yield</span>    <span class="c1">;互斥量忙，调度另一个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">JMP</span> <span class="no">mutex_lock</span>       <span class="c1">;稍后再试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">ok:</span> <span class="nf">RET</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">mutex_unlock:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">MOVE</span> <span class="no">MUTEX</span><span class="p">,</span> <span class="c1">#0       ;将互斥量置0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">RET</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>thread_yield 只是调用用户空间线程调度程序，运行十分快捷，这样 mutex_lock 和 mutex_unlock 都不需要任何内核调用。用户级线程通过互斥量的这个过程即可实现同步，而同步过程仅需要少量指令</p>
</li>
</ul>
<h2 id="管程monitor">管程(monitor)</h2>
<ul>
<li>如果把生产者代码中的两个 down 操作交换顺序，使得 mutex 在 empty 之前减 1，就会导致死锁，因此使用信号量要十分小心。为了更易于编写正确的程序，Brinch Hansen 和 Hoare 提出了一种称为管程的高级同步原语</li>
<li>一个管程是由过程、变量、数据结构等组成的一个集合，它们组成一个特殊的模块或软件包，进程可以在任何需要的时候调用管程中的过程，但不能在管程之外声明的过程中直接访问管程内的数据结构</li>
<li>任一时刻管程中只能有一个活跃进程，这一特性使得管程能有效地完成互斥。管程是编程语言的组成部分，编译器知道其特殊性，进入管程时的互斥由编译器负责，通常做法是使用互斥量或二元信号量。这样就不需要程序员安排互斥，出错的可能性就小很多</li>
<li>管程提供了互斥的简便途径，但此外还需要一种方法使得进程在无法继续运行时被阻塞，这个方法就是引入条件变量(condition variable)</li>
<li>当一个管程过程发现它无法继续运行时(如生产者发现缓冲区满)，则会在某个条件变量(如 full)上执行 wait 操作，该操作将阻塞当前进程，并将另一个在管程外的进程调入管程。另一个进程可以通过对同一条件变量执行 signal 操作唤醒阻塞进程</li>
<li>为了避免管程中有两个活跃进程，执行 signal 操作之后有两种规则。Hoare 建议让新唤醒的进程运行，挂起另一个进程。Brinch Hansen 建议执行 signal 的进程必须立即退出管程，即 signal 语句只能作为一个管程过程的最后一条语句。后者在概念上更简单，并且更容易实现。第三种方法是，让发信号者继续运行，直到其退出管程，才允许等待的进程开始运行</li>
<li>如果一个条件变量上有若干进程正在等待，则对其执行 signal 操作之后，系统调度程序只能选择其中一个恢复运行</li>
<li>如果一个条件变量没有等待进程，则对其执行 signal 会丢失信号，因此 wait 操作必须在 signal 之前。这与之前提到的 sleep 和 wakeup 的关键区别是，管程的自动互斥保证了在 wait 完成之前不会先 signal</li>
</ul>
<h2 id="消息传递message-passing">消息传递(message passing)</h2>
<ul>
<li>管程和信号量通过共享内存解决 CPU 互斥问题，但没有提供不同机器间(比如局域网中的机器)的信息交换方法</li>
<li>消息传递使用 send 和 receive 原语来实现进程间通信，它们像信号量而不像管程，是系统调用而非语言成分</li>
</ul>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">send</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">receive</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>send 向一个给定目标发送一条消息，receive 从一个给定源(或者任意源)接收一条消息，如果没有消息可用则接收者可能被阻塞直至有一条消息到达，或者带着一个错误码立即返回</p>
</li>
<li>
<p>消息传递系统面临许多设计难点：比如消息可能被网络丢失，需要三次握手来确认信息到达情况；比如发送方未收到确认，因此重发消息导致接收方收到两条相同消息，接收方需要区分新老消息；比如身份认证(authentication)问题，客户端如何确认通信的是一个文件服务器还是冒充者</p>
</li>
<li>
<p>消息传递方式可以有许多变体，一种对消息进行编址的方式是，为每个进程分配一个唯一地址，让消息按进程的地址编址。另一种方式是引入一种称为信箱(mailbox)的数据结构，用来对一定数量的消息进行缓冲。使用信箱时，send 和 receive 调用的地址参数就是信箱而非进程的地址</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">// 消息缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">receive</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>    <span class="c1">// 等待消费者发送空缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">build_message</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>  <span class="c1">// 建立一个待发送的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">send</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>       <span class="c1">// 发送数据项给消费者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">message</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">send</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 发送 N 个空缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">receive</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>        <span class="c1">// 接收包含数据项的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">extract_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// 将数据项从消息中提取出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">send</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>           <span class="c1">// 将空缓冲区发送回生产者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用信箱的另一种极端方法是彻底取消缓冲。采取这种方法时，如果 send 在 receive 之前执行则发送进程被阻塞，直到 receive 发生，反之亦然。执行 receive 时，消息可以直接从发送者复制到接收者，不用任何中间缓冲。这种方案常被称为会和(rendezvous)，实现起来更容易，但降低了灵活性，因为发送者和接收者一定要以步步紧接的方式运行</p>
</li>
<li>
<p>通常在并行程序设计系统中使用消息传递，一个著名的消息传递系统是消息传递接口(Message-Passing Interface，MPI)，它广泛应用于科学计算</p>
</li>
</ul>
<h2 id="屏障barrier">屏障(barrier)</h2>
<ul>
<li>屏障是一种用于进程组的同步机制，只有所有进程就绪时才能进入下一阶段。每个阶段的结尾设置一个屏障，当一个进程到达屏障时将被阻拦，直到所有进程到达屏障为止</li>
</ul>
<h2 id="调度">调度</h2>
<ul>
<li>几乎所有进程的 I/O 请求和计算都是交替突发的，如果进程花费大量时间在计算上，则称为计算密集型(compute-bound)，如果大量时间花费在等待 I/O 上，则称为 I/O 密集型(I/O-bound)</li>
<li>随着 CPU 变得越来越快，更多的进程倾向为 I/O 密集型。这种现象的原因是 CPU 的改进比磁盘的改进快得多，所以未来对 I/O 密集型进程的调度处理更为重要</li>
<li>调度的基本思想是，如果需要运行 I/O 密集型进程，就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌</li>
<li>根据如何处理时钟中断，可以把调度算法分为非抢占式和抢占式两类</li>
<li>非抢占式调度算法挑选一个进程，然后让该进程运行直至阻塞，或直到该进程自动释放 CPU。即使该进程运行了几个小时也不会被强迫挂起，这样导致时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程，则被中断的进程将继续运行</li>
<li>抢占式调度算法挑选一个进程，让该进程运行某个固定时段的最大值，时段结束时将挂起该进程，并挑选另一个进程运行。抢占式调度需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序，如果没有可用的时钟，就只能选择非抢占式调度</li>
<li>不同的应用领域有不同的目标，也就需要不同的调度算法。环境可以划分为三种
<ul>
<li>批处理：广泛用于商业领域，比如处理薪水清单、账目收入、账目支出、利息计算，批处理系统不会有用户在旁边急切等待响应，因此通常使用非抢占式算法，或对每个进程都有长时间周期的抢占式算法，这样减少了进程切换从而改进了性能</li>
<li>交互式：必须使用抢占式算法，以避免 CPU 被一个进程霸占而拒绝为其他进程服务。服务器也归于此类，因为通常要服务多个突发的远程用户</li>
<li>实时：有时不需要抢占，因为进程了解它们可能会长时间得不到运行，所以通常很快地完成各自工作并阻塞</li>
</ul>
</li>
</ul>
<h2 id="调度算法的评价指标">调度算法的评价指标</h2>
<ul>
<li>对于批处理系统，调度算法的评价指标主要有三个
<ul>
<li>吞吐量(throughout)：系统单位时间内完成的作业数量，比如 10 道作业花费 100 秒，则吞吐量为 0.1 道/秒</li>
<li>周转时间(turnaround time)：一个批处理作业从提交开始到完成的统计平均时间</li>
<li>CPU 利用率：CPU 忙碌时间相对总时间的占比</li>
</ul>
</li>
<li>对于交互式系统，评价指标最重要的是最小响应时间，即从发出命令到得到响应之间的时间</li>
<li>实时系统的特点是或多或少必须满足截止时间，多数实时系统中，可预测性十分重要，比如如果多媒体实时系统的音频进程运行错误太多，音质就会明显下降，为此实时系统的调度算法必须是高度可预测和有规律的</li>
</ul>
<h2 id="批处理系统中的调度">批处理系统中的调度</h2>
<h3 id="先来先服务first-come-first-servedfcfs">先来先服务(First-Come First-Served，FCFS)</h3>
<ul>
<li>
<p>非抢占式。进程按照请求 CPU 的先后顺序调度，优点是公平，算法实现简单，不会导致进程饥饿(Starvation，等待时间对进程响应带来明显影响)</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">先到先服务，因此调度顺序为 P1 -&gt; P2 -&gt; P3 -&gt; P4
</span></span><span class="line"><span class="cl">P1      P2   P3 P4
</span></span><span class="line"><span class="cl">------- ---- -  ----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">周转时间 = 完成时间 - 到达时间
</span></span><span class="line"><span class="cl">P1 = 7 - 0 = 7
</span></span><span class="line"><span class="cl">P2 = 11 - 2 = 9
</span></span><span class="line"><span class="cl">P3 = 12 - 4 = 8  // 只运行 1，却需要等待 8，可见 FCFS 算法对短作业不利
</span></span><span class="line"><span class="cl">P4 = 16 - 5 = 11
</span></span><span class="line"><span class="cl">平均周转时间 = 8.75
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">带权周转时间 = 周转时间 / 运行时间
</span></span><span class="line"><span class="cl">P1 = 7 / 7 = 1
</span></span><span class="line"><span class="cl">P2 = 9 / 4 = 2.25
</span></span><span class="line"><span class="cl">P3 = 8 / 1 = 8
</span></span><span class="line"><span class="cl">P4 = 11 / 4 = 2.75
</span></span><span class="line"><span class="cl">平均带权周转时间 = 3.5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">等待时间 = 周转时间 - 运行时间(不考虑等待 I/O 操作的时间)
</span></span><span class="line"><span class="cl">P1 = 7 - 7 = 0
</span></span><span class="line"><span class="cl">P2 = 9 - 4 = 5
</span></span><span class="line"><span class="cl">P3 = 8 - 1 = 7
</span></span><span class="line"><span class="cl">P4 = 11 - 4 = 7
</span></span><span class="line"><span class="cl">平均等待时间 = 4.75</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="最短作业优先shortest-job-firstsjf">最短作业优先(Shortest Job First，SJF)</h3>
<ul>
<li>
<p>非抢占式。选择已到达的且运行时间最短的进程，运行时间相同则先到达的先运行。目标是追求最短的平均周转时间、平均带权周转时间、平均等待时间，缺点是不公平，对短作业有利，对长作业不利，如果一直有短作业到达可能导致长作业饥饿</p>
<div class="highlight" id="id-14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P1 先到达，P1 运行结束时 P2、P3、P4 均到达，P3 运行时间最短先运行
</span></span><span class="line"><span class="cl">P2、P4 运行时间相同，P2 先到达，因此 P2 先于 P4 运行
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最终调度顺序为 P1 -&gt; P3 -&gt; P2 -&gt; P4
</span></span><span class="line"><span class="cl">P1      P3 P2    P4
</span></span><span class="line"><span class="cl">------- -  ----  ----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">周转时间 = 完成时间 - 到达时间
</span></span><span class="line"><span class="cl">P1 = 7 - 0 = 7
</span></span><span class="line"><span class="cl">P2 = 12 - 2 = 10
</span></span><span class="line"><span class="cl">P3 = 8 - 4 = 4
</span></span><span class="line"><span class="cl">P4 = 16 - 5 = 11
</span></span><span class="line"><span class="cl">平均周转时间 = 8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">带权周转时间 = 周转时间 / 运行时间
</span></span><span class="line"><span class="cl">P1 = 7 / 7 = 1
</span></span><span class="line"><span class="cl">P2 = 10 / 4 = 2.5
</span></span><span class="line"><span class="cl">P3 = 4 / 1 = 4
</span></span><span class="line"><span class="cl">P4 = 11 / 4 = 2.75
</span></span><span class="line"><span class="cl">平均带权周转时间 = 2.56
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">等待时间 = 周转时间 - 运行时间(不考虑等待 I/O 操作的时间)
</span></span><span class="line"><span class="cl">P1 = 7 - 7 = 0
</span></span><span class="line"><span class="cl">P2 = 10 - 4 = 6
</span></span><span class="line"><span class="cl">P3 = 4 - 1 = 3
</span></span><span class="line"><span class="cl">P4 = 11 - 4 = 7
</span></span><span class="line"><span class="cl">平均等待时间 = 4</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="最短剩余时间优先shortest-remaining-time-nextsrtn">最短剩余时间优先(Shortest Remaining Time Next，SRTN)</h3>
<ul>
<li>
<p>SRTN 是 SJF 的抢占式版本，每当新进程加入时，调度程序总是选择剩余运行时间最短的进程运行，如果当前进程剩余运行时间比新进程长，则挂起当前进程而运行新进程</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">P2 到达时，P1 剩余 5，P2 为 4，运行 P2
</span></span><span class="line"><span class="cl">P3 到达时，P1 剩余 5，P2 剩余 2，P3 为 1，运行 P3
</span></span><span class="line"><span class="cl">P4 到达时，P3 运行结束，P1 剩余 5，P2 剩余 2，P4 为 4，运行 P2
</span></span><span class="line"><span class="cl">最后依次运行 P4 和 P1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最终调度顺序为 P1 -&gt; P2 -&gt; P3 -&gt; P2 -&gt; P4 -&gt; P1
</span></span><span class="line"><span class="cl">P1 P2 P3 P2 P4    P1
</span></span><span class="line"><span class="cl">-- -- -  -- ----  -----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">周转时间 = 完成时间 - 到达时间
</span></span><span class="line"><span class="cl">P1 = 16 - 0 = 16
</span></span><span class="line"><span class="cl">P2 = 7 - 2 = 5
</span></span><span class="line"><span class="cl">P3 = 5 - 4 = 1
</span></span><span class="line"><span class="cl">P4 = 11 - 5 = 6
</span></span><span class="line"><span class="cl">平均周转时间 = 7
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">带权周转时间 = 周转时间 / 运行时间
</span></span><span class="line"><span class="cl">P1 = 16 / 7 = 2.29
</span></span><span class="line"><span class="cl">P2 = 5 / 4 = 1.25
</span></span><span class="line"><span class="cl">P3 = 1 / 1 = 1
</span></span><span class="line"><span class="cl">P4 = 6 / 4 = 1.5
</span></span><span class="line"><span class="cl">平均带权周转时间 = 1.51
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">等待时间 = 周转时间 - 运行时间(不考虑等待 I/O 操作的时间)
</span></span><span class="line"><span class="cl">P1 = 16 - 7 = 9
</span></span><span class="line"><span class="cl">P2 = 5 - 4 = 1
</span></span><span class="line"><span class="cl">P3 = 1 - 1 = 0
</span></span><span class="line"><span class="cl">P4 = 6 - 4 = 2
</span></span><span class="line"><span class="cl">平均等待时间 = 3</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="高响应比优先highest-response-ratio-nexthrrn">高响应比优先(Highest Response Ratio Next，HRRN)</h3>
<ul>
<li>
<p>非抢占式。在所有已到达进程中选择响应比(<code>等待时间 / 运行时间 + 1</code>)最高的运行，综合 FCFS 和 SJF 的优点，等待时间长、运行时间短的优先，避免长作业饥饿的问题</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">进程 到达时间 运行时间
</span></span><span class="line"><span class="cl">P1   0        7
</span></span><span class="line"><span class="cl">P2   2        4
</span></span><span class="line"><span class="cl">P3   4        1
</span></span><span class="line"><span class="cl">P4   5        4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">响应比 = (等待时间 + 运行时间) / 运行时间
</span></span><span class="line"><span class="cl">P1 运行至结束，P2、P3、P4 均到达，响应比分别为
</span></span><span class="line"><span class="cl">P2 = (5 + 4) / 4 = 2.25
</span></span><span class="line"><span class="cl">P3 = (3 + 1) / 1 = 4
</span></span><span class="line"><span class="cl">P4 = (2 + 4) / 4 = 1.5
</span></span><span class="line"><span class="cl">运行 P3，P3 结束时，响应比分别为
</span></span><span class="line"><span class="cl">P2 = (6 + 4) / 4 = 2.5
</span></span><span class="line"><span class="cl">P4 = (3 + 4) / 4 = 1.75
</span></span><span class="line"><span class="cl">运行 P2，最后运行 P4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最终调度顺序为 P1 -&gt; P3 -&gt; P2 -&gt; P4
</span></span><span class="line"><span class="cl">P1      P3 P2    P4
</span></span><span class="line"><span class="cl">------- -  ----  ----</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="交互式系统中的调度">交互式系统中的调度</h2>
<h3 id="时间片轮转调度round-robin-schedulingrr">时间片轮转调度(Round-Robin Scheduling，RR)</h3>
<ul>
<li>
<p>RR 是一种简单公平的抢占式调度算法，并且可以避免饥饿。每个进程被分配一个时间片(quantum)。时间片结束时，如果进程还在运行，则剥夺 CPU 并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即切换。RR 算法实现很容易，只需要维护一张进程队列表</p>
<div class="highlight" id="id-17"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A -&gt; B -&gt; C -&gt; D
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">若 A 用完时间片，但仍在运行，则插入到队列尾
</span></span><span class="line"><span class="cl">B -&gt; C -&gt; D -&gt; A
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">若 B 用完时间片，但仍在运行，并到达一个新进程 E，则先插入新进程
</span></span><span class="line"><span class="cl">C -&gt; D -&gt; A -&gt; E -&gt; B
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">若 C 用完时间片之前就结束了，则直接切换到下一个进程
</span></span><span class="line"><span class="cl">D -&gt; A -&gt; E -&gt; B</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>需要考虑的是时间片的长度，假设时间片为 4 ms，上下文切换为 1 ms，则 CPU 完成 4 ms 工作后将浪费 1 ms 进行上下文切换(context switch)，即浪费了 20% 的时间。但如果时间片太大，就会退化为 FCFS，导致增大响应时间。通常为了提高 CPU 效率，设置时间片时，切换开销占比应不超过 1%</p>
</li>
</ul>
<h3 id="优先级调度">优先级调度</h3>
<ul>
<li>为每个进程设置优先级，在已到达进程中，选择优先级最高的运行，可以为抢占式或非抢占式</li>
<li>比如对于操作系统来说，I/O 密集型进程的优先级应该更高。I/O 密集型继承多数时间用于等待 I/O 结束，因此需要 CPU 时应立即分配给它以便启动下一个 I/O 请求，这样就可以在另一个进程计算的同时执行 I/O 操作</li>
<li>一种简单做法是将优先级设置为 <code>1 / f</code>，<code>f</code> 为该进程在上一时间片中的运行时间占比。比如在 50 ms 时间片中，使用 1 ms 的进程优先级为 50，使用 25 ms 的进程优先级为 2。将进程按优先级分组，再使用 RR 算法调度高优先级组中的进程</li>
</ul>
<h3 id="多级反馈队列调度">多级反馈队列调度</h3>
<ul>
<li>CTSS(Compatible Time Sharing System)是最早使用优先级调度的系统之一，但存在进程切换速度太慢的问题，其设计者意识到设置较长的时间片可以减少切换次数，但长时间片又会影响到响应时间。最终的解决方法是多级反馈队列调度，它是对 FCFS、SJF、RR、优先级调度的折中权衡</li>
<li>设置多个优先级队列，每个级别对应不同长度的时间片，比如第一级(最高级)时间片为 1，第二级为 2，第三级为 4，以此类推</li>
<li>如果一个进程用完当前级别时间片后仍未运行完，则加入下一级队列队尾，如果已经位于最后一级则放回该级队尾</li>
<li>高优先级队列为空时，才会调度低优先级队列，因此可能导致低优先级进程饥饿</li>
<li>比如一个进程需要 100 个时间片，第一次分配 1 个时间片，第二次分配 2 个，接下来是 4、8、16、32、64，最后一次使用 64 中的 37 个即可结束工作，一共进行 7 次切换。如果使用 RR 算法，则需要 100 次切换</li>
</ul>
<h3 id="最短进程优先">最短进程优先</h3>
<ul>
<li>
<p>关键在于如何从可运行进程中找出最短的一个</p>
</li>
<li>
<p>一种方法是根据过去的行为进行预测。假设某终端每条命令的估计运行时间为 <code>T0</code>，测量到下一次运行时间为 <code>T1</code>，则估计时间可以修正为 <code>a * T0 + (1 - a) * T1</code>，比如设 <code>a</code> 为 <code>1 / 2</code> 可以得到序列如下</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">T0
</span></span><span class="line"><span class="cl">T0/2 + T1/2
</span></span><span class="line"><span class="cl">T0/4 + T1/4 + T2/2
</span></span><span class="line"><span class="cl">T0/8 + T1/8 + T2/4 + T3/2  // T0 在此时估计时间中的占比下降到 1/8</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="保证调度">保证调度</h3>
<ul>
<li>向用户作出明确的性能保证，然后实现它。比如有 <code>n</code> 个进程运行的单用户系统中，如果所有进程等价，则每个进程获得 <code>1 / n</code> 的CPU时间，为了实现所作的保证，系统跟踪每个进程已使用的 CPU 时间，并计算应获得的时间，然后转向已用时间最少的进程，直到超过最接近的竞争者</li>
</ul>
<h3 id="彩票调度lottery-scheduling">彩票调度(Lottery Scheduling)</h3>
<ul>
<li>保证调度的想法不错，但很难实现。彩票调度既可以给出类似预测结果，并且实现非常简单。其基本思想是为进程提供各种系统资源(如 CPU 时间)的彩票，一旦需要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程获取该资源</li>
<li>比如系统掌握每秒 50 次的一种彩票，作为奖励每个获奖者可以获得 20 ms 的 CPU 时间</li>
<li>可以给更重要的进程额外的彩票，以增加其获胜的机会，比如出售 100 张彩票，一个进程持有其中 20 张，则每次抽奖该进程就有 20% 的取胜机会，在较长运行时间中该进程就会得到 20% 的 CPU</li>
<li>彩票调度可以解决其他方法很难解决的问题，比如一个视频服务器上有若干提供视频流的进程，每个流的帧率不同，假设帧率分别为 10、20、25，那么给这些进程分别分配 10、20、25 张彩票，它们就会自动按照接近 10:20:25 的比例划分 CPU 的使用</li>
</ul>
<h3 id="公平分享调度">公平分享调度</h3>
<ul>
<li>之前的调度关注的都是进程本身，而没有关注进程所有者。假设两个用户分别启动 9 个进程和 1 个进程，使用 RR 算法，则两者分别得到 90% 和 10% 的 CPU 时间。为了避免这种情况，在调度处理之前应该考虑进程拥有者</li>
</ul>
]]></description></item><item><title>C++ Concurrency in Action | Memory Management</title><link>https://jianye0428.github.io/posts/memorymanagement/</link><pubDate>Sun, 19 Nov 2023 13:05:52 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/memorymanagement/</guid><description><![CDATA[<h2 id="无存储器抽象">无存储器抽象</h2>
<ul>
<li>
<p>早期计算机没有存储器抽象，每个程序都直接访问物理内存</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REGISTER1</span><span class="p">,</span> <span class="mi">1000</span>  <span class="err">;将位置</span><span class="mi">1000</span><span class="err">的物理内存中的内容移到</span> <span class="no">REGISTER1</span> <span class="err">中</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>因此那时呈现给程序员的存储器模型就是简单的物理内存：从 0 到某个上限的地址集合，每个地址对应一个可容纳一定数目（通常是 8 个）二进制位的存储单元</p>
</li>
<li>
<p>这种情况下，在内存中同时运行两个程序是不可能的，如果一个程序在 2000 的位置写入一个新值，就会擦掉另一个程序在相同位置上的内容，因此无法同时运行两个程序，这两个程序会立刻崩溃</p>
</li>
<li>
<p>为了运行多个程序，一个解决方法是，操作系统把当前内存中所有内容保存到磁盘，然后把下一个程序读入到内存中再运行即可。同一时刻，只要内存中只有一个程序，就不会发生冲突</p>
</li>
<li>
<p>但这种方法有一个重要的缺陷，即重定位（即逻辑地址到物理地址的转换）问题。假设有两个程序，第一个程序在 0 处的指令是 <code>JMP 24</code>，第二个程序在 0 处的指令是 <code>JMP 28</code>，当第一个程序运行一段时间后再运行第二个程序，第二个程序会跳到第一个程序 28 处的指令。由于对内存地址的不正确访问，程序立刻崩溃</p>
</li>
<li>
<p>一个补救方法是静态重定位，即装入时将逻辑地址转换为物理地址。当一个程序被装载到地址 16384 时，常数 16384 被加到每一个程序地址上。虽然这个机制在不出错误的情况下可行，但不是一种通用的解决方法，同时会减慢装载速度，并且它要求所有的可执行程序提供额外的信息，以区分哪些内存字中存有可重定位的地址，哪些没有</p>
</li>
<li>
<p>虽然直接引用物理地址对大型计算机、小型计算机、台式计算机、笔记本都已经成为了历史，但在嵌入式系统、智能卡系统中，缺少存储器抽象的情况仍然很常见。像收音机、洗衣机、微波炉都是采用访问绝对内存地址的寻址方式，其中的程序都是事先确定的，用户不能在其上运行自己的软件，因此它们可以正常工作</p>
</li>
<li>
<p>总之，把物理地址暴露给进程带来的严重问题有：</p>
<ul>
<li>如果用户程序可以寻址内存的每个字节，就可以轻易破坏操作系统</li>
<li>想要运行多个程序很困难</li>
</ul>
</li>
</ul>
<h2 id="一种存储器抽象地址空间">一种存储器抽象：地址空间</h2>
<ul>
<li>要使多个程序同时存在于内存中并且互不影响，需要解决保护（进程只能访问自己的内存）和重定位两个问题。对前者的一个原始的解决方法是，给内存标记上一个保护键，并且比较执行进程的键和其访问的每个内存字的保护键，比如进程能访问的空间是 0-100，CPU 标记此范围，然后在访问内存时检查是否为该进程可访问空间。不过这种方法并没有解决重定位问题</li>
<li>更好的方法是创造一个新的存储器抽象：地址空间。地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了一些情况下进程需要共享地址空间）</li>
<li>地址空间的概念非常通用，比如 7 位数字的电话号码的地址空间是 <code>0 000 000</code> 到 <code>9 999 999</code>，x86 的 I/O 端口的地址空间是 <code>0</code> 到 <code>16383</code>，IPv4 的地址空间是 <code>0</code> 到 <code>2 ^ 32 - 1</code>。地址空间也可以是非数字的，比如以 <code>.com</code> 结尾的网络域名的集合</li>
<li>比较难的是给每个程序一个独有的地址空间，使得两个程序的相同地址（如地址 28）对应不同的物理地址</li>
<li>一个简单的方法是使用动态重定位，即运行时将逻辑地址转换为物理地址。把每个进程的地址空间映射到物理内存的不同部分，当一个进程运行时，程序的起始物理地址装载到基址寄存器（又称重定位寄存器），程序的长度装载到界限寄存器（又称限长寄存器）。进程访问内存，CPU 在把地址发送到内存总线前会自动把基址加到进程发出的地址值上，同时检查程序提供的地址是否超出了界限寄存器中的值，如果超出了就会产生错误并终止访问。对于之前的例子，比如第二个程序的 <code>JMP 28</code>，CPU 会将其解释为 <code>JMP 16412</code></li>
<li>使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算，比较运算可以很快，但加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢</li>
<li>但物理内存是有限的，把所有进程一直保存在内存中需要巨大的内存，内存不足就无法支持这点。处理内存超载有两种通用方法，最简单的是交换（swapping）技术，即把进程完整调入内存运行一段时间，然后把它存回磁盘，这样空闲进程主要存储在磁盘上，不运行就不会占用内存。另一种方法是虚拟内存（virtual memory），它能使程序只有一部分调入内存的情况下运行</li>
<li>交换可能在内存中产生多个空闲区（hole）。把进程尽可能靠近，将这些小的间隙合并成一大块，这种技术称为内存紧缩（memory compaction）。通常不进行这个操作，因为它需要耗费大量 CPU 时间</li>
<li>如果进程的数据段可以增长（比如从堆中动态分配内存），进程与空闲区相邻，则可以把空闲区分配给进程使其增大。如果进程之间紧紧相邻，就需要把要增长的进程移到内存中一个足够大的区域，或者把一个或多个进程交换出去以生成足够大的空闲区。如果进程在内存中不能增长，并且磁盘上的交换区已满，则这个进程只能挂起直到有空间空闲，或者结束</li>
<li>如果大部分进程在运行时需要增长，为了减少因内存区不够而引起的进程交换和移动开销，一种方法是在换入或移动进程时额外分配一些预留内存</li>
<li>动态分配内存时，操作系统必须对其进行管理，一般跟踪内存使用情况有两种方法：位图和空闲区链表</li>
<li>使用位图法时，把内存划分成分配单元（每个单元小到几个字节或大到几千字节），用位图中的一位来记录每个分配单元的使用情况，比如 0 表示空闲 1 表示占用（或者相反）。分配单元越小，位图越大，不过即使 4 个字节大小的分配单元，32 位的内存只需要 1 位位图，位图只占用了 <code>1 / 32</code> 的内存</li>
<li>位图法的主要问题是，在决定把一个占 <code>k</code> 个分配单元的进程调入内存时，存储管理器必须搜索位图，在位图中找出有 <code>k</code> 个连续 0 的串，这个查找操作很耗时，因为在位图中该串可能跨越字的边界</li>
<li>另一个记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点包含一个进程或者两个进程间的一块空闲区</li>
<li>使用链表法时，为进程分配内存的最简单的算法是首次适配（first fit）算法，存储管理器沿链表搜索，直到找到一个足够大的空闲区，然后将空闲区分为两部分，一部分为要分配的大小，供进程使用，另一部分形成新的空闲区</li>
<li>对首次适配算法进行小修改可以得到下次适配（next fit）算法，区别是在每次找到合适的空闲区时记录位置，这样下次就可以从上次结束的地方开始搜索。Bays 的仿真程序证明下次适配算法性能略低于首次适配算法</li>
<li>另一个著名并广泛使用的算法是最佳适配（best fit）算法，搜索整个链表，找到能容纳进程的最小空闲区。因为每次都要搜索整个链表，所以它比首次适配算法慢。有些令人意外的是，它比前两种算法浪费更多的内存，因为它会产生大量无用的小空闲区。为了避免分裂出很多非常小的空闲区，可以考虑最差适配（worst fit）算法，即总是分配最大的可用空闲区，但仿真程序表明这也不是一个好方法</li>
<li>一个提高算法速度的方式是，为进程和空闲区分别维护链表，代价是增加复杂度和内存释放速度变慢，因为必须将回收的段从进程链表删除并插入到空闲区链表</li>
<li>如果分别维护进程和空闲区的链表，就可以对空闲区链表按大小排序，以提高最佳适配算法的速度，比如按从小到大排序，第一个合适的空间就是最小的空闲区，就是最佳适配。排序后，首次适配算法与最佳适配算法一样快，下次适配算法无意义</li>
<li>单独维护空闲区链表时可以做一个小优化，利用空闲区存储信息，每个空闲区的第一个字就是空闲区大小，第二个字指向下一空闲区</li>
<li>另一种分配算法是快速分配（quick fit）算法，它为常用大小的空闲区维护单独的链表，比如链表第一项是 4 KB 大小空闲区的链表头指针，第二项是 8 KB 大小空闲区的链表头指针，以此类推。像 21 KB 的空闲区，既可以放在 20 KB 的链表中，也可以放在一个专门存放特殊大小的链表中。这种算法查找指定大小的空闲区很快，但同样存在的缺点是，进程终止或换出时，寻找它的相邻块并查找是否可以合并的过程非常费时，如果不合并，内存将很快分裂出大量无法利用的小空闲区</li>
</ul>
<h2 id="虚拟内存">虚拟内存</h2>
<ul>
<li>当程序大到内存无法容纳时，交换技术就有所缺陷，一个典型 SATA 磁盘的峰值传输率高达每秒几百兆，交换一个 1 GB 的程序就需要好几秒</li>
<li>程序大于内存的问题在一些应用领域早就存在了，比如模拟宇宙的创建就要花费大量内存。20 世纪 60 年代的解决方案是，将程序分割为多个覆盖区（overlay）。程序开始运行时，将覆盖管理模块装入内存，该模块立刻装入并运行第一个覆盖区，执行完成后，第一个覆盖区通知管理模块装入下一个覆盖区</li>
<li>程序员必须把程序分割成多个片段，这个工作非常费时枯燥，并且易出错。不久后有了虚拟内存（virtual memory）的方法，这些工作都可以交给计算机去做</li>
<li>虚拟内存的基本思想是，程序的地址空间被分割成多个页（page），每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有页必须在内存中才能运行程序。当程序引用到一部分物理内存中的地址空间时，由硬件执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令</li>
</ul>
<h2 id="分页paging">分页（paging）</h2>
<ul>
<li>
<p>大部分虚拟内存系统都使用了分页技术</p>
</li>
<li>
<p>由程序产生的地址称为虚拟地址（virtual address）</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REG</span><span class="p">,</span> <span class="mi">1000</span>  <span class="err">;将地址为</span> <span class="mi">1000</span> <span class="err">的内存单元的内容复制到</span> <span class="no">REG</span><span class="err">，</span><span class="mi">1000</span> <span class="err">是虚拟地址</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>虚拟地址构成了虚拟地址空间（virtual address space）。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用相同地址的物理内存字。在使用虚拟内存时，虚拟地址被送到内存管理单元（Memory Management Unit，MMU），MMU 把虚拟地址映射为物理内存地址</p>
</li>
<li>
<p>页表给出虚拟地址与物理内存地址之间的映射关系</p>
</li>
<li>
<p>虚拟地址空间按固定大小划分为页面（page），物理内存中对应的单元称为页框（page frame），页面和页框的大小通常相同，页表说明了每个页面对应的页框。RAM 和磁盘之间的交换总是以整个页面为单元进行的</p>
</li>
</ul>
<p></p>
<ul>
<li>
<p>对应 64 KB 的虚拟地址空间和 32 KB 的物理内存，可以得到 16 个页面和 8 个页框</p>
</li>
<li>
<p>比如执行指令访问地址 0 时</p>
<div class="highlight" id="id-3"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REG</span><span class="p">,</span> <span class="mi">0</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>虚拟地址 0 被送到 MMU，MMU 发现其位于页面 0（0 - 4095），根据映射结果，页面 0 对应页框 2（8192 - 12287），于是 MMU 将地址转换为 8192，并把地址 8192 送到总线上。内存并不需要知道 MMU 做的事，只看到一个访问地址 8192 的请求并执行</p>
</li>
<li>
<p>当虚拟地址空间比物理内存大时，就会存在未被映射的页面。当程序执行指令访问未映射的页面</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">REG</span><span class="p">,</span> <span class="mi">32780</span>  <span class="err">;位于页面</span> <span class="mi">8</span><span class="err">（从</span> <span class="mi">32768</span> <span class="err">开始）</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>MMU 发现该页面未被映射，于是使 CPU 陷入（traps）到操作系统，这称为缺页中断（page fault）。操作系统找到一个很少使用的页框并把其内容写入磁盘，比如找到页面 1 对应的页框 1。将页面 1 标记为未映射，再把页面 8 映射到这个页框 1，然后重新启动访问指令，此时虚拟地址 32780 就可以映射到物理地址 4108（4096 + 32780 - 32768）</p>
</li>
<li>
<p>页面大小一般是 2 的整数次幂。比如页面大小为 4 KB，即 <code>2 ^ 12</code>，对于一个 16 位的虚拟地址，即可用前 4 位表示页面的页号，后 12 位表示偏移量。比如虚拟地址 <code>8192</code>，二进制为 <code>0010 0000 0000 0100</code>，<code>0010</code> 即为页号，<code>0000 0000 0100</code> 即为偏移，因此 <code>8192</code> 位于页号 <code>2</code> 偏移 <code>4</code> 的位置</p>
</li>
<li>
<p>页表中，查找页号 <code>2</code> 对应的页框号为 <code>6</code>，把页框号 <code>110</code> 复制到输出寄存器的高 3 位，后 12 位保持不变，<code>110 0000 0000 0100</code> 即为物理地址</p>
</li>
<li>
<p>除了页框号，页表还会有一些其他的位</p>
<ul>
<li>有效位，如果该位为 1 则说明存在映射，如果为 0，则访问该页面将引起缺页中断</li>
<li>保护（protection）位，指出一个页允许的访问方式，比如用一个位表示，0 表示读写，1 表示只读</li>
<li>修改（modified）位，记录页面使用情况，写入页面后由硬件自动设置修改位，该位也称为脏位（dirty bit），在重新分配页框时很有用，比如一个页是脏的（已被修改过），则必须把它写回磁盘，是干净的则可以直接丢弃</li>
<li>访问（referenced）位，在页面被访问时设置，主要用来帮助操作系统在发生缺页中断时选择要淘汰的页面</li>
<li>禁止高速缓存位，该位对于映射到设备寄存器而非常规内存的页面十分重要，比如操作系统持续等待 I/O 设备的响应，必须保证硬件读取的数据来自设备而非高速缓存</li>
</ul>
</li>
</ul>
<h2 id="加速分页过程">加速分页过程</h2>
<ul>
<li>在任何分页系统中都需要考虑两个问题
<ul>
<li>虚拟地址到物理地址的映射必须非常快：每次访问内存都要进行映射，所有的指令最终都来自内存，并且很多指令也会访问内存中的操作数，因此每条指令进行一两次或更多页表访问是必要的。如果指令一条指令要 1 ns，页表查询必须在 0.2 ns 内完成，以避免映射成为主要瓶颈</li>
<li>如果虚拟地址空间很大，页表也会很大：现代计算机至少使用 32 位虚拟地址，假设页面大小为 4 KB，32 位的地址空间将有 100 万页，页表也必然有 100 万条表项。每个进程都有自己的虚拟地址空间，都需要自己的页表，于是需要为进程分配非常多的连续页框</li>
</ul>
</li>
<li>大多数程序总是对少量页面多次访问，没有必要让将整个页表保存在内存中，由此得出的一种解决方案是，设置一个转换检测缓冲区（Translation Lookaside Buffer，TLB），也称相联存储器（associate memory）或快表，将虚拟内存直接映射到物理地址，而不必再访问页表</li>
<li>TLB 通常在 MMU 中，包含少量表项，实际中很少会超过 256 个。将一个虚拟地址放入 MMU 中进行转换时，硬件先将页号与 TLB 中所有表项进行匹配，如果匹配成功且操作不违反保护位，则直接从 TLB 中取出页框号，而不再访问页表。如果匹配失败，则进行正常的页表查询，并从 TLB 淘汰一个表项，然后用新找到的页表项代替它</li>
<li>处理巨大的虚拟地址空间有两种解决方法：多级页表和倒排页表</li>
<li>比如 32 位地址空间中，页面大小为 4 KB，偏移量占 12 位，则页号占 20 位。将页号分组，页表项大小为 4 B，4 KB 的页面就能放 1024 个表项，于是每 1024 个页号分为一组。这样分组得到的页表为二级页表，再用一个顶级页表映射页号到二级页表的物理地址即可</li>
<li>使用多级页表时，32 位的地址划分为 10 位的 PT1 域、10 位的 PT2 域、12 位的 Offset 域。比如对于虚拟地址 <code>0000 0000 0100 0000 0011 0000 0000 0100</code>，PT1 为 1，PT2 为 3，Offset 为 4，MMU 先访问顶级页表 1 处，得到二级页表的物理地址，由此访问二级页表 3 处，得到页框号，最后加上 Offset 即为最终的物理地址</li>
<li>二级页表可以扩充为更多级。每级页表大小不能超过一个页面，比如 4 KB 页面，偏移为 12 位，页表项大小为 4 B，每 1024 分为一组，则每级最多 10 位，如果是 40 位，则除去 12 位，剩余可以划分为一级 8 位、二级 10 位、三级 10 位的三级页表</li>
<li>单级页表只要进行两次访存（第一次访问页表得到物理地址，第二次访问物理地址），而每多一级页表就要多一次访存（不考虑 TLB）</li>
<li>另一种方式是倒排页表（inverted page table），让每个页框（而非页面）对应一个表项。比如对于 64 位虚拟地址，4 KB 的页，4 GB 的 RAM，一个倒排页表仅需要 <code>2 ^ 20</code> 个表项，表项记录了一个页框对应的页面（进程）</li>
<li>虽然倒排页表节省了大量空间，但从虚拟地址到物理地址的转换变得很困难，必须搜索整个倒排页表来找到页面，每一次搜索都要执行访问操作。这个问题可以通过 TLB 解决</li>
<li>倒排页表在 64 位机器中很常见，因为 64 位机器中，即使使用大页面页表项数量也很庞大，比如对于 4 MB 页面和 64 位虚拟地址，需要的页表项目数为 <code>2 ^ 42</code></li>
</ul>
<h2 id="页面置换算法">页面置换算法</h2>
<ul>
<li>发生缺页中断时，操作系统必须换出内存中的一个页面，以腾出空间。如果换出的页面在内存驻留期间被修改过，就必须把它写回磁盘以更新其在磁盘上的副本，如果未被修改过则不需要写回</li>
<li>如果一个经常用到的页面被换出内存，短时间内它可能又被调入内存，这会带来不必要的开销。因此发生缺页中断时，如何选择要换出的页面是一个值得考虑的问题</li>
</ul>
<h3 id="最优页面置换算法optimal-replacementopt">最优页面置换算法（OPTimal replacement，OPT）</h3>
<ul>
<li>
<p>OPT 算法的思路很简单，从所有页面中选出下次访问时间距现在最久的淘汰</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">432143543215</span>  <span class="c1">// 页面队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">444444444222</span>  <span class="c1">// 页 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">33333333311</span>  <span class="c1">// 页 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="mi">2111555555</span>  <span class="c1">// 页 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TTTT</span>  <span class="n">T</span>  <span class="n">TT</span>   <span class="c1">// 是否发生缺页中断（共发生 7 次缺页中断，4 次页面置换）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">|</span>
</span></span><span class="line"><span class="cl">  <span class="err">把</span> <span class="mi">2</span> <span class="err">替换掉，因为</span> <span class="mi">432</span> <span class="err">中，</span><span class="mi">2</span> <span class="err">下一次被访问的时间最靠后</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>这个算法的唯一问题在于，它是无法实现的，因为发生缺页中断时，操作系统无法得知各个页面下一次在什么时候被访问</p>
</li>
<li>
<p>作为理论最优算法，可以用它衡量其他算法的性能。如果操作系统的页面置换性能只比最优算法差 1%，那么花费大量精力来优化算法就不是特别必要的</p>
</li>
</ul>
<h3 id="最近未使用页面置换算法not-recently-usednru">最近未使用页面置换算法（Not Recently Used，NRU）</h3>
<ul>
<li>操作系统为每个页面设置了两个状态位，当页面被访问时设置 R 位，被修改时设置 M 位。启动进程时，所有页面的 RM 均设为 0，并且 R 被定期（比如每次时钟中断时）清零</li>
<li>发生缺页中断时，根据 RM 位的值，可以将页面分为 4 类
<ul>
<li>第 0 类：未访问未修改（R 位为 0，M 位为 0）</li>
<li>第 1 类：未访问已修改（R 位为 0，M 位为 1，看起来似乎不可能，实际可以由第 3 类转换而来）</li>
<li>第 2 类：已访问未修改（R 位为 1，M 位为 0）</li>
<li>第 3 类：已访问已修改（R 位为 1，M 位为 1，R 在清零后即变为第 1 类）</li>
</ul>
</li>
<li>NRU 算法随机从第0类中选择一个页面淘汰，如果第 0 类中没有页面则选择第 1 类，以此类推，优先选择编号最小的类</li>
<li>这个算法的隐含思想是，淘汰一个未访问已修改页面（第 1 类），比淘汰一个频繁使用的干净页面（第 2 类）好</li>
<li>NRU 的主要优点是易理解且能有效实现，虽然性能不是最好的，但已经够用了</li>
</ul>
<h3 id="先进先出页面置换算法first-in-first-outfifo">先进先出页面置换算法（First-In First-Out，FIFO）</h3>
<ul>
<li>顾名思义，淘汰最早进入的页面</li>
<li>操作系统维护一个内存中所有当前页面的链表，最新进入的页面放在表尾，淘汰页面就是表头页面</li>
<li>FIFO 可能淘汰常用页面，甚至可能出现分配页面数增多但缺页率反而提高的异常现象（Belady 异常），因此很少使用纯粹的 FIFO 算法</li>
</ul>
<h3 id="第二次机会页面置换算法second-chance">第二次机会页面置换算法（Second-Chance）</h3>
<ul>
<li>对 FIFO 做一个简单的修改：检查最老页面的 R 位（访问位），如果 R 位是 0 则淘汰，如果是 1 则把 R 位清零，并把该页面放到表尾，然后继续搜索</li>
<li>如果所有页面都被访问过，则该算法就简化为纯粹的 FIFO 算法</li>
</ul>
<h3 id="时钟页面置换算法clock">时钟页面置换算法（clock）</h3>
<ul>
<li>第二次机会算法经常要在链表中移动页面，降低了效率且不是很有必要</li>
<li>一个更好的办法是将所有页面保存在在一个类似钟面的环形链表中，一个表针指向最老的页面。发生缺页中断时，检查表针指向的页面，如果 R 位是 0 则淘汰该页面，并在该位置插入新页面，然后表针后移一步。如果 R 位是 1 则把 R 位清零，然后表针后移一步。如果该页已存在，不发生缺页中断，R 位是 0 则改为 1，表针不需要移动</li>
</ul>
<h3 id="最近最少使用页面置换算法least-recently-usedlru">最近最少使用页面置换算法（Least Recently Used，LRU）</h3>
<ul>
<li>LRU 是 OPT 的一个近似思路，在前几条指令中频繁使用的页面很可能在后几条指令中被使用，反过来说，很久没使用的页面很可能在之后的长时间内仍然不使用</li>
<li>LRU 是可实现的，但代价很高。实现 LRU 需要维护一个所有页面的链表，最常使用的位于表头，每次访问时必须更新整个链表，在链表中找到页面删除后再添加到表头</li>
<li>有一些使用特殊硬件实现 LRU 的方法，比如要求硬件有一个 64 位计数器，它在每条指令执行完后加 1，每个页表项中有一个足够容纳这个计数器值的域。发生缺页中断时，检查所有页表项的计数值，值最小的就是最近最少使用的</li>
<li>只有非常少的计算机有这种硬件，LRU 很优秀但很难实现</li>
</ul>
<h3 id="最不常用页面置换算法not-frequently-usednfu">最不常用页面置换算法（Not Frequently Used，NFU）</h3>
<ul>
<li>NFU 是 LRU 的一个软件实现方案</li>
<li>NFU 将每个页面与一个软件计数器关联，计数器初值为 0，每次时钟中断时，操作系统扫描内存中所有页面，将每个页面的 R 位值加到计数器上，这个计数器大致跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面</li>
<li>NFU 的问题在于，第一遍扫描中频繁使用的页面，第二遍扫描时，计数器值仍然很高。这就会导致后续扫描中，即使该页面使用次数最少，也会由于计数器值较高而不被置换</li>
</ul>
<h3 id="老化aging算法">老化（aging）算法</h3>
<ul>
<li>
<p>老化算法对 NFU 做了一些改进，在R位加进之前先将计数器右移一位，然后把 R 位加到计数器最左端的位</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">页面
</span></span><span class="line"><span class="cl">0    10000000     11000000     11100000     11110000     01111000
</span></span><span class="line"><span class="cl">1    00000000     10000000     11000000     01100000     10110000
</span></span><span class="line"><span class="cl">2    10000000     01000000     00100000     00100000     10001000
</span></span><span class="line"><span class="cl">3    00000000     00000000     10000000     01000000     00100000
</span></span><span class="line"><span class="cl">4    10000000     11000000     01100000     10110000     01011000
</span></span><span class="line"><span class="cl">5    10000000     01000000     10100000     01010000     00101000
</span></span><span class="line"><span class="cl">    |            |            |            |            |
</span></span><span class="line"><span class="cl">    访问页面 024 访问 014     访问 013     访问 04      访问 12</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>发生缺页中断时，置换计数器值最小的页面，因为前面的 0 越多，说明其最近越不常被访问</p>
</li>
<li>
<p>老化算法非常近似 LRU，但有两个区别</p>
<ul>
<li>比如最后一次访问时，如果发生缺页中断，需要置换一个页面。页面 3 和页面 5 开头都是 001，即前两次未被访问，前第三次被访问，如果前第三次是页面 5 先被访问，则 LRU 会替换页面 5，但这里无法区分两者谁先被访问，而只能替换值较小的页面 3</li>
<li>老化算法计数器位数有限，比如这里是 8 位，只能记录过去 8 次的访问，超过该次数的记录无法得知。不过实践中，如果时钟滴答是 20 ms，8 位一般是够用的，如果一个页面 160 ms 未被访问，则很可能不重要</li>
</ul>
</li>
</ul>
<h3 id="工作集页面置换算法">工作集页面置换算法</h3>
<ul>
<li>在单纯的分页系统中，刚开始启动进程时，内存中没有页面，CPU 尝试取第一条指令时就会产生一次缺页中断，使操作系统装入含第一条指令的页面。一段时间后，进程需要的大部分页面都在内存了，进程开始在较少缺页中断的情况下运行。这个策略称为请求调页（demand paging），因为页面在需要时被调入，而不是预先装入</li>
<li>一个进程当前正在使用的页面集合称为它的工作集（Denning），如果整个工作集都被装入内存中，那么进程在运行到下一阶段之前不会产生很多缺页中断。如果内存太小无法容纳整个工作集，进程的运行过程中将产生大量缺页中断，导致运行速度变慢，因为通常执行一条指令只要几纳秒，而从磁盘读入一个页面需要十几毫秒。如果每执行几条指令就发生一次缺页中断，就称这个程序发生了颠簸（Denning）</li>
<li>请求调页策略中，每次装入一个进程都要产生大量缺页中断，速度太慢，并且 CPU 花了很多时间处理缺页中断，浪费了许多 CPU 时间，因此不少分页系统会设法跟踪工作集，以确保在进程运行前，工作集已经在内存中了，这个方法称为工作集模型（Denning），也叫预先调页（prepaging），其目的在于大大减少缺页中断率</li>
<li>工作集是随着时间变化的，它是最近k次访存所访问过的页面集合。为了实现该算法，需要一种精确的方法来确定哪些页面在工作集中，为此必须预先选定 k 值。但有了工作集的定义并不意味着就能计算出工作集</li>
<li>假设有一个长度为 k 的移位寄存器，每次访存都把寄存器左移一位，然后在最右端插入刚才访问过的页面号，寄存器中 k 个页面号的集合就是工作集。理论上，发生缺页中断时，只要读出寄存器中的内容并排序，然后删除重复的页面，结果就是工作集。但维护该寄存器并在缺页中断时处理它需要很大的开销，因此该技术从未被使用过</li>
<li>有几种近似的方法作为替代，一种常见近似方法是，不向后查找最近 k 次的内存访问，而是查找过去一定时间内，比如过去 10 ms 访存所用到的页面集合</li>
<li>基于工作集的页面置换算法是，找出一个不在工作集中的页面并淘汰，为此表项中至少需要包含两条信息，一是上次使用该页面的近似时间，二是 R 位（访问位）</li>
<li>处理表项时，如果 R 位是 1，则把上次使用时间改为当前实际时间。如果 R 位是 0，则可以作为置换候选者，计算生存时间（当前实际时间与上次使用时间的差），如果生存时间大于定义工作集范围的时间，则该页面在工作集外，将其置换。如果 R 为 0 且生存时间不超过定义工作集范围的时间，则该页面仍在工作集中，记录该页面。如果扫描完整个页表都没有可淘汰的，则从记录页面中选一个生存时间最长的淘汰，如果记录页面为空，即所有页面 R 位均为 1，则随机选择一个淘汰</li>
</ul>
<h3 id="工作集时钟wsclock页面置换算法">工作集时钟（WSClock）页面置换算法</h3>
<ul>
<li>工作集算法需要扫描整个页表，比较费时，结合时钟算法的思路稍作改进，即可得到 WSClock 算法。它实现简单，性能较好，在实际工作中得到了广泛使用</li>
</ul>
<h2 id="分段segmentation">分段（Segmentation）</h2>
<ul>
<li>一个编译器在编译过程中会建立许多表，其中可能包括
<ul>
<li>被保存起来供打印清单用的源程序正文（用于批处理系统）</li>
<li>包含变量名字和属性的符号表</li>
<li>包含用到的所有整型量和浮点常量的表</li>
<li>包含程序语法分析结果的语法分析树</li>
<li>编译器内部过程调用使用的堆栈</li>
</ul>
</li>
<li>在一维地址空间中，当有多个动态增加的表时，就可能发生碰撞。一种能令程序员不用管理表扩张和收缩的方法是，在机器上提供多个互相独立的段（segment）的地址空间，段的长度可以不同，在运行时可以改变，比如堆栈段的长度在数据压入时会增长，在数据弹出时会减小</li>
<li>每个段都构成一个独立的地址空间，在内存中占据连续空间，可以独立地增长或减小，而不会影响其他段</li>
<li>段是按逻辑功能的划分的实体，程序员使用起来更方便，并且程序的可读性更高。此外，分段有助于共享和保护。分段系统中，可以把共享库放到一个单独的段中由各个进程共享，而不需要在每个进程的地址空间中保存一份。当组成一个程序的所有过程都被编译和链接好以后，如果一个段的过程被修改并重新编译，也不会影响到其他段，因为这个段的起始地址（基址）没有被修改</li>
<li>要在分段的存储器中表示一个地址，必须提供一个段号（段名）和一个段内地址（段内偏移量）</li>
</ul>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">31</span> <span class="p">...</span> <span class="mi">16</span> <span class="mi">15</span> <span class="p">...</span> <span class="mi">0</span>  <span class="c1">// 可用 31 - 16 表示段号，15 - 0 表示段内地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>每个进程需要一张段表，每个段表项记录一个段的起始位置和段的长度。段表项长度是固定的，因此段号可以是隐含的，不占存储空间。查找时，如果段号越界，则产生越界中断。如果段内地址超出段长，则产生越界中断</li>
</ul>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">K 号段的段表存放地址 = 段表起始位置 + K * 段表项长度
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">段号 基址 段长
</span></span><span class="line"><span class="cl">0    20K  3K
</span></span><span class="line"><span class="cl">1    60K  2K
</span></span><span class="line"><span class="cl">2    40K  5K
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">如果一个逻辑地址段号为 1，段内地址为 1024
</span></span><span class="line"><span class="cl">段号 1 的段长为 2K，大于 1024，不产生越界中断
</span></span><span class="line"><span class="cl">存放地址 = 60K + 1024 = 61K</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>分段管理的缺点是，如果段长过大，则不便于分配连续空间，此外会产生外部碎片。分页管理的内存利用率高，不会产生外部碎片，只会有少量页内碎片。因此，两者结合可以互相弥补，实现段页式管理</li>
<li>段页式系统的地址由段号、页号、页内地址（页内偏移量）组成。分段对用户可见，而分页不可见</li>
</ul>
<div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">31</span> <span class="p">...</span> <span class="mi">16</span> <span class="mi">15</span> <span class="p">...</span> <span class="mi">12</span> <span class="mi">11</span> <span class="p">...</span> <span class="mi">0</span>  <span class="c1">// 可用 31 - 16 表示段号，15 - 12 表示页号，11 - 0 表示页内地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>每个段表项记录页表长度、页表起始地址，通过页表起始地址找到页号，通过页号对应的页表项目找到物理地址，一共需要三次访存（如果引入以段号和页号为关键字的 TLB 且命中，则只需要一次访存）。段表项长度是固定的，段号可以是隐含的。同样，每个页表项长度固定，页号是隐含的</li>
</ul>
]]></description></item><item><title>C++ Concurrency in Action | IO</title><link>https://jianye0428.github.io/posts/io/</link><pubDate>Sun, 19 Nov 2023 13:05:24 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/io/</guid><description><![CDATA[<h2 id="io-硬件原理">I/O 硬件原理</h2>
<ul>
<li>I/O 设备就是可以将数据输入到计算机(如鼠标、键盘)，或者可以接收计算机输出数据的外部设备(如显示器)</li>
<li>I/O 设备按信息交换单位可分为两类
<ul>
<li><strong>块设备(block device)</strong>：把信息存储在固定大小的块中，每个块都有自己的地址。块设备的基本特征是，传输速率快，可寻址，每个块都能独立于其他块而读写。磁盘就是最常见的块可寻址设备，无论磁盘臂当前处于什么位置，总是能寻址其他柱面并且等待所需要的磁盘块旋转到磁头下面</li>
<li><strong>字符设备(character device)</strong>：以字符为单位发送或接收一个字符流，而不考虑任何块结构，因此传输速率较慢，不可寻址，也没有任何寻道操作，在输入/输出时常采用中断驱动方式。打印机、鼠标就是常见的字符设备</li>
</ul>
</li>
<li>I/O 设备一般由机械部件和电子部件两部分组成
<ul>
<li>机械部件主要用于执行具体 I/O 操作，如鼠标的按钮、键盘的按键、显示器的屏幕、硬盘的磁盘臂</li>
<li>电子部件也称作设备控制器(device controller)或适配器(adapter)，通常是主板上的芯片，或一块插入主板扩充槽的印刷电路板</li>
</ul>
</li>
<li>CPU 无法直接控制机械部件，因此需要通过设备控制器作为中介来控制机械部件。设备控制器的主要功能有
<ul>
<li>接收和识别 CPU 发出的命令：每个控制器有几个寄存器用于与 CPU 通信，通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行其他某些操作</li>
<li>向 CPU 报告设备的状态：通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等</li>
<li>数据交换：除了控制寄存器外，许多设备还有一个操作系统可以读写的数据缓冲区，比如在屏幕上显示像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，可供程序或操作系统写入数据</li>
<li>地址识别：为了区分设备控制器中的寄存器，需要给每个寄存器设置一个地址，控制器通过 CPU 提供的地址来判断 CPU 要访问的寄存器</li>
</ul>
</li>
<li>设备控制器中有多个寄存器，为这些寄存器编址有两种方式
<ul>
<li>内存映射 I/O(memory-mapped I/O)：所有设备控制器的寄存器映射到内存空间中，每个控制寄存器被分配一个唯一的内存地址，并且不会有内存被分配到这一地址</li>
<li>寄存器独立编址：每个寄存器被分配一个 I/O 端口(port)号，所有端口号形成 I/O 端口空间(I/O port space)，并且受到保护使得普通用户程序不能对其进行访问，只有操作系统可以访问。这一方案中，内存地址空间和 I/O 地址空间是不同且不相关的</li>
</ul>
</li>
</ul>
<h2 id="io-软件原理">I/O 软件原理</h2>
<ul>
<li>I/O 软件的设计有以下目标
<ul>
<li>设备独立性(device independence)：允许编写出的程序可以访问任意 I/O 设备而无需事先指定设备，比如读取一个文件作为输入的程序，应该能在硬盘、DVD 或 USB 盘上读取文件，无需为每一种不同的设备修改程序</li>
<li>统一命名(uniform naming)：一个文件或一个设备的名字应该是一个简单的字符串或一个整数，不应依赖于设备</li>
<li>错误处理(error handling)：一般来说，错误应该尽可能在接近硬件的层面得到处理。当控制器发现一个读错误时，如果它能够处理，就应该自己设法纠正错误。如果控制器处理不了，设备驱动程序就应当予以处理，可能只需要重读一次这块数据就正确了</li>
<li>同步(synchronous，即阻塞)和异步(asynchronous，即中断驱动)传输：大多数物理 I/O 是异步的，比如 CPU 启动传输后便转去做其他工作，直到中断发生。如果 I/O 操作是阻塞的，用户程序就更容易编写，比如 read 系统调用之后程序将自动被挂起，直到缓冲区中的数据准备好，而正是操作系统将实际异步的操作变为了在用户程序看来是阻塞式的操作</li>
<li>缓冲(buffering)：数据离开一个设备之后通常不能直接存放到最终目的地，比如从网络上进来一个数据包时，直到将该数据包存放到某个地方，并对其进行检查，操作系统才知道要将其置于何处。缓冲涉及大量复制工作，经常对 I/O 性能有重大影响</li>
<li>共享设备和独占设备：共享设备能同时让多个用户使用(如磁盘)，独占设备则只能由单个用户独占使用(如磁带机)。独占设备的引入带来了各种问题(如死锁)，操作系统必须能处理共享设备和独占设备以避免问题发生</li>
</ul>
</li>
<li>I/O 有三种实现方式
<ul>
<li>程序控制 I/O(programmed I/O)：这是 I/O 的最简单形式。CPU 轮询设备状态，当设备准备好时，CPU 向控制器发出读指令，从 I/O 设备中读取字，再把这些字写入到存储器。这种方式的优点是实现简单，缺点是在完成全部 I/O 之前，CPU 的所有时间都被其占用，如果 CPU 有其他事情要做，轮询就导致了 CPU 利用率低</li>
<li>中断驱动 I/O ：用中断阻塞等待 I/O 的进程，CPU 在等待 I/O 设备就绪时，通过调度程序先执行其他进程。当 I/O 完成后(比如打印机打印完一个字符，准备接收下一个字符)，设备控制器将向 CPU 发送一个中断信号，CPU 检测到中断信号后保存当前进程的运行环境信息，然后执行中断驱动程序来处理中断。CPU 从设备控制器读一个字的数据传送到 CPU 寄存器，再写入主存，接着 CPU 恢复其他进程的运行环境并继续执行(打印下一个字符)。中断的优点是提高了 CPU 利用率，缺点是每次只能读一个字，每次都要发生一个中断，频繁的中断处理将浪费一定的 CPU 时间</li>
<li>使用 DMA(Direct Memory Access)的 I/O ：让 DMA 控制器来完成 CPU 要做的工作，使得 CPU 可以在 I/O 期间做其他操作。有了 DMA 控制器，就不用每个字中断一次，而是减少到每个缓冲区一次。DMA 控制器通常比 CPU 慢很多，如果 CPU 在等待 DMA 中断时没有其他事情要做，采用中断驱动 I/O 甚至程序控制 I/O 也许更好</li>
</ul>
</li>
</ul>
<h2 id="io-软件层次">I/O 软件层次</h2>
<ul>
<li>I/O 软件通常组织成四个层次，从上层到底层依次为
<ul>
<li>用户级 I/O 软件：实现了与用户交互的接口，为用户提供 I/O 操作相关的库函数接口，如 <code>printf</code></li>
<li>与设备无关的操作系统软件：向用户层提供系统调用，如为 <code>printf</code> 提供 <code>write</code>，另外还要提供设备保护(设置访问权限)、缓冲、错误报告、分配与释放专用设备、建立逻辑设备名到物理设备名的映射关系等功能</li>
<li>设备驱动程序(device driver)：每个连接到计算机上的 I/O 设备都需要某些设备特定的代码来对其进行控制，这样的代码称为设备驱动程序</li>
<li>中断处理程序：进行中断处理</li>
</ul>
</li>
</ul>
<h2 id="盘">盘</h2>
<ul>
<li>盘有多种多样的类型，最常用的是磁盘，它具有读写速度同样快的特点，适合作为辅助存储器(用于分页、文件系统等)</li>
<li>磁盘被组织成柱面，每一个柱面包含若干磁道，磁道数与垂直堆叠的磁头个数相同，磁道又被分为若干扇区，通过 <code>(柱面号, 盘面号, 扇区号)</code> 即可定位一个磁盘块</li>
<li>磁盘臂调度算法有
<ul>
<li>先来先服务算法(First-Come First-Served，FCFS)：按照请求接收顺序完成请求，优点是公平简单易实现，缺点是平均寻道时间较长</li>
<li>最短寻道时间优先算法(Shortest Seek Time First，SSTF)：下一次处理，磁头向所有请求中距离最近的位置移动。缺点是可能出现饥饿现象</li>
<li>扫描算法(SCAN)：也叫电梯算法(elevator algorithm)，磁头持续向一个方向移动，直到到达最内侧或最外侧时才改变方向。优点是平均寻道时间较短，不会产生饥饿现象</li>
<li>LOOK 调度算法：对扫描算法稍作优化，如果磁头移动方向上已没有需要处理的请求，则直接改变方向</li>
<li>循环扫描算法(C-SCAN)：SCAN 算法对于各个位置磁道的响应频率不平均，靠近磁盘两侧的可能更快被下一次访问。为了解决这个问题，C-SCAN 算法的原理是，只在一个移动方向上处理请求，磁头返回时不处理任何请求</li>
<li>C-LOOK：只在一个移动方向上处理请求，如果该方向之后没有要处理的请求，则磁头返回，并且只需要返回到第一个有请求的位置</li>
</ul>
</li>
</ul>
]]></description></item><item><title>C++ Concurrency in Action | File Systems</title><link>https://jianye0428.github.io/posts/filesystems/</link><pubDate>Sun, 19 Nov 2023 13:05:12 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/filesystems/</guid><description><![CDATA[<ul>
<li>进程运行时，可以在自己的地址空间存储信息，但这样保存信息的问题是
<ul>
<li>对于一些程序，如银行系统，这样的存储空间太小</li>
<li>进程终止时，保存的信息就丢失了</li>
<li>经常需要多个进程访问同一信息，这要求信息独立于任何一个进程</li>
</ul>
</li>
<li>因此，长期存储信息有三个基本要求
<ul>
<li>能够存储大量信息</li>
<li>使用信息的进程终止时，信息仍存在</li>
<li>允许多个进程并发访问信息</li>
</ul>
</li>
<li>理论上，磁盘(magnetic disk)就能解决长期存储的问题，但实际上，有许多操作不便于实现
<ul>
<li>如何找到信息?</li>
<li>如何防止一个用户读取另一个用户的数据?</li>
<li>如何知道哪些块是空闲的?</li>
</ul>
</li>
<li>为了解决这个问题，引入文件的概念，它是一个建模于磁盘的抽象概念</li>
<li>文件由操作系统管理，文件的构造、命名、访问、使用、保护、实现、管理方法是操作系统设计的主要内容，操作系统中处理文件的部分称为文件系统(file system)</li>
</ul>
<h2 id="文件">文件</h2>
<h3 id="文件命名">文件命名</h3>
<ul>
<li>各个系统中的文件命名规则不同，现代操作系统都允许用 1 到 8 个字母组成的字符串作为合法的文件名，通常也允许有数字和一些特殊字符</li>
<li>一般操作系统支持文件名用圆点分隔为两部分，如 <code>main.cpp</code>，圆点后的部分称为文件扩展名(file extension)。UNIX 中，文件扩展名只是一种约定，Windows 中的扩展名则有特别意义，用户或进程可以在操作系统中注册扩展名，并规定哪个程序拥有该扩展名(即双击该文件则启动此程序并运行该文件)</li>
</ul>
<h3 id="文件结构">文件结构</h3>
<ul>
<li>文件可以有多种构造方式
<ul>
<li>常见的一种构造方式是无结构的单字节序列，操作系统见到的就是字节，文件内容的任何含义只在用户程序中解释，UNIX 和 Windows 都采用这种方法。这为操作系统提供了最大的灵活性，用户可以向文件中加入任何内容，以任何形式命名，操作系统不提供帮助也不进行阻碍</li>
<li>第二种构造方式是固定长度记录的序列，这种方式的中心思想是，读操作返回一个记录，写操作重写或追加一个记录。几十年前，80 列的穿孔卡片是主流时，很多大型机的操作系统使用的就是这种方式，文件由 80 个字符的记录组成，文件系统建立在这种文件基础上</li>
<li>第三种构造方式是用一棵记录树构成文件，记录的固定位置有一个键，树按键排序，从而可以对键进行快速查找，这种方式被广泛用于处理商业数据的大型计算机</li>
</ul>
</li>
</ul>
<h3 id="文件类型">文件类型</h3>
<ul>
<li>操作系统一般支持多种文件类型，UNIX 和 Windows 都有普通文件(regular file)和目录(directory)，此外 UNIX 还有字符特殊文件(character special file)和块特殊文件(block special file)</li>
<li>普通文件一般分为 ASCII 文件和二进制文件
<ul>
<li>ASCII 文件由多行正文组成，每行用回车符或换行符或两者(如 MS-DOS)结束，其最大优势是可以显示、打印、编辑，如果很多程序都用 ASCII 文件作为输入和输出，就很容易把一个程序的输出作为另一个程序的输入</li>
<li>二进制文件打印出来是充满乱码的表，通常二进制文件有一定的内部结构，使用该文件的程序才了解这种结构。比如 UNIX 存档文件，每个文件以模块头开始，其中记录了名称、创建日期、所有者、保护码、文件大小，该模块头与可执行文件一样都是二进制数字，打印输出它们毫无意义</li>
</ul>
</li>
</ul>
<h3 id="文件访问">文件访问</h3>
<ul>
<li>早期操作系统只有顺序访问(sequential access)一种文件访问方式，进程可以从头按顺序读取文件的字节，不能跳过某一些内容。在存储介质是磁带而不是磁盘时，顺序访问文件是很方便的</li>
<li>用磁盘存储文件时，就能以任何次序读取文件的字节，能被这种方式访问的文件称为随机访问文件(random access file)。对许多程序来说，随机访问文件必不可少，比如数据库系统，查找一条记录时，不需要先读出之前的成千上万条记录</li>
</ul>
<h3 id="文件属性">文件属性</h3>
<ul>
<li>除了文件名和数据，操作系统还会保存文件相关的信息，如创建日期、文件大小等，这些附加信息称为文件属性(attribute)或元数据(metadata)。不同系统中的文件属性差别很大</li>
</ul>
<h3 id="文件操作">文件操作</h3>
<ul>
<li>使用文件是为了存储信息并方便以后检索，不同的操作系统提供了不同的方式，常见的文件相关的系统调用有 <code>create</code>、<code>delete</code>、<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>、<code>append</code>、<code>seek</code>、<code>get attributes</code>、<code>set attributes</code>、<code>rename</code></li>
</ul>
<h2 id="目录">目录</h2>
<ul>
<li>目录系统的最简单形式是单层目录系统，即一个目录中包含所有文件，这个目录通常称为根目录，其优势是简单，且能快速定位文件，常用于简单的嵌入式装置，如电话、数码相机</li>
<li>现在的用户通常有成千上万的文件，用单层目录寻找文件就很困难了，这就需要层次结构(即一个目录树)，几乎所有现代文件系统使用的都是层次目录系统。用目录树组织文件系统时，常用绝对路径名(absolute path name)或相对路径名(relative path name)来指明文件名</li>
<li>UNIX 中常见的目录操作的系统调用有 <code>create</code>、<code>delete</code>(只能删除空目录)、<code>opendir</code>、<code>closedir</code>、<code>readdir</code>、<code>rename</code>、<code>link</code>、<code>unlink</code></li>
</ul>
<h2 id="文件系统的实现">文件系统的实现</h2>
<h3 id="文件系统布局">文件系统布局</h3>
<ul>
<li>文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统</li>
<li>磁盘的 0 号扇区称为主引导记录(Master Boot Record，MBR)，用来引导计算机</li>
<li>MBR 的结尾是分区表，该表给出了每个分区的起始地址和结束地址。表中的一个分区被标记为活动分区，计算机被引导时，BIOS 读入并执行 MBR，MBR 做的第一件事就是确定活动分区，读入第一个块，即引导块(boot block)，并执行</li>
<li>除了引导块，磁盘分区的布局通常随文件系统的不同而变化，一个可能的文件系统布局如下</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">|-----------------整个磁盘-----------------|
</span></span><span class="line"><span class="cl">  分区表               磁盘分区
</span></span><span class="line"><span class="cl">     ↓       ↙     ↙        ↘        ↘
</span></span><span class="line"><span class="cl"> __________________________________________
</span></span><span class="line"><span class="cl">|MBR||||________|________|________|________|
</span></span><span class="line"><span class="cl">               /          \
</span></span><span class="line"><span class="cl">              /            \
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">|引导块|超级块|空闲空间管理|i节点|根目录|文件和目录|</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="文件的实现">文件的实现</h3>
<ul>
<li>文件存储实现的关键是记录文件用到了哪些磁盘块，不同的操作系统的实现方式不同</li>
<li>最简单的方式是连续分配，每个文件作为一连串连续数据块存储在磁盘上，比如块大小为 1 KB 的磁盘上，50 KB 的文件要分配 50 个连续的块。每个文件都要从一个新的块开始，上一个文件末尾块可能会存在部分被浪费的空间</li>
<li>连续分配的优势是实现简单，只需要为每个文件记录第一块的磁盘地址和使用的块数，另外读操作性能较好，单个操作就可以读出整个文件</li>
<li>缺点是删除文件会在磁盘中留下断断续续的空闲块。压缩磁盘代价太高，不可行。维护一个空闲块链表，但创建新文件时，为了选择选择合适的空闲区，必须先给出文件的最终大小，如果用户要创建一个文档然后录入，用户是无法给出最终大小的。但这在 CD-ROM 中是可行的，因为所有文件的大小都事先定好了，并且后续使用也不会被改变</li>
<li>第二种方式是链式分配，这样不会因为磁盘碎片而浪费存储空间，但随机访问很慢，每次要访问一个块时，都必须从第一个块开始。此外，指向下一个块的指针占用了一些字节，每个磁盘块存储数据的字节数不再是 2 的整数次幂，虽然这个问题不是非常严重，但也会降低系统的运行效率，因为程序一般以长度为 2 的整数次幂来读写磁盘块</li>
<li>第三种方式是把链式分配的指针放到内存的一个表中，这个表称为文件分配表(File Allocation Table，FAT)，这样就解决了大小不正常带来的问题，但如果表项过多，比如 1 TB 的磁盘和 1 KB 的块，FAT 有 10 亿项，每项至少占 3 字节，这就占了 3 GB 内存，因此 FAT 在大型磁盘中不实用</li>
<li>最后一种方式是为每个文件赋予一个 i 节点(index-node)的数据结构，其中列出了文件属性和文件块的磁盘地址。给定 i 节点就能找到文件的所有块，这种方式相对于 FAT 的优势是，只有在文件打开时，其 i 节点才在内存中，最终需要的内存与同时打开的最大文件数成正比</li>
</ul>
<h3 id="目录的实现">目录的实现</h3>
<ul>
<li>读文件时必须先打开文件，打开文件时，操作系统利用路径名找到目录项，目录项中提供了查找文件磁盘块所需要的信息。这些信息与系统有关，信息可能是整个文件的磁盘地址(对于连续分配的系统)、第一块的编号(链式分配)、i 节点号。文件属性存放的位置可以是目录项或者 i 节点</li>
<li>现代操作系统一般都支持长度可变的长文件名。最简单的实现方式是，给文件名一个长度限制，如 255 个字符，并为每个文件名保留该长度的空间，这种方式简单但浪费了大量目录空间</li>
<li>第二种方式是，每个目录项中开头有一个记录目录项长度的固定部分，接着是文件属性、任意长度的文件名。缺点和连续分配的磁盘碎片问题一样，移除一个个文件后会留下断断续续的空隙。由于整个目录在内存中，只有对目录进行紧凑操作才能节省空间。另一个问题是一个目录项可能会分布在多个页面上，读取文件名时可能发生缺页中断</li>
<li>第三种方式是，使目录项有固定长度，将文件名放在目录后面的堆上，并管理这个堆，这样移除一个目录项后，下一个进来的目录项总可以填满这个空隙</li>
<li>线性查找文件名要从头到尾搜索目录，对于非常长的目录，一个优化方式是在每个目录中使用散列表来映射文件名和对应的目录项</li>
</ul>
<h3 id="共享文件">共享文件</h3>
<ul>
<li>几个用户在同一个项目中工作时常需要共享文件。对于如下文件系统，B 与 C 有一个共享文件，B 的目录与该文件的联系称为一个链接(link)。这样，文件系统本身是一个有向无环图(Derected Acyclic Graph，DAG)而不是一棵树，代价是维护变得复杂</li>
</ul>
<p></p>
<ul>
<li>共享文件的问题是，如果目录中包含磁盘地址，链接文件时必须将 C 目录中的磁盘地址复制到 B 目录中，如果 B(或 C)往文件中添加内容，新数据块只会列入 B(或 C)的用户目录中，C(或 B)对此改变是不知道的，这就违背了共享的目的</li>
<li>解决这个问题的第一个方法是，磁盘块不列入目录，而是列入一个与文件关联的小型数据结构，目录将指向这个小型数据结构。这是 UNIX 的做法，小型数据结构就是 i 节点</li>
<li>这种方法的缺点是，B 链接该共享文件时，i 节点记录的文件所有者仍是 C，只是将 i 节点的链接计数加 1，以让系统知道该文件有多少个指向它的目录项。如果 C 之后删除了这个文件，B 就有一个指向无效的i节点的目录项。如果这个 i 节点之后分配给另一个文件，B 的链接将指向一个错误的文件。系统可以通过i节点的计数知道文件被引用，但无法找到所有目录项并删除，也不可能把目录项指针存储在 i 节点中，因为可能有无数个这样的目录</li>
<li>第二个方法是符号链接(symbolic linking)，让系统建立一个 LINK 类型的文件，把该文件放在 B 目录下，使得 B 与 C 的一个文件存在链接。LINK 文件中包含了要链接的文件的路径名，B 读该链接文件时，操作系统发现是 LINK 类型，则找到其链接文件的路径并读取</li>
<li>符号链接在文件被删除后，通过路径名查找文件将失败，因此不会有第一种方法的问题。符号链接的问题在于需要额外开销，必须读取包含路径的文件，然后逐步扫描路径直到找到 i 节点，这些操作可能需要很多次额外的磁盘访问</li>
<li>此外，所有方式的链接都存在的一个问题是，文件有多个路径，如果查找文件，将多次定位到被链接的文件，如果一个程序的功能是查找某个文件并复制，就可能导致多次复制同一文件</li>
</ul>
<h3 id="日志结构文件系统log-structured-file-systemlfs">日志结构文件系统(Log-structured File System，LFS)</h3>
<ul>
<li>设计 LFS 的主要原因是，CPU 运行速度越来越快，RAM 内存变得更大，磁盘高速缓存迅速增加，不需要磁盘访问操作，就可能满足直接来自高速缓存的大部分读请求，由此可以推断，未来的磁盘访问多数是写操作，且写操作往往是零碎的，提前读机制并不能获得更好的性能</li>
<li>因此 LFS 的设计者决定重新实现一种 UNIX 文件系统，即使面对一个由大部分为零碎的随机写操作组成的任务，也能够充分利用磁盘带宽</li>
<li>基本思路是，将整个磁盘结构化为一个日志，最初所有写操作都缓冲在内存中，每隔一段时间或有特殊需要时，被缓冲在内存中未执行的写操作被放到一个单独的段中，作为日志末尾的一个邻接段被写入磁盘</li>
<li>但磁盘空间不是无限大的，这种做法最终将导致日志占满整个磁盘，此时就无法再写入新的段。为了解决这个问题，LFS 有一个清理线程，该线程周期性扫描日志进行磁盘压缩。整个磁盘成为一个大的环形缓冲区，写线程将新的段写到前面，清理线程将旧的段从后面移走</li>
<li>LFS 在处理大量零碎写操作时的性能比 UNIX 好一个数量级，在处理读和大块写操作时的性能也不比 UNIX 差，甚至更好</li>
</ul>
<h3 id="日志文件系统">日志文件系统</h3>
<ul>
<li>由于 LFS 和现有的文件系统不相匹配，所以还未被广泛使用，但其内在的一个思想，即面对出错的鲁棒性，可以被其他文件系统借鉴。这个基本想法是，保存一个用于记录系统下一步要做什么的日志。当系统在完成任务前崩溃时，重新启动后，就能通过查看日志获取崩溃前计划完成的任务。这样的文件系统被称为日志文件系统，并已被实际使用，比如微软的 NTFS、Linux ext3、RerserFS，OS X将日志文件系统作为可选项提供</li>
</ul>
<h3 id="虚拟文件系统virtual-file-systemvfs">虚拟文件系统(Virtual File System，VFS)</h3>
<ul>
<li>同一台计算机或同一个操作系统中，可以有多个不同的文件系统</li>
<li>Windows 有一个主要的 NTFS 文件系统，但也有一个包含 FAT-32 或 FAT-16 的驱动器或分区，此外还可能有 CD-ROM 或者 DVD(每一个包含特定文件系统)，Windows 通过指定盘符来处理不同的文件系统，进程打开文件时，盘符是显式或隐式存在的，Windows 由此可知向哪个文件系统传递请求，不需要将不同的文件系统整合为统一模式</li>
<li>所有现代的 UNIX 尝试将多种文件系统整合到一个统一的结构中。一个 Linux 系统可以用 ext2 作为根文件系统，ext3 分区装载在 <code>/usr</code> 下，采用 RerserFS 的文件系统的硬盘装载在 <code>/home</code> 下，ISO 9660 的 CD-ROM 临时装载在 <code>/mnt</code> 下。用户视角中，只有一个文件系统层级，但实际上是对用户和进程不可见的多种不相容的文件系统</li>
<li>但是多种文件系统的存在在实际应用中是明确可见的，以前大多 UNIX 操作系统都使用 VFS 概念尝试将多种文件系统统一成一个有序结构，其核心思想是抽象出所有文件系统共有的部分为单独一层，这一层通过调用底层的实际文件系统来具体管理数据</li>
<li>UNIX 中，所有文件相关的系统调用最初都指向 VFS，这些来自用户进程的调用都是标准的 POSIX 系统调用，VFS 对用户进程提供的上层接口就是 POSIX 接口。VFS 也有一个对于实际文件系统的下层接口，即 VFS 接口，当创造一个新的文件系统和 VFS 一起工作时，新系统的设计者必须确定它提供 VFS 所需要的功能调用</li>
</ul>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">--------------------------------
</span></span><span class="line"><span class="cl">用户进程
</span></span><span class="line"><span class="cl">--------------------------------
</span></span><span class="line"><span class="cl">|
</span></span><span class="line"><span class="cl">|             POSIX 接口
</span></span><span class="line"><span class="cl">↓
</span></span><span class="line"><span class="cl">--------------------------------
</span></span><span class="line"><span class="cl">VFS
</span></span><span class="line"><span class="cl">--------------------------------
</span></span><span class="line"><span class="cl">|    |    |
</span></span><span class="line"><span class="cl">|    |    |   VFS 接口
</span></span><span class="line"><span class="cl">↓    ↓    ↓
</span></span><span class="line"><span class="cl">--------------------------------
</span></span><span class="line"><span class="cl">FS1  FS2  FS3 实际文件系统
</span></span><span class="line"><span class="cl">--------------------------------
</span></span><span class="line"><span class="cl">↑    ↑    ↑
</span></span><span class="line"><span class="cl">|    |    |
</span></span><span class="line"><span class="cl">↓    ↓    ↓
</span></span><span class="line"><span class="cl">--------------------------------
</span></span><span class="line"><span class="cl">高速缓冲区
</span></span><span class="line"><span class="cl">--------------------------------</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="文件系统管理和优化">文件系统管理和优化</h2>
<h3 id="磁盘空间管理">磁盘空间管理</h3>
<ul>
<li>几乎所有文件系统都将文件分割成固定大小的块存储，各块之间不一定相邻。块的大小是一个需要考虑的问题，块太小则文件块数越多，需要更多次的寻道与旋转延迟才能读出它们，从而降低了性能。块太大，则文件的最后一个块存在空间浪费。从历史观点上来说，一般设将块大小为 1 到 4 KB，但随着现在磁盘超过了 1 TB，磁盘空间已经不再短缺了，将块的大小提升到 64 KB并接受一些浪费比较好</li>
<li>选定块大小后，下一个问题是如何记录空闲块。有两种方法被广泛使用，一是链表，二是位图</li>
<li>为了防止占用太多磁盘空间，多用户操作系统通常提供了强制性磁盘配额机制，系统管理员为每个用户分配拥有文件和块的最大数量，操作系统确保每个用户不超过得到的配额</li>
</ul>
<h3 id="文件系统备份">文件系统备份</h3>
<ul>
<li>磁盘转储到磁带上有两种方案
<ul>
<li>物理转储：从磁盘的第 0 块开始，将全部的磁盘块按序输出到磁带上，直到最后一块复制完毕</li>
<li>逻辑转储：从一个或几个指定的目录开始，递归地转储其自给定日期后有所更改的全部文件和目录</li>
</ul>
</li>
</ul>
<h3 id="文件系统的一致性">文件系统的一致性</h3>
<ul>
<li>很多文件系统读取磁盘块，修改后再写回磁盘。如果在写回完成前系统崩溃，文件系统可能处于不一致状态。为此，很多计算机都有一个检查文件系统一致性的实用程序，比如 UNIX 的 fsck、Windows 的 scandisk，系统启动时，特别是崩溃后的重启，可以运行该程序</li>
<li>一致性检查分两种
<ul>
<li>块的一致性检查：程序构造两张表，每张表为每个块设立一个计数器，第一张表记录块在文件中的出现次数，第二张记录块在空闲区的出现次数。如果文件系统一致，最终每一个块在其中一张表中的计数器为 1，如果一个块在两张表中的计数器都为 0，则称为块丢失</li>
<li>文件的一致性检查：原理同上，区别是一个文件(而非一个块)对应一个计数器。注意，由于存在硬链接，一个文件可能出现在多个目录中。而遇到符号链接是不计数的，不会对目标文件的计数器加 1</li>
</ul>
</li>
</ul>
<h3 id="文件系统性能">文件系统性能</h3>
<ul>
<li>访问磁盘比访问内存慢很多，如果只需要一个字，内存访问可以比磁盘访问快百万数量级，因此许多文件系统采用了各种优化措施来改善性能</li>
<li>最常用的减少磁盘访问次数的技术是块高速缓存(block cache)或缓冲区高速缓存(buffer cache)，它们逻辑上属于磁盘，但实际上保存在内存中</li>
<li>第二个明显提高性能的技术是块提前读，在需要用到块之前先将块提前写入高速缓存，从而提高命中率。块提前读只适用于顺序读取的文件，如果请求文件系统在某个文件中生成一个块，文件系统将潜在地检查高速缓存，如果下一个块不在缓存中，则为下一个块安排一个预读</li>
<li>另一个重要技术是把可能顺序访问的块放在一起，最好是在同一个柱面上，从而减少磁盘臂的移动次数。这个技术仅当磁盘中装有磁盘臂时才有意义，现在固态硬盘(SSD)越来越流行，而它们不带移动部件。固态硬盘采用了和闪存同样的制造技术，使得随机访问与顺序访问在传输速度上已经较为接近，传统硬盘的诸多问题就消失了，但也有一些新问题，比如每一块只可写入有限次数，使用时要十分小心以达到均匀分散磨损的目的</li>
</ul>
<h3 id="磁盘碎片整理">磁盘碎片整理</h3>
<ul>
<li>随着不断创建与删除文件，磁盘会逐渐产生许多碎片，创建一个新文件时，其使用的块会散布在整个磁盘上，造成性能降低</li>
<li>一个恢复方式是，移动文件使其相邻，把空闲区放到一个或多个大的连续区域内。Windows 有一个 defrag 程序，就是用于完成这项工作的，Windows 用户应该定期使用它。Linux 文件系统由于其选择磁盘块的方式，在磁盘碎片整理上一般不会遇到 Windows 那样的困难，因此很少需要手动整理磁盘碎片</li>
<li>固态硬盘不受磁盘碎片的影响，对其做磁盘碎片整理不仅没有提高性能，反而磨损了硬盘，缩短了使用寿命</li>
</ul>
]]></description></item><item><title>C++ Concurrency in Action | Dead Locks</title><link>https://jianye0428.github.io/posts/deadlocks/</link><pubDate>Sun, 19 Nov 2023 13:04:54 +0800</pubDate><author>Jian YE</author><guid>https://jianye0428.github.io/posts/deadlocks/</guid><description><![CDATA[<h2 id="资源死锁resource-deadlock">资源死锁(resource deadlock)</h2>
<ul>
<li>资源分为两类
<ul>
<li>可抢占资源(preemptable resource): 可以从拥有它的进程中抢占，而不会产生任何副作用，如存储器</li>
<li>不可抢占资源(nonpreemptable resource): 在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来，如光盘刻录机</li>
</ul>
</li>
<li>死锁主要关心<strong>不可抢占资源</strong></li>
<li>如果一个进程集合中，每个进程都在等待集合中的其他进程才能引发的事件，则该进程集合就是死锁的。通常这个事件是其他进程释放自身占有的资源，这种死锁称为<strong>资源死锁</strong>，这是最常见的死锁类型，但不是唯一的类型</li>
<li>发生资源死锁的四个必要条件是:
<ul>
<li><font color=red>互斥条件</font>: 每个资源要么分配给一个进程，要么是可用的</li>
<li><font color=red>占有和等待条件</font>: 已得到某个资源的进程可以再请求新的资源，并且不会释放已有资源</li>
<li><font color=red>不可抢占条件</font>: 已分配给一个进程的资源不能被强制抢占，只能被占有它的进程显式释放</li>
<li><font color=red>环路等待条件</font>: 死锁发生时，系统中必然有多个进程组成一条环路，环路中的每个进程都在等待下一个进程所占有的资源</li>
</ul>
</li>
</ul>
<h2 id="鸵鸟算法">鸵鸟算法</h2>
<ul>
<li>最简单的解决方法是，把头埋到沙子里，假装根本没有问题发生。不同人对该方法的看法也不同，数学家认为这种方法完全不可接受，无论代价多大都应该彻底防止死锁发生，工程师认为要根据死锁发生的频率、严重程度、系统崩溃次数来决定，如果死锁每五年发生一次，而系统每个月都会因故障崩溃一次，就没有必要用损失性能和可用性的代价去防止死锁</li>
</ul>
<h2 id="死锁检测和死锁恢复">死锁检测和死锁恢复</h2>
<ul>
<li>第二种技术是<strong>死锁检测和恢复</strong>，使用这种技术时，系统不阻止死锁的产生，而是允许死锁发生，在检测到死锁发生后再恢复</li>
<li>用 E 表示现有资源向量(exisiting resource vector)，A 表示可用资源向量(available resource vector)，用 C 表示当前分配矩阵(current allocation matrix)，用 R 表示请求矩阵(request matrix)，死锁检测的算法是
<ul>
<li>在 R 中查找是否存在某一行(即一个进程)小于等于 A</li>
<li>如果找到这样一行，就将 C 中相同行数的行(即该进程的已分配资源)加到 A 中，然后标记该进程，再转到上一步</li>
<li>如果不存在这样一行，则算法终止。算法结束时，所有没标记过的进程都是死锁进程</li>
</ul>
</li>
<li>死锁恢复方法有: <strong>抢占</strong>、<strong>回滚</strong>、<strong>终止进程</strong></li>
</ul>
<h2 id="死锁避免">死锁避免</h2>
<ul>
<li>
<p>如果当前状态下没有死锁发生，并且存在某种调度次序能使每个进程都运行完毕，则称该状态是安全的</p>
</li>
<li>
<p>对于目前有 3 个空闲资源的如下状态，先分配 2 个资源给 B，B 运行完释放 4 个资源，此时有 5 个空闲资源，接着 5 个资源全分配给 C，C 运行结束后将有 9 个空闲资源，最后将 9 个资源全分配给 A 即可。按 BCA 的分配顺序可以使得所有进程都能完成，因此这个状态是安全的</p>
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">已分配资源</th>
<th style="text-align:center">最大需求</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">3</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">2</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>空闲资源数为 2 时的如下状态就是不安全状态。首先只能先运行 B，B 运行结束后共有 4 个空闲资源，无法再运行 A 或 C</p>
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">已分配资源</th>
<th style="text-align:center">最大需求</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">4</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">2</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>安全状态和不安全状态的区别是: 从安全状态出发，系统可以保证所有进程都能完成，而从不安全状态出发就没有这样的保证</p>
</li>
<li>
<p>Dijkstra 提出了一种避免死锁的调度算法，称为<strong>银行家算法(banker&rsquo;s algorithm)</strong>，方法是对每一个请求进行检查，如果满足这一请求会到达安全状态，则满足该请求，否则推迟对该请求的满足</p>
</li>
<li>
<p>之前安全状态的例子考虑的就是单个资源的银行家算法，下面考虑多个资源的银行家算法</p>
</li>
<li>
<p>已分配资源</p>
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">资源1</th>
<th style="text-align:center">资源2</th>
<th style="text-align:center">资源3</th>
<th style="text-align:center">资源4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>仍需要的资源</p>
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">资源1</th>
<th style="text-align:center">资源2</th>
<th style="text-align:center">资源3</th>
<th style="text-align:center">资源4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对应的当前分配矩阵 C 和请求矩阵 R 为</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">C</span>       <span class="n">R</span>
</span></span><span class="line"><span class="cl"><span class="mi">3011</span>    <span class="mi">1100</span>
</span></span><span class="line"><span class="cl"><span class="mo">0100</span>    <span class="mo">0112</span>
</span></span><span class="line"><span class="cl"><span class="mi">1110</span>    <span class="mi">3100</span>
</span></span><span class="line"><span class="cl"><span class="mi">1101</span>    <span class="mo">0010</span>
</span></span><span class="line"><span class="cl"><span class="mo">0000</span>    <span class="mi">2110</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>用三个向量表示现有资源 E、已分配资源 P、可用资源 A，计算分配矩阵 C 的每列和得到 <code>P = (5322)</code>，以 <code>E = (6342)</code> 为例，<code>A = E - P = (1020)</code></p>
</li>
<li>
<p>检测一个状态是否安全的算法是</p>
<ul>
<li>查找一个使用可用资源即可运行的进程，如果找不到则系统就会死锁</li>
<li>如果找到，则假设该进程获取所需资源并运行结束，将该进程标记为终止，再将其资源加到 A 上</li>
<li>重复上述两步，如果最后所有进程都被标记为终止，则初始状态是安全的</li>
</ul>
</li>
<li>
<p>对于这个例子</p>
<ul>
<li>进程 D 仍需要的资源为 <code>(0010)</code>，均小于 <code>(1020)</code>，因此运行 D，D 最初的已分配资源为 <code>(1101)</code>，因此结束后 <code>A = (1020) + (1101) = (2121)</code></li>
<li>进程 A 仍需要的资源为 <code>(1100)</code>，均小于运行 <code>(2121)</code>，运行 A(此时 E 也满足条件，也可以运行 E)，A 最初的已分配资源为 <code>(3011)</code>，结束后 <code>A = (2121) + (3011) = (5132)</code></li>
<li>运行 B，结束后 <code>A = (5132) + (0100) = (5232)</code></li>
<li>运行 C，结束后 <code>A = (5232) + (1110) = (6342)</code></li>
<li>运行 E，结束后 <code>A = (6342) + (0000) = (6342)</code></li>
<li>所有进程都运行结束，因此这个例子的状态是安全的</li>
</ul>
</li>
</ul>
<h2 id="死锁预防">死锁预防</h2>
<ul>
<li>死锁避免本质上来说是不可能的，因为它需要获取未来的请求，而这些请求是不可知的</li>
<li>死锁发生时，四个条件必须同时成立，因此破坏其中条件即可预防发生死锁
<ul>
<li>破坏互斥条件: 如果资源不被一个进程独占，就一定不会发生死锁。实际情况中，如果允许两个进程同时使用打印机就会造成混乱，解决这个问题的方法是假脱机打印机技术(spooling printer)</li>
<li>破坏占有并等待条件: 禁止已持有资源的进程再等待其他资源即可。一种实现方法是，规定所有进程在开始执行前请求所需的全部资源。这种方法的问题是，很多进程在运行时才知道需要多少资源，实际上如果进程知道需要多少资源就可以使用银行家算法。另一种方法是，当进程请求资源时，先暂时释放其占有的资源，再尝试一次获取所需的全部资源</li>
<li>破坏不可抢占条件: 这种方法是可能的</li>
<li>破坏环路等待条件: 对资源编号，请求必须按编号升序提出，但问题在于，几乎找不出一种使每个人都满意的编号次序</li>
</ul>
</li>
</ul>
<h2 id="通信死锁communication-deadlock">通信死锁(communication deadlock)</h2>
<ul>
<li>除了最常见的资源死锁，还有通信死锁。通信死锁发生在通信系统(如网络)中，比如进程 A 向进程 B 发送请求信息并阻塞至 B 回复，如果 A 发送的信息丢失，就会导致 A 和 B 均阻塞，从而导致死锁</li>
<li>通信死锁可以通过超时来解决，发送者在发送信息时启动计时器，如果计时器在回复到达前停止，则发送者可以认为信息已丢失，并重新发送</li>
</ul>
<h2 id="活锁livelock">活锁(livelock)</h2>
<ul>
<li>
<p>活锁不会导致进程阻塞，甚至可以说进程正在活动，因此不是死锁，但实际上进程不会继续往下执行，因此可以称为活锁</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process_A</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">acquire_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">try_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_2</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 进程 A 尝试获取资源 2 失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">release_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_1</span><span class="p">);</span>  <span class="c1">// 先释放资源 1，一段时间后再尝试获取资源 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">wait_fixed_time</span><span class="p">();</span>  <span class="c1">// 若 B 此时也在等待，则两者都让出了资源但对方都未获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">acquire_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_1</span><span class="p">);</span>  <span class="c1">// 两者各自拿回资源，则下次获取对方资源仍会失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>                             <span class="c1">// 若此过程一直重复就是活锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">use_both_resources</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">release_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">release_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process_B</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">acquire_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">try_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">release_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">wait_fixed_time</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">acquire_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">use_both_resources</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">release_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">release_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></description></item></channel></rss>