<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>OS - 标签 - yejian's blog</title><link>https://lruihao.cn/tags/os/</link><description>OS - 标签 - yejian's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>18817571704@163.com (Jian YE)</managingEditor><webMaster>18817571704@163.com (Jian YE)</webMaster><lastBuildDate>Thu, 13 Jul 2023 08:05:28 +0800</lastBuildDate><atom:link href="https://lruihao.cn/tags/os/" rel="self" type="application/rss+xml"/><item><title>Process and Coroutine</title><link>https://lruihao.cn/posts/os_2/</link><pubDate>Thu, 13 Jul 2023 08:05:28 +0800</pubDate><author>Jian YE</author><guid>https://lruihao.cn/posts/os_2/</guid><description><![CDATA[<h2 id="进程和线程的区别">进程和线程的区别</h2>
<h3 id="进程线程协程的概念">进程、线程、协程的概念</h3>
<p>进程：</p>
<ul>
<li>是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</li>
</ul>
<p>线程：</p>
<ul>
<li>是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</li>
</ul>
<p>协程：</p>
<ul>
<li>是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。</li>
</ul>
<h3 id="进程和线程的区别-1">进程和线程的区别</h3>
<p>地址空间：</p>
<ul>
<li>线程共享本进程的地址空间，而进程之间是独立的地址空间。</li>
</ul>
<p>资源：</p>
<ul>
<li>线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。</li>
</ul>
<p>健壮性：</p>
<ul>
<li>多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。</li>
</ul>
<p>执行过程：</p>
<ul>
<li>
<p>每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。</p>
</li>
<li>
<p>但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。</p>
</li>
</ul>
<p>可并发性：</p>
<ul>
<li>两者均可并发执行。</li>
</ul>
<p>切换时：</p>
<ul>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。</li>
</ul>
<p>其他：</p>
<ul>
<li>线程是处理器调度的基本单位，但是进程不是。</li>
</ul>
<h3 id="协程和线程的区别">协程和线程的区别</h3>
<p>协程避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任。同时，协程也失去了标准线程使用多CPU的能力。</p>
<p><strong>线程（thread）</strong></p>
<ul>
<li>相对独立</li>
<li>有自己的上下文</li>
<li>切换受系统控制；</li>
</ul>
<p><strong>协程（coroutine）</strong></p>
<ul>
<li>相对独立</li>
<li>有自己的上下文</li>
<li>切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</li>
</ul>
<h3 id="何时使用多进程何时使用多线程">何时使用多进程，何时使用多线程？</h3>
<p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</p>
<p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p>
<h3 id="为什么会有线程">为什么会有线程？</h3>
<p>每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。</p>
<h3 id="python多线程存在的问题">*python多线程存在的问题</h3>
<ul>
<li>存在问题：</li>
</ul>
<p>python由于历史遗留的问题，严格说多个线程并不会同时执行（没法有效利用多核处理器，python的并发只是在交替执行不同的代码）。</p>
<p>多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。所以python的多线程并发并不能充分利用多核，并发没有java的并发严格。</p>
<ul>
<li>原因：</li>
</ul>
<p>原因就在于GIL ，在Cpython 解释器（Python语言的主流解释器）中，有一把全局解释锁（GIL, Global Interpreter Lock），在解释器解释执行Python 代码时，任何Python线程执行前，都先要得到这把GIL锁。</p>
<p>这个GIL全局锁实际上把所有线程的执行代码都给上了锁。</p>
<p>这意味着，python在任何时候，只可能有一个线程在执行代码。</p>
<p>其它线程要想获得CPU执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。</p>
<p>多个线程一起执行反而更加慢的原因：</p>
<p>同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上线文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。</p>
<ul>
<li>什么时候GIL被释放？</li>
</ul>
<p>当一个线程遇到I/O 任务时，将释放GIL。</p>
<p>计算密集型（CPU-bound）线程执行100次解释器的计步（ticks）时（计步可粗略看作Python 虚拟机的指令），也会释放GIL。</p>
<p>即，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。</p>
<p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.sohu.com/a/230407177_99992472"target="_blank" rel="external nofollow noopener noreferrer">参考博客<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="进程的几种通信方式">*进程的几种通信方式</h3>
<ul>
<li>管道：</li>
</ul>
<p>速度慢，容量有限，只有父子进程能通讯</p>
<ul>
<li>FIFO：</li>
</ul>
<p>任何进程间都能通讯，但速度慢</p>
<ul>
<li>消息队列：</li>
</ul>
<p>容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题</p>
<ul>
<li>信号量：</li>
</ul>
<p>不能传递复杂消息，只能用来同步</p>
<ul>
<li>共享内存区：</li>
</ul>
<p>能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>
<h3 id="举例说明进程线程协程">*举例说明进程、线程、协程</h3>
<p><strong>程序</strong>：</p>
<p>例如main.py这是程序，是一个静态的程序。</p>
<p><strong>python进程</strong>：</p>
<p>一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。</p>
<p>multiprocessing.Process实现多进程</p>
<p><strong>进程池</strong>：</p>
<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。</p>
<p>multiprocessing.Pool</p>
<p><strong>进程间通信</strong>：</p>
<p>各自在独立的地址空间，并不能直接进行全局的数据共享，在创建子进程的时候会将父进程的数据复制到子进程中一份。</p>
<p>进程间通信 Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</p>
<p><strong>python线程</strong>：</p>
<p>thread是比较低级,底层的模块，threading是高级模块，对thread进行了封装,可以更加方便的被使用。</p>
<p><strong>python协程</strong>：</p>
<p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员,当程序中存在大量不需要CPU的操作时（例如 I/O），适用于协程。</p>
<p>例如yield</p>
<p>其中 yield 是python当中的语法。</p>
<p>当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。</p>
<p>但是，yield让协程暂停，和线程的阻塞是有本质区别的。</p>
<p>&lt;/font color=red&gt;协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。</font></p>
<p>因此，协程的开销远远小于线程的开销。</p>
<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>python可以通过 yield/send 的方式实现协程。<strong>在python 3.5以后，async/await 成为了更好的替代方案</strong>。</p>
]]></description></item><item><title>计算机操作系统</title><link>https://lruihao.cn/posts/os_1/</link><pubDate>Thu, 13 Jul 2023 08:05:24 +0800</pubDate><author>Jian YE</author><guid>https://lruihao.cn/posts/os_1/</guid><description><![CDATA[<h2 id="操作系统一">操作系统(一)</h2>
<h3 id="11-进程和线程的区别">1.1 进程和线程的区别？</h3>
<p>进程和线程都是操作系统中进行任务调度的基本单位，二者之间的主要区别如下：</p>
<ul>
<li>资源占用：进程是操作系统资源分配的基本单位，一个进程可以拥有多个线程，而线程是进程中的执行单元，是CPU调度的基本单位。每个线程共享所属进程的资源，如代码段、数据段、打开的文件等。而进程之间互相独立，互不干扰，每个进程有自己独立的资源空间，不同进程之间需要通过IPC（进程间通信）来进行通信和数据共享。</li>
<li>调度和切换：操作系统在调度和分配CPU时，将进程作为基本的调度和分配单位，即进程拥有自己的调度队列。而线程是依附于进程而存在的，一个进程中的多个线程共享进程的时间片和资源，因此在调度和切换时，线程切换比进程切换更快，也更加轻量级。</li>
<li>创建和销毁：进程的创建和销毁比线程更加复杂，创建一个进程需要为其分配资源、建立PCB（进程控制块）、建立内核对象等，而销毁进程需要回收资源、关闭打开的文件等。而线程的创建和销毁相对简单，只需要为其分配线程栈、建立TCB（线程控制块）等即可。</li>
<li>通信和同步：进程之间通过IPC（管道、套接字、消息队列等）进行通信和数据共享，而线程之间可以直接访问同一进程的共享数据区，也可以通过锁机制实现同步。</li>
</ul>
<p>综上所述，进程和线程在资源占用、调度和切换、创建和销毁、通信和同步等方面有着不同的特点，开发者在实际编程时需要根据具体的情况选择使用进程还是线程来完成任务。</p>
<h3 id="12-协程与线程的区别">1.2 协程与线程的区别？</h3>
<p>协程和线程都是用于实现多任务的技术，但是它们的实现方式有所不同，具体区别如下：</p>
<ul>
<li>调度方式不同：线程由操作系统内核进行调度，而协程则是在用户空间中进行调度，不需要切换到内核态。</li>
<li>并发性不同：线程是操作系统调度的最小单位，多个线程可以并行执行；协程则是在单线程内部通过协作式调度实现并发。</li>
<li>内存使用不同：线程是由操作系统内核创建的，需要占用一定的系统资源，而协程则是由用户程序创建，不需要占用额外的系统资源。</li>
<li>上下文切换开销不同：线程在切换时需要保存和恢复所有的寄存器状态和内核堆栈，而协程只需要保存和恢复少量的寄存器状态，开销较小。</li>
<li>编程难度不同：线程的编程难度相对较大，因为多线程之间需要共享资源并进行同步，而协程则是在单线程内部调度，因此编程难度相对较小。</li>
</ul>
<p>总之，线程是操作系统内核的调度对象，具有独立的系统资源，可以并行执行多个任务；而协程是用户程序的调度对象，不需要占用额外的系统资源，通过协作式调度实现任务之间的切换。</p>
<h3 id="13并发和并行的区别">1.3、并发和并行的区别？</h3>
<p>并发和并行都是指同时处理多个任务的方式，但是它们有不同的含义。</p>
<p>并发是指一个处理器同时处理多个任务，这些任务通常是通过在不同的时间间隔内交替进行的，这样在同一时刻可以看到有多个任务在运行。这些任务可以是在同一个程序内的不同线程，也可以是在不同程序之间的交互，例如客户端与服务器之间的通信。</p>
<p>并行是指使用多个处理器同时处理多个任务，这些任务在同一时刻可以看到有多个任务在同时运行。与并发不同的是，并行需要多个处理器或多个计算核心，而并发则可以在单个处理器上执行多个任务。</p>
<p>简单来说，并发是在一个处理器上同时执行多个任务，而并行是在多个处理器或计算核心上同时执行多个任务。</p>
<h3 id="14-进程与线程的切换流程">1.4 进程与线程的切换流程？</h3>
<p>进程与线程的切换流程如下：</p>
<ol>
<li>当前进程或线程执行到阻塞状态（如等待I/O完成）时，触发切换操作。</li>
<li>操作系统内核保存当前进程或线程的上下文（即当前的寄存器值和程序计数器等信息），并将处理器分配给另一个进程或线程。</li>
<li>内核从调度队列中选择另一个进程或线程，并恢复其保存的上下文信息。</li>
<li>处理器开始执行新的进程或线程，从之前保存的状态恢复执行。</li>
</ol>
<p>在进程切换时，需要将整个进程的上下文信息保存下来，包括进程的虚拟内存、全局变量等，切换时还需要进行内存映射，开销比较大。</p>
<p>在线程切换时，只需要保存当前线程的上下文信息即可，线程共享进程的虚拟内存，切换时不需要进行内存映射，开销较小。</p>
<h3 id="15-为什么虚拟地址空间切换比较耗时">1.5 为什么虚拟地址空间切换比较耗时？</h3>
<p>虚拟地址空间切换的耗时是因为它涉及到了硬件和操作系统的复杂操作。当进程或线程切换时，需要保存当前的程序状态（寄存器值、堆栈指针等）和上下文信息（当前指令位置、程序计数器等）。然后，内核必须选择另一个进程或线程，并将它的状态和上下文信息装入内存，这样才能保证程序能够继续运行。这个过程涉及到多个操作系统的内核和硬件机制，例如上下文切换、内存管理和硬件中断等。</p>
<p>在这个过程中，为了切换到另一个进程或线程，需要保存和恢复大量的状态信息，包括内核上下文和硬件寄存器等。这些操作需要耗费大量的CPU时间和内存带宽，因此切换过程通常是相对比较耗时的。</p>
<p>ref:</br>
[1].https://zhuanlan.zhihu.com/p/616080301</p>
]]></description></item><item><title>磁盘存储器的管理</title><link>https://lruihao.cn/posts/cipanadmin/</link><pubDate>Mon, 04 Mar 2019 23:08:32 +0000</pubDate><author>Jian YE</author><guid>https://lruihao.cn/posts/cipanadmin/</guid><description><![CDATA[<h2 id="外存的组织方式">外存的组织方式</h2>
<h3 id="连续组织方式">连续组织方式</h3>
<ul>
<li>
<p>连续组织方式的优点</p>
<ul>
<li>顺序访问容易</li>
<li>顺序访问速度快</li>
</ul>
</li>
<li>
<p>连续组织方式的缺点</p>
<ul>
<li>分配连续的存储空间</li>
<li>必须知道文件长度</li>
<li>删除与插入数据不灵活</li>
<li>动态增长的文件分配空间问题</li>
</ul>
</li>
</ul>
<h3 id="链接组织方式">链接组织方式</h3>
<ul>
<li>隐式链接</li>
<li>显式链接</li>
</ul>
<h3 id="fat-技术">FAT 技术</h3>
<ul>
<li>
<p>FAT12</p>
<ul>
<li>早期的 FAT12 文件系统</li>
<li>以簇为单位的 FAT12 文件系统</li>
</ul>
</li>
<li>
<p>FAT16</p>
</li>
<li>
<p>FAT32</p>
</li>
</ul>
<h3 id="ntfs-的文件组织方式">NTFS 的文件组织方式</h3>
<ul>
<li>NTFS 新特征</li>
<li>磁盘组织</li>
<li>文件的组织</li>
</ul>
<h3 id="索引组织方式">索引组织方式</h3>
<ul>
<li>
<p>单级索引组织方式</p>
</li>
<li>
<p>多级索引组织方式</p>
</li>
<li>
<p>增量式索引组织方式</p>
<ul>
<li>
<p>增量式索引组织方式的基本思想</p>
</li>
<li>
<p>UNIX System V 的组织方式</p>
<ul>
<li>直接地址</li>
<li>一次间接地址</li>
<li>多次间接地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件存储空间的管理">文件存储空间的管理</h2>
<h3 id="空闲表法和空闲链表法">空闲表法和空闲链表法</h3>
<ul>
<li>
<p>空闲表法</p>
<ul>
<li>空闲表</li>
<li>存储空间的分配与回收</li>
</ul>
</li>
<li>
<p>空闲链表法</p>
<ul>
<li>空闲盘块链</li>
<li>空闲盘区链</li>
</ul>
</li>
</ul>
<h3 id="位示图法">位示图法</h3>
<ul>
<li>
<p>位示图</p>
</li>
<li>
<p>盘块的分配（步骤）</p>
<ul>
<li>
<ol>
<li>顺序扫描示图</li>
</ol>
</li>
<li>
<ol start="2">
<li>转换盘块号</li>
</ol>
</li>
<li>
<ol start="3">
<li>修改位示图</li>
</ol>
</li>
</ul>
</li>
<li>
<p>盘块的回收（步骤）</p>
<ul>
<li>
<ol>
<li>盘块号转换成行列号</li>
</ol>
</li>
<li>
<ol start="2">
<li>修改位示图</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="成组链接法">成组链接法</h3>
<ul>
<li>空闲盘块的组织</li>
<li>空闲盘块的分配与回收</li>
</ul>
<h2 id="提高磁盘-io-速度的途径">提高磁盘 I/O 速度的途径</h2>
<h3 id="磁盘高速缓存">磁盘高速缓存</h3>
<ul>
<li>
<p>数据交付方式</p>
<ul>
<li>数据交付</li>
<li>指针交付</li>
</ul>
</li>
<li>
<p>置换算法</p>
</li>
<li>
<p>周期性地写回磁盘</p>
</li>
</ul>
<h3 id="提高磁盘-io-速度的其他方法">提高磁盘 I/O 速度的其他方法</h3>
<ul>
<li>提前读</li>
<li>延迟写</li>
<li>优化物理块的分布</li>
<li>虚拟盘</li>
</ul>
<h3 id="廉价磁盘冗余阵列-raid">廉价磁盘冗余阵列 (RAID)</h3>
<ul>
<li>
<p>并行交叉存取</p>
</li>
<li>
<p>RAID 的分级</p>
<ul>
<li>RAID 0 级</li>
<li>RAID 1 级</li>
<li>RAID 2 级</li>
<li>RAID 3 级</li>
<li>RAID 4 级</li>
<li>RAID 5 级</li>
<li>RAID 6 级和 RAID 7 级</li>
</ul>
</li>
<li>
<p>RAID 的优点</p>
<ul>
<li>可靠性高</li>
<li>磁盘 I/O 速度高</li>
<li>性价比高</li>
</ul>
</li>
</ul>
<h2 id="提高磁盘可靠性的技术">提高磁盘可靠性的技术</h2>
<h3 id="第一级容错技术-sft-">第一级容错技术 SFT-Ⅰ</h3>
<ul>
<li>
<p>双份目录和双份文件分配表</p>
</li>
<li>
<p>热修复重定向和写后读校验</p>
<ul>
<li>热修复重定向</li>
<li>写后读校验方式</li>
</ul>
</li>
</ul>
<h3 id="第二级容错技术-sft-">第二级容错技术 SFT-Ⅱ</h3>
<ul>
<li>磁盘镜像</li>
<li>磁盘双工</li>
</ul>
<h3 id="基于集群技术的容错功能">基于集群技术的容错功能</h3>
<ul>
<li>双机热备份模式</li>
<li>双机互为备份模式</li>
<li>公用磁盘模式</li>
</ul>
<h3 id="后备系统">后备系统</h3>
<ul>
<li>
<p>磁带机</p>
</li>
<li>
<p>硬盘</p>
<ul>
<li>移动磁盘</li>
<li>固定硬盘驱动器</li>
</ul>
</li>
<li>
<p>光盘驱动器</p>
<ul>
<li>CD-ROM 和 DVD-ROM</li>
<li>刻录机</li>
</ul>
</li>
</ul>
<h2 id="数据一致性控制">数据一致性控制</h2>
<h3 id="事务">事务</h3>
<ul>
<li>
<p>事务的定义</p>
</li>
<li>
<p>事务记录</p>
</li>
<li>
<p>恢复算法</p>
<ul>
<li>undo &lt;Ti&gt;</li>
<li>redo &lt;Ti&gt;</li>
</ul>
</li>
</ul>
<h3 id="检查点">检查点</h3>
<ul>
<li>检查点的作用</li>
<li>新的恢复算法</li>
</ul>
<h3 id="并发控制">并发控制</h3>
<ul>
<li>利用互斥锁实现“顺序性”</li>
<li>利用互斥锁和共享锁实现顺序性</li>
</ul>
<h3 id="重复数据的数据一致性问题">重复数据的数据一致性问题</h3>
<ul>
<li>重复文件的一致性</li>
<li>链接数一致性检查</li>
</ul>
]]></description></item></channel></rss>